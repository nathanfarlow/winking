// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.1.1

//# unitInfo: Provides: Sexplib0__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp
//# unitInfo: Requires: Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__BytesLabels, Stdlib__Char, Stdlib__Format, Stdlib__ListLabels, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "(",
    cst$12 = "()",
    cst$13 = ")",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$11,
    cst$3 = cst$12,
    cst$4 = cst$13,
    cst$5 = " ",
    cst$6 = cst$11,
    cst$7 = cst$12,
    cst$8 = cst$13,
    cst$10 = cst$12,
    cst$9 = cst$12,
    cst = "\\",
    cst$0 = ' "',
    cst$1 = '"',
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib = global_data.Stdlib,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    _b_ = [0, [15, [17, 2, 0]], "%a@?"],
    _a_ = [0, 0, 0],
    cst_n = "\\n",
    cst_Sexplib0_Sexp_Not_found_s = "Sexplib0__Sexp.Not_found_s",
    cst_Sexplib0_Sexp_Of_sexp_erro = "Sexplib0__Sexp.Of_sexp_error";
   function sexp_of_t(t){return t;}
   function t_of_sexp(t){return t;}
   function compare(a$0, b$0){
    if(a$0 === b$0) return 0;
    if(0 === a$0[0]){
     var a$1 = a$0[1];
     if(0 !== b$0[0]) return -1;
     var b$1 = b$0[1];
     return caml_call2(Stdlib_StringLabels[9], a$1, b$1);
    }
    var a$2 = a$0[1];
    if(0 === b$0[0]) return 1;
    var b$2 = b$0[1], a = a$2, b = b$2;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], res = compare(x, y);
     if(0 !== res) return res;
     var a = xs, b = ys;
    }
   }
   function equal(a, b){return 0 === compare(a, b) ? 1 : 0;}
   var
    Not_found_s = [248, cst_Sexplib0_Sexp_Not_found_s, caml_fresh_oo_id(0)],
    Of_sexp_error = [248, cst_Sexplib0_Sexp_Of_sexp_erro, caml_fresh_oo_id(0)],
    default_indent = [0, 1];
   function must_escape(str){
    var len = caml_ml_string_length(str), _x_ = 0 === len ? 1 : 0;
    if(_x_) return _x_;
    var ix$1 = len - 1 | 0, ix = ix$1;
    for(;;){
     var match = caml_string_get(str, ix), switch$0 = 0;
     if(92 <= match){
      var switcher = match - 93 | 0;
      if(33 < switcher >>> 0)
       if(0 <= switcher) switch$0 = 2; else switch$0 = 1;
      else if(31 === switcher){
       var _y_ = 0 < ix ? 1 : 0;
       if(_y_){
        var
         next = ix - 1 | 0,
         _z_ = caml_string_get(str, next),
         _A_ = caml_call2(Stdlib_Char[8], _z_, 35);
        if(! _A_){var ix = next; continue;}
        var _B_ = _A_;
       }
       else
        var _B_ = _y_;
       return _B_;
      }
     }
     else
      if(42 <= match){
       if(59 === match) switch$0 = 1;
      }
      else if(33 <= match)
       switch(match - 33 | 0){
         case 2:
          var _D_ = 0 < ix ? 1 : 0;
          if(_D_){
           var
            next$0 = ix - 1 | 0,
            _E_ = caml_string_get(str, next$0),
            _F_ = caml_call2(Stdlib_Char[8], _E_, 124);
           if(! _F_){var ix = next$0; continue;}
           var _G_ = _F_;
          }
          else
           var _G_ = _D_;
          return _G_;
         case 1:
         case 7:
         case 8:
          switch$0 = 1; break;
       }
      else
       switch$0 = 2;
     switch(switch$0){
       case 0:
        var _C_ = 0 < ix ? 1 : 0;
        if(! _C_) return _C_;
        var ix$0 = ix - 1 | 0, ix = ix$0;
        continue;
       case 1:
        return 1;
       default: return 1;
     }
    }
   }
   function escaped(s){
    var n = [0, 0], _n_ = caml_ml_string_length(s) - 1 | 0, _m_ = 0;
    if(_n_ >= 0){
     var i$0 = _m_;
     for(;;){
      var match = caml_string_unsafe_get(s, i$0), switch$0 = 0;
      if(32 <= match){
       var _u_ = match - 34 | 0, switch$1 = 0;
       if(58 < _u_ >>> 0){
        if(93 > _u_) switch$1 = 1;
       }
       else if(56 < _u_ - 1 >>> 0) switch$0 = 1; else switch$1 = 1;
       if(switch$1){var _v_ = 1; switch$0 = 2;}
      }
      else
       if(11 <= match){
        if(13 === match) switch$0 = 1;
       }
       else if(8 <= match) switch$0 = 1;
      switch(switch$0){case 0: var _v_ = 4; break;case 1: var _v_ = 2; break;
      }
      n[1] = n[1] + _v_ | 0;
      var _w_ = i$0 + 1 | 0;
      if(_n_ !== i$0){var i$0 = _w_; continue;}
      break;
     }
    }
    if(n[1] === caml_ml_string_length(s)) return s;
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _p_ = caml_ml_string_length(s) - 1 | 0, _o_ = 0;
    if(_p_ >= 0){
     var i = _o_;
     for(;;){
      var c = caml_string_unsafe_get(s, i), switch$2 = 0;
      if(35 <= c)
       if(92 === c)
        switch$2 = 2;
       else if(127 <= c) switch$2 = 1; else switch$2 = 3;
      else if(32 <= c)
       if(34 <= c) switch$2 = 2; else switch$2 = 3;
      else if(14 <= c)
       switch$2 = 1;
      else
       switch(c){
         case 8:
          caml_bytes_unsafe_set(s$0, n[1], 92);
          n[1]++;
          caml_bytes_unsafe_set(s$0, n[1], 98);
          break;
         case 9:
          caml_bytes_unsafe_set(s$0, n[1], 92);
          n[1]++;
          caml_bytes_unsafe_set(s$0, n[1], 116);
          break;
         case 10:
          caml_bytes_unsafe_set(s$0, n[1], 92);
          n[1]++;
          caml_bytes_unsafe_set(s$0, n[1], 110);
          break;
         case 13:
          caml_bytes_unsafe_set(s$0, n[1], 92);
          n[1]++;
          caml_bytes_unsafe_set(s$0, n[1], 114);
          break;
         default: switch$2 = 1;
       }
      switch(switch$2){
        case 1:
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         var _r_ = caml_call1(Stdlib_Char[1], 48 + (c / 100 | 0) | 0);
         caml_bytes_unsafe_set(s$0, n[1], _r_);
         n[1]++;
         var
          _s_ = caml_call1(Stdlib_Char[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
         caml_bytes_unsafe_set(s$0, n[1], _s_);
         n[1]++;
         var _t_ = caml_call1(Stdlib_Char[1], 48 + (c % 10 | 0) | 0);
         caml_bytes_unsafe_set(s$0, n[1], _t_);
         break;
        case 2:
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break;
        case 3:
         caml_bytes_unsafe_set(s$0, n[1], c); break;
      }
      n[1]++;
      var _q_ = i + 1 | 0;
      if(_p_ !== i){var i = _q_; continue;}
      break;
     }
    }
    return caml_call1(Stdlib_BytesLabels[48], s$0);
   }
   function esc_str(str){
    var
     estr = escaped(str),
     elen = caml_ml_string_length(estr),
     res = caml_create_bytes(elen + 2 | 0);
    caml_call5(Stdlib_Bytes[12], estr, 0, res, 1, elen);
    caml_bytes_unsafe_set(res, 0, 34);
    caml_bytes_unsafe_set(res, elen + 1 | 0, 34);
    return caml_call1(Stdlib_BytesLabels[48], res);
   }
   function index_of_newline(str, start){
    try{
     var _k_ = [0, caml_call3(Stdlib_StringLabels[31], str, start, 10)];
     return _k_;
    }
    catch(_l_){
     var _j_ = caml_wrap_exception(_l_);
     if(_j_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_j_, 0);
    }
   }
   function mach_maybe_esc_str(str){
    return must_escape(str) ? esc_str(str) : str;
   }
   function pp_hum_indent(indent, ppf, param){
    if(0 === param[0]){
     var str = param[1];
     if(! must_escape(str)) return caml_call2(Stdlib_Format[13], ppf, str);
     var match = index_of_newline(str, 0);
     if(match)
      var
       index = match[1],
       _g_ = (index + 1 | 0) === caml_ml_string_length(str) ? 1 : 0;
     else
      var _g_ = 1;
     if(_g_){
      var _h_ = esc_str(str);
      return caml_call2(Stdlib_Format[13], ppf, _h_);
     }
     caml_call2(Stdlib_Format[1], ppf, 0);
     caml_call2(Stdlib_Format[13], ppf, cst$0);
     var index$0 = 0;
     for(;;){
      var next_newline = index_of_newline(str, index$0);
      if(next_newline)
       var end_pos = next_newline[1], end_pos$0 = end_pos;
      else
       var end_pos$0 = caml_ml_string_length(str);
      var
       next_line =
         caml_call3
          (Stdlib_StringLabels[15], str, index$0, end_pos$0 - index$0 | 0),
       _i_ = escaped(next_line);
      caml_call2(Stdlib_Format[13], ppf, _i_);
      if(next_newline){
       var newline_index = next_newline[1];
       caml_call2(Stdlib_Format[13], ppf, cst);
       caml_call2(Stdlib_Format[34], ppf, 0);
       caml_call2(Stdlib_Format[13], ppf, cst_n);
       var index$1 = newline_index + 1 | 0, index$0 = index$1;
       continue;
      }
      caml_call2(Stdlib_Format[13], ppf, cst$1);
      return caml_call2(Stdlib_Format[3], ppf, 0);
     }
    }
    var match$0 = param[1];
    if(! match$0) return caml_call2(Stdlib_Format[13], ppf, cst$3);
    var t = match$0[2], h = match$0[1];
    caml_call2(Stdlib_Format[1], ppf, indent);
    caml_call2(Stdlib_Format[13], ppf, cst$2);
    pp_hum_indent(indent, ppf, h);
    var param$0 = t;
    for(;;){
     if(param$0){
      var t$0 = param$0[2], h$0 = param$0[1];
      caml_call2(Stdlib_Format[27], ppf, 0);
      pp_hum_indent(indent, ppf, h$0);
      var param$0 = t$0;
      continue;
     }
     caml_call2(Stdlib_Format[13], ppf, cst$4);
     return caml_call2(Stdlib_Format[3], ppf, 0);
    }
   }
   function pp_mach_internal(may_need_space, ppf, param){
    if(0 === param[0]){
     var
      str = param[1],
      str$0 = mach_maybe_esc_str(str),
      new_may_need_space = str$0 === str ? 1 : 0,
      new_may_need_space$0 =
        may_need_space ? new_may_need_space : may_need_space;
     if(new_may_need_space$0) caml_call2(Stdlib_Format[13], ppf, cst$5);
     caml_call2(Stdlib_Format[13], ppf, str$0);
     return new_may_need_space;
    }
    var match = param[1];
    if(! match){caml_call2(Stdlib_Format[13], ppf, cst$7); return 0;}
    var t = match[2], h = match[1];
    caml_call2(Stdlib_Format[13], ppf, cst$6);
    var
     may_need_space$0 = pp_mach_internal(0, ppf, h),
     may_need_space$1 = may_need_space$0,
     param$0 = t;
    for(;;){
     if(param$0){
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = pp_mach_internal(may_need_space$1, ppf, h$0),
       may_need_space$1 = may_need_space$2,
       param$0 = t$0;
      continue;
     }
     caml_call2(Stdlib_Format[13], ppf, cst$8);
     return 0;
    }
   }
   function pp_hum(ppf, sexp){
    return pp_hum_indent(default_indent[1], ppf, sexp);
   }
   function pp_mach(ppf, sexp){pp_mach_internal(0, ppf, sexp); return 0;}
   function size_loop(acc, param){
    var c = acc[2], v = acc[1];
    if(0 === param[0]){
     var str = param[1];
     return [0, v + 1 | 0, c + caml_ml_string_length(str) | 0];
    }
    var lst = param[1];
    return caml_call3(Stdlib_ListLabels[25], size_loop, acc, lst);
   }
   function size(sexp){return size_loop(_a_, sexp);}
   function to_buffer_hum(buf, opt, sexp){
    if(opt)
     var sth = opt[1], indent = sth;
    else
     var indent = default_indent[1];
    var ppf = caml_call1(Stdlib_Format[111], buf);
    function _d_(_e_, _f_){return pp_hum_indent(indent, _e_, _f_);}
    return caml_call4(Stdlib_Format[129], ppf, _b_, _d_, sexp);
   }
   function to_buffer_mach(buf, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(Stdlib_Buffer[12], buf, 32);
      caml_call2(Stdlib_Buffer[16], buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(Stdlib_Buffer[16], buf, cst$9); return 0;}
     var t = match[2], h = match[1];
     caml_call2(Stdlib_Buffer[12], buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(param$0){
       var
        t$0 = param$0[2],
        h$0 = param$0[1],
        may_need_space$2 = loop(may_need_space$1, h$0),
        may_need_space$1 = may_need_space$2,
        param$0 = t$0;
       continue;
      }
      caml_call2(Stdlib_Buffer[12], buf, 41);
      return 0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function to_buffer_gen(buf, add_char, add_string, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(add_char, buf, 32);
      caml_call2(add_string, buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(add_string, buf, cst$10); return 0;}
     var t = match[2], h = match[1];
     caml_call2(add_char, buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(param$0){
       var
        t$0 = param$0[2],
        h$0 = param$0[1],
        may_need_space$2 = loop(may_need_space$1, h$0),
        may_need_space$1 = may_need_space$2,
        param$0 = t$0;
       continue;
      }
      caml_call2(add_char, buf, 41);
      return 0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function buffer(param){return caml_call1(Stdlib_Buffer[1], 1024);}
   function to_string_hum(indent, sexp){
    if(0 === sexp[0]){
     var str = sexp[1], _c_ = index_of_newline(str, 0) ? 0 : 1;
     if(_c_) return mach_maybe_esc_str(str);
    }
    var buf = buffer(0);
    to_buffer_hum(buf, indent, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function to_string_mach(sexp){
    if(0 === sexp[0]){var str = sexp[1]; return mach_maybe_esc_str(str);}
    var buf = buffer(0);
    to_buffer_mach(buf, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   var of_float_style = [0, 1009018843], of_int_style = [0, 1009018843];
   function message(name, fields){
    function conv_fields(param){
     if(! param) return 0;
     var
      rest = param[2],
      match = param[1],
      fsexp = match[2],
      fname = match[1];
     return runtime.caml_string_notequal(fname, "")
             ? [0, [1, [0, [0, fname], [0, fsexp, 0]]], conv_fields(rest)]
             : [0, fsexp, conv_fields(rest)];
    }
    return [1, [0, [0, name], conv_fields(fields)]];
   }
   var
    Sexplib0_Sexp =
      [0,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp_mach,
       to_string_hum,
       to_string_mach,
       to_string_mach,
       of_float_style,
       of_int_style,
       [0,
        size,
        buffer,
        to_buffer_mach,
        to_buffer_hum,
        to_buffer_mach,
        to_buffer_gen,
        mach_maybe_esc_str,
        must_escape,
        esc_str]];
   runtime.caml_register_global(26, Sexplib0_Sexp, "Sexplib0__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_grammar
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    doc_comment_tag = "sexp_grammar.doc_comment";
   function coerce(t){return t;}
   var Sexplib0_Sexp_grammar = [0, coerce, doc_comment_tag];
   runtime.caml_register_global
    (1, Sexplib0_Sexp_grammar, "Sexplib0__Sexp_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_grammar
//# unitInfo: Requires: Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    unit_sexp_grammar = [2, 0],
    sexp_t_sexp_grammar = [0, "Sexp.t"],
    empty_sexp_grammar = [4, 0],
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    bool_sexp_grammar = 0,
    string_sexp_grammar = 4,
    bytes_sexp_grammar = 4,
    char_sexp_grammar = 1,
    int_sexp_grammar = 2,
    float_sexp_grammar = 3,
    int32_sexp_grammar = 2,
    int64_sexp_grammar = 2,
    nativeint_sexp_grammar = 2;
   function ref_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function lazy_t_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function option_sexp_grammar(param){return [1, param];}
   function list_sexp_grammar(param){return [2, [1, param]];}
   function array_sexp_grammar(param){return [2, [1, param]];}
   var
    Sexplib0_Sexp_conv_grammar =
      [0,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       empty_sexp_grammar,
       empty_sexp_grammar];
   runtime.caml_register_global
    (4, Sexplib0_Sexp_conv_grammar, "Sexplib0__Sexp_conv_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, Sexplib0__Sexp, Sexplib0__Sexp_conv_grammar, Stdlib, Stdlib__Arg, Stdlib__ArrayLabels, Stdlib__BytesLabels, Stdlib__Ephemeron, Stdlib__Int32, Stdlib__Int64, Stdlib__Lazy, Stdlib__ListLabels, Stdlib__MoreLabels, Stdlib__Nativeint, Stdlib__Obj, Stdlib__Parsing, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Scanf, Stdlib__Stack, Stdlib__StringLabels, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Assert_failure$0 = "Assert_failure",
    cst_None = "None",
    cst_Some = "Some",
    cst_none = "none",
    cst_option_of_sexp_only_none_c$1 = "option_of_sexp: only none can be atom",
    cst_some = "some",
    cst_src_sexp_conv_ml = "src/sexp_conv.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_format_float = runtime.caml_format_float,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Parsing = global_data.Stdlib__Parsing,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Obj = global_data.Stdlib__Obj,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Ephemeron = global_data.Stdlib__Ephemeron,
    Sexplib0_Sexp_conv_grammar = global_data.Sexplib0__Sexp_conv_grammar,
    _aF_ = [0, 0],
    _aG_ = [0, 1],
    _aB_ = [0, "Sexplib.Conv.Of_sexp_error"],
    _aC_ = [0, cst_src_sexp_conv_ml, 410, 15],
    _ay_ = [0, 0],
    _az_ = [0, 0],
    cst_Assert_failure = cst_Assert_failure$0,
    _av_ = [0, cst_src_sexp_conv_ml, 334, 15],
    _ar_ = [0, "Exit"],
    _as_ = [0, cst_src_sexp_conv_ml, 338, 15],
    _an_ = [0, "End_of_file"],
    _ao_ = [0, cst_src_sexp_conv_ml, 342, 15],
    _aj_ = [0, "Failure"],
    _ak_ = [0, cst_src_sexp_conv_ml, 346, 15],
    _af_ = [0, "Not_found"],
    _ag_ = [0, cst_src_sexp_conv_ml, 350, 15],
    _ab_ = [0, "Invalid_argument"],
    _ac_ = [0, cst_src_sexp_conv_ml, 354, 15],
    cst_Match_failure = "Match_failure",
    ___ = [0, cst_src_sexp_conv_ml, 358, 15],
    _W_ = [0, "Not_found_s"],
    _X_ = [0, cst_src_sexp_conv_ml, 362, 15],
    _S_ = [0, "Sys_error"],
    _T_ = [0, cst_src_sexp_conv_ml, 366, 15],
    _O_ = [0, "Arg.Help"],
    _P_ = [0, cst_src_sexp_conv_ml, 370, 15],
    _K_ = [0, "Arg.Bad"],
    _L_ = [0, cst_src_sexp_conv_ml, 374, 15],
    _G_ = [0, "Lazy.Undefined"],
    _H_ = [0, cst_src_sexp_conv_ml, 378, 15],
    _C_ = [0, "Parsing.Parse_error"],
    _D_ = [0, cst_src_sexp_conv_ml, 382, 15],
    _y_ = [0, "Queue.Empty"],
    _z_ = [0, cst_src_sexp_conv_ml, 386, 15],
    _u_ = [0, "Scanf.Scan_failure"],
    _v_ = [0, cst_src_sexp_conv_ml, 390, 15],
    _q_ = [0, "Stack.Empty"],
    _r_ = [0, cst_src_sexp_conv_ml, 394, 15],
    _m_ = [0, "Sys.Break"],
    _n_ = [0, cst_src_sexp_conv_ml, 398, 15],
    _j_ =
      [0,
       [2,
        0,
        [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, [12, 58, [4, 0, 0, 0, 0]]]]]]],
       "%s %s:%d:%d"],
    cst_fun_of_sexp_cannot_convert =
      "fun_of_sexp: cannot convert function values",
    cst_opaque_of_sexp_cannot_conv =
      "opaque_of_sexp: cannot convert opaque values",
    cst_hashtbl_of_sexp_tuple_list = "hashtbl_of_sexp: tuple list needed",
    cst_hashtbl_of_sexp_list_neede = "hashtbl_of_sexp: list needed",
    cst_array_of_sexp_list_needed = "array_of_sexp: list needed",
    cst_list_of_sexp_list_needed = "list_of_sexp: list needed",
    cst_triple_of_sexp_list_needed = "triple_of_sexp: list needed",
    cst_triple_of_sexp_list_must_c =
      "triple_of_sexp: list must contain exactly three elements only",
    cst_pair_of_sexp_list_needed = "pair_of_sexp: list needed",
    cst_pair_of_sexp_list_must_con =
      "pair_of_sexp: list must contain exactly two elements only",
    cst_option_of_sexp_only_none_c = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_r =
      "option_of_sexp: list must represent optional value",
    cst_option_of_sexp_only_none_c$0 = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_b = "option_of_sexp: list must be (some el)",
    cst_nativeint_of_sexp = "nativeint_of_sexp: ",
    cst_nativeint_of_sexp_atom_nee = "nativeint_of_sexp: atom needed",
    cst_int64_of_sexp = "int64_of_sexp: ",
    cst_int64_of_sexp_atom_needed = "int64_of_sexp: atom needed",
    cst_int32_of_sexp = "int32_of_sexp: ",
    cst_int32_of_sexp_atom_needed = "int32_of_sexp: atom needed",
    cst_float_of_sexp = "float_of_sexp: ",
    cst_float_of_sexp_atom_needed = "float_of_sexp: atom needed",
    cst_int_of_sexp = "int_of_sexp: ",
    cst_int_of_sexp_atom_needed = "int_of_sexp: atom needed",
    cst_char_of_sexp_atom_string_m =
      "char_of_sexp: atom string must contain one character only",
    cst_char_of_sexp_atom_needed = "char_of_sexp: atom needed",
    cst_bytes_of_sexp_atom_needed = "bytes_of_sexp: atom needed",
    cst_string_of_sexp_atom_needed = "string_of_sexp: atom needed",
    cst_bool_of_sexp_unknown_strin = "bool_of_sexp: unknown string",
    cst_bool_of_sexp_atom_needed = "bool_of_sexp: atom needed",
    cst_unit_of_sexp_empty_list_ne = "unit_of_sexp: empty list needed",
    _i_ = [0, 2],
    _h_ = [0, 2],
    _f_ = [0, "<fun>"],
    _e_ = [0, "<opaque>"],
    _b_ = [0, cst_some],
    _c_ = [1, 0],
    _d_ = [0, cst_none],
    _a_ = [1, 0],
    default_string_of_float =
      [0,
       function(x){
        var y = caml_format_float("%.15G", x);
        return caml_float_of_string(y) == x
                ? y
                : caml_format_float("%.17G", x);
       }],
    read_old_option_format = [0, 1],
    write_old_option_format = [0, 1];
   function list_map(f, l){
    var _bo_ = caml_call2(Stdlib_ListLabels[21], f, l);
    return caml_call1(Stdlib_ListLabels[9], _bo_);
   }
   function sexp_of_unit(param){return _a_;}
   function sexp_of_bool(b){return [0, caml_call1(Stdlib[30], b)];}
   function sexp_of_string(str){return [0, str];}
   function sexp_of_bytes(bytes){
    return [0, caml_call1(Stdlib_BytesLabels[6], bytes)];
   }
   function sexp_of_char(c){
    return [0, caml_call2(Stdlib_StringLabels[1], 1, c)];
   }
   function sexp_of_int(n){return [0, caml_call1(Stdlib[33], n)];}
   function sexp_of_float(n){
    return [0, caml_call1(default_string_of_float[1], n)];
   }
   function sexp_of_int32(n){return [0, caml_call1(Stdlib_Int32[14], n)];}
   function sexp_of_int64(n){return [0, caml_call1(Stdlib_Int64[14], n)];}
   function sexp_of_nativeint(n){
    return [0, caml_call1(Stdlib_Nativeint[15], n)];
   }
   function sexp_of_ref(sexp_of_a, rf){return caml_call1(sexp_of_a, rf[1]);}
   function sexp_of_lazy_t(sexp_of_a, lv){
    var
     _bm_ = runtime.caml_obj_tag(lv),
     _bn_ =
       250 === _bm_
        ? lv[1]
        : 246 === _bm_ ? caml_call1(CamlinternalLazy[2], lv) : lv;
    return caml_call1(sexp_of_a, _bn_);
   }
   function sexp_of_option(sexp_of_a, param){
    if(! param) return write_old_option_format[1] ? _c_ : _d_;
    var x = param[1];
    return write_old_option_format[1]
            ? [1, [0, caml_call1(sexp_of_a, x), 0]]
            : [1, [0, _b_, [0, caml_call1(sexp_of_a, x), 0]]];
   }
   function sexp_of_pair(sexp_of_a, sexp_of_b, param){
    var b = param[2], a = param[1], _bl_ = [0, caml_call1(sexp_of_b, b), 0];
    return [1, [0, caml_call1(sexp_of_a, a), _bl_]];
   }
   function sexp_of_triple(sexp_of_a, sexp_of_b, sexp_of_c, param){
    var
     c = param[3],
     b = param[2],
     a = param[1],
     _bj_ = [0, caml_call1(sexp_of_c, c), 0],
     _bk_ = [0, caml_call1(sexp_of_b, b), _bj_];
    return [1, [0, caml_call1(sexp_of_a, a), _bk_]];
   }
   function sexp_of_list(sexp_of_a, lst){
    var _bi_ = caml_call2(Stdlib_ListLabels[21], sexp_of_a, lst);
    return [1, caml_call1(Stdlib_ListLabels[9], _bi_)];
   }
   function sexp_of_array(sexp_of_a, ar){
    var lst_ref = [0, 0], _bf_ = ar.length - 1 - 1 | 0;
    if(_bf_ >= 0){
     var i = _bf_;
     for(;;){
      var _bg_ = lst_ref[1];
      lst_ref[1] =
       [0, caml_call1(sexp_of_a, caml_check_bound(ar, i)[1 + i]), _bg_];
      var _bh_ = i - 1 | 0;
      if(0 !== i){var i = _bh_; continue;}
      break;
     }
    }
    return [1, lst_ref[1]];
   }
   function sexp_of_hashtbl(sexp_of_key, sexp_of_val, htbl){
    function coll(k, v, acc){
     var _be_ = [0, caml_call1(sexp_of_val, v), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, k), _be_]], acc];
    }
    return [1, caml_call3(Stdlib_MoreLabels[1][14], coll, htbl, 0)];
   }
   function sexp_of_opaque(param){return _e_;}
   function sexp_of_fun(param){return _f_;}
   function equal(_bd_, _bc_){return _bd_ === _bc_ ? 1 : 0;}
   var
    hash = Stdlib_Obj[22][3],
    Exn_table = caml_call1(Stdlib_Ephemeron[1][14], [0, equal, hash]),
    the_exn_table = caml_call1(Exn_table[1], 17);
   function add(opt, param, extension_constructor, sexp_of_exn){
    if(opt) var sth = opt[1], printexc = sth; else var printexc = 1;
    return caml_call3
            (Exn_table[5],
             the_exn_table,
             extension_constructor,
             [0, sexp_of_exn, printexc]);
   }
   function find_auto(for_printexc, exn){
    var
     extension_constructor = caml_call1(Stdlib_Obj[22][1], exn),
     match = caml_call2(Exn_table[8], the_exn_table, extension_constructor);
    if(! match) return 0;
    var match$0 = match[1], printexc = match$0[2], sexp_of_exn = match$0[1];
    if(for_printexc && ! printexc) return 0;
    return [0, caml_call1(sexp_of_exn, exn)];
   }
   function size(param){return caml_call1(Exn_table[24], the_exn_table)[1];}
   var For_unit_tests_only = [0, size];
   function sexp_of_exn_opt(exn){return find_auto(0, exn);}
   function sexp_of_exn(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return [1, [0, [0, caml_call1(Stdlib_Printexc[1], exn)], 0]];
    var sexp = match[1];
    return sexp;
   }
   function exn_to_string(e){
    var _bb_ = sexp_of_exn(e);
    return caml_call2(Sexplib0_Sexp[13], 0, _bb_);
   }
   function _g_(exn){
    var match = find_auto(1, exn);
    if(! match) return 0;
    var sexp = match[1];
    return [0, caml_call2(Sexplib0_Sexp[13], _h_, sexp)];
   }
   caml_call1(Stdlib_Printexc[9], _g_);
   function printexc_prefer_sexp(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return caml_call1(Stdlib_Printexc[1], exn);
    var sexp = match[1];
    return caml_call2(Sexplib0_Sexp[13], _i_, sexp);
   }
   var Of_sexp_error = Sexplib0_Sexp[6], record_check_extra_fields = [0, 1];
   function of_sexp_error_exn(exc, sexp){
    throw caml_maybe_attach_backtrace([0, Of_sexp_error, exc, sexp], 1);
   }
   function of_sexp_error(what, sexp){
    throw caml_maybe_attach_backtrace
           ([0, Of_sexp_error, [0, Stdlib[7], what], sexp], 1);
   }
   function unit_of_sexp(sexp){
    if(1 === sexp[0] && ! sexp[1]) return 0;
    return of_sexp_error(cst_unit_of_sexp_empty_list_ne, sexp);
   }
   function bool_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bool_of_sexp_atom_needed, sexp);
    var _ba_ = sexp[1];
    if(caml_string_notequal(_ba_, "False")){
     var switch$0 = 0;
     if(caml_string_notequal(_ba_, "True"))
      if(caml_string_notequal(_ba_, "false")){
       if(caml_string_notequal(_ba_, "true"))
        return of_sexp_error(cst_bool_of_sexp_unknown_strin, sexp);
      }
      else
       switch$0 = 1;
     if(! switch$0) return 1;
    }
    return 0;
   }
   function string_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_string_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return str;
   }
   function bytes_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bytes_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return caml_call1(Stdlib_BytesLabels[5], str);
   }
   function char_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_char_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    if(1 !== runtime.caml_ml_string_length(str))
     of_sexp_error(cst_char_of_sexp_atom_string_m, sexp);
    return runtime.caml_string_get(str, 0);
   }
   function int_of_sexp(sexp){
    if(0 !== sexp[0]) return of_sexp_error(cst_int_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a$_ = caml_int_of_string(str); return _a$_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a__ = exn_to_string(exc);
     return of_sexp_error(caml_call2(Stdlib[28], cst_int_of_sexp, _a__), sexp);
    }
   }
   function float_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_float_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a9_ = caml_float_of_string(str); return _a9_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a8_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_float_of_sexp, _a8_), sexp);
    }
   }
   function int32_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int32_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a7_ = caml_int_of_string(str); return _a7_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a6_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int32_of_sexp, _a6_), sexp);
    }
   }
   function int64_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int64_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a5_ = runtime.caml_int64_of_string(str); return _a5_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a4_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int64_of_sexp, _a4_), sexp);
    }
   }
   function nativeint_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_nativeint_of_sexp_atom_nee, sexp);
    var str = sexp[1];
    try{var _a3_ = caml_int_of_string(str); return _a3_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a2_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_nativeint_of_sexp, _a2_), sexp);
    }
   }
   function ref_of_sexp(a_of_sexp, sexp){
    return [0, caml_call1(a_of_sexp, sexp)];
   }
   function lazy_t_of_sexp(a_of_sexp, sexp){
    var _a1_ = caml_call1(a_of_sexp, sexp);
    return caml_call1(Stdlib_Lazy[4], _a1_);
   }
   function option_of_sexp(a_of_sexp, sexp){
    if(! read_old_option_format[1]){
     if(0 === sexp[0]){
      var _aW_ = sexp[1];
      if
       (caml_string_notequal(_aW_, cst_None)
        && caml_string_notequal(_aW_, cst_none))
       return of_sexp_error(cst_option_of_sexp_only_none_c$0, sexp);
      return 0;
     }
     var _aX_ = sexp[1];
     if(_aX_){
      var _aY_ = _aX_[1];
      if(0 === _aY_[0]){
       var _aZ_ = _aY_[1], switch$2 = 0;
       if
        (!
         caml_string_notequal(_aZ_, cst_Some)
         || ! caml_string_notequal(_aZ_, cst_some))
        switch$2 = 1;
       if(switch$2){
        var _a0_ = _aX_[2];
        if(_a0_ && ! _a0_[2]){
         var el$0 = _a0_[1];
         return [0, caml_call1(a_of_sexp, el$0)];
        }
       }
      }
     }
     return of_sexp_error(cst_option_of_sexp_list_must_b, sexp);
    }
    if(0 === sexp[0]){
     var _aR_ = sexp[1];
     if
      (caml_string_notequal(_aR_, cst_None)
       && caml_string_notequal(_aR_, cst_none))
      return of_sexp_error(cst_option_of_sexp_only_none_c, sexp);
    }
    else{
     var _aS_ = sexp[1];
     if(_aS_){
      var _aT_ = _aS_[1];
      if(_aS_[2]){
       var switch$0 = 0;
       if(0 === _aT_[0]){
        var _aU_ = _aT_[1], switch$1 = 0;
        if
         (!
          caml_string_notequal(_aU_, cst_Some)
          || ! caml_string_notequal(_aU_, cst_some))
         switch$1 = 1;
        if(switch$1){
         var _aV_ = _aS_[2];
         if(! _aV_[2]){var el = _aV_[1]; switch$0 = 1;}
        }
       }
       if(! switch$0)
        return of_sexp_error(cst_option_of_sexp_list_must_r, sexp);
      }
      else
       var el = _aT_;
      return [0, caml_call1(a_of_sexp, el)];
     }
    }
    return 0;
   }
   function pair_of_sexp(a_of_sexp, b_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_pair_of_sexp_list_needed, sexp);
    var _aP_ = sexp[1];
    if(_aP_){
     var _aQ_ = _aP_[2];
     if(_aQ_ && ! _aQ_[2]){
      var
       b_sexp = _aQ_[1],
       a_sexp = _aP_[1],
       a = caml_call1(a_of_sexp, a_sexp),
       b = caml_call1(b_of_sexp, b_sexp);
      return [0, a, b];
     }
    }
    return of_sexp_error(cst_pair_of_sexp_list_must_con, sexp);
   }
   function triple_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_triple_of_sexp_list_needed, sexp);
    var _aM_ = sexp[1];
    if(_aM_){
     var _aN_ = _aM_[2];
     if(_aN_){
      var _aO_ = _aN_[2];
      if(_aO_ && ! _aO_[2]){
       var
        c_sexp = _aO_[1],
        b_sexp = _aN_[1],
        a_sexp = _aM_[1],
        a = caml_call1(a_of_sexp, a_sexp),
        b = caml_call1(b_of_sexp, b_sexp),
        c = caml_call1(c_of_sexp, c_sexp);
       return [0, a, b, c];
      }
     }
    }
    return of_sexp_error(cst_triple_of_sexp_list_must_c, sexp);
   }
   function list_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_list_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     rev_lst = caml_call2(Stdlib_ListLabels[21], a_of_sexp, lst);
    return caml_call1(Stdlib_ListLabels[9], rev_lst);
   }
   function array_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_array_of_sexp_list_needed, sexp);
    var match = sexp[1];
    if(! match) return [0];
    var
     t = match[2],
     h = match[1],
     len = caml_call1(Stdlib_ListLabels[1], t) + 1 | 0,
     res = runtime.caml_make_vect(len, caml_call1(a_of_sexp, h)),
     i = 1,
     param = t;
    for(;;){
     if(! param) return res;
     var t$0 = param[2], h$0 = param[1], _aL_ = caml_call1(a_of_sexp, h$0);
     caml_check_bound(res, i)[1 + i] = _aL_;
     var i$0 = i + 1 | 0, i = i$0, param = t$0;
    }
   }
   function hashtbl_of_sexp(key_of_sexp, val_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_hashtbl_of_sexp_list_neede, sexp);
    var lst = sexp[1], htbl = caml_call2(Stdlib_MoreLabels[1][1], 0, 0);
    function act(param){
     if(1 === param[0]){
      var _aH_ = param[1];
      if(_aH_){
       var _aI_ = _aH_[2];
       if(_aI_ && ! _aI_[2]){
        var
         v_sexp = _aI_[1],
         k_sexp = _aH_[1],
         _aJ_ = caml_call1(val_of_sexp, v_sexp),
         _aK_ = caml_call1(key_of_sexp, k_sexp);
        return caml_call3(Stdlib_MoreLabels[1][5], htbl, _aK_, _aJ_);
       }
      }
     }
     return of_sexp_error(cst_hashtbl_of_sexp_tuple_list, sexp);
    }
    caml_call2(Stdlib_ListLabels[17], act, lst);
    return htbl;
   }
   function opaque_of_sexp(sexp){
    return of_sexp_error(cst_opaque_of_sexp_cannot_conv, sexp);
   }
   function fun_of_sexp(sexp){
    return of_sexp_error(cst_fun_of_sexp_cannot_convert, sexp);
   }
   var
    unit_sexp_grammar = Sexplib0_Sexp_conv_grammar[1],
    bool_sexp_grammar = Sexplib0_Sexp_conv_grammar[2],
    string_sexp_grammar = Sexplib0_Sexp_conv_grammar[3],
    bytes_sexp_grammar = Sexplib0_Sexp_conv_grammar[4],
    char_sexp_grammar = Sexplib0_Sexp_conv_grammar[5],
    int_sexp_grammar = Sexplib0_Sexp_conv_grammar[6],
    float_sexp_grammar = Sexplib0_Sexp_conv_grammar[7],
    int32_sexp_grammar = Sexplib0_Sexp_conv_grammar[8],
    int64_sexp_grammar = Sexplib0_Sexp_conv_grammar[9],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv_grammar[10],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[11],
    ref_sexp_grammar = Sexplib0_Sexp_conv_grammar[12],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[13],
    option_sexp_grammar = Sexplib0_Sexp_conv_grammar[14],
    list_sexp_grammar = Sexplib0_Sexp_conv_grammar[15],
    array_sexp_grammar = Sexplib0_Sexp_conv_grammar[16],
    opaque_sexp_grammar = Sexplib0_Sexp_conv_grammar[17],
    fun_sexp_grammar = Sexplib0_Sexp_conv_grammar[18];
   function get_flc_error(name, param){
    var chr = param[3], line = param[2], file = param[1];
    return [0, caml_call5(Stdlib_Printf[4], _j_, name, file, line, chr)];
   }
   var _k_ = 0;
   function _l_(param){
    if(param === Stdlib_Sys[44]) return _m_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   var _o_ = [0, [0, Stdlib_Sys[44], _l_], _k_];
   function _p_(param){
    if(param === Stdlib_Stack[1]) return _q_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
   }
   var _s_ = [0, [0, Stdlib_Stack[1], _p_], _o_];
   function _t_(param){
    if(param[1] !== Stdlib_Scanf[2])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
    var arg = param[2];
    return [1, [0, _u_, [0, [0, arg], 0]]];
   }
   var _w_ = [0, [0, Stdlib_Scanf[2], _t_], _s_];
   function _x_(param){
    if(param === Stdlib_Queue[1]) return _y_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
   }
   var _A_ = [0, [0, Stdlib_Queue[1], _x_], _w_];
   function _B_(param){
    if(param === Stdlib_Parsing[10]) return _C_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
   }
   var _E_ = [0, [0, Stdlib_Parsing[10], _B_], _A_];
   function _F_(param){
    if(param === Stdlib_Lazy[1]) return _G_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
   }
   var _I_ = [0, [0, Stdlib_Lazy[1], _F_], _E_];
   function _J_(param){
    if(param[1] !== Stdlib_Arg[8])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
    var arg = param[2];
    return [1, [0, _K_, [0, [0, arg], 0]]];
   }
   var _M_ = [0, [0, Stdlib_Arg[8], _J_], _I_];
   function _N_(param){
    if(param[1] !== Stdlib_Arg[7])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
    var arg = param[2];
    return [1, [0, _O_, [0, [0, arg], 0]]];
   }
   var _Q_ = [0, [0, Stdlib_Arg[7], _N_], _M_];
   function _R_(param){
    if(param[1] !== Stdlib[11])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
    var arg = param[2];
    return [1, [0, _S_, [0, [0, arg], 0]]];
   }
   var _U_ = [0, [0, Stdlib[11], _R_], _Q_];
   function _V_(param){
    if(param[1] !== Sexplib0_Sexp[5])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
    var arg = param[2];
    return [1, [0, _W_, [0, arg, 0]]];
   }
   var _Y_ = [0, [0, Sexplib0_Sexp[5], _V_], _U_];
   function _Z_(param){
    if(param[1] !== Stdlib[4])
     throw caml_maybe_attach_backtrace([0, Assert_failure, ___], 1);
    var arg = param[2];
    return get_flc_error(cst_Match_failure, arg);
   }
   var _$_ = [0, [0, Stdlib[4], _Z_], _Y_];
   function _aa_(param){
    if(param[1] !== Stdlib[6])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ac_], 1);
    var arg = param[2];
    return [1, [0, _ab_, [0, [0, arg], 0]]];
   }
   var _ad_ = [0, [0, Stdlib[6], _aa_], _$_];
   function _ae_(param){
    if(param === Stdlib[8]) return _af_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ag_], 1);
   }
   var _ah_ = [0, [0, Stdlib[8], _ae_], _ad_];
   function _ai_(param){
    if(param[1] !== Stdlib[7])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ak_], 1);
    var arg = param[2];
    return [1, [0, _aj_, [0, [0, arg], 0]]];
   }
   var _al_ = [0, [0, Stdlib[7], _ai_], _ah_];
   function _am_(param){
    if(param === Stdlib[12]) return _an_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ao_], 1);
   }
   var _ap_ = [0, [0, Stdlib[12], _am_], _al_];
   function _aq_(param){
    if(param === Stdlib[3]) return _ar_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _as_], 1);
   }
   var _at_ = [0, [0, Stdlib[3], _aq_], _ap_];
   function _au_(param){
    if(param[1] !== Stdlib[5])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _av_], 1);
    var arg = param[2];
    return get_flc_error(cst_Assert_failure, arg);
   }
   var _aw_ = [0, [0, Stdlib[5], _au_], _at_];
   function _ax_(param){
    var handler = param[2], extension_constructor = param[1];
    return add(_az_, _ay_, extension_constructor, handler);
   }
   caml_call2(Stdlib_ListLabels[17], _ax_, _aw_);
   var
    _aA_ = 0,
    _aD_ =
      [0,
       [0,
        Of_sexp_error,
        function(param){
         if(param[1] !== Of_sexp_error)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aC_], 1);
         var sexp = param[3], exc = param[2];
         return [1, [0, _aB_, [0, sexp_of_exn(exc), [0, sexp, 0]]]];
        }],
       _aA_];
   function _aE_(param){
    var handler = param[2], extension_constructor = param[1];
    return add(_aG_, _aF_, extension_constructor, handler);
   }
   caml_call2(Stdlib_ListLabels[17], _aE_, _aD_);
   var
    Sexplib0_Sexp_conv =
      [0,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       [0, add, For_unit_tests_only]];
   runtime.caml_register_global
    (117, Sexplib0_Sexp_conv, "Sexplib0__Sexp_conv");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_error
//# unitInfo: Requires: Sexplib0__Sexp_conv, Stdlib, Stdlib__ListLabels, Stdlib__Printf, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = " ",
    cst_has_incorrect_number_of_ar = " has incorrect number of arguments",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    cst_of_sexp_trying_to_convert_ =
      "_of_sexp: trying to convert an empty type",
    cst_of_sexp_the_empty_list_is_ =
      "_of_sexp: the empty list is an invalid polymorphic variant",
    cst_of_sexp_a_nested_list_is_a =
      "_of_sexp: a nested list is an invalid polymorphic variant",
    cst_of_sexp_polymorphic_varian$0 =
      "_of_sexp: polymorphic variant tag takes an argument",
    _e_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: polymorphic variant tag ",
         [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]]],
       "%s_of_sexp: polymorphic variant tag %S has incorrect number of arguments"],
    cst_of_sexp_polymorphic_varian =
      "_of_sexp: polymorphic variant does not take arguments",
    cst_of_sexp_no_matching_varian = "_of_sexp: no matching variant found",
    cst_of_sexp_cannot_convert_val =
      "_of_sexp: cannot convert values of types resulting from polymorphic record fields",
    cst_of_sexp_list_instead_of_at =
      "_of_sexp: list instead of atom for record expected",
    _d_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: the following record elements were undefined: ",
         [2, 0, 0]]],
       "%s_of_sexp: the following record elements were undefined: %s"],
    cst_extra_fields = "extra fields",
    cst_duplicate_fields = "duplicate fields",
    _c_ =
      [0,
       [2, 0, [11, "_of_sexp: ", [2, 0, [11, ": ", [2, 0, 0]]]]],
       "%s_of_sexp: %s: %s"],
    cst_of_sexp_record_conversion_$0 =
      "_of_sexp: record conversion: only pairs expected, their first element must be an atom",
    cst_of_sexp_record_conversion_ =
      "_of_sexp: record conversion: a [sexp.bool] field was given a payload.",
    cst_of_sexp_unexpected_variant =
      "_of_sexp: unexpected variant constructor",
    cst_of_sexp_expected_a_variant$0 =
      "_of_sexp: expected a variant type, saw an empty list",
    cst_of_sexp_expected_a_variant =
      "_of_sexp: expected a variant type, saw a nested list",
    cst_of_sexp_this_constructor_r =
      "_of_sexp: this constructor requires arguments",
    _b_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: sum tag ",
         [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]]],
       "%s_of_sexp: sum tag %S has incorrect number of arguments"],
    cst_of_sexp_this_constructor_d =
      "_of_sexp: this constructor does not take arguments",
    _a_ =
      [0,
       [2,
        0,
        [11, "_of_sexp: tuple of size ", [4, 0, 0, 0, [11, " expected", 0]]]],
       "%s_of_sexp: tuple of size %d expected"],
    cst_Sexplib0_Sexp_conv_error_N =
      "Sexplib0__Sexp_conv_error.No_variant_match";
   function tuple_of_size_n_expected(loc, n, sexp){
    var _t_ = caml_call3(Stdlib_Printf[4], _a_, loc, n);
    return caml_call2(Sexplib0_Sexp_conv[27], _t_, sexp);
   }
   function stag_no_args(loc, sexp){
    var _s_ = caml_call2(Stdlib[28], loc, cst_of_sexp_this_constructor_d);
    return caml_call2(Sexplib0_Sexp_conv[27], _s_, sexp);
   }
   function stag_incorrect_n_args(loc, tag, sexp){
    var msg = caml_call3(Stdlib_Printf[4], _b_, loc, tag);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function stag_takes_args(loc, sexp){
    var _r_ = caml_call2(Stdlib[28], loc, cst_of_sexp_this_constructor_r);
    return caml_call2(Sexplib0_Sexp_conv[27], _r_, sexp);
   }
   function nested_list_invalid_sum(loc, sexp){
    var _q_ = caml_call2(Stdlib[28], loc, cst_of_sexp_expected_a_variant);
    return caml_call2(Sexplib0_Sexp_conv[27], _q_, sexp);
   }
   function empty_list_invalid_sum(loc, sexp){
    var _p_ = caml_call2(Stdlib[28], loc, cst_of_sexp_expected_a_variant$0);
    return caml_call2(Sexplib0_Sexp_conv[27], _p_, sexp);
   }
   function unexpected_stag(loc, sexp){
    var _o_ = caml_call2(Stdlib[28], loc, cst_of_sexp_unexpected_variant);
    return caml_call2(Sexplib0_Sexp_conv[27], _o_, sexp);
   }
   function record_sexp_bool_with_payload(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_record_conversion_);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_only_pairs_expected(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_record_conversion_$0);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_superfluous_fields(what, loc, rev_fld_names, sexp){
    var
     _n_ = caml_call1(Stdlib_ListLabels[9], rev_fld_names),
     fld_names_str = caml_call2(Stdlib_StringLabels[6], cst, _n_),
     msg = caml_call4(Stdlib_Printf[4], _c_, loc, what, fld_names_str);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_duplicate_fields(loc, rev_fld_names, sexp){
    return record_superfluous_fields
            (cst_duplicate_fields, loc, rev_fld_names, sexp);
   }
   function record_extra_fields(loc, rev_fld_names, sexp){
    return record_superfluous_fields
            (cst_extra_fields, loc, rev_fld_names, sexp);
   }
   function record_get_undefined_loop(fields, param){
    var fields$0 = fields, param$0 = param;
    for(;;){
     if(! param$0){
      var _m_ = caml_call1(Stdlib_ListLabels[9], fields$0);
      return caml_call2(Stdlib_StringLabels[6], cst$0, _m_);
     }
     var _l_ = param$0[1];
     if(_l_[1]){
      var
       rest = param$0[2],
       field = _l_[2],
       fields$1 = [0, field, fields$0],
       fields$0 = fields$1,
       param$0 = rest;
      continue;
     }
     var rest$0 = param$0[2], param$0 = rest$0;
    }
   }
   function record_undefined_elements(loc, sexp, lst){
    var
     undefined$0 = record_get_undefined_loop(0, lst),
     msg = caml_call3(Stdlib_Printf[4], _d_, loc, undefined$0);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_list_instead_atom(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_list_instead_of_at);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_poly_field_value(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_cannot_convert_val);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   var
    No_variant_match =
      [248, cst_Sexplib0_Sexp_conv_error_N, runtime.caml_fresh_oo_id(0)];
   function no_variant_match(param){
    throw caml_maybe_attach_backtrace(No_variant_match, 1);
   }
   function no_matching_variant_found(loc, sexp){
    var _k_ = caml_call2(Stdlib[28], loc, cst_of_sexp_no_matching_varian);
    return caml_call2(Sexplib0_Sexp_conv[27], _k_, sexp);
   }
   function ptag_no_args(loc, sexp){
    var _j_ = caml_call2(Stdlib[28], loc, cst_of_sexp_polymorphic_varian);
    return caml_call2(Sexplib0_Sexp_conv[27], _j_, sexp);
   }
   function ptag_incorrect_n_args(loc, cnstr, sexp){
    var msg = caml_call3(Stdlib_Printf[4], _e_, loc, cnstr);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function ptag_takes_args(loc, sexp){
    var _i_ = caml_call2(Stdlib[28], loc, cst_of_sexp_polymorphic_varian$0);
    return caml_call2(Sexplib0_Sexp_conv[27], _i_, sexp);
   }
   function nested_list_invalid_poly_var(loc, sexp){
    var _h_ = caml_call2(Stdlib[28], loc, cst_of_sexp_a_nested_list_is_a);
    return caml_call2(Sexplib0_Sexp_conv[27], _h_, sexp);
   }
   function empty_list_invalid_poly_var(loc, sexp){
    var _g_ = caml_call2(Stdlib[28], loc, cst_of_sexp_the_empty_list_is_);
    return caml_call2(Sexplib0_Sexp_conv[27], _g_, sexp);
   }
   function empty_type(loc, sexp){
    var _f_ = caml_call2(Stdlib[28], loc, cst_of_sexp_trying_to_convert_);
    return caml_call2(Sexplib0_Sexp_conv[27], _f_, sexp);
   }
   var
    Sexplib0_Sexp_conv_error =
      [0,
       Of_sexp_error,
       tuple_of_size_n_expected,
       stag_no_args,
       stag_incorrect_n_args,
       stag_takes_args,
       nested_list_invalid_sum,
       empty_list_invalid_sum,
       unexpected_stag,
       record_sexp_bool_with_payload,
       record_only_pairs_expected,
       record_superfluous_fields,
       record_duplicate_fields,
       record_extra_fields,
       record_get_undefined_loop,
       record_undefined_elements,
       record_list_instead_atom,
       record_poly_field_value,
       No_variant_match,
       no_variant_match,
       no_matching_variant_found,
       ptag_no_args,
       ptag_incorrect_n_args,
       ptag_takes_args,
       nested_list_invalid_poly_var,
       empty_list_invalid_poly_var,
       empty_type];
   runtime.caml_register_global
    (30, Sexplib0_Sexp_conv_error, "Sexplib0__Sexp_conv_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexpable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0_Sexpable = [0];
   runtime.caml_register_global(0, Sexplib0_Sexpable, "Sexplib0__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2V4cF9vZl90IiwidCIsInRfb2Zfc2V4cCIsImNvbXBhcmUiLCJhJDAiLCJiJDAiLCJhJDEiLCJiJDEiLCJhJDIiLCJiJDIiLCJhIiwiYiIsInlzIiwieSIsInhzIiwieCIsInJlcyIsImVxdWFsIiwiZGVmYXVsdF9pbmRlbnQiLCJtdXN0X2VzY2FwZSIsInN0ciIsImxlbiIsIml4JDEiLCJpeCIsIm5leHQiLCJuZXh0JDAiLCJpeCQwIiwiZXNjYXBlZCIsInMiLCJuIiwiaSQwIiwicyQwIiwiaSIsImMiLCJlc2Nfc3RyIiwiZXN0ciIsImVsZW4iLCJpbmRleF9vZl9uZXdsaW5lIiwic3RhcnQiLCJtYWNoX21heWJlX2VzY19zdHIiLCJwcF9odW1faW5kZW50IiwiaW5kZW50IiwicHBmIiwiaW5kZXgiLCJpbmRleCQwIiwibmV4dF9uZXdsaW5lIiwiZW5kX3BvcyIsImVuZF9wb3MkMCIsIm5leHRfbGluZSIsIm5ld2xpbmVfaW5kZXgiLCJpbmRleCQxIiwiaCIsInQkMCIsImgkMCIsInBwX21hY2hfaW50ZXJuYWwiLCJtYXlfbmVlZF9zcGFjZSIsInN0ciQwIiwibmV3X21heV9uZWVkX3NwYWNlIiwibmV3X21heV9uZWVkX3NwYWNlJDAiLCJtYXlfbmVlZF9zcGFjZSQwIiwibWF5X25lZWRfc3BhY2UkMSIsIm1heV9uZWVkX3NwYWNlJDIiLCJwcF9odW0iLCJzZXhwIiwicHBfbWFjaCIsInNpemVfbG9vcCIsImFjYyIsInYiLCJsc3QiLCJzaXplIiwidG9fYnVmZmVyX2h1bSIsImJ1ZiIsIm9wdCIsInN0aCIsInRvX2J1ZmZlcl9tYWNoIiwibG9vcCIsInRvX2J1ZmZlcl9nZW4iLCJhZGRfY2hhciIsImFkZF9zdHJpbmciLCJidWZmZXIiLCJ0b19zdHJpbmdfaHVtIiwidG9fc3RyaW5nX21hY2giLCJvZl9mbG9hdF9zdHlsZSIsIm9mX2ludF9zdHlsZSIsIm1lc3NhZ2UiLCJuYW1lIiwiZmllbGRzIiwiY29udl9maWVsZHMiLCJyZXN0IiwiZnNleHAiLCJmbmFtZSIsImRvY19jb21tZW50X3RhZyIsImNvZXJjZSIsInVuaXRfc2V4cF9ncmFtbWFyIiwic2V4cF90X3NleHBfZ3JhbW1hciIsImVtcHR5X3NleHBfZ3JhbW1hciIsImJvb2xfc2V4cF9ncmFtbWFyIiwic3RyaW5nX3NleHBfZ3JhbW1hciIsImJ5dGVzX3NleHBfZ3JhbW1hciIsImNoYXJfc2V4cF9ncmFtbWFyIiwiaW50X3NleHBfZ3JhbW1hciIsImZsb2F0X3NleHBfZ3JhbW1hciIsImludDMyX3NleHBfZ3JhbW1hciIsImludDY0X3NleHBfZ3JhbW1hciIsIm5hdGl2ZWludF9zZXhwX2dyYW1tYXIiLCJyZWZfc2V4cF9ncmFtbWFyIiwiZ3JhbW1hciIsImxhenlfdF9zZXhwX2dyYW1tYXIiLCJvcHRpb25fc2V4cF9ncmFtbWFyIiwicGFyYW0iLCJsaXN0X3NleHBfZ3JhbW1hciIsImFycmF5X3NleHBfZ3JhbW1hciIsImRlZmF1bHRfc3RyaW5nX29mX2Zsb2F0IiwicmVhZF9vbGRfb3B0aW9uX2Zvcm1hdCIsIndyaXRlX29sZF9vcHRpb25fZm9ybWF0IiwibGlzdF9tYXAiLCJmIiwibCIsInNleHBfb2ZfdW5pdCIsInNleHBfb2ZfYm9vbCIsInNleHBfb2Zfc3RyaW5nIiwic2V4cF9vZl9ieXRlcyIsImJ5dGVzIiwic2V4cF9vZl9jaGFyIiwic2V4cF9vZl9pbnQiLCJzZXhwX29mX2Zsb2F0Iiwic2V4cF9vZl9pbnQzMiIsInNleHBfb2ZfaW50NjQiLCJzZXhwX29mX25hdGl2ZWludCIsInNleHBfb2ZfcmVmIiwic2V4cF9vZl9hIiwicmYiLCJzZXhwX29mX2xhenlfdCIsImx2Iiwic2V4cF9vZl9vcHRpb24iLCJzZXhwX29mX3BhaXIiLCJzZXhwX29mX2IiLCJzZXhwX29mX3RyaXBsZSIsInNleHBfb2ZfYyIsInNleHBfb2ZfbGlzdCIsInNleHBfb2ZfYXJyYXkiLCJhciIsImxzdF9yZWYiLCJzZXhwX29mX2hhc2h0YmwiLCJzZXhwX29mX2tleSIsInNleHBfb2ZfdmFsIiwiaHRibCIsImNvbGwiLCJrIiwic2V4cF9vZl9vcGFxdWUiLCJzZXhwX29mX2Z1biIsImhhc2giLCJ0aGVfZXhuX3RhYmxlIiwiYWRkIiwiZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIiwic2V4cF9vZl9leG4iLCJwcmludGV4YyIsImZpbmRfYXV0byIsImZvcl9wcmludGV4YyIsImV4biIsInNleHBfb2ZfZXhuX29wdCIsImV4bl90b19zdHJpbmciLCJlIiwicHJpbnRleGNfcHJlZmVyX3NleHAiLCJyZWNvcmRfY2hlY2tfZXh0cmFfZmllbGRzIiwib2Zfc2V4cF9lcnJvcl9leG4iLCJleGMiLCJvZl9zZXhwX2Vycm9yIiwid2hhdCIsInVuaXRfb2Zfc2V4cCIsImJvb2xfb2Zfc2V4cCIsInN0cmluZ19vZl9zZXhwIiwiYnl0ZXNfb2Zfc2V4cCIsImNoYXJfb2Zfc2V4cCIsImludF9vZl9zZXhwIiwiZXhjJDAiLCJmbG9hdF9vZl9zZXhwIiwiaW50MzJfb2Zfc2V4cCIsImludDY0X29mX3NleHAiLCJuYXRpdmVpbnRfb2Zfc2V4cCIsInJlZl9vZl9zZXhwIiwiYV9vZl9zZXhwIiwibGF6eV90X29mX3NleHAiLCJvcHRpb25fb2Zfc2V4cCIsImVsJDAiLCJlbCIsInBhaXJfb2Zfc2V4cCIsImJfb2Zfc2V4cCIsImJfc2V4cCIsImFfc2V4cCIsInRyaXBsZV9vZl9zZXhwIiwiY19vZl9zZXhwIiwiY19zZXhwIiwibGlzdF9vZl9zZXhwIiwicmV2X2xzdCIsImFycmF5X29mX3NleHAiLCJoYXNodGJsX29mX3NleHAiLCJrZXlfb2Zfc2V4cCIsInZhbF9vZl9zZXhwIiwiYWN0Iiwidl9zZXhwIiwia19zZXhwIiwib3BhcXVlX29mX3NleHAiLCJmdW5fb2Zfc2V4cCIsImdldF9mbGNfZXJyb3IiLCJjaHIiLCJsaW5lIiwiZmlsZSIsImFyZyIsImhhbmRsZXIiLCJ0dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQiLCJsb2MiLCJzdGFnX25vX2FyZ3MiLCJzdGFnX2luY29ycmVjdF9uX2FyZ3MiLCJ0YWciLCJtc2ciLCJzdGFnX3Rha2VzX2FyZ3MiLCJuZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSIsImVtcHR5X2xpc3RfaW52YWxpZF9zdW0iLCJ1bmV4cGVjdGVkX3N0YWciLCJyZWNvcmRfc2V4cF9ib29sX3dpdGhfcGF5bG9hZCIsInJlY29yZF9vbmx5X3BhaXJzX2V4cGVjdGVkIiwicmVjb3JkX3N1cGVyZmx1b3VzX2ZpZWxkcyIsInJldl9mbGRfbmFtZXMiLCJmbGRfbmFtZXNfc3RyIiwicmVjb3JkX2R1cGxpY2F0ZV9maWVsZHMiLCJyZWNvcmRfZXh0cmFfZmllbGRzIiwicmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCIsImZpZWxkcyQwIiwiZmllbGQiLCJyZXN0JDAiLCJyZWNvcmRfdW5kZWZpbmVkX2VsZW1lbnRzIiwidW5kZWZpbmVkJDAiLCJyZWNvcmRfbGlzdF9pbnN0ZWFkX2F0b20iLCJyZWNvcmRfcG9seV9maWVsZF92YWx1ZSIsIm5vX3ZhcmlhbnRfbWF0Y2giLCJub19tYXRjaGluZ192YXJpYW50X2ZvdW5kIiwicHRhZ19ub19hcmdzIiwicHRhZ19pbmNvcnJlY3Rfbl9hcmdzIiwiY25zdHIiLCJwdGFnX3Rha2VzX2FyZ3MiLCJuZXN0ZWRfbGlzdF9pbnZhbGlkX3BvbHlfdmFyIiwiZW1wdHlfbGlzdF9pbnZhbGlkX3BvbHlfdmFyIiwiZW1wdHlfdHlwZSJdLCJzb3VyY2VzIjpbIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9zZXhwbGliMC9zZXhwLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL3NleHBsaWIwL3NleHBfZ3JhbW1hci5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9zZXhwbGliMC9zZXhwX2NvbnZfZ3JhbW1hci5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9zZXhwbGliMC9zZXhwX2NvbnYubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvc2V4cGxp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R3BCaUwsZ0JBQWdCN0IsS0FBSXBKO0lBQ1IsaUNBRElvSjtJQUNsQiwrQ0FEc0JwSjtHQUMwRDtZQUc5RWtMLDZCQUE2QjlCLEtBQUlwSjtJQUNyQixpQ0FEaUJvSjtJQUMvQiwrQ0FEbUNwSjtHQUNtRDtZQUdwRm1MLDRCQUE0Qi9CLEtBQUlwSjtJQUNwQixpQ0FEZ0JvSjtJQUM5QiwrQ0FEa0NwSjtHQUNxRDtZQUdyRm9MLFdBQVdoQyxLQUFJcEo7SUFDSCxpQ0FERG9KO0lBQ2IsK0NBRGlCcEo7R0FDcUQ7Ozs7O09BL0hwRW1KO09BTUFFO09BSUFDO09BS0FHO09BSUFDO09BSUFDO09BSUFDO09BTUFDO09BT0FDO09BU0FDO09BTUFHO09BSUFDO09BSUlDO09BTUpJO09BUUFFO09BS0FDOztPQVlBQztPQUVBQztPQUlBQztPQUlBQztPQVVBRTtPQUlBQztPQUlBQztPQUlBQzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG4oKiBibGl0X3N0cmluZyBkb2Vzbid0IGV4aXN0IGluIFtTdGRMYWJlbHMuQnl0ZXNdLi4uICAqKVxubGV0IGJ5dGVzX2JsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuID1cbiAgQnl0ZXMuYmxpdF9zdHJpbmcgc3JjIHNyY19wb3MgZHN0IGRzdF9wb3MgbGVuXG47O1xuXG5vcGVuIFN0ZExhYmVsc1xub3BlbiBGb3JtYXRcblxuKCoqIFR5cGUgb2YgUy1leHByZXNzaW9ucyAqKVxudHlwZSB0ID1cbiAgfCBBdG9tIG9mIHN0cmluZ1xuICB8IExpc3Qgb2YgdCBsaXN0XG5cbmxldCBzZXhwX29mX3QgdCA9IHRcbmxldCB0X29mX3NleHAgdCA9IHRcblxubGV0IHJlYyBjb21wYXJlX2xpc3QgYSBiID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgbGV0IHJlcyA9IGNvbXBhcmUgeCB5IGluXG4gICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBjb21wYXJlX2xpc3QgeHMgeXNcblxuYW5kIGNvbXBhcmUgYSBiID1cbiAgaWYgYSA9PSBiXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IEF0b20gYSwgQXRvbSBiIC0+IFN0cmluZy5jb21wYXJlIGEgYlxuICAgIHwgQXRvbSBfLCBfIC0+IC0xXG4gICAgfCBfLCBBdG9tIF8gLT4gMVxuICAgIHwgTGlzdCBhLCBMaXN0IGIgLT4gY29tcGFyZV9saXN0IGEgYilcbjs7XG5cbmxldCBlcXVhbCBhIGIgPSBjb21wYXJlIGEgYiA9IDBcblxuZXhjZXB0aW9uIE5vdF9mb3VuZF9zIG9mIHRcbmV4Y2VwdGlvbiBPZl9zZXhwX2Vycm9yIG9mIGV4biAqIHRcblxubW9kdWxlIFByaW50aW5nID0gc3RydWN0XG4gICgqIERlZmF1bHQgaW5kZW50YXRpb24gbGV2ZWwgZm9yIGh1bWFuLXJlYWRhYmxlIGNvbnZlcnNpb25zICopXG5cbiAgbGV0IGRlZmF1bHRfaW5kZW50ID0gcmVmIDFcblxuICAoKiBFc2NhcGluZyBvZiBzdHJpbmdzIHVzZWQgYXMgYXRvbXMgaW4gUy1leHByZXNzaW9ucyAqKVxuXG4gIGxldCBtdXN0X2VzY2FwZSBzdHIgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxlbiA9IDBcbiAgICB8fFxuICAgIGxldCByZWMgbG9vcCBzdHIgaXggPVxuICAgICAgbWF0Y2ggc3RyLltpeF0gd2l0aFxuICAgICAgfCAnXCInIHwgJygnIHwgJyknIHwgJzsnIHwgJ1xcXFwnIC0+IHRydWVcbiAgICAgIHwgJ3wnIC0+XG4gICAgICAgIGl4ID4gMFxuICAgICAgICAmJlxuICAgICAgICBsZXQgbmV4dCA9IGl4IC0gMSBpblxuICAgICAgICBDaGFyLmVxdWFsIHN0ci5bbmV4dF0gJyMnIHx8IGxvb3Agc3RyIG5leHRcbiAgICAgIHwgJyMnIC0+XG4gICAgICAgIGl4ID4gMFxuICAgICAgICAmJlxuICAgICAgICBsZXQgbmV4dCA9IGl4IC0gMSBpblxuICAgICAgICBDaGFyLmVxdWFsIHN0ci5bbmV4dF0gJ3wnIHx8IGxvb3Agc3RyIG5leHRcbiAgICAgIHwgJ1xcMDAwJyAuLiAnXFwwMzInIHwgJ1xcMTI3JyAuLiAnXFwyNTUnIC0+IHRydWVcbiAgICAgIHwgXyAtPiBpeCA+IDAgJiYgbG9vcCBzdHIgKGl4IC0gMSlcbiAgICBpblxuICAgIGxvb3Agc3RyIChsZW4gLSAxKVxuICA7O1xuXG4gIGxldCBlc2NhcGVkIHMgPVxuICAgIGxldCBuID0gcmVmIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgblxuICAgICAgOj0gIW5cbiAgICAgICAgICtcbiAgICAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXG4nIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXGInIC0+IDJcbiAgICAgICAgIHwgJyAnIC4uICd+JyAtPiAxXG4gICAgICAgICB8IF8gLT4gNFxuICAgIGRvbmU7XG4gICAgaWYgIW4gPSBTdHJpbmcubGVuZ3RoIHNcbiAgICB0aGVuIHNcbiAgICBlbHNlIChcbiAgICAgIGxldCBzJyA9IEJ5dGVzLmNyZWF0ZSAhbiBpblxuICAgICAgbiA6PSAwO1xuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgKG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICAgICB8ICdcXG4nIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ24nXG4gICAgICAgICB8ICdcXHQnIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ3InXG4gICAgICAgICB8ICdcXGInIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ2InXG4gICAgICAgICB8ICcgJyAuLiAnficgYXMgYyAtPiBCeXRlcy51bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgICAgIHwgYyAtPlxuICAgICAgICAgICBsZXQgYSA9IENoYXIuY29kZSBjIGluXG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gKENoYXIuY2hyICg0OCArIChhIC8gMTAwKSkpO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gKENoYXIuY2hyICg0OCArIChhIC8gMTAgbW9kIDEwKSkpO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gKENoYXIuY2hyICg0OCArIChhIG1vZCAxMCkpKSk7XG4gICAgICAgIGluY3IgblxuICAgICAgZG9uZTtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcycpXG4gIDs7XG5cbiAgbGV0IGVzY19zdHIgc3RyID1cbiAgICBsZXQgZXN0ciA9IGVzY2FwZWQgc3RyIGluXG4gICAgbGV0IGVsZW4gPSBTdHJpbmcubGVuZ3RoIGVzdHIgaW5cbiAgICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIChlbGVuICsgMikgaW5cbiAgICBieXRlc19ibGl0X3N0cmluZyB+c3JjOmVzdHIgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3BvczoxIH5sZW46ZWxlbjtcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlcyAwICdcIic7XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXMgKGVsZW4gKyAxKSAnXCInO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIDs7XG5cbiAgbGV0IGluZGV4X29mX25ld2xpbmUgc3RyIHN0YXJ0ID1cbiAgICB0cnkgU29tZSAoU3RyaW5nLmluZGV4X2Zyb20gc3RyIHN0YXJ0ICdcXG4nKSB3aXRoXG4gICAgfCBOb3RfZm91bmQgLT4gTm9uZVxuICA7O1xuXG4gIGxldCBnZXRfc3Vic3RyaW5nIHN0ciBpbmRleCBlbmRfcG9zX29wdCA9XG4gICAgbGV0IGVuZF9wb3MgPVxuICAgICAgbWF0Y2ggZW5kX3Bvc19vcHQgd2l0aFxuICAgICAgfCBOb25lIC0+IFN0cmluZy5sZW5ndGggc3RyXG4gICAgICB8IFNvbWUgZW5kX3BvcyAtPiBlbmRfcG9zXG4gICAgaW5cbiAgICBTdHJpbmcuc3ViIHN0ciB+cG9zOmluZGV4IH5sZW46KGVuZF9wb3MgLSBpbmRleClcbiAgOztcblxuICBsZXQgaXNfb25lX2xpbmUgc3RyID1cbiAgICBtYXRjaCBpbmRleF9vZl9uZXdsaW5lIHN0ciAwIHdpdGhcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgIHwgU29tZSBpbmRleCAtPiBpbmRleCArIDEgPSBTdHJpbmcubGVuZ3RoIHN0clxuICA7O1xuXG4gIGxldCBwcF9odW1fbWF5YmVfZXNjX3N0ciBwcGYgc3RyID1cbiAgICBpZiBub3QgKG11c3RfZXNjYXBlIHN0cilcbiAgICB0aGVuIHBwX3ByaW50X3N0cmluZyBwcGYgc3RyXG4gICAgZWxzZSBpZiBpc19vbmVfbGluZSBzdHJcbiAgICB0aGVuIHBwX3ByaW50X3N0cmluZyBwcGYgKGVzY19zdHIgc3RyKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlYyBsb29wIGluZGV4ID1cbiAgICAgICAgbGV0IG5leHRfbmV3bGluZSA9IGluZGV4X29mX25ld2xpbmUgc3RyIGluZGV4IGluXG4gICAgICAgIGxldCBuZXh0X2xpbmUgPSBnZXRfc3Vic3RyaW5nIHN0ciBpbmRleCBuZXh0X25ld2xpbmUgaW5cbiAgICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZXNjYXBlZCBuZXh0X2xpbmUpO1xuICAgICAgICBtYXRjaCBuZXh0X25ld2xpbmUgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgfCBTb21lIG5ld2xpbmVfaW5kZXggLT5cbiAgICAgICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiXFxcXFwiO1xuICAgICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpO1xuICAgICAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCJcXFxcblwiO1xuICAgICAgICAgIGxvb3AgKG5ld2xpbmVfaW5kZXggKyAxKVxuICAgICAgaW5cbiAgICAgIHBwX29wZW5fYm94IHBwZiAwO1xuICAgICAgKCogdGhlIGxlYWRpbmcgc3BhY2UgaXMgdG8gbGluZSB1cCB0aGUgbGluZXMgKilcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIgXFxcIlwiO1xuICAgICAgbG9vcCAwO1xuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIlxcXCJcIjtcbiAgICAgIHBwX2Nsb3NlX2JveCBwcGYgKCkpXG4gIDs7XG5cbiAgbGV0IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgPSBpZiBtdXN0X2VzY2FwZSBzdHIgdGhlbiBlc2Nfc3RyIHN0ciBlbHNlIHN0clxuXG4gICgqIE91dHB1dCBvZiBTLWV4cHJlc3Npb25zIHRvIGZvcm1hdHRlcnMgKilcblxuICBsZXQgcmVjIHBwX2h1bV9pbmRlbnQgaW5kZW50IHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPiBwcF9odW1fbWF5YmVfZXNjX3N0ciBwcGYgc3RyXG4gICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICBwcF9vcGVuX2JveCBwcGYgaW5kZW50O1xuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIihcIjtcbiAgICAgIHBwX2h1bV9pbmRlbnQgaW5kZW50IHBwZiBoO1xuICAgICAgcHBfaHVtX3Jlc3QgaW5kZW50IHBwZiB0XG4gICAgfCBMaXN0IFtdIC0+IHBwX3ByaW50X3N0cmluZyBwcGYgXCIoKVwiXG5cbiAgYW5kIHBwX2h1bV9yZXN0IGluZGVudCBwcGYgPSBmdW5jdGlvblxuICAgIHwgaCA6OiB0IC0+XG4gICAgICBwcF9wcmludF9zcGFjZSBwcGYgKCk7XG4gICAgICBwcF9odW1faW5kZW50IGluZGVudCBwcGYgaDtcbiAgICAgIHBwX2h1bV9yZXN0IGluZGVudCBwcGYgdFxuICAgIHwgW10gLT5cbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIpXCI7XG4gICAgICBwcF9jbG9zZV9ib3ggcHBmICgpXG4gIDs7XG5cbiAgbGV0IHJlYyBwcF9tYWNoX2ludGVybmFsIG1heV9uZWVkX3NwYWNlIHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPlxuICAgICAgbGV0IHN0cicgPSBtYWNoX21heWJlX2VzY19zdHIgc3RyIGluXG4gICAgICBsZXQgbmV3X21heV9uZWVkX3NwYWNlID0gc3RyJyA9PSBzdHIgaW5cbiAgICAgIGlmIG1heV9uZWVkX3NwYWNlICYmIG5ld19tYXlfbmVlZF9zcGFjZSB0aGVuIHBwX3ByaW50X3N0cmluZyBwcGYgXCIgXCI7XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIHN0cic7XG4gICAgICBuZXdfbWF5X25lZWRfc3BhY2VcbiAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIoXCI7XG4gICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBwcF9tYWNoX2ludGVybmFsIGZhbHNlIHBwZiBoIGluXG4gICAgICBwcF9tYWNoX3Jlc3QgbWF5X25lZWRfc3BhY2UgcHBmIHQ7XG4gICAgICBmYWxzZVxuICAgIHwgTGlzdCBbXSAtPlxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIigpXCI7XG4gICAgICBmYWxzZVxuXG4gIGFuZCBwcF9tYWNoX3Jlc3QgbWF5X25lZWRfc3BhY2UgcHBmID0gZnVuY3Rpb25cbiAgICB8IGggOjogdCAtPlxuICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gcHBfbWFjaF9pbnRlcm5hbCBtYXlfbmVlZF9zcGFjZSBwcGYgaCBpblxuICAgICAgcHBfbWFjaF9yZXN0IG1heV9uZWVkX3NwYWNlIHBwZiB0XG4gICAgfCBbXSAtPiBwcF9wcmludF9zdHJpbmcgcHBmIFwiKVwiXG4gIDs7XG5cbiAgbGV0IHBwX2h1bSBwcGYgc2V4cCA9IHBwX2h1bV9pbmRlbnQgIWRlZmF1bHRfaW5kZW50IHBwZiBzZXhwXG4gIGxldCBwcF9tYWNoIHBwZiBzZXhwID0gaWdub3JlIChwcF9tYWNoX2ludGVybmFsIGZhbHNlIHBwZiBzZXhwKVxuICBsZXQgcHAgPSBwcF9tYWNoXG5cbiAgKCogU2V4cCBzaXplICopXG5cbiAgbGV0IHJlYyBzaXplX2xvb3AgKCh2LCBjKSBhcyBhY2MpID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+IHYgKyAxLCBjICsgU3RyaW5nLmxlbmd0aCBzdHJcbiAgICB8IExpc3QgbHN0IC0+IExpc3QuZm9sZF9sZWZ0IGxzdCB+aW5pdDphY2MgfmY6c2l6ZV9sb29wXG4gIDs7XG5cbiAgbGV0IHNpemUgc2V4cCA9IHNpemVfbG9vcCAoMCwgMCkgc2V4cFxuXG4gICgqIEJ1ZmZlciBjb252ZXJzaW9ucyAqKVxuXG4gIGxldCB0b19idWZmZXJfaHVtIH5idWYgPyhpbmRlbnQgPSAhZGVmYXVsdF9pbmRlbnQpIHNleHAgPVxuICAgIGxldCBwcGYgPSBGb3JtYXQuZm9ybWF0dGVyX29mX2J1ZmZlciBidWYgaW5cbiAgICBGb3JtYXQuZnByaW50ZiBwcGYgXCIlYUA/XCIgKHBwX2h1bV9pbmRlbnQgaW5kZW50KSBzZXhwXG4gIDs7XG5cbiAgbGV0IHRvX2J1ZmZlcl9tYWNoIH5idWYgc2V4cCA9XG4gICAgbGV0IHJlYyBsb29wIG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgQXRvbSBzdHIgLT5cbiAgICAgICAgbGV0IHN0cicgPSBtYWNoX21heWJlX2VzY19zdHIgc3RyIGluXG4gICAgICAgIGxldCBuZXdfbWF5X25lZWRfc3BhY2UgPSBzdHInID09IHN0ciBpblxuICAgICAgICBpZiBtYXlfbmVlZF9zcGFjZSAmJiBuZXdfbWF5X25lZWRfc3BhY2UgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmICcgJztcbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIHN0cic7XG4gICAgICAgIG5ld19tYXlfbmVlZF9zcGFjZVxuICAgICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJygnO1xuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIGZhbHNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHQ7XG4gICAgICAgIGZhbHNlXG4gICAgICB8IExpc3QgW10gLT5cbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiKClcIjtcbiAgICAgICAgZmFsc2VcbiAgICBhbmQgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgaCA6OiB0IC0+XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgbWF5X25lZWRfc3BhY2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdFxuICAgICAgfCBbXSAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmICcpJ1xuICAgIGluXG4gICAgaWdub3JlIChsb29wIGZhbHNlIHNleHApXG4gIDs7XG5cbiAgbGV0IHRvX2J1ZmZlciA9IHRvX2J1ZmZlcl9tYWNoXG5cbiAgbGV0IHRvX2J1ZmZlcl9nZW4gfmJ1ZiB+YWRkX2NoYXIgfmFkZF9zdHJpbmcgc2V4cCA9XG4gICAgbGV0IHJlYyBsb29wIG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgQXRvbSBzdHIgLT5cbiAgICAgICAgbGV0IHN0cicgPSBtYWNoX21heWJlX2VzY19zdHIgc3RyIGluXG4gICAgICAgIGxldCBuZXdfbWF5X25lZWRfc3BhY2UgPSBzdHInID09IHN0ciBpblxuICAgICAgICBpZiBtYXlfbmVlZF9zcGFjZSAmJiBuZXdfbWF5X25lZWRfc3BhY2UgdGhlbiBhZGRfY2hhciBidWYgJyAnO1xuICAgICAgICBhZGRfc3RyaW5nIGJ1ZiBzdHInO1xuICAgICAgICBuZXdfbWF5X25lZWRfc3BhY2VcbiAgICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgICBhZGRfY2hhciBidWYgJygnO1xuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIGZhbHNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHQ7XG4gICAgICAgIGZhbHNlXG4gICAgICB8IExpc3QgW10gLT5cbiAgICAgICAgYWRkX3N0cmluZyBidWYgXCIoKVwiO1xuICAgICAgICBmYWxzZVxuICAgIGFuZCBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBoIDo6IHQgLT5cbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBtYXlfbmVlZF9zcGFjZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0XG4gICAgICB8IFtdIC0+IGFkZF9jaGFyIGJ1ZiAnKSdcbiAgICBpblxuICAgIGlnbm9yZSAobG9vcCBmYWxzZSBzZXhwKVxuICA7O1xuXG4gICgqIFRoZSBtYXhpbXVtIHNpemUgb2YgYSB0aGluZyBvbiB0aGUgbWlub3IgaGVhcCBpcyAyNTYgd29yZHMuXG4gICAgIFByZXZpb3VzbHksIHRoaXMgc2l6ZSBvZiB0aGUgcmV0dXJuZWQgYnVmZmVyIGhlcmUgd2FzIDQwOTYgYnl0ZXMsIHdoaWNoXG4gICAgIGNhdXNlZCB0aGUgQnVmZmVyIHRvIGJlIGFsbG9jYXRlZCBvbiB0aGUgKm1ham9yKiBoZWFwIGV2ZXJ5IHRpbWUuXG5cbiAgICAgQWNjb3JkaW5nIHRvIGEgc2ltcGxlIGJlbmNobWFyayBieSBSb24sIHdlIGNhbiBpbXByb3ZlIHBlcmZvcm1hbmNlIGZvclxuICAgICBzbWFsbCBzLWV4cHJlc3Npb25zIGJ5IGEgZmFjdG9yIG9mIH40IGlmIHdlIG9ubHkgYWxsb2NhdGUgMTAyNCBieXRlc1xuICAgICAoMTI4IHdvcmRzICsgc29tZSBzbWFsbCBvdmVyaGVhZCkgd29ydGggb2YgYnVmZmVyIGluaXRpYWxseS4gIEFuZCBvbmVcbiAgICAgY2FuIGFyZ3VlIHRoYXQgaWYgaXQncyBmcmVlIHRvIGFsbG9jYXRlIHN0cmluZ3Mgc21hbGxlciB0aGFuIDI1NiB3b3JkcyxcbiAgICAgbGFyZ2Ugcy1leHByZXNzaW9ucyByZXF1aXJpbmcgbGFyZ2VyIGV4cGVuc2l2ZSBidWZmZXJzIHdvbid0IG5vdGljZVxuICAgICB0aGUgZXh0cmEgdHdvIGRvdWJsaW5ncyBmcm9tIDEwMjQgYnl0ZXMgdG8gMjA0OCBhbmQgNDA5Ni4gQW5kIGVzcGVjaWFsbHlcbiAgICAgcGVyZm9ybWFuY2Utc2Vuc2l0aXZlIGFwcGxpY2F0aW9ucyB0byBhbHdheXMgcGFzcyBpbiBhIGxhcmdlciBidWZmZXIgdG9cbiAgICAgdXNlLiAqKVxuICBsZXQgYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSAxMDI0XG5cbiAgKCogU3RyaW5nIGNvbnZlcnNpb25zICopXG5cbiAgbGV0IHRvX3N0cmluZ19odW0gP2luZGVudCA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0clxuICAgICAgd2hlbiBtYXRjaCBpbmRleF9vZl9uZXdsaW5lIHN0ciAwIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICAgfCBTb21lIF8gLT4gZmFsc2UgLT4gbWFjaF9tYXliZV9lc2Nfc3RyIHN0clxuICAgIHwgc2V4cCAtPlxuICAgICAgbGV0IGJ1ZiA9IGJ1ZmZlciAoKSBpblxuICAgICAgdG9fYnVmZmVyX2h1bSA/aW5kZW50IHNleHAgfmJ1ZjtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nX21hY2ggPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT4gbWFjaF9tYXliZV9lc2Nfc3RyIHN0clxuICAgIHwgc2V4cCAtPlxuICAgICAgbGV0IGJ1ZiA9IGJ1ZmZlciAoKSBpblxuICAgICAgdG9fYnVmZmVyX21hY2ggc2V4cCB+YnVmO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdfbWFjaFxuZW5kXG5cbmluY2x1ZGUgUHJpbnRpbmdcblxubGV0IG9mX2Zsb2F0X3N0eWxlIDogWyBgVW5kZXJzY29yZXMgfCBgTm9fdW5kZXJzY29yZXMgXSByZWYgPSByZWYgYE5vX3VuZGVyc2NvcmVzXG5sZXQgb2ZfaW50X3N0eWxlIDogWyBgVW5kZXJzY29yZXMgfCBgTm9fdW5kZXJzY29yZXMgXSByZWYgPSByZWYgYE5vX3VuZGVyc2NvcmVzXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGluY2x1ZGUgUHJpbnRpbmdcbmVuZFxuXG5sZXQgbWVzc2FnZSBuYW1lIGZpZWxkcyA9XG4gIGxldCByZWMgY29udl9maWVsZHMgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IChmbmFtZSwgZnNleHApIDo6IHJlc3QgLT5cbiAgICAgIChtYXRjaCBmbmFtZSB3aXRoXG4gICAgICAgfCBcIlwiIC0+IGZzZXhwIDo6IGNvbnZfZmllbGRzIHJlc3RcbiAgICAgICB8IF8gLT4gTGlzdCBbIEF0b20gZm5hbWU7IGZzZXhwIF0gOjogY29udl9maWVsZHMgcmVzdClcbiAgaW5cbiAgTGlzdCAoQXRvbSBuYW1lIDo6IGNvbnZfZmllbGRzIGZpZWxkcylcbjs7XG4iLCIoKiogUmVwcmVzZW50YXRpb24gb2YgUy1leHByZXNzaW9uIGdyYW1tYXJzICopXG5cbigqKiBUaGlzIG1vZHVsZSBkZWZpbmVzIGEgcmVwcmVzZW50YXRpb24gZm9yIHMtZXhwcmVzc2lvbiBncmFtbWFycy4gVXNpbmcgcHB4X3NleHBfY29udlxuICAgIGFuZCBbW0BAZGVyaXZpbmcgc2V4cF9ncmFtbWFyXV0gcHJvZHVjZXMgYSBncmFtbWFyIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBkZXJpdmVkXG4gICAgW29mX3NleHBdIGZvciBhIGdpdmVuIHR5cGUuXG5cbiAgICBBcyB3aXRoIG90aGVyIGRlcml2ZWQgZGVmaW5pdGlvbnMsIHBvbHltb3JwaGljIHR5cGVzIGRlcml2ZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYVxuICAgIGdyYW1tYXIgZm9yIGVhY2ggdHlwZSBhcmd1bWVudCBhbmQgcHJvZHVjZXMgYSBncmFtbWFyIGZvciB0aGUgbW9ub21vcnBoaXplZCB0eXBlLlxuXG4gICAgTW9ub21vcnBoaWMgdHlwZXMgZGVyaXZlIGEgZ3JhbW1hciBkaXJlY3RseS4gVG8gYXZvaWQgdG9wLWxldmVsIHNpZGUgZWZmZWN0cyxcbiAgICBbW0BAZGVyaXZpbmcgc2V4cF9ncmFtbWFyXV0gd3JhcHMgZ3JhbW1hcnMgaW4gdGhlIFtMYXp5XSBjb25zdHJ1Y3RvciBhcyBuZWVkZWQuXG5cbiAgICBUaGlzIHR5cGUgbWF5IGNoYW5nZSBvdmVyIHRpbWUgYXMgb3VyIG5lZWRzIGZvciBleHByZXNzaXZlIGdyYW1tYXJzIGNoYW5nZS4gV2Ugd2lsbFxuICAgIGF0dGVtcHQgdG8gbWFrZSBjaGFuZ2VzIGJhY2t3YXJkLWNvbXBhdGlibGUsIG9yIGF0IGxlYXN0IHByb3ZpZGUgYSByZWFzb25hYmxlIHVwZ3JhZGVcbiAgICBwYXRoLiAqKVxuXG5bQEBAd2FybmluZyBcIi0zMFwiXSAoKiBhbGxvdyBkdXBsaWNhdGUgZmllbGQgbmFtZXMgKilcblxuKCoqIEdyYW1tYXIgb2YgYSBzZXhwLiAqKVxudHlwZSBncmFtbWFyID1cbiAgfCBBbnkgb2Ygc3RyaW5nICgqKiBhY2NlcHRzIGFueSBzZXhwOyBzdHJpbmcgaXMgYSB0eXBlIG5hbWUgZm9yIGh1bWFuIHJlYWRhYmlsaXR5ICopXG4gIHwgQm9vbCAoKiogYWNjZXB0cyB0aGUgYXRvbXMgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiLCBtb2R1bG8gY2FwaXRhbGl6YXRpb24gKilcbiAgfCBDaGFyICgqKiBhY2NlcHRzIGFueSBzaW5nbGUtY2hhcmFjdGVyIGF0b20gKilcbiAgfCBJbnRlZ2VyICgqKiBhY2NlcHRzIGFueSBhdG9tIG1hdGNoaW5nIG9jYW1sIGludGVnZXIgc3ludGF4LCByZWdhcmRsZXNzIG9mIGJpdCB3aWR0aCAqKVxuICB8IEZsb2F0ICgqKiBhY2NlcHRzIGFueSBhdG9tIG1hdGNoaW5nIG9jYW1sIGZsb2F0IHN5bnRheCAqKVxuICB8IFN0cmluZyAoKiogYWNjZXB0cyBhbnkgYXRvbSAqKVxuICB8IE9wdGlvbiBvZiBncmFtbWFyICgqKiBhY2NlcHRzIGFuIG9wdGlvbiwgYm90aCBbTm9uZV0gdnMgW1NvbWUgX10gYW5kIFsoKV0gdnMgWyhfKV0uICopXG4gIHwgTGlzdCBvZiBsaXN0X2dyYW1tYXIgKCoqIGFjY2VwdHMgYSBsaXN0ICopXG4gIHwgVmFyaWFudCBvZiB2YXJpYW50ICgqKiBhY2NlcHRzIGNsYXVzZXMga2V5ZWQgYnkgYSBsZWFkaW5nIG9yIHNvbGUgYXRvbSAqKVxuICB8IFVuaW9uIG9mIGdyYW1tYXIgbGlzdCAoKiogYWNjZXB0cyBhIHNleHAgaWYgYW55IG9mIHRoZSBsaXN0ZWQgZ3JhbW1hcnMgYWNjZXB0cyBpdCAqKVxuICB8IFRhZ2dlZCBvZiBncmFtbWFyIHdpdGhfdGFnXG4gICgqKiBhbm5vdGF0ZXMgYSBncmFtbWFyIHdpdGggYSBjbGllbnQtc3BlY2lmaWMga2V5L3ZhbHVlIHBhaXIgKilcbiAgfCBUeXZhciBvZiBzdHJpbmdcbiAgKCoqIE5hbWUgb2YgYSB0eXBlIHZhcmlhYmxlLCBlLmcuIFtUeXZhciBcImFcIl0gZm9yIFsnYV0uIE9ubHkgbWVhbmluZ2Z1bCB3aGVuIHRoZSBib2R5IG9mXG4gICAgICB0aGUgaW5uZXJtb3N0IGVuY2xvc2luZyBbZGVmbl0gZGVmaW5lcyBhIGNvcnJlc3BvbmRpbmcgdHlwZSB2YXJpYWJsZS4gKilcbiAgfCBUeWNvbiBvZiBzdHJpbmcgKiBncmFtbWFyIGxpc3RcbiAgKCoqIFR5cGUgY29uc3RydWN0b3IgYXBwbGllZCB0byBhcmd1bWVudHMuIEZvciBleGFtcGxlLCBbVHljb24gKFwibGlzdFwiLCBbIEludGVnZXIgXSldXG4gICAgICByZXByZXNlbnRzIFtpbnQgbGlzdF0uIE9ubHkgbWVhbmluZ2Z1bCB3aGVuIHRoZSBpbm5lcm1vc3QgZW5jbG9zaW5nIFtSZWN1cnNpdmVdXG4gICAgICBncmFtbWFyIGRlZmluZXMgYSBjb3JyZXNwb25kaW5nIHR5cGUgY29uc3RydWN0b3IuICopXG4gIHwgUmVjdXJzaXZlIG9mIGdyYW1tYXIgKiBkZWZuIGxpc3RcbiAgKCoqIFtSZWN1cnNpdmUgKGdyYW1tYXIsIGRlZmluaXRpb25zKV0gYWxsb3dzIFtncmFtbWFyXSB0byByZWZlciB0byB0eXBlIGNvbnN0cnVjdG9yc1xuICAgICAgZnJvbSB0aGUgbXV0dWFsbHkgcmVjdXJzaXZlIFtkZWZpbml0aW9uc10uIFRoZSBkZWZpbml0aW9ucyBtYXkgYWxzbyByZWZlciB0byBlYWNoXG4gICAgICBvdGhlcnMnIHR5cGUgY29uc3RydWN0b3JzLlxuXG4gICAgICBPcmRpbmFyaWx5LCBbZ3JhbW1hcl0gaXRzZWxmIGlzIGp1c3QgYSBbVHljb25dIGFyZ3VtZW50LCBhbHRob3VnaCB0ZWNobmljYWxseSBpdCBjYW5cbiAgICAgIGJlIGFueSBncmFtbWFyLlxuXG4gICAgICBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBkZWZpbml0aW9ucyBkZWZpbmUgYSBiaW5hcnkgdHJlZSBwYXJhbWV0ZXJpemVkIGJ5IGEgdHlwZVxuICAgICAgc3RvcmVkIGF0IGl0cyBsZWF2ZXMuXG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBkZWZucyA9XG4gICAgICAgICAgWyB7IHR5Y29uID0gXCJ0cmVlXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID1cbiAgICAgICAgICAgICAgICBWYXJpYW50XG4gICAgICAgICAgICAgICAgICB7IG5hbWVfa2luZCA9IENhcGl0YWxpemVkXG4gICAgICAgICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgICAgICAgIFsgeyBuYW1lID0gXCJOb2RlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFR5Y29uIChcIm5vZGVcIiwgW1R5dmFyIFwiYVwiXSksIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIDsgeyBuYW1lID0gXCJUcmVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFR5Y29uIChcImxlYWZcIiwgW1R5dmFyIFwiYVwiXSksIEVtcHR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICA7IHsgdHljb24gPSBcIm5vZGVcIlxuICAgICAgICAgICAgOyB0eXZhcnMgPSBbXCJhXCJdXG4gICAgICAgICAgICA7IGdyYW1tYXIgPSBMaXN0IChNYW55IChUeWNvbiBcInRyZWVcIiwgW1R5dmFyIFwiYVwiXSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOyB7IHR5Y29uID0gXCJsZWFmXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID0gW1R5dmFyIFwiYVwiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgOztcbiAgICAgIF19XG5cbiAgICAgIE5vcm1hbGx5LCB0aGUgdHlwZSBvZiBhIHRyZWUgc3RvcmluZyBpbnRlZ2VycyB3b3VsZCBiZSB3cml0dGVuIGxpa2UgdGhpczpcblxuICAgICAge1tcbiAgICAgICAgUmVjdXJzaXZlIChUeWNvbiAoXCJ0cmVlXCIsIFsgSW50ZWdlciBdKSwgZGVmbnMpXG4gICAgICBdfVxuXG4gICAgICBJdCBpcyBlcXVpdmFsZW50LCB0aG91Z2ggbmVlZGxlc3NseSB2ZXJib3NlLCB0byByZXBsYWNlIHRoZSBbVHljb25dIHJlZmVyZW5jZSB3aXRoXG4gICAgICB0aGUgZ3JhbW1hciBvZiBbXCJ0cmVlXCJdLCBzdWJzdGl0dXRpbmcgW0ludGVnZXJdIGZvciBbVHl2YXIgXCJhXCJdOlxuXG4gICAgICB7W1xuICAgICAgICBSZWN1cnNpdmVcbiAgICAgICAgICAoIFZhcmlhbnRcbiAgICAgICAgICAgICAgeyBuYW1lX2tpbmQgPSBDYXBpdGFsaXplZFxuICAgICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgICAgWyB7IG5hbWUgPSBcIk5vZGVcIlxuICAgICAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChUeWNvbiAoXCJub2RlXCIsIFtUeXZhciBcImFcIl0pLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgOyB7IG5hbWUgPSBcIlRyZWVcIlxuICAgICAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChUeWNvbiAoXCJsZWFmXCIsIFtUeXZhciBcImFcIl0pLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgLCBkZWZucyApXG4gICAgICBdfVxuICAqKVxuICB8IExhenkgb2YgZ3JhbW1hciBsYXp5X3RcbiAgKCoqIExhemlseSBjb21wdXRlZCBncmFtbWFyLiBVc2UgW0xhenldIHRvIGF2b2lkIHRvcC1sZXZlbCBzaWRlIGVmZmVjdHMuIFRvIGRlZmluZVxuICAgICAgcmVjdXJzaXZlIGdyYW1tYXJzLCB1c2UgW1JlY3Vyc2l2ZV0gaW5zdGVhZC4gKilcblxuKCoqIEdyYW1tYXIgb2YgYSBsaXN0IG9mIHNleHBzLiAqKVxuYW5kIGxpc3RfZ3JhbW1hciA9XG4gIHwgRW1wdHkgKCoqIGFjY2VwdHMgYW4gZW1wdHkgbGlzdCBvZiBzZXhwcyAqKVxuICB8IENvbnMgb2YgZ3JhbW1hciAqIGxpc3RfZ3JhbW1hclxuICAoKiogYWNjZXB0cyBhIG5vbi1lbXB0eSBsaXN0IHdpdGggaGVhZCBhbmQgdGFpbCBtYXRjaGluZyB0aGUgZ2l2ZW4gZ3JhbW1hcnMgKilcbiAgfCBNYW55IG9mIGdyYW1tYXIgKCoqIGFjY2VwdHMgemVybyBvciBtb3JlIHNleHBzLCBlYWNoIG1hdGNoaW5nIHRoZSBnaXZlbiBncmFtbWFyICopXG4gIHwgRmllbGRzIG9mIHJlY29yZCAoKiogYWNjZXB0cyBzZXhwcyByZXByZXNlbnRpbmcgZmllbGRzIG9mIGEgcmVjb3JkICopXG5cbigqKiBDYXNlIHNlbnNpdGl2aXR5IG9wdGlvbnMgZm9yIG5hbWVzIG9mIHZhcmlhbnQgY29uc3RydWN0b3JzLiAqKVxuYW5kIGNhc2Vfc2Vuc2l0aXZpdHkgPVxuICB8IENhc2VfaW5zZW5zaXRpdmUgKCoqIENvbXBhcmlzb24gaXMgY2FzZSBpbnNlbnNpdGl2ZS4gVXNlZCBmb3IgY3VzdG9tIHBhcnNlcnMuICopXG4gIHwgQ2FzZV9zZW5zaXRpdmUgKCoqIENvbXBhcmlzb24gaXMgY2FzZSBzZW5zaXRpdmUuIFVzZWQgZm9yIHBvbHltb3JwaGljIHZhcmlhbnRzLiAqKVxuICB8IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgKCoqIENvbXBhcmlzb24gaXMgY2FzZSBpbnNlbnNpdGl2ZSBmb3IgdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgY2FzZSBzZW5zaXRpdmUgYWZ0ZXJ3YXJkLlxuICAgICAgVXNlZCBmb3IgcmVndWxhciB2YXJpYW50cy4gKilcblxuKCoqIEdyYW1tYXIgb2YgdmFyaWFudHMuIEFjY2VwdHMgYW55IHNleHAgbWF0Y2hpbmcgb25lIG9mIHRoZSBjbGF1c2VzLiAqKVxuYW5kIHZhcmlhbnQgPVxuICB7IGNhc2Vfc2Vuc2l0aXZpdHkgOiBjYXNlX3NlbnNpdGl2aXR5XG4gIDsgY2xhdXNlcyA6IGNsYXVzZSB3aXRoX3RhZ19saXN0IGxpc3RcbiAgfVxuXG4oKiogR3JhbW1hciBvZiBhIHNpbmdsZSB2YXJpYW50IGNsYXVzZS4gQWNjZXB0cyBzZXhwcyBiYXNlZCBvbiB0aGUgW2NsYXVzZV9raW5kXS4gKilcbmFuZCBjbGF1c2UgPVxuICB7IG5hbWUgOiBzdHJpbmdcbiAgOyBjbGF1c2Vfa2luZCA6IGNsYXVzZV9raW5kXG4gIH1cblxuKCoqIEdyYW1tYXIgb2YgYSBzaW5nbGUgdmFyaWFudCBjbGF1c2UncyBjb250ZW50cy4gW0F0b21fY2xhdXNlXSBhY2NlcHRzIGFuIGF0b20gbWF0Y2hpbmdcbiAgICB0aGUgY2xhdXNlJ3MgbmFtZS4gW0xpc3RfY2xhdXNlXSBhY2NlcHRzIGEgbGlzdCB3aG9zZSBoZWFkIGlzIGFuIGF0b20gbWF0Y2hpbmcgdGhlXG4gICAgY2xhdXNlJ3MgbmFtZSBhbmQgd2hvc2UgdGFpbCBtYXRjaGVzIFthcmdzXS4gVGhlIGNsYXVzZSdzIG5hbWUgaXMgbWF0Y2hlZCBtb2R1bG8gdGhlXG4gICAgdmFyaWFudCdzIFtuYW1lX2tpbmRdLiAqKVxuYW5kIGNsYXVzZV9raW5kID1cbiAgfCBBdG9tX2NsYXVzZVxuICB8IExpc3RfY2xhdXNlIG9mIHsgYXJncyA6IGxpc3RfZ3JhbW1hciB9XG5cbigqKiBHcmFtbWFyIG9mIGEgcmVjb3JkLiBBY2NlcHRzIGFueSBsaXN0IG9mIHNleHBzIHNwZWNpZnlpbmcgZWFjaCBvZiB0aGUgZmllbGRzLFxuICAgIHJlZ2FyZGxlc3Mgb2Ygb3JkZXIuIElmIFthbGxvd19leHRyYV9maWVsZHNdIGlzIHNwZWNpZmllZCwgaWdub3JlcyBzZXhwcyB3aXRoIG5hbWVzXG4gICAgbm90IGZvdW5kIGluIFtmaWVsZHNdLiAqKVxuYW5kIHJlY29yZCA9XG4gIHsgYWxsb3dfZXh0cmFfZmllbGRzIDogYm9vbFxuICA7IGZpZWxkcyA6IGZpZWxkIHdpdGhfdGFnX2xpc3QgbGlzdFxuICB9XG5cbigqKiBHcmFtbWFyIG9mIGEgcmVjb3JkIGZpZWxkLiBBIGZpZWxkIG11c3Qgc2hvdyB1cCBleGFjdGx5IG9uY2UgaW4gYSByZWNvcmQgaWZcbiAgICBbcmVxdWlyZWRdLCBvciBhdCBtb3N0IG9uY2Ugb3RoZXJ3aXNlLiBBY2NlcHRzIGEgbGlzdCBoZWFkZWQgYnkgW25hbWVdIGFzIGFuIGF0b20sXG4gICAgZm9sbG93ZWQgYnkgc2V4cHMgbWF0Y2hpbmcgW2FyZ3NdLiAqKVxuYW5kIGZpZWxkID1cbiAgeyBuYW1lIDogc3RyaW5nXG4gIDsgcmVxdWlyZWQgOiBib29sXG4gIDsgYXJncyA6IGxpc3RfZ3JhbW1hclxuICB9XG5cbigqKiBHcmFtbWFyIHRhZ2dlZCB3aXRoIGNsaWVudC1zcGVjaWZpYyBrZXkvdmFsdWUgcGFpci4gKilcbmFuZCAnYSB3aXRoX3RhZyA9XG4gIHsga2V5IDogc3RyaW5nXG4gIDsgdmFsdWUgOiBTZXhwLnRcbiAgOyBncmFtbWFyIDogJ2FcbiAgfVxuXG5hbmQgJ2Egd2l0aF90YWdfbGlzdCA9XG4gIHwgVGFnIG9mICdhIHdpdGhfdGFnX2xpc3Qgd2l0aF90YWdcbiAgfCBOb190YWcgb2YgJ2FcblxuKCoqIEdyYW1tYXIgb2YgYSByZWN1cnNpdmUgdHlwZSBkZWZpbml0aW9uLiBOYW1lcyB0aGUgW3R5Y29uXSBiZWluZyBkZWZpbmVkLCBhbmQgdGhlXG4gICAgW3R5dmFyc10gaXQgdGFrZXMgYXMgcGFyYW1ldGVycy4gU3BlY2lmaWVzIHRoZSBbZ3JhbW1hcl0gb2YgdGhlIFt0eWNvbl0uIFRoZSBncmFtbWFyXG4gICAgbWF5IHJlZmVyIHRvIGFueSBvZiB0aGUgW3R5dmFyc10sIGFuZCB0byBhbnkgb2YgdGhlIFt0eWNvbl1zIGZyb20gdGhlIHNhbWUgc2V0IG9mXG4gICAgW1JlY3Vyc2l2ZV0gZGVmaW5pdGlvbnMuICopXG5hbmQgZGVmbiA9XG4gIHsgdHljb24gOiBzdHJpbmdcbiAgOyB0eXZhcnMgOiBzdHJpbmcgbGlzdFxuICA7IGdyYW1tYXIgOiBncmFtbWFyXG4gIH1cblxuKCoqIFRvcC1sZXZlbCBncmFtbWFyIHR5cGUuIEhhcyBhIHBoYW50b20gdHlwZSBwYXJhbWV0ZXIgdG8gYXNzb2NpYXRlIGVhY2ggZ3JhbW1hciB3aXRoXG4gICAgdGhlIHR5cGUgaXRzIHNleHBzIHJlcHJlc2VudC4gVGhpcyBtYWtlcyBpdCBoYXJkZXIgdG8gYXBwbHkgZ3JhbW1hcnMgdG8gdGhlIHdyb25nXG4gICAgdHlwZSwgd2hpbGUgZ3JhbW1hcnMgY2FuIHN0aWxsIGJlIGVhc2lseSBjb2VyY2VkIHRvIGEgbmV3IHR5cGUgaWYgbmVlZGVkLiAqKVxudHlwZSBfIHQgPSB7IHVudHlwZWQgOiBncmFtbWFyIH0gW0BAdW5ib3hlZF1cblxubGV0IGNvZXJjZSAodHlwZSBhIGIpICh7IHVudHlwZWQgPSBfIH0gYXMgdCA6IGEgdCkgOiBiIHQgPSB0XG5cbigqKiBUaGlzIHJlc2VydmVkIGtleSBpcyB1c2VkIGZvciBhbGwgdGFncyBnZW5lcmF0ZWQgZnJvbSBkb2MgY29tbWVudHMuICopXG5sZXQgZG9jX2NvbW1lbnRfdGFnID0gXCJzZXhwX2dyYW1tYXIuZG9jX2NvbW1lbnRcIlxuIiwibGV0IHVuaXRfc2V4cF9ncmFtbWFyIDogdW5pdCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IExpc3QgRW1wdHkgfVxubGV0IGJvb2xfc2V4cF9ncmFtbWFyIDogYm9vbCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEJvb2wgfVxubGV0IHN0cmluZ19zZXhwX2dyYW1tYXIgOiBzdHJpbmcgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBTdHJpbmcgfVxubGV0IGJ5dGVzX3NleHBfZ3JhbW1hciA6IGJ5dGVzIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gU3RyaW5nIH1cbmxldCBjaGFyX3NleHBfZ3JhbW1hciA6IGNoYXIgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBDaGFyIH1cbmxldCBpbnRfc2V4cF9ncmFtbWFyIDogaW50IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgZmxvYXRfc2V4cF9ncmFtbWFyIDogZmxvYXQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBGbG9hdCB9XG5sZXQgaW50MzJfc2V4cF9ncmFtbWFyIDogaW50MzIgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBJbnRlZ2VyIH1cbmxldCBpbnQ2NF9zZXhwX2dyYW1tYXIgOiBpbnQ2NCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IG5hdGl2ZWludF9zZXhwX2dyYW1tYXIgOiBuYXRpdmVpbnQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBJbnRlZ2VyIH1cbmxldCBzZXhwX3Rfc2V4cF9ncmFtbWFyIDogU2V4cC50IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gQW55IFwiU2V4cC50XCIgfVxubGV0IHJlZl9zZXhwX2dyYW1tYXIgZ3JhbW1hciA9IFNleHBfZ3JhbW1hci5jb2VyY2UgZ3JhbW1hclxubGV0IGxhenlfdF9zZXhwX2dyYW1tYXIgZ3JhbW1hciA9IFNleHBfZ3JhbW1hci5jb2VyY2UgZ3JhbW1hclxuXG5sZXQgb3B0aW9uX3NleHBfZ3JhbW1hciAoeyB1bnR5cGVkIH0gOiBfIFNleHBfZ3JhbW1hci50KSA6IF8gb3B0aW9uIFNleHBfZ3JhbW1hci50ID1cbiAgeyB1bnR5cGVkID0gT3B0aW9uIHVudHlwZWQgfVxuOztcblxubGV0IGxpc3Rfc2V4cF9ncmFtbWFyICh7IHVudHlwZWQgfSA6IF8gU2V4cF9ncmFtbWFyLnQpIDogXyBsaXN0IFNleHBfZ3JhbW1hci50ID1cbiAgeyB1bnR5cGVkID0gTGlzdCAoTWFueSB1bnR5cGVkKSB9XG47O1xuXG5sZXQgYXJyYXlfc2V4cF9ncmFtbWFyICh7IHVudHlwZWQgfSA6IF8gU2V4cF9ncmFtbWFyLnQpIDogXyBhcnJheSBTZXhwX2dyYW1tYXIudCA9XG4gIHsgdW50eXBlZCA9IExpc3QgKE1hbnkgdW50eXBlZCkgfVxuOztcblxubGV0IGVtcHR5X3NleHBfZ3JhbW1hciA6IF8gU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBVbmlvbiBbXSB9XG5sZXQgb3BhcXVlX3NleHBfZ3JhbW1hciA9IGVtcHR5X3NleHBfZ3JhbW1hclxubGV0IGZ1bl9zZXhwX2dyYW1tYXIgPSBlbXB0eV9zZXhwX2dyYW1tYXJcbiIsIigqIFV0aWxpdHkgTW9kdWxlIGZvciBTLWV4cHJlc3Npb24gQ29udmVyc2lvbnMgKilcblxub3BlbiBTdGRMYWJlbHNcbm9wZW4gTW9yZUxhYmVsc1xub3BlbiBQcmludGZcbm9wZW4gU2V4cFxuXG4oKiBDb252ZXJzaW9uIG9mIE9DYW1sLXZhbHVlcyB0byBTLWV4cHJlc3Npb25zICopXG5leHRlcm5hbCBmb3JtYXRfZmxvYXQgOiBzdHJpbmcgLT4gZmxvYXQgLT4gc3RyaW5nID0gXCJjYW1sX2Zvcm1hdF9mbG9hdFwiXG5cbigqICclLjE3ZycgaXMgZ3VhcmFudGVlZCB0byBiZSByb3VuZC10cmlwcGFibGUuXG5cbiAgICclLjE1Zycgd2lsbCBiZSByb3VuZC10cmlwcGFibGUgYW5kIG5vdCBoYXZlIG5vaXNlIGF0IHRoZSBsYXN0IGRpZ2l0IG9yIHR3byBmb3IgYSBmbG9hdFxuICAgd2hpY2ggd2FzIGNvbnZlcnRlZCBmcm9tIGEgZGVjaW1hbCAoc3RyaW5nKSB3aXRoIDw9IDE1IHNpZ25pZmljYW50IGRpZ2l0cy4gIFNvIGl0J3NcbiAgIHdvcnRoIHRyeWluZyBmaXJzdCB0byBhdm9pZCB0aGluZ3MgbGlrZSBcIjMuMTQwMDAwMDAwMDAwMDAwMVwiLlxuXG4gICBTZWUgY29tbWVudCBhYm92ZSBbdG9fc3RyaW5nX3JvdW5kX3RyaXBwYWJsZV0gaW4geyFDb3JlLkZsb2F0fSBmb3JcbiAgIGRldGFpbGVkIGV4cGxhbmF0aW9uIGFuZCBleGFtcGxlcy4gKilcbmxldCBkZWZhdWx0X3N0cmluZ19vZl9mbG9hdCA9XG4gIHJlZiAoZnVuIHggLT5cbiAgICBsZXQgeSA9IGZvcm1hdF9mbG9hdCBcIiUuMTVHXCIgeCBpblxuICAgIGlmIGZsb2F0X29mX3N0cmluZyB5ID0geCB0aGVuIHkgZWxzZSBmb3JtYXRfZmxvYXQgXCIlLjE3R1wiIHgpXG47O1xuXG5sZXQgcmVhZF9vbGRfb3B0aW9uX2Zvcm1hdCA9IHJlZiB0cnVlXG5sZXQgd3JpdGVfb2xkX29wdGlvbl9mb3JtYXQgPSByZWYgdHJ1ZVxubGV0IGxpc3RfbWFwIGYgbCA9IExpc3QucmV2IChMaXN0LnJldl9tYXAgbCB+ZilcbmxldCBzZXhwX29mX3VuaXQgKCkgPSBMaXN0IFtdXG5sZXQgc2V4cF9vZl9ib29sIGIgPSBBdG9tIChzdHJpbmdfb2ZfYm9vbCBiKVxubGV0IHNleHBfb2Zfc3RyaW5nIHN0ciA9IEF0b20gc3RyXG5sZXQgc2V4cF9vZl9ieXRlcyBieXRlcyA9IEF0b20gKEJ5dGVzLnRvX3N0cmluZyBieXRlcylcbmxldCBzZXhwX29mX2NoYXIgYyA9IEF0b20gKFN0cmluZy5tYWtlIDEgYylcbmxldCBzZXhwX29mX2ludCBuID0gQXRvbSAoc3RyaW5nX29mX2ludCBuKVxubGV0IHNleHBfb2ZfZmxvYXQgbiA9IEF0b20gKCFkZWZhdWx0X3N0cmluZ19vZl9mbG9hdCBuKVxubGV0IHNleHBfb2ZfaW50MzIgbiA9IEF0b20gKEludDMyLnRvX3N0cmluZyBuKVxubGV0IHNleHBfb2ZfaW50NjQgbiA9IEF0b20gKEludDY0LnRvX3N0cmluZyBuKVxubGV0IHNleHBfb2ZfbmF0aXZlaW50IG4gPSBBdG9tIChOYXRpdmVpbnQudG9fc3RyaW5nIG4pXG5sZXQgc2V4cF9vZl9yZWYgc2V4cF9vZl9fYSByZiA9IHNleHBfb2ZfX2EgIXJmXG5sZXQgc2V4cF9vZl9sYXp5X3Qgc2V4cF9vZl9fYSBsdiA9IHNleHBfb2ZfX2EgKExhenkuZm9yY2UgbHYpXG5cbmxldCBzZXhwX29mX29wdGlvbiBzZXhwX29mX19hID0gZnVuY3Rpb25cbiAgfCBTb21lIHggd2hlbiAhd3JpdGVfb2xkX29wdGlvbl9mb3JtYXQgLT4gTGlzdCBbIHNleHBfb2ZfX2EgeCBdXG4gIHwgU29tZSB4IC0+IExpc3QgWyBBdG9tIFwic29tZVwiOyBzZXhwX29mX19hIHggXVxuICB8IE5vbmUgd2hlbiAhd3JpdGVfb2xkX29wdGlvbl9mb3JtYXQgLT4gTGlzdCBbXVxuICB8IE5vbmUgLT4gQXRvbSBcIm5vbmVcIlxuOztcblxubGV0IHNleHBfb2ZfcGFpciBzZXhwX29mX19hIHNleHBfb2ZfX2IgKGEsIGIpID0gTGlzdCBbIHNleHBfb2ZfX2EgYTsgc2V4cF9vZl9fYiBiIF1cblxubGV0IHNleHBfb2ZfdHJpcGxlIHNleHBfb2ZfX2Egc2V4cF9vZl9fYiBzZXhwX29mX19jIChhLCBiLCBjKSA9XG4gIExpc3QgWyBzZXhwX29mX19hIGE7IHNleHBfb2ZfX2IgYjsgc2V4cF9vZl9fYyBjIF1cbjs7XG5cbigqIExpc3QucmV2IChMaXN0LnJldl9tYXAgLi4uKSBpcyB0YWlsIHJlY3Vyc2l2ZSwgdGhlIE9DYW1sIHN0YW5kYXJkXG4gICBsaWJyYXJ5IExpc3QubWFwIGlzIE5PVC4gKilcbmxldCBzZXhwX29mX2xpc3Qgc2V4cF9vZl9fYSBsc3QgPSBMaXN0IChMaXN0LnJldiAoTGlzdC5yZXZfbWFwIGxzdCB+ZjpzZXhwX29mX19hKSlcblxubGV0IHNleHBfb2ZfYXJyYXkgc2V4cF9vZl9fYSBhciA9XG4gIGxldCBsc3RfcmVmID0gcmVmIFtdIGluXG4gIGZvciBpID0gQXJyYXkubGVuZ3RoIGFyIC0gMSBkb3dudG8gMCBkb1xuICAgIGxzdF9yZWYgOj0gc2V4cF9vZl9fYSBhci4oaSkgOjogIWxzdF9yZWZcbiAgZG9uZTtcbiAgTGlzdCAhbHN0X3JlZlxuOztcblxubGV0IHNleHBfb2ZfaGFzaHRibCBzZXhwX29mX2tleSBzZXhwX29mX3ZhbCBodGJsID1cbiAgbGV0IGNvbGwgfmtleTprIH5kYXRhOnYgYWNjID0gTGlzdCBbIHNleHBfb2Zfa2V5IGs7IHNleHBfb2ZfdmFsIHYgXSA6OiBhY2MgaW5cbiAgTGlzdCAoSGFzaHRibC5mb2xkIGh0YmwgfmluaXQ6W10gfmY6Y29sbClcbjs7XG5cbmxldCBzZXhwX29mX29wYXF1ZSBfID0gQXRvbSBcIjxvcGFxdWU+XCJcbmxldCBzZXhwX29mX2Z1biBfID0gQXRvbSBcIjxmdW4+XCJcblxuKCogRXhjZXB0aW9uIGNvbnZlcnRlciByZWdpc3RyYXRpb24gYW5kIGxvb2t1cCAqKVxuXG5tb2R1bGUgRXhuX2NvbnZlcnRlciA9IHN0cnVjdFxuICAoKiBUaGVzZSBleGNlcHRpb24gcmVnaXN0cmF0aW9uIGZ1bmN0aW9ucyBhc3N1bWUgdGhhdCBjb250ZXh0LXN3aXRjaGVzXG4gICAgIGNhbm5vdCBoYXBwZW4gdW5sZXNzIHRoZXJlIGlzIGFuIGFsbG9jYXRpb24uICBJdCBpcyByZWFzb25hYmxlIHRvIGV4cGVjdFxuICAgICB0aGF0IHRoaXMgd2lsbCByZW1haW4gdHJ1ZSBmb3IgdGhlIGZvcmVzZWVhYmxlIGZ1dHVyZS4gIFRoYXQgd2F5IHdlXG4gICAgIGF2b2lkIHVzaW5nIG11dGV4ZXMgYW5kIHRodXMgYSBkZXBlbmRlbmN5IG9uIHRoZSB0aHJlYWRzIGxpYnJhcnkuICopXG5cbiAgKCogRmFzdCBhbmQgYXV0b21hdGljIGV4Y2VwdGlvbiByZWdpc3RyYXRpb24gKilcblxuICBtb2R1bGUgUmVnaXN0cmF0aW9uID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHsgc2V4cF9vZl9leG4gOiBleG4gLT4gU2V4cC50XG4gICAgICA7ICgqIElmIFtwcmludGV4YyA9IHRydWVdIHRoZW4gdGhpcyBzZXhwIGNvbnZlcnRlciBpcyB1c2VkIGZvciBQcmludGV4Yy50b19zdHJpbmcgKilcbiAgICAgICAgcHJpbnRleGMgOiBib29sXG4gICAgICB9XG4gIGVuZFxuXG4gIG1vZHVsZSBFeG5fdGFibGUgPSBFcGhlbWVyb24uSzEuTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIHQgPSBleHRlbnNpb25fY29uc3RydWN0b3JcblxuICAgICAgbGV0IGVxdWFsID0gKCA9PSApXG4gICAgICBsZXQgaGFzaCA9IE9iai5FeHRlbnNpb25fY29uc3RydWN0b3IuaWRcbiAgICBlbmQpXG5cbiAgbGV0IHRoZV9leG5fdGFibGUgOiBSZWdpc3RyYXRpb24udCBFeG5fdGFibGUudCA9IEV4bl90YWJsZS5jcmVhdGUgMTdcblxuICAoKiBFcGhlbWVyb25zIGFyZSB1c2VkIHNvIHRoYXQgW3NleHBfb2ZfZXhuXSBjbG9zdXJlIGRvbid0IGtlZXAgdGhlXG4gICAgIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBsaXZlLiAqKVxuICBsZXQgYWRkID8ocHJpbnRleGMgPSB0cnVlKSA/ZmluYWxpc2U6XyBleHRlbnNpb25fY29uc3RydWN0b3Igc2V4cF9vZl9leG4gPVxuICAgIEV4bl90YWJsZS5hZGQgdGhlX2V4bl90YWJsZSBleHRlbnNpb25fY29uc3RydWN0b3IgeyBzZXhwX29mX2V4bjsgcHJpbnRleGMgfVxuICA7O1xuXG4gIGxldCBmaW5kX2F1dG8gfmZvcl9wcmludGV4YyBleG4gPVxuICAgIGxldCBleHRlbnNpb25fY29uc3RydWN0b3IgPSBPYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbCBleG4gaW5cbiAgICBtYXRjaCBFeG5fdGFibGUuZmluZF9vcHQgdGhlX2V4bl90YWJsZSBleHRlbnNpb25fY29uc3RydWN0b3Igd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHsgc2V4cF9vZl9leG47IHByaW50ZXhjIH0gLT5cbiAgICAgIChtYXRjaCBmb3JfcHJpbnRleGMsIHByaW50ZXhjIHdpdGhcbiAgICAgICB8IGZhbHNlLCBfIHwgXywgdHJ1ZSAtPiBTb21lIChzZXhwX29mX2V4biBleG4pXG4gICAgICAgfCB0cnVlLCBmYWxzZSAtPiBOb25lKVxuICA7O1xuXG4gIG1vZHVsZSBGb3JfdW5pdF90ZXN0c19vbmx5ID0gc3RydWN0XG4gICAgbGV0IHNpemUgKCkgPSAoRXhuX3RhYmxlLnN0YXRzX2FsaXZlIHRoZV9leG5fdGFibGUpLm51bV9iaW5kaW5nc1xuICBlbmRcbmVuZFxuXG5sZXQgc2V4cF9vZl9leG5fb3B0X2Zvcl9wcmludGV4YyBleG4gPSBFeG5fY29udmVydGVyLmZpbmRfYXV0byB+Zm9yX3ByaW50ZXhjOnRydWUgZXhuXG5sZXQgc2V4cF9vZl9leG5fb3B0IGV4biA9IEV4bl9jb252ZXJ0ZXIuZmluZF9hdXRvIH5mb3JfcHJpbnRleGM6ZmFsc2UgZXhuXG5cbmxldCBzZXhwX29mX2V4biBleG4gPVxuICBtYXRjaCBzZXhwX29mX2V4bl9vcHQgZXhuIHdpdGhcbiAgfCBOb25lIC0+IExpc3QgWyBBdG9tIChQcmludGV4Yy50b19zdHJpbmcgZXhuKSBdXG4gIHwgU29tZSBzZXhwIC0+IHNleHBcbjs7XG5cbmxldCBleG5fdG9fc3RyaW5nIGUgPSBTZXhwLnRvX3N0cmluZ19odW0gKHNleHBfb2ZfZXhuIGUpXG5cbigqIHtbZXhjZXB0aW9uIEJsYWggW0BAZGVyaXZpbmcgc2V4cF1dfSBnZW5lcmF0ZXMgYSBjYWxsIHRvIHRoZSBmdW5jdGlvblxuICAgW0V4bl9jb252ZXJ0ZXIuYWRkXSBkZWZpbmVkIGluIHRoaXMgZmlsZS4gIFNvIHdlIGFyZSBndWFyYW50ZWQgdGhhdCBhcyBzb29uIGFzIHdlXG4gICBtYXJrIGFuIGV4Y2VwdGlvbiBhcyBzZXhwYWJsZSwgdGhpcyBtb2R1bGUgd2lsbCBiZSBsaW5rZWQgaW4gYW5kIHRoaXMgcHJpbnRlciB3aWxsIGJlXG4gICByZWdpc3RlcmVkLCB3aGljaCBpcyB3aGF0IHdlIHdhbnQuICopXG5sZXQgKCkgPVxuICBQcmludGV4Yy5yZWdpc3Rlcl9wcmludGVyIChmdW4gZXhuIC0+XG4gICAgbWF0Y2ggc2V4cF9vZl9leG5fb3B0X2Zvcl9wcmludGV4YyBleG4gd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHNleHAgLT4gU29tZSAoU2V4cC50b19zdHJpbmdfaHVtIH5pbmRlbnQ6MiBzZXhwKSlcbjs7XG5cbmxldCBwcmludGV4Y19wcmVmZXJfc2V4cCBleG4gPVxuICBtYXRjaCBzZXhwX29mX2V4bl9vcHQgZXhuIHdpdGhcbiAgfCBOb25lIC0+IFByaW50ZXhjLnRvX3N0cmluZyBleG5cbiAgfCBTb21lIHNleHAgLT4gU2V4cC50b19zdHJpbmdfaHVtIH5pbmRlbnQ6MiBzZXhwXG47O1xuXG4oKiBDb252ZXJzaW9uIG9mIFMtZXhwcmVzc2lvbnMgdG8gT0NhbWwtdmFsdWVzICopXG5cbmV4Y2VwdGlvbiBPZl9zZXhwX2Vycm9yID0gU2V4cC5PZl9zZXhwX2Vycm9yXG5cbmxldCByZWNvcmRfY2hlY2tfZXh0cmFfZmllbGRzID0gcmVmIHRydWVcbmxldCBvZl9zZXhwX2Vycm9yX2V4biBleGMgc2V4cCA9IHJhaXNlIChPZl9zZXhwX2Vycm9yIChleGMsIHNleHApKVxubGV0IG9mX3NleHBfZXJyb3Igd2hhdCBzZXhwID0gcmFpc2UgKE9mX3NleHBfZXJyb3IgKEZhaWx1cmUgd2hhdCwgc2V4cCkpXG5cbmxldCB1bml0X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgW10gLT4gKClcbiAgfCBBdG9tIF8gfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcInVuaXRfb2Zfc2V4cDogZW1wdHkgbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgYm9vbF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIChcInRydWVcIiB8IFwiVHJ1ZVwiKSAtPiB0cnVlXG4gIHwgQXRvbSAoXCJmYWxzZVwiIHwgXCJGYWxzZVwiKSAtPiBmYWxzZVxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiYm9vbF9vZl9zZXhwOiB1bmtub3duIHN0cmluZ1wiIHNleHBcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImJvb2xfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgc3RyaW5nX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+IHN0clxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwic3RyaW5nX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGJ5dGVzX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+IEJ5dGVzLm9mX3N0cmluZyBzdHJcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImJ5dGVzX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGNoYXJfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICBpZiBTdHJpbmcubGVuZ3RoIHN0ciA8PiAxXG4gICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiY2hhcl9vZl9zZXhwOiBhdG9tIHN0cmluZyBtdXN0IGNvbnRhaW4gb25lIGNoYXJhY3RlciBvbmx5XCIgc2V4cDtcbiAgICBzdHIuWzBdXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJjaGFyX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGludF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgaW50X29mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcImludF9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiaW50X29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGZsb2F0X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBmbG9hdF9vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJmbG9hdF9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiZmxvYXRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaW50MzJfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IEludDMyLm9mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcImludDMyX29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJpbnQzMl9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBpbnQ2NF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgSW50NjQub2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiaW50NjRfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImludDY0X29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IG5hdGl2ZWludF9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgTmF0aXZlaW50Lm9mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcIm5hdGl2ZWludF9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwibmF0aXZlaW50X29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IHJlZl9vZl9zZXhwIGFfX29mX3NleHAgc2V4cCA9IHJlZiAoYV9fb2Zfc2V4cCBzZXhwKVxubGV0IGxhenlfdF9vZl9zZXhwIGFfX29mX3NleHAgc2V4cCA9IExhenkuZnJvbV92YWwgKGFfX29mX3NleHAgc2V4cClcblxubGV0IG9wdGlvbl9vZl9zZXhwIGFfX29mX3NleHAgc2V4cCA9XG4gIGlmICFyZWFkX29sZF9vcHRpb25fZm9ybWF0XG4gIHRoZW4gKFxuICAgIG1hdGNoIHNleHAgd2l0aFxuICAgIHwgTGlzdCBbXSB8IEF0b20gKFwibm9uZVwiIHwgXCJOb25lXCIpIC0+IE5vbmVcbiAgICB8IExpc3QgWyBlbCBdIHwgTGlzdCBbIEF0b20gKFwic29tZVwiIHwgXCJTb21lXCIpOyBlbCBdIC0+IFNvbWUgKGFfX29mX3NleHAgZWwpXG4gICAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBsaXN0IG11c3QgcmVwcmVzZW50IG9wdGlvbmFsIHZhbHVlXCIgc2V4cFxuICAgIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogb25seSBub25lIGNhbiBiZSBhdG9tXCIgc2V4cClcbiAgZWxzZSAoXG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBBdG9tIChcIm5vbmVcIiB8IFwiTm9uZVwiKSAtPiBOb25lXG4gICAgfCBMaXN0IFsgQXRvbSAoXCJzb21lXCIgfCBcIlNvbWVcIik7IGVsIF0gLT4gU29tZSAoYV9fb2Zfc2V4cCBlbClcbiAgICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwib3B0aW9uX29mX3NleHA6IG9ubHkgbm9uZSBjYW4gYmUgYXRvbVwiIHNleHBcbiAgICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwib3B0aW9uX29mX3NleHA6IGxpc3QgbXVzdCBiZSAoc29tZSBlbClcIiBzZXhwKVxuOztcblxubGV0IHBhaXJfb2Zfc2V4cCBhX19vZl9zZXhwIGJfX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgWyBhX3NleHA7IGJfc2V4cCBdIC0+XG4gICAgbGV0IGEgPSBhX19vZl9zZXhwIGFfc2V4cCBpblxuICAgIGxldCBiID0gYl9fb2Zfc2V4cCBiX3NleHAgaW5cbiAgICBhLCBiXG4gIHwgTGlzdCBfIC0+XG4gICAgb2Zfc2V4cF9lcnJvciBcInBhaXJfb2Zfc2V4cDogbGlzdCBtdXN0IGNvbnRhaW4gZXhhY3RseSB0d28gZWxlbWVudHMgb25seVwiIHNleHBcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcInBhaXJfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgdHJpcGxlX29mX3NleHAgYV9fb2Zfc2V4cCBiX19vZl9zZXhwIGNfX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgWyBhX3NleHA7IGJfc2V4cDsgY19zZXhwIF0gLT5cbiAgICBsZXQgYSA9IGFfX29mX3NleHAgYV9zZXhwIGluXG4gICAgbGV0IGIgPSBiX19vZl9zZXhwIGJfc2V4cCBpblxuICAgIGxldCBjID0gY19fb2Zfc2V4cCBjX3NleHAgaW5cbiAgICBhLCBiLCBjXG4gIHwgTGlzdCBfIC0+XG4gICAgb2Zfc2V4cF9lcnJvciBcInRyaXBsZV9vZl9zZXhwOiBsaXN0IG11c3QgY29udGFpbiBleGFjdGx5IHRocmVlIGVsZW1lbnRzIG9ubHlcIiBzZXhwXG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJ0cmlwbGVfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgbGlzdF9vZl9zZXhwIGFfX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgbHN0IC0+XG4gICAgbGV0IHJldl9sc3QgPSBMaXN0LnJldl9tYXAgbHN0IH5mOmFfX29mX3NleHAgaW5cbiAgICBMaXN0LnJldiByZXZfbHN0XG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJsaXN0X29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGFycmF5X29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbXSAtPiBbfHxdXG4gIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgIGxldCBsZW4gPSBMaXN0Lmxlbmd0aCB0ICsgMSBpblxuICAgIGxldCByZXMgPSBBcnJheS5tYWtlIGxlbiAoYV9fb2Zfc2V4cCBoKSBpblxuICAgIGxldCByZWMgbG9vcCBpID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmVzXG4gICAgICB8IGggOjogdCAtPlxuICAgICAgICByZXMuKGkpIDwtIGFfX29mX3NleHAgaDtcbiAgICAgICAgbG9vcCAoaSArIDEpIHRcbiAgICBpblxuICAgIGxvb3AgMSB0XG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJhcnJheV9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBoYXNodGJsX29mX3NleHAga2V5X29mX3NleHAgdmFsX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IExpc3QgbHN0IC0+XG4gICAgbGV0IGh0YmwgPSBIYXNodGJsLmNyZWF0ZSAwIGluXG4gICAgbGV0IGFjdCA9IGZ1bmN0aW9uXG4gICAgICB8IExpc3QgWyBrX3NleHA7IHZfc2V4cCBdIC0+XG4gICAgICAgIEhhc2h0YmwuYWRkIGh0YmwgfmtleTooa2V5X29mX3NleHAga19zZXhwKSB+ZGF0YToodmFsX29mX3NleHAgdl9zZXhwKVxuICAgICAgfCBMaXN0IF8gfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImhhc2h0Ymxfb2Zfc2V4cDogdHVwbGUgbGlzdCBuZWVkZWRcIiBzZXhwXG4gICAgaW5cbiAgICBMaXN0Lml0ZXIgbHN0IH5mOmFjdDtcbiAgICBodGJsXG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJoYXNodGJsX29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IG9wYXF1ZV9vZl9zZXhwIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIFwib3BhcXVlX29mX3NleHA6IGNhbm5vdCBjb252ZXJ0IG9wYXF1ZSB2YWx1ZXNcIiBzZXhwXG47O1xuXG5sZXQgZnVuX29mX3NleHAgc2V4cCA9IG9mX3NleHBfZXJyb3IgXCJmdW5fb2Zfc2V4cDogY2Fubm90IGNvbnZlcnQgZnVuY3Rpb24gdmFsdWVzXCIgc2V4cFxuXG4oKiBTZXhwIEdyYW1tYXJzICopXG5cbmluY2x1ZGUgU2V4cF9jb252X2dyYW1tYXJcblxuKCogUmVnaXN0ZXJpbmcgZGVmYXVsdCBleGNlcHRpb24gcHJpbnRlcnMgKilcblxubGV0IGdldF9mbGNfZXJyb3IgbmFtZSAoZmlsZSwgbGluZSwgY2hyKSA9IEF0b20gKHNwcmludGYgXCIlcyAlczolZDolZFwiIG5hbWUgZmlsZSBsaW5lIGNocilcblxubGV0ICgpID1cbiAgTGlzdC5pdGVyXG4gICAgfmY6KGZ1biAoZXh0ZW5zaW9uX2NvbnN0cnVjdG9yLCBoYW5kbGVyKSAtPlxuICAgICAgRXhuX2NvbnZlcnRlci5hZGQgfnByaW50ZXhjOmZhbHNlIH5maW5hbGlzZTpmYWxzZSBleHRlbnNpb25fY29uc3RydWN0b3IgaGFuZGxlcilcbiAgICBbICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgQXNzZXJ0X2ZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgQXNzZXJ0X2ZhaWx1cmUgYXJnIC0+IGdldF9mbGNfZXJyb3IgXCJBc3NlcnRfZmFpbHVyZVwiIGFyZ1xuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgRXhpdF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBFeGl0IC0+IEF0b20gXCJFeGl0XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEVuZF9vZl9maWxlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEVuZF9vZl9maWxlIC0+IEF0b20gXCJFbmRfb2ZfZmlsZVwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBGYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEZhaWx1cmUgYXJnIC0+IExpc3QgWyBBdG9tIFwiRmFpbHVyZVwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBOb3RfZm91bmRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgTm90X2ZvdW5kIC0+IEF0b20gXCJOb3RfZm91bmRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgSW52YWxpZF9hcmd1bWVudF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBJbnZhbGlkX2FyZ3VtZW50IGFyZyAtPiBMaXN0IFsgQXRvbSBcIkludmFsaWRfYXJndW1lbnRcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgTWF0Y2hfZmFpbHVyZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBNYXRjaF9mYWlsdXJlIGFyZyAtPiBnZXRfZmxjX2Vycm9yIFwiTWF0Y2hfZmFpbHVyZVwiIGFyZ1xuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgTm90X2ZvdW5kX3NdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgTm90X2ZvdW5kX3MgYXJnIC0+IExpc3QgWyBBdG9tIFwiTm90X2ZvdW5kX3NcIjsgYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFN5c19lcnJvcl1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBTeXNfZXJyb3IgYXJnIC0+IExpc3QgWyBBdG9tIFwiU3lzX2Vycm9yXCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEFyZy5IZWxwXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEFyZy5IZWxwIGFyZyAtPiBMaXN0IFsgQXRvbSBcIkFyZy5IZWxwXCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEFyZy5CYWRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgQXJnLkJhZCBhcmcgLT4gTGlzdCBbIEF0b20gXCJBcmcuQmFkXCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIExhenkuVW5kZWZpbmVkXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IExhenkuVW5kZWZpbmVkIC0+IEF0b20gXCJMYXp5LlVuZGVmaW5lZFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBQYXJzaW5nLlBhcnNlX2Vycm9yXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFBhcnNpbmcuUGFyc2VfZXJyb3IgLT4gQXRvbSBcIlBhcnNpbmcuUGFyc2VfZXJyb3JcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgUXVldWUuRW1wdHldXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgUXVldWUuRW1wdHkgLT4gQXRvbSBcIlF1ZXVlLkVtcHR5XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNjYW5mLlNjYW5fZmFpbHVyZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBTY2FuZi5TY2FuX2ZhaWx1cmUgYXJnIC0+IExpc3QgWyBBdG9tIFwiU2NhbmYuU2Nhbl9mYWlsdXJlXCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFN0YWNrLkVtcHR5XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFN0YWNrLkVtcHR5IC0+IEF0b20gXCJTdGFjay5FbXB0eVwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTeXMuQnJlYWtdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU3lzLkJyZWFrIC0+IEF0b20gXCJTeXMuQnJlYWtcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICBdXG47O1xuXG5sZXQgKCkgPVxuICBMaXN0Lml0ZXJcbiAgICB+ZjooZnVuIChleHRlbnNpb25fY29uc3RydWN0b3IsIGhhbmRsZXIpIC0+XG4gICAgICBFeG5fY29udmVydGVyLmFkZCB+cHJpbnRleGM6dHJ1ZSB+ZmluYWxpc2U6ZmFsc2UgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIGhhbmRsZXIpXG4gICAgWyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE9mX3NleHBfZXJyb3JdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgT2Zfc2V4cF9lcnJvciAoZXhjLCBzZXhwKSAtPlxuICAgICAgICAgIExpc3QgWyBBdG9tIFwiU2V4cGxpYi5Db252Lk9mX3NleHBfZXJyb3JcIjsgc2V4cF9vZl9leG4gZXhjOyBzZXhwIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgXVxuOztcblxuZXh0ZXJuYWwgaWdub3JlIDogXyAtPiB1bml0ID0gXCIlaWdub3JlXCJcbmV4dGVybmFsICggPSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiIsIigqIENvbnZfZXJyb3I6IE1vZHVsZSBmb3IgSGFuZGxpbmcgRXJyb3JzIGR1cmluZyBBdXRvbWF0ZWQgUy1leHByZXNzaW9uXG4gICBDb252ZXJzaW9ucyAqKVxuXG5vcGVuIFN0ZExhYmVsc1xub3BlbiBQcmludGZcbm9wZW4gU2V4cF9jb252XG5cbmV4Y2VwdGlvbiBPZl9zZXhwX2Vycm9yID0gT2Zfc2V4cF9lcnJvclxuXG4oKiBFcnJvcnMgY29uY2VybmluZyB0dXBsZXMgKilcblxubGV0IHR1cGxlX29mX3NpemVfbl9leHBlY3RlZCBsb2MgbiBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAoc3ByaW50ZiBcIiVzX29mX3NleHA6IHR1cGxlIG9mIHNpemUgJWQgZXhwZWN0ZWRcIiBsb2Mgbikgc2V4cFxuOztcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgc3VtIHR5cGVzICopXG5cbmxldCBzdGFnX25vX2FyZ3MgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB0aGlzIGNvbnN0cnVjdG9yIGRvZXMgbm90IHRha2UgYXJndW1lbnRzXCIpIHNleHBcbjs7XG5cbmxldCBzdGFnX2luY29ycmVjdF9uX2FyZ3MgbG9jIHRhZyBzZXhwID1cbiAgbGV0IG1zZyA9IHNwcmludGYgXCIlc19vZl9zZXhwOiBzdW0gdGFnICVTIGhhcyBpbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50c1wiIGxvYyB0YWcgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHN0YWdfdGFrZXNfYXJncyBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHRoaXMgY29uc3RydWN0b3IgcmVxdWlyZXMgYXJndW1lbnRzXCIpIHNleHBcbjs7XG5cbmxldCBuZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IGV4cGVjdGVkIGEgdmFyaWFudCB0eXBlLCBzYXcgYSBuZXN0ZWQgbGlzdFwiKSBzZXhwXG47O1xuXG5sZXQgZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IGV4cGVjdGVkIGEgdmFyaWFudCB0eXBlLCBzYXcgYW4gZW1wdHkgbGlzdFwiKSBzZXhwXG47O1xuXG5sZXQgdW5leHBlY3RlZF9zdGFnIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogdW5leHBlY3RlZCB2YXJpYW50IGNvbnN0cnVjdG9yXCIpIHNleHBcbjs7XG5cbigqIEVycm9ycyBjb25jZXJuaW5nIHJlY29yZHMgKilcblxubGV0IHJlY29yZF9zZXhwX2Jvb2xfd2l0aF9wYXlsb2FkIGxvYyBzZXhwID1cbiAgbGV0IG1zZyA9XG4gICAgbG9jIF4gXCJfb2Zfc2V4cDogcmVjb3JkIGNvbnZlcnNpb246IGEgW3NleHAuYm9vbF0gZmllbGQgd2FzIGdpdmVuIGEgcGF5bG9hZC5cIlxuICBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX29ubHlfcGFpcnNfZXhwZWN0ZWQgbG9jIHNleHAgPVxuICBsZXQgbXNnID1cbiAgICBsb2NcbiAgICBeIFwiX29mX3NleHA6IHJlY29yZCBjb252ZXJzaW9uOiBvbmx5IHBhaXJzIGV4cGVjdGVkLCB0aGVpciBmaXJzdCBlbGVtZW50IG11c3QgYmUgYW4gXFxcbiAgICAgICBhdG9tXCJcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHJlY29yZF9zdXBlcmZsdW91c19maWVsZHMgfndoYXQgfmxvYyByZXZfZmxkX25hbWVzIHNleHAgPVxuICBsZXQgZmxkX25hbWVzX3N0ciA9IFN0cmluZy5jb25jYXQgKExpc3QucmV2IHJldl9mbGRfbmFtZXMpIH5zZXA6XCIgXCIgaW5cbiAgbGV0IG1zZyA9IHNwcmludGYgXCIlc19vZl9zZXhwOiAlczogJXNcIiBsb2Mgd2hhdCBmbGRfbmFtZXNfc3RyIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfZHVwbGljYXRlX2ZpZWxkcyBsb2MgcmV2X2ZsZF9uYW1lcyBzZXhwID1cbiAgcmVjb3JkX3N1cGVyZmx1b3VzX2ZpZWxkcyB+d2hhdDpcImR1cGxpY2F0ZSBmaWVsZHNcIiB+bG9jIHJldl9mbGRfbmFtZXMgc2V4cFxuOztcblxubGV0IHJlY29yZF9leHRyYV9maWVsZHMgbG9jIHJldl9mbGRfbmFtZXMgc2V4cCA9XG4gIHJlY29yZF9zdXBlcmZsdW91c19maWVsZHMgfndoYXQ6XCJleHRyYSBmaWVsZHNcIiB+bG9jIHJldl9mbGRfbmFtZXMgc2V4cFxuOztcblxubGV0IHJlYyByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIGZpZWxkcyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gU3RyaW5nLmNvbmNhdCAoTGlzdC5yZXYgZmllbGRzKSB+c2VwOlwiIFwiXG4gIHwgKHRydWUsIGZpZWxkKSA6OiByZXN0IC0+IHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgKGZpZWxkIDo6IGZpZWxkcykgcmVzdFxuICB8IF8gOjogcmVzdCAtPiByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIGZpZWxkcyByZXN0XG47O1xuXG5sZXQgcmVjb3JkX3VuZGVmaW5lZF9lbGVtZW50cyBsb2Mgc2V4cCBsc3QgPVxuICBsZXQgdW5kZWZpbmVkID0gcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCBbXSBsc3QgaW5cbiAgbGV0IG1zZyA9XG4gICAgc3ByaW50ZiBcIiVzX29mX3NleHA6IHRoZSBmb2xsb3dpbmcgcmVjb3JkIGVsZW1lbnRzIHdlcmUgdW5kZWZpbmVkOiAlc1wiIGxvYyB1bmRlZmluZWRcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHJlY29yZF9saXN0X2luc3RlYWRfYXRvbSBsb2Mgc2V4cCA9XG4gIGxldCBtc2cgPSBsb2MgXiBcIl9vZl9zZXhwOiBsaXN0IGluc3RlYWQgb2YgYXRvbSBmb3IgcmVjb3JkIGV4cGVjdGVkXCIgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHJlY29yZF9wb2x5X2ZpZWxkX3ZhbHVlIGxvYyBzZXhwID1cbiAgbGV0IG1zZyA9XG4gICAgbG9jXG4gICAgXiBcIl9vZl9zZXhwOiBjYW5ub3QgY29udmVydCB2YWx1ZXMgb2YgdHlwZXMgcmVzdWx0aW5nIGZyb20gcG9seW1vcnBoaWMgcmVjb3JkIGZpZWxkc1wiXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbigqIEVycm9ycyBjb25jZXJuaW5nIHBvbHltb3JwaGljIHZhcmlhbnRzICopXG5cbmV4Y2VwdGlvbiBOb192YXJpYW50X21hdGNoXG5cbmxldCBub192YXJpYW50X21hdGNoICgpID0gcmFpc2UgTm9fdmFyaWFudF9tYXRjaFxuXG5sZXQgbm9fbWF0Y2hpbmdfdmFyaWFudF9mb3VuZCBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IG5vIG1hdGNoaW5nIHZhcmlhbnQgZm91bmRcIikgc2V4cFxuOztcblxubGV0IHB0YWdfbm9fYXJncyBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHBvbHltb3JwaGljIHZhcmlhbnQgZG9lcyBub3QgdGFrZSBhcmd1bWVudHNcIikgc2V4cFxuOztcblxubGV0IHB0YWdfaW5jb3JyZWN0X25fYXJncyBsb2MgY25zdHIgc2V4cCA9XG4gIGxldCBtc2cgPVxuICAgIHNwcmludGZcbiAgICAgIFwiJXNfb2Zfc2V4cDogcG9seW1vcnBoaWMgdmFyaWFudCB0YWcgJVMgaGFzIGluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzXCJcbiAgICAgIGxvY1xuICAgICAgY25zdHJcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHB0YWdfdGFrZXNfYXJncyBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHBvbHltb3JwaGljIHZhcmlhbnQgdGFnIHRha2VzIGFuIGFyZ3VtZW50XCIpIHNleHBcbjs7XG5cbmxldCBuZXN0ZWRfbGlzdF9pbnZhbGlkX3BvbHlfdmFyIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogYSBuZXN0ZWQgbGlzdCBpcyBhbiBpbnZhbGlkIHBvbHltb3JwaGljIHZhcmlhbnRcIikgc2V4cFxuOztcblxubGV0IGVtcHR5X2xpc3RfaW52YWxpZF9wb2x5X3ZhciBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHRoZSBlbXB0eSBsaXN0IGlzIGFuIGludmFsaWQgcG9seW1vcnBoaWMgdmFyaWFudFwiKSBzZXhwXG47O1xuXG5sZXQgZW1wdHlfdHlwZSBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHRyeWluZyB0byBjb252ZXJ0IGFuIGVtcHR5IHR5cGVcIikgc2V4cFxuOztcbiJdfQ==
