// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.1.1

//# unitInfo: Provides: Ppx_inline_test_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Ppx_inline_test_lib = [0];
   runtime.caml_register_global(0, Ppx_inline_test_lib, "Ppx_inline_test_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Ppx_inline_test_lib__Runtime
//# unitInfo: Requires: Base, Base__Int63, Base__List, Base__Random, Base__String, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib, Stdlib__Arg, Stdlib__Array, Stdlib__Filename, Stdlib__Hashtbl, Stdlib__List, Stdlib__Printexc, Stdlib__Printf, Stdlib__Random, Stdlib__Result, Stdlib__Scanf, Stdlib__String, Stdlib__Sys, Time_now
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$13 = "",
    cst$14 = "\n",
    cst$15 = " ",
    cst_line = " , line ",
    cst_File = " File ",
    cst_threw = " threw",
    cst_s$0 = "%s",
    cst_s = "%s%!",
    cst$12 = ".\n",
    cst_Ppx_inline_test_lib_Runtim$0 = "Ppx_inline_test_lib__Runtime",
    cst_TES = "TES",
    cst_TESTING_FRAMEWORK = "TESTING_FRAMEWORK",
    cst_T_MODULE_at$0 = "T_MODULE at ",
    cst_T_MODULES = "T_MODULES",
    cst_inline_test_runner$0 = "inline-test-runner",
    cst_inline_tests_log$0 = "inline_tests.log",
    cst_ppx_inline_test_error_the_ =
      "ppx_inline_test error: the following -only-test flags matched nothing:",
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$11 = cst$13,
    cst$9 = cst$14,
    cst$10 = cst$15,
    cst$7 = cst$14,
    cst$8 = cst$15,
    cst$5 = cst$14,
    cst$6 = "  ",
    cst$3 = cst$14,
    cst$4 = cst$13,
    cst$2 = ".",
    cst$0 = cst$13,
    cst$1 = ": ",
    enable_everything = [0, 0, 0],
    cst = cst$13,
    am_running_inline_test_env_var = cst_TESTING_FRAMEWORK,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Filename = global_data.Stdlib__Filename,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_String = global_data.Stdlib__String,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Result = global_data.Stdlib__Result,
    Base = global_data.Base,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Random = global_data.Base__Random,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int63 = global_data.Base__Int63,
    Time_now = global_data.Time_now,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Array = global_data.Stdlib__Array,
    _E_ = [0, [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, 0]]]], " %s:%d"],
    _F_ = [0, [12, 32, [2, 0, 0]], " %s"],
    _z_ =
      [0,
       [11,
        "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n",
        [10, 0]],
       "inline_tests_runner.exe is not supposed to be run by hand, you \nshould run the inline_tests_runner script instead.\n%!"],
    _A_ =
      [0,
       [11,
        "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n",
        [10, 0]],
       "You are doing something unexpected with the tests. No tests have \nbeen run. You should use the inline_tests_runner script to run \ntests.\n%!"],
    _B_ = [0, [2, 0, [12, 10, 0]], "%s\n"],
    _C_ =
      [0,
       [4,
        0,
        0,
        0,
        [11,
         " tests ran, ",
         [4, 0, 0, 0, [11, " test_modules ran\n", [10, 0]]]]],
       "%d tests ran, %d test_modules ran\n%!"],
    _D_ =
      [0,
       [11, cst_ppx_inline_test_error_the_, 0],
       cst_ppx_inline_test_error_the_],
    _G_ = [0, [11, cst$12, [10, 0]], ".\n%!"],
    _H_ =
      [0,
       [11, "ppx_inline_test error: no tests have been run.\n", [10, 0]],
       "ppx_inline_test error: no tests have been run.\n%!"],
    _J_ = [0, [11, cst_T_MODULES, 0], cst_T_MODULES],
    _K_ = [0, [11, ", ", [4, 0, 0, 0, [11, " TES", 0]]], ", %d TES"],
    _I_ =
      [0,
       [11,
        "FAILED ",
        [4,
         0,
         0,
         0,
         [11, " / ", [4, 0, 0, 0, [11, " tests", [2, 0, [12, 10, [10, 0]]]]]]]],
       "FAILED %d / %d tests%s\n%!"],
    _x_ =
      [0,
       [11,
        cst_T_MODULE_at$0,
        [2,
         0,
         [11,
          cst_threw,
          [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]]],
       "T_MODULE at %s threw%s%s.\n%s%s\n%!"],
    _y_ = [0, [11, cst_TES, 0], cst_TES],
    cst_ppx_inline_test_cannot_use =
      "ppx_inline_test: cannot use -list-partition or -partition without specifying a partition at preprocessing time",
    _r_ = [0, [2, 0, [12, 10, [2, 0, 0]]], "%s\n%s"],
    _s_ = [0, [2, 0, [10, 0]], cst_s],
    _t_ = [0, 1],
    _u_ =
      [0,
       [11, " (", [8, [0, 0, 0], 0, [0, 3], [11, " sec)\n", [10, 0]]]],
       " (%.3f sec)\n%!"],
    _v_ =
      [0,
       [2, 0, [11, " is false.\n", [2, 0, [12, 10, [10, 0]]]]],
       "%s is false.\n%s\n%!"],
    _w_ =
      [0,
       [2,
        0,
        [11,
         cst_threw,
         [2, 0, [2, 0, [11, cst$12, [2, 0, [2, 0, [12, 10, [10, 0]]]]]]]]],
       "%s threw%s%s.\n%s%s\n%!"],
    _q_ = [0, [2, 0, [10, 0]], cst_s],
    _p_ = [0, [2, 0, [10, 0]], cst_s],
    _o_ = [0, [12, 10, [2, 0, [12, 10, [10, 0]]]], "\n%s\n%!"],
    cst_T_MODULE_at = cst_T_MODULE_at$0,
    cst_in_TES = "  in TES",
    cst_time_without_resetting_ran = "time_without_resetting_random_seeds",
    cst_Ppx_inline_test_lib_Runtim = cst_Ppx_inline_test_lib_Runtim$0,
    cst_inline_tests_log = cst_inline_tests_log$0,
    _S_ =
      [0,
       [11,
        "Argument ",
        [2,
         0,
         [11, " doesn't fit the format filename[:line_number]\n", [10, 0]]]],
       "Argument %s doesn't fit the format filename[:line_number]\n%!"],
    _O_ =
      [0,
       [2,
        0,
        [11, ": unexpected anonymous argument ", [2, 0, [12, 10, [10, 0]]]]],
       "%s: unexpected anonymous argument %s\n%!"],
    _h_ =
      [0,
       [11,
        cst_File,
        [3,
         0,
         [11,
          cst_line,
          [4,
           0,
           0,
           0,
           [11,
            " , characters ",
            [4, 0, 0, 0, [11, " - ", [4, 0, 0, 0, [12, 32, [10, 0]]]]]]]]]],
       " File %S , line %d , characters %d - %d %!"],
    _g_ =
      [0,
       [11, cst_File, [3, 0, [11, cst_line, [4, 0, 0, 0, [12, 32, [10, 0]]]]]],
       " File %S , line %d %!"],
    _f_ = [0, [11, cst_File, [3, 0, [12, 32, [10, 0]]]], " File %S %!"],
    _e_ =
      [0,
       [11,
        "File ",
        [3,
         0,
         [11,
          ", line ",
          [4,
           0,
           0,
           0,
           [11,
            ", characters ",
            [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, [2, 0, 0]]]]]]]]],
       "File %S, line %d, characters %d-%d%s"],
    _a_ = [0, [2, 0, 0], cst_s$0],
    _b_ = [0, [2, 0, 0], cst_s$0],
    cst_success = "success",
    cst_failure = "failure",
    cst_error = "error",
    cst_inline_test_runner = cst_inline_test_runner$0,
    _N_ =
      [0,
       [2, 0, [12, 32, [2, 0, [12, 32, [2, 0, [11, " [args]", 0]]]]]],
       "%s %s %s [args]"],
    cst_Path_to_the_root_of_the_so = " Path to the root of the source tree",
    cst_source_tree_root = "-source-tree-root",
    cst_Allow_output_patterns_in_t =
      " Allow output patterns in tests expectations",
    cst_allow_output_patterns = "-allow-output-patterns",
    cst_Diff_command_for_tests_tha =
      " Diff command for tests that require diffing (use - to disable diffing)",
    cst_diff_cmd = "-diff-cmd",
    cst_Update_expect_tests_in_pla = " Update expect tests in place",
    cst_in_place = "-in-place",
    cst_Summarize_tests_without_us = " Summarize tests without using color",
    cst_no_color = "-no-color",
    cst_location_Run_only_the_test =
      'location Run only the tests specified by all the -only-test options.\n                      Locations can be one of these forms:\n                      - file.ml\n                      - file.ml:line_number\n                      - File "file.ml"\n                      - File "file.ml", line 23\n                      - File "file.ml", line 23, characters 2-3',
    cst_only_test = "-only-test",
    cst_substring_Only_run_tests_w =
      "substring Only run tests whose names contain the given substring",
    cst_matching = "-matching",
    cst_tag_Only_run_tests_tagged_ =
      "tag Only run tests tagged with [tag] (overrides previous -drop-tag)",
    cst_require_tag = "-require-tag",
    cst_tag_Only_run_tests_not_tag =
      "tag Only run tests not tagged with [tag] (overrides previous -require-tag)",
    cst_drop_tag = "-drop-tag",
    cst_Log_the_tests_run_in_inlin = " Log the tests run in inline_tests.log",
    cst_log = "-log",
    cst_Show_the_number_of_tests_r = " Show the number of tests ran",
    cst_show_counts = "-show-counts",
    cst_End_with_an_error_if_no_te = " End with an error if no tests were run",
    cst_strict = "-strict",
    cst_Run_tests_only_up_to_the_f =
      " Run tests only up to the first error (doesn't work for expect tests)",
    cst_stop_on_error = "-stop-on-error",
    cst_Show_the_tests_as_they_run = " Show the tests as they run",
    cst_verbose = "-verbose",
    cst_Only_run_the_tests_in_the_ =
      " Only run the tests in the given partition",
    cst_partition = "-partition",
    cst_Lists_all_the_partitions_t =
      " Lists all the partitions that contain at least one test or test_module",
    cst_list_partitions = "-list-partitions",
    cst_Do_not_run_tests_but_show_ =
      " Do not run tests but show what would have been run",
    cst_list_test_names = "-list-test-names",
    _n_ = [0, 187165616, 545942154],
    _L_ = [0, 187165616, -863538453];
   function to_string(param){
    switch(param){
      case 0:
       return cst_success;
      case 1:
       return cst_failure;
      default: return cst_error;
    }
   }
   function combine(t1, t2){
    var switch$0 = 0;
    switch(t1){
      case 0:
       if(! t2) return 0; break;
      case 1: break;
      default: switch$0 = 1;
    }
    if(! switch$0 && 2 !== t2) return 1;
    return 2;
   }
   function combine_all(ts){
    return caml_call3(Stdlib_List[25], combine, 0, ts);
   }
   var
    test_modules_ran = [0, 0],
    test_modules_failed = [0, 0],
    tests_ran = [0, 0],
    tests_failed = [0, 0],
    dynamic_lib = [0, 0],
    action = [0, -950194894];
   try{
    caml_sys_getenv("FORCE_DROP_INLINE_TEST");
    var _aa_ = 1, force_drop = _aa_;
   }
   catch(_bY_){
    var _c_ = caml_wrap_exception(_bY_);
    if(_c_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_c_, 0);
    var force_drop = 0;
   }
   function get(param){return force_drop ? -950194894 : action[1];}
   var _d_ = caml_call2(Stdlib_Hashtbl[1], 0, 23), current = [0, cst];
   function found_test(param){
    var
     _bW_ = caml_string_notequal(current[1], cst$13),
     _bX_ = _bW_ ? 1 - caml_call2(Stdlib_Hashtbl[9], _d_, current[1]) : _bW_;
    return _bX_ ? caml_call3(Stdlib_Hashtbl[5], _d_, current[1], 0) : _bX_;
   }
   function is_current(param){
    if(! param) return 1;
    var p = param[1];
    return caml_string_equal(p, current[1]);
   }
   var current$0 = [0, 0];
   function current_tags(param){
    var t = current$0[1];
    function _bU_(m){return m[2];}
    var _bV_ = caml_call2(Stdlib_List[19], _bU_, t);
    return caml_call1(Stdlib_List[13], _bV_);
   }
   var
    verbose = [0, 0],
    strict = [0, 0],
    show_counts = [0, 0],
    list_test_names = [0, 0],
    delayed_errors = [0, 0],
    stop_on_error = [0, 0],
    log = [0, 0],
    time_sec = [0, 0.],
    use_color = [0, 1],
    in_place = [0, 0],
    diff_command = [0, 0],
    source_tree_root = [0, 0],
    allow_output_patterns = [0, 0];
   function displayed_descr(param){
    var
     _bS_ = caml_obj_tag(param),
     descr =
       250 === _bS_
        ? param[1]
        : 246 === _bS_ ? caml_call1(CamlinternalLazy[2], param) : param;
    return function(filename, line, start_pos, end_pos){
     var
      _bT_ =
        caml_string_equal(descr, cst$13)
         ? cst$0
         : caml_call2(Stdlib[28], cst$1, descr);
     return caml_call6
             (Stdlib_Printf[4], _e_, filename, line, start_pos, end_pos, _bT_);};
   }
   var
    _i_ = caml_sys_argv(0),
    match = caml_call1(Stdlib_Array[11], _i_),
    switch$0 = 0;
   if(match){
    var _j_ = match[2];
    if(_j_){
     var name = match[1];
     if(! caml_string_notequal(_j_[1], cst_inline_test_runner$0)){
      var match$0 = _j_[2];
      if(match$0){
       var rest = match$0[2], lib = match$0[1];
       if(Base[85][1]){
        var
         tests = [0, 0],
         list_partitions = [0, 0],
         partition = [0, 0],
         tag_predicate = [0, enable_everything],
         name_filter = [0, 0],
         msg$1 =
           caml_call4
            (Stdlib_Printf[4], _N_, name, cst_inline_test_runner, lib),
         f =
           function(anon){
            caml_call3(Stdlib_Printf[3], _O_, name, anon);
            return caml_call1(Stdlib[99], 1);
           },
         _P_ = 0,
         _Q_ =
           [0,
            [0,
             cst_allow_output_patterns,
             [2, allow_output_patterns],
             cst_Allow_output_patterns_in_t],
            [0,
             [0,
              cst_source_tree_root,
              [4, function(s){source_tree_root[1] = [0, s]; return 0;}],
              cst_Path_to_the_root_of_the_so],
             _P_]],
         _R_ =
           [0,
            [0, cst_no_color, [3, use_color], cst_Summarize_tests_without_us],
            [0,
             [0, cst_in_place, [2, in_place], cst_Update_expect_tests_in_pla],
             [0,
              [0,
               cst_diff_cmd,
               [4, function(s){diff_command[1] = [0, s]; return 0;}],
               cst_Diff_command_for_tests_tha],
              _Q_]]],
         _T_ =
           [0,
            [0,
             cst_only_test,
             [4,
              function(str){
               try{
                var
                 _bK_ =
                   function(file, line, start_pos, end_pos){return [0, file, [0, line]];
                   },
                 _bL_ = [0, caml_call3(Stdlib_Scanf[4], str, _h_, _bK_)],
                 match = _bL_;
               }
               catch(_bP_){
                try{
                 var
                  _bI_ = function(file, line){return [0, file, [0, line]];},
                  _bJ_ = [0, caml_call3(Stdlib_Scanf[4], str, _g_, _bI_)],
                  match = _bJ_;
                }
                catch(_bQ_){
                 try{
                  var
                   _bG_ = function(file){return [0, file, 0];},
                   _bH_ = [0, caml_call3(Stdlib_Scanf[4], str, _f_, _bG_)],
                   match = _bH_;
                 }
                 catch(_bR_){var match = 0;}
                }
               }
               if(match)
                var
                 match$0 = match[1],
                 index = match$0[2],
                 file = match$0[1],
                 index$0 = index,
                 filename = file;
               else if(caml_call2(Stdlib_String[14], str, 58)){
                var
                 i = caml_call2(Stdlib_String[35], str, 58),
                 filename$0 = caml_call3(Stdlib_String[15], str, 0, i),
                 index_string =
                   caml_call3
                    (Stdlib_String[15],
                     str,
                     i + 1 | 0,
                     (caml_ml_string_length(str) - i | 0) - 1 | 0);
                try{
                 var
                  _bN_ = runtime.caml_int_of_string(index_string),
                  index$1 = _bN_;
                }
                catch(_bO_){
                 var _bM_ = caml_wrap_exception(_bO_);
                 if(_bM_[1] !== Stdlib[7])
                  throw caml_maybe_attach_backtrace(_bM_, 0);
                 caml_call2(Stdlib_Printf[3], _S_, str);
                 var index$1 = caml_call1(Stdlib[99], 1);
                }
                var index$0 = [0, index$1], filename = filename$0;
               }
               else
                var index$0 = 0, filename = str;
               tests[1] = [0, [0, filename, index$0, [0, 0]], tests[1]];
               return 0;
              }],
             cst_location_Run_only_the_test],
            _R_],
         _U_ =
           [0,
            [0,
             cst_matching,
             [4,
              function(s){name_filter[1] = [0, s, name_filter[1]]; return 0;}],
             cst_substring_Only_run_tests_w],
            _T_],
         _V_ =
           [0,
            [0,
             cst_require_tag,
             [4,
              function(tag){
               var t = tag_predicate[1], _bC_ = t[2];
               function _bD_(_bF_){return caml_string_notequal(tag, _bF_);}
               var _bE_ = caml_call2(Stdlib_List[41], _bD_, _bC_);
               tag_predicate[1] = [0, [0, tag, t[1]], _bE_];
               return 0;
              }],
             cst_tag_Only_run_tests_tagged_],
            _U_],
         _W_ =
           [0,
            [0,
             cst_drop_tag,
             [4,
              function(tag){
               var t = tag_predicate[1], _by_ = [0, tag, t[2]], _bz_ = t[1];
               function _bA_(_bB_){return caml_string_notequal(tag, _bB_);}
               tag_predicate[1] =
                [0, caml_call2(Stdlib_List[41], _bA_, _bz_), _by_];
               return 0;
              }],
             cst_tag_Only_run_tests_not_tag],
            _V_],
         _X_ =
           [0,
            [0, cst_verbose, [2, verbose], cst_Show_the_tests_as_they_run],
            [0,
             [0,
              cst_stop_on_error,
              [2, stop_on_error],
              cst_Run_tests_only_up_to_the_f],
             [0,
              [0, cst_strict, [2, strict], cst_End_with_an_error_if_no_te],
              [0,
               [0,
                cst_show_counts,
                [2, show_counts],
                cst_Show_the_number_of_tests_r],
               [0,
                [0,
                 cst_log,
                 [0,
                  function(param){
                   try{runtime.caml_sys_remove(cst_inline_tests_log$0);}
                   catch(_bx_){}
                   log[1] = [0, caml_call1(Stdlib[60], cst_inline_tests_log)];
                   return 0;
                  }],
                 cst_Log_the_tests_run_in_inlin],
                _W_]]]]],
         _Y_ =
           [0,
            [0,
             cst_partition,
             [4, function(i){partition[1] = [0, i]; return 0;}],
             cst_Only_run_the_tests_in_the_],
            _X_],
         _Z_ =
           [0,
            [0,
             cst_list_partitions,
             [0, function(param){list_partitions[1] = 1; return 0;}],
             cst_Lists_all_the_partitions_t],
            _Y_],
         ___ =
           [0,
            [0,
             cst_list_test_names,
             [0,
              function(param){
               list_test_names[1] = 1;
               verbose[1] = 1;
               return 0;
              }],
             cst_Do_not_run_tests_but_show_],
            _Z_],
         l = caml_call2(Stdlib_Arg[11], 0, ___),
         argv = caml_call1(Stdlib_Array[12], [0, name, rest]);
        try{caml_call5(Stdlib_Arg[3], 0, argv, l, f, msg$1);}
        catch(exn$0){
         var exn = caml_wrap_exception(exn$0);
         if(exn[1] === Stdlib_Arg[8]){
          var msg = exn[2];
          caml_call2(Stdlib_Printf[3], _a_, msg);
          caml_call1(Stdlib[99], 1);
         }
         else{
          if(exn[1] !== Stdlib_Arg[7])
           throw caml_maybe_attach_backtrace(exn, 0);
          var msg$0 = exn[2];
          caml_call2(Stdlib_Printf[2], _b_, msg$0);
          caml_call1(Stdlib[99], 0);
         }
        }
        var
         _$_ = list_partitions[1] ? -260537174 : [0, 1025081494, partition[1]],
         v =
           [0,
            -753295984,
            [0, [0, lib, tests[1], name_filter[1], tag_predicate[1]], _$_]];
        action[1] = v;
        switch$0 = 1;
       }
      }
     }
    }
   }
   var am_test_runner = typeof get(0) === "number" ? 0 : 1, switch$1 = 0;
   try{caml_sys_getenv("PPX_INLINE_TEST_LIB_AM_RUNNING_INLINE_TEST");}
   catch(_bv_){
    var _k_ = caml_wrap_exception(_bv_);
    if(_k_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_k_, 0);
    var switch$2 = 0;
    try{var val = caml_sys_getenv(cst_TESTING_FRAMEWORK);}
    catch(_bw_){
     var _l_ = caml_wrap_exception(_bw_);
     if(_l_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_l_, 0);
     var _m_ = 0;
     switch$2 = 1;
    }
    if(! switch$2)
     var _M_ = caml_string_notequal(val, "inline-test") ? 0 : 1, _m_ = _M_;
    var am_running_inline_test = _m_;
    switch$1 = 1;
   }
   if(! switch$1) var am_running_inline_test = 1;
   var
    testing = am_test_runner ? _n_ : am_running_inline_test ? _L_ : 822171972;
   function wall_time_clock_ns(param){return caml_call1(Time_now[1], 0);}
   var
    where_to_cut_backtrace =
      [246,
       function(param){
        var
         _bt_ = caml_call2(Stdlib[28], cst$2, cst_time_without_resetting_ran),
         _bu_ = caml_call2(Stdlib[28], cst_Ppx_inline_test_lib_Runtim, _bt_);
        return caml_call2(Base_String[70][2], 0, _bu_);
       }];
   function time_without_resetting_random_(f){
    var before_ns = wall_time_clock_ns(0);
    try{var _bs_ = [0, caml_call1(f, 0)], res = _bs_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      res = [1, [0, exn, caml_call1(Stdlib_Printexc[6], 0)]];
    }
    var
     _bq_ = wall_time_clock_ns(0),
     _br_ = caml_call2(Base_Int63[42], _bq_, before_ns);
    time_sec[1] = caml_call1(Base_Int63[3], _br_) / 1000000000.;
    return res;
   }
   var
    saved_caml_random_state =
      [246,
       function(_bp_){
        return caml_call1(Stdlib_Random[12][1], [0, 100, 200, 300]);
       }],
    saved_base_random_state =
      [246,
       function(_bo_){
        return caml_call1(Base_Random[18][2], [0, 111, 222, 333]);
       }];
   function string_of_module_descr(param){
    var t = current$0[1];
    function _bh_(m){return m[1];}
    var _bi_ = caml_call2(Stdlib_List[19], _bh_, t);
    function _bj_(s){
     var
      _bl_ = caml_call1(Stdlib_String[28], s),
      _bm_ = caml_call2(Stdlib[28], _bl_, cst$3),
      _bn_ = caml_call2(Stdlib[28], cst_T_MODULE_at, _bm_);
     return caml_call2(Stdlib[28], cst_in_TES, _bn_);
    }
    var _bk_ = caml_call2(Stdlib_List[19], _bj_, _bi_);
    return caml_call2(Stdlib_String[6], cst$4, _bk_);
   }
   function print_delayed_errors(param){
    var delayed_errors$0 = caml_call1(Stdlib_List[9], delayed_errors[1]);
    if(! delayed_errors$0) return 0;
    var _bf_ = caml_call2(Stdlib_String[1], 70, 61);
    caml_call2(Stdlib_Printf[3], _o_, _bf_);
    function _bg_(message){return caml_call2(Stdlib_Printf[3], _p_, message);}
    return caml_call2(Stdlib_List[17], _bg_, delayed_errors$0);
   }
   function eprintf_or_delay(fmt){
    function _bd_(s){
     if(verbose[1])
      delayed_errors[1] = [0, s, delayed_errors[1]];
     else
      caml_call2(Stdlib_Printf[3], _q_, s);
     var _be_ = stop_on_error[1];
     return _be_ ? (print_delayed_errors(0), caml_call1(Stdlib[99], 2)) : _be_;
    }
    return caml_call2(Stdlib_Printf[10], _bd_, fmt);
   }
   function add_hooks(C){
    return function(f, param){caml_call1(C[1], 0); return caml_call1(f, 0);};
   }
   function hum_backtrace(backtrace){
    var
     _a7_ = caml_call1(Base_String[88], backtrace),
     _a8_ = Base_List[133],
     _a9_ =
       caml_call2
        (_a8_,
         _a7_,
         function(str){
          var
           _bb_ = caml_obj_tag(where_to_cut_backtrace),
           _bc_ =
             250 === _bb_
              ? where_to_cut_backtrace[1]
              : 246
                === _bb_
                ? caml_call1(CamlinternalLazy[2], where_to_cut_backtrace)
                : where_to_cut_backtrace;
          return 1 - caml_call2(Base_String[70][5], _bc_, str);
         }),
     _a__ = Base_List[76],
     _a$_ =
       caml_call2
        (_a__,
         _a9_,
         function(str){
          var _ba_ = caml_call2(Base[197], str, cst$5);
          return caml_call2(Base[197], cst$6, _ba_);
         });
    return caml_call2(Base_String[54], 0, _a$_);
   }
   function test_inner
   (config,
    descr,
    tags,
    def_filename,
    def_line_number,
    start_pos,
    end_pos,
    f,
    bool_of_f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _aN_ = match[2],
     what_to_do = _aN_[2],
     match$0 = _aN_[1],
     which_tags = match$0[4],
     name_filter = match$0[3],
     only_test_location = match$0[2],
     libname = match$0[1],
     f$0 = caml_call1(add_hooks(config), f),
     descr$0 =
       [246,
        function(_a6_){
         return caml_call4
                 (displayed_descr(descr),
                  def_filename,
                  def_line_number,
                  start_pos,
                  end_pos);
        }],
     _aO_ = current_tags(0),
     complete_tags = caml_call2(Stdlib[37], tags, _aO_),
     _aP_ = caml_equal([0, libname], dynamic_lib[1]);
    if(_aP_){
     if(only_test_location)
      var
       _aL_ =
         function(param){
          var
           used = param[3],
           line_number_opt = param[2],
           filename = param[1],
           position_start =
             caml_ml_string_length(def_filename)
             - caml_ml_string_length(filename)
             | 0,
           _a1_ = 0 <= position_start ? 1 : 0;
          if(_a1_){
           var
            end_of_def_filename =
              caml_call3
               (Stdlib_String[15],
                def_filename,
                position_start,
                caml_ml_string_length(filename)),
            _a2_ = caml_string_equal(end_of_def_filename, filename);
           if(_a2_){
            var
             _a3_ = 0 === position_start ? 1 : 0,
             _a4_ =
               _a3_
               ||
                (47
                  ===
                   runtime.caml_string_get
                    (def_filename, position_start - 1 | 0)
                  ? 1
                  : 0);
            if(_a4_)
             if(line_number_opt)
              var
               line_number = line_number_opt[1],
               _a5_ = caml_equal(def_line_number, line_number);
             else
              var _a5_ = 1;
            else
             var _a5_ = _a4_;
           }
           else
            var _a5_ = _a2_;
           var found = _a5_;
          }
          else
           var found = _a1_;
          if(found) used[1] = 1;
          return found;
         },
       _aQ_ = caml_call2(Stdlib_List[33], _aL_, only_test_location);
     else
      var _aQ_ = 1;
     if(_aQ_){
      var
       _aC_ = which_tags[1],
       _aD_ =
         function(req){
          return 1 - caml_call2(Stdlib_List[36], req, complete_tags);
         },
       _aE_ = caml_call2(Stdlib_List[33], _aD_, _aC_);
      if(_aE_)
       var _aR_ = _aE_;
      else
       var
        _aF_ = which_tags[2],
        _aG_ =
          function(dropped){
           return caml_call2(Stdlib_List[36], dropped, complete_tags);
          },
        _aR_ = caml_call2(Stdlib_List[33], _aG_, _aF_);
      var _aS_ = 1 - _aR_;
      if(_aS_){
       var
        _aT_ = caml_obj_tag(descr$0),
        descr$1 =
          250 === _aT_
           ? descr$0[1]
           : 246 === _aT_ ? caml_call1(CamlinternalLazy[2], descr$0) : descr$0;
       if(name_filter)
        var
         _aM_ =
           function(substring){
            return caml_call2(Base_String[76], descr$1, substring);
           },
         _aU_ = caml_call2(Stdlib_List[33], _aM_, name_filter);
       else
        var _aU_ = 1;
       var should_run = _aU_;
      }
      else
       var should_run = _aS_;
     }
     else
      var should_run = _aQ_;
    }
    else
     var should_run = _aP_;
    if(should_run){
     if(typeof what_to_do === "number") return found_test(0);
     var partition = what_to_do[2], _aV_ = is_current(partition);
     if(_aV_){
      var
       _aW_ = caml_obj_tag(descr$0),
       descr$2 =
         250 === _aW_
          ? descr$0[1]
          : 246 === _aW_ ? caml_call1(CamlinternalLazy[2], descr$0) : descr$0;
      tests_ran[1]++;
      var match$1 = log[1];
      if(match$1){
       var ch = match$1[1], _aX_ = string_of_module_descr(0);
       caml_call4(Stdlib_Printf[1], ch, _r_, descr$2, _aX_);
      }
      if(verbose[1]) caml_call2(Stdlib_Printf[2], _s_, descr$2);
      if(list_test_names[1])
       var result$0 = _t_;
      else{
       var
        caml_random_state = caml_call1(Stdlib_Random[13], 0),
        base_random_state = caml_call1(Base_Random[18][4], Base_Random[18][1]),
        _aH_ = caml_obj_tag(saved_caml_random_state),
        _aI_ =
          250 === _aH_
           ? saved_caml_random_state[1]
           : 246
             === _aH_
             ? caml_call1(CamlinternalLazy[2], saved_caml_random_state)
             : saved_caml_random_state;
       caml_call1(Stdlib_Random[14], _aI_);
       var
        _aJ_ = caml_obj_tag(saved_base_random_state),
        _aK_ =
          250 === _aJ_
           ? saved_base_random_state[1]
           : 246
             === _aJ_
             ? caml_call1(CamlinternalLazy[2], saved_base_random_state)
             : saved_base_random_state;
       caml_call1(Base_Random[19], _aK_);
       var result = time_without_resetting_random_(f$0);
       caml_call1(Stdlib_Random[14], caml_random_state);
       caml_call1(Base_Random[19], base_random_state);
       var result$0 = caml_call2(Stdlib_Result[8], bool_of_f, result);
      }
      if(verbose[1]) caml_call2(Stdlib_Printf[2], _u_, time_sec[1]);
      if(0 !== result$0[0]){
       var match$2 = result$0[1], backtrace = match$2[2], exn = match$2[1];
       tests_failed[1]++;
       var
        backtrace$0 = hum_backtrace(backtrace),
        exn_str = caml_call1(Sexplib0_Sexp_conv[68], exn),
        sep = caml_call2(Stdlib_String[14], exn_str, 10) ? cst$7 : cst$8,
        _aZ_ = string_of_module_descr(0);
       return caml_call5
               (eprintf_or_delay(_w_),
                descr$2,
                sep,
                exn_str,
                backtrace$0,
                _aZ_);
      }
      if(result$0[1]) return 0;
      tests_failed[1]++;
      var _aY_ = string_of_module_descr(0);
      return caml_call2(eprintf_or_delay(_v_), descr$2, _aY_);
     }
     var _a0_ = _aV_;
    }
    else
     var _a0_ = should_run;
    return _a0_;
   }
   function set_lib_and_partition(static_lib, partition){
    if(dynamic_lib[1]) return 0;
    dynamic_lib[1] = [0, static_lib];
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     match$0 = match[2],
     what_to_do = match$0[2],
     which_tests = match$0[1],
     _aB_ = caml_string_equal(which_tests[1], static_lib);
    if(! _aB_) return _aB_;
    var switch$0 = 0;
    if(typeof what_to_do !== "number" && ! what_to_do[2]){var requires_partition = 0; switch$0 = 1;}
    if(! switch$0) var requires_partition = 1;
    if(caml_string_equal(partition, cst$13) && requires_partition)
     return caml_call1(Stdlib[2], cst_ppx_inline_test_cannot_use);
    current[1] = partition;
    return 0;
   }
   function unset_lib(static_lib){
    var match = dynamic_lib[1];
    if(! match) return 0;
    var
     lib = match[1],
     _az_ = caml_string_equal(lib, static_lib),
     _aA_ = _az_ ? (dynamic_lib[1] = 0, 0) : _az_;
    return _aA_;
   }
   function test
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(b){return b;});
   }
   function test_unit
   (config, descr, tags, filename, line_number, start_pos, end_pos, f){
    return test_inner
            (config,
             descr,
             tags,
             filename,
             line_number,
             start_pos,
             end_pos,
             f,
             function(param){return 1;});
   }
   function test_module
   (config, descr, tags, def_filename, def_line_number, start_pos, end_pos, f){
    var match = get(0);
    if(typeof match === "number") return 0;
    var
     _as_ = match[2],
     what_to_do = _as_[2],
     match$0 = _as_[1],
     which_tags = match$0[4],
     libname = match$0[1],
     f$0 = caml_call1(add_hooks(config), f),
     _at_ = current_tags(0),
     partial_tags = caml_call2(Stdlib[37], tags, _at_),
     _au_ = caml_equal([0, libname], dynamic_lib[1]);
    if(_au_)
     var
      _aq_ = which_tags[2],
      _ar_ =
        function(dropped){
         return caml_call2(Stdlib_List[36], dropped, partial_tags);
        },
      should_run = 1 - caml_call2(Stdlib_List[33], _ar_, _aq_);
    else
     var should_run = _au_;
    if(should_run){
     if(typeof what_to_do === "number") return found_test(0);
     var partition = what_to_do[2], _av_ = is_current(partition);
     if(_av_){
      test_modules_ran[1]++;
      var
       descr$0 =
         caml_call4
          (displayed_descr(descr),
           def_filename,
           def_line_number,
           start_pos,
           end_pos),
       prev = current$0[1];
      current$0[1] = [0, [0, descr$0, tags], prev];
      try{var x = time_without_resetting_random_(f$0); current$0[1] = prev;}
      catch(e$0){
       var e = caml_wrap_exception(e$0);
       current$0[1] = prev;
       throw caml_maybe_attach_backtrace(e, 0);
      }
      if(0 === x[0]) return 0;
      var match$1 = x[1], backtrace = match$1[2], exn = match$1[1];
      test_modules_failed[1]++;
      var
       backtrace$0 = hum_backtrace(backtrace),
       exn_str = caml_call1(Sexplib0_Sexp_conv[68], exn),
       sep = caml_call2(Stdlib_String[14], exn_str, 10) ? cst$9 : cst$10,
       _aw_ = string_of_module_descr(0),
       _ax_ = caml_call1(Stdlib_String[28], descr$0);
      return caml_call5
              (eprintf_or_delay(caml_call2(Stdlib[98], _y_, _x_)),
               _ax_,
               sep,
               exn_str,
               backtrace$0,
               _aw_);
     }
     var _ay_ = _av_;
    }
    else
     var _ay_ = should_run;
    return _ay_;
   }
   function summarize(param){
    var match = get(0);
    if(typeof match === "number"){
     var switch$0 = 0;
     if(runtime.caml_notequal(caml_sys_argv(0), [0])){
      var _ai_ = runtime.caml_check_bound(caml_sys_argv(0), 0)[1];
      if
       (caml_string_equal
         (caml_call1(Stdlib_Filename[13], _ai_), "inline_tests_runner.exe")){caml_call1(Stdlib_Printf[3], _z_); switch$0 = 1;}
     }
     if(! switch$0) caml_call1(Stdlib_Printf[3], _A_);
     return 2;
    }
    var _aj_ = match[2], which_tests = _aj_[1];
    if(typeof _aj_[2] === "number"){
     var
      _ae_ = 0,
      _af_ = function(k, param, acc){return [0, k, acc];},
      _ag_ = caml_call3(Stdlib_Hashtbl[14], _af_, _d_, _ae_),
      _ah_ = caml_call2(Stdlib_List[56], Stdlib_String[9], _ag_),
      _ak_ = caml_call1(Stdlib_Printf[2], _B_);
     caml_call2(Stdlib_List[17], _ak_, _ah_);
     return 0;
    }
    var match$0 = log[1];
    if(match$0){var ch = match$0[1]; caml_call1(Stdlib[76], ch);}
    print_delayed_errors(0);
    var count = tests_failed[1], count_test_modules = test_modules_failed[1];
    if(0 === count && 0 === count_test_modules){
     if(show_counts[1])
      caml_call3(Stdlib_Printf[3], _C_, tests_ran[1], test_modules_ran[1]);
     var
      _al_ = which_tests[2],
      _am_ = function(param){var used = param[3]; return 1 - used[1];},
      unused_tests = caml_call2(Stdlib_List[41], _am_, _al_),
      errors = unused_tests ? [0, unused_tests] : 0;
     if(errors){
      var tests = errors[1];
      caml_call1(Stdlib_Printf[3], _D_);
      var
       _an_ =
         function(param){
          var line_number_opt = param[2], filename = param[1];
          if(! line_number_opt)
           return caml_call2(Stdlib_Printf[3], _F_, filename);
          var line_number = line_number_opt[1];
          return caml_call3(Stdlib_Printf[3], _E_, filename, line_number);
         };
      caml_call2(Stdlib_List[17], _an_, tests);
      caml_call1(Stdlib_Printf[3], _G_);
      return 2;
     }
     if(0 === tests_ran[1] && strict[1]){
      caml_call1(Stdlib_Printf[3], _H_);
      return 2;
     }
     return 0;
    }
    if(0 === count_test_modules)
     var _ao_ = cst$11;
    else
     var
      _ap_ = caml_call2(Stdlib[98], _K_, _J_),
      _ao_ = caml_call2(Stdlib_Printf[4], _ap_, count_test_modules);
    caml_call4(Stdlib_Printf[3], _I_, count, tests_ran[1], _ao_);
    return 1;
   }
   var
    use_color$0 = use_color[1],
    in_place$0 = in_place[1],
    diff_command$0 = diff_command[1],
    source_tree_root$0 = source_tree_root[1],
    allow_output_patterns$0 = allow_output_patterns[1],
    evaluators = [0, [0, summarize, 0]];
   function add_evaluator(f){evaluators[1] = [0, f, evaluators[1]]; return 0;}
   function exit(param){
    var _ab_ = caml_call1(Stdlib_List[9], evaluators[1]);
    function _ac_(f){return caml_call1(f, 0);}
    switch(combine_all(caml_call2(Stdlib_List[19], _ac_, _ab_))){
      case 0:
       var _ad_ = 0; break;
      case 1:
       var _ad_ = 2; break;
      default: var _ad_ = 1;
    }
    return caml_call1(Stdlib[99], _ad_);
   }
   var
    Ppx_inline_test_lib_Runtime =
      [0,
       [0, combine, combine_all, to_string],
       set_lib_and_partition,
       unset_lib,
       test,
       test_unit,
       test_module,
       testing,
       use_color$0,
       in_place$0,
       diff_command$0,
       source_tree_root$0,
       allow_output_patterns$0,
       am_running_inline_test,
       am_running_inline_test_env_var,
       add_evaluator,
       exit];
   runtime.caml_register_global
    (124, Ppx_inline_test_lib_Runtime, cst_Ppx_inline_test_lib_Runtim$0);
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwcHhfaW5saW5lX3Rlc3RfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlbmFibGVfZXZlcnl0aGluZyIsImFtX3J1bm5pbmdfaW5saW5lX3Rlc3RfZW52X3ZhciIsInRvX3N0cmluZyIsImNvbWJpbmUiLCJ0MSIsInQyIiwiY29tYmluZV9hbGwiLCJ0cyIsInRlc3RfbW9kdWxlc19yYW4iLCJ0ZXN0X21vZHVsZXNfZmFpbGVkIiwidGVzdHNfcmFuIiwidGVzdHNfZmFpbGVkIiwiZHluYW1pY19saWIiLCJhY3Rpb24iLCJmb3JjZV9kcm9wIiwiZ2V0IiwiY3VycmVudCIsImZvdW5kX3Rlc3QiLCJpc19jdXJyZW50IiwicCIsImN1cnJlbnQkMCIsImN1cnJlbnRfdGFncyIsInQiLCJtIiwidmVyYm9zZSIsInN0cmljdCIsInNob3dfY291bnRzIiwibGlzdF90ZXN0X25hbWVzIiwiZGVsYXllZF9lcnJvcnMiLCJzdG9wX29uX2Vycm9yIiwibG9nIiwidGltZV9zZWMiLCJ1c2VfY29sb3IiLCJpbl9wbGFjZSIsImRpZmZfY29tbWFuZCIsInNvdXJjZV90cmVlX3Jvb3QiLCJhbGxvd19vdXRwdXRfcGF0dGVybnMiLCJkaXNwbGF5ZWRfZGVzY3IiLCJkZXNjciIsImZpbGVuYW1lIiwibGluZSIsInN0YXJ0X3BvcyIsImVuZF9wb3MiLCJuYW1lIiwicmVzdCIsImxpYiIsInRlc3RzIiwibGlzdF9wYXJ0aXRpb25zIiwicGFydGl0aW9uIiwidGFnX3ByZWRpY2F0ZSIsIm5hbWVfZmlsdGVyIiwibXNnJDEiLCJmIiwiYW5vbiIsInMiLCJzdHIiLCJmaWxlIiwiaW5kZXgiLCJpbmRleCQwIiwiaSIsImZpbGVuYW1lJDAiLCJpbmRleF9zdHJpbmciLCJpbmRleCQxIiwidGFnIiwibCIsImFyZ3YiLCJtc2ciLCJtc2ckMCIsInYiLCJhbV90ZXN0X3J1bm5lciIsImFtX3J1bm5pbmdfaW5saW5lX3Rlc3QiLCJ0ZXN0aW5nIiwid2FsbF90aW1lX2Nsb2NrX25zIiwid2hlcmVfdG9fY3V0X2JhY2t0cmFjZSIsInRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tXyIsImJlZm9yZV9ucyIsInJlcyIsImV4biQwIiwiZXhuIiwic2F2ZWRfY2FtbF9yYW5kb21fc3RhdGUiLCJzYXZlZF9iYXNlX3JhbmRvbV9zdGF0ZSIsInN0cmluZ19vZl9tb2R1bGVfZGVzY3IiLCJwcmludF9kZWxheWVkX2Vycm9ycyIsImRlbGF5ZWRfZXJyb3JzJDAiLCJtZXNzYWdlIiwiZXByaW50Zl9vcl9kZWxheSIsImZtdCIsImFkZF9ob29rcyIsIkMiLCJodW1fYmFja3RyYWNlIiwiYmFja3RyYWNlIiwidGVzdF9pbm5lciIsImNvbmZpZyIsInRhZ3MiLCJkZWZfZmlsZW5hbWUiLCJkZWZfbGluZV9udW1iZXIiLCJib29sX29mX2YiLCJ3aGF0X3RvX2RvIiwid2hpY2hfdGFncyIsIm9ubHlfdGVzdF9sb2NhdGlvbiIsImxpYm5hbWUiLCJmJDAiLCJkZXNjciQwIiwiY29tcGxldGVfdGFncyIsInVzZWQiLCJsaW5lX251bWJlcl9vcHQiLCJwb3NpdGlvbl9zdGFydCIsImVuZF9vZl9kZWZfZmlsZW5hbWUiLCJsaW5lX251bWJlciIsImZvdW5kIiwicmVxIiwiZHJvcHBlZCIsImRlc2NyJDEiLCJzdWJzdHJpbmciLCJzaG91bGRfcnVuIiwiZGVzY3IkMiIsImNoIiwicmVzdWx0JDAiLCJjYW1sX3JhbmRvbV9zdGF0ZSIsImJhc2VfcmFuZG9tX3N0YXRlIiwicmVzdWx0IiwiYmFja3RyYWNlJDAiLCJleG5fc3RyIiwic2VwIiwic2V0X2xpYl9hbmRfcGFydGl0aW9uIiwic3RhdGljX2xpYiIsIndoaWNoX3Rlc3RzIiwicmVxdWlyZXNfcGFydGl0aW9uIiwidW5zZXRfbGliIiwidGVzdCIsImIiLCJ0ZXN0X3VuaXQiLCJ0ZXN0X21vZHVsZSIsInBhcnRpYWxfdGFncyIsInByZXYiLCJ4IiwiZSQwIiwiZSIsInN1bW1hcml6ZSIsImsiLCJhY2MiLCJjb3VudCIsImNvdW50X3Rlc3RfbW9kdWxlcyIsInVudXNlZF90ZXN0cyIsImVycm9ycyIsInVzZV9jb2xvciQwIiwiaW5fcGxhY2UkMCIsImRpZmZfY29tbWFuZCQwIiwic291cmNlX3RyZWVfcm9vdCQwIiwiYWxsb3dfb3V0cHV0X3BhdHRlcm5zJDAiLCJldmFsdWF0b3JzIiwiYWRkX2V2YWx1YXRvciIsImV4aXQiXSwic291cmNlcyI6WyIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvcHB4X2lubGluZV90ZXN0L3J1bnRpbWUtbGliL3J1bnRpbWUubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBNERNQTs7SUFrUEZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBclNFQztJQUFZOztPQUNEOztPQUNBO2VBQ0E7O0dBQU87WUFHbEJDLFFBQVFDLElBQUdDO0lBQ2I7V0FEVUQ7O1lBQUdDLElBRWdCOzs7OzJCQUZoQkEsSUFJZ0I7SUFEQTtHQUNPO1lBR2xDQyxZQUFZQztJQUFLLG1DQVBqQkosWUFPWUk7R0FBc0M7R0FZakM7SUFBbkJDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBcUVFQzs7SUFFVTtJQUErQyxjQUR6REM7Ozs7Ozs7WUFHQUMsV0FNRixPQVRFRCwwQkFEQUQsVUFZVTtHQVdKLGdEQUNORztZQUNBQztJQUNGO0tBQUcsNEJBRkREO0tBRUMsa0JBQXNCLG1DQUZ2QkE7a0JBR0EsbUNBSEFBO0dBRzJCO1lBRTNCRTtJQUFh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O1dBem5CSEgsU0FPQUcsYUFiQUo7T0E2ZEYwSDtPQXVCQUk7T0FVQUM7T0FJQUU7T0FJZUM7T0FqTmY3RDtPQThUQTBFO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BM1VBL0U7T0FQQXJFO09BcVZBc0o7T0FDQUM7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZSBUZXN0X3Jlc3VsdCA9IHN0cnVjdFxuICB0eXBlIHQgPSBTdWNjZXNzIHwgRmFpbHVyZSB8IEVycm9yXG5cbiAgbGV0IHRvX2V4aXRfY29kZSA9IGZ1bmN0aW9uXG4gICAgfCBTdWNjZXNzIC0+IDBcbiAgICB8IEZhaWx1cmUgLT4gMlxuICAgIHwgRXJyb3IgICAtPiAxXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IGZ1bmN0aW9uXG4gICAgfCBTdWNjZXNzIC0+IFwic3VjY2Vzc1wiXG4gICAgfCBGYWlsdXJlIC0+IFwiZmFpbHVyZVwiXG4gICAgfCBFcnJvciAgIC0+IFwiZXJyb3JcIlxuICA7O1xuXG4gIGxldCBjb21iaW5lIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgU3VjY2VzcywgU3VjY2VzcyAgICAgICAgLT4gU3VjY2Vzc1xuICAgIHwgRXJyb3IgICwgXyB8IF8sIEVycm9yICAgLT4gRXJyb3JcbiAgICB8IEZhaWx1cmUsIF8gfCBfLCBGYWlsdXJlIC0+IEZhaWx1cmVcbiAgOztcblxuICBsZXQgY29tYmluZV9hbGwgdHMgPSBMaXN0LmZvbGRfbGVmdCBjb21iaW5lIFN1Y2Nlc3MgdHNcbmVuZFxuXG5sZXQgcGFyc2VfYXJndiBhcmd2IGwgZiBtc2cgPVxuICB0cnlcbiAgICBBcmcucGFyc2VfYXJndiBhcmd2IGwgZiBtc2dcbiAgd2l0aFxuICB8IEFyZy5CYWQgbXNnIC0+IFByaW50Zi5lcHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMVxuICB8IEFyZy5IZWxwIG1zZyAtPiBQcmludGYucHJpbnRmIFwiJXNcIiBtc2c7IGV4aXQgMFxuOztcblxudHlwZSBkZXNjciA9IHN0cmluZ1xubGV0IHRlc3RfbW9kdWxlc19yYW4gPSByZWYgMFxubGV0IHRlc3RfbW9kdWxlc19mYWlsZWQgPSByZWYgMFxubGV0IHRlc3RzX3JhbiA9IHJlZiAwXG5sZXQgdGVzdHNfZmFpbGVkID0gcmVmIDBcbmxldCBkeW5hbWljX2xpYiA6IHN0cmluZyBvcHRpb24gcmVmID0gcmVmIE5vbmVcbnR5cGUgZmlsZW5hbWUgPSBzdHJpbmdcbnR5cGUgbGluZV9udW1iZXIgPSBpbnRcbnR5cGUgc3RhcnRfcG9zID0gaW50XG50eXBlIGVuZF9wb3MgPSBpbnRcbnR5cGUgY29uZmlnID0gKG1vZHVsZSBJbmxpbmVfdGVzdF9jb25maWcuUylcbnR5cGUgJ2EgdGVzdF9mdW5jdGlvbl9hcmdzXG4gID0gY29uZmlnOmNvbmZpZ1xuICAtPiBkZXNjcjpkZXNjciBMYXp5LnRcbiAgLT4gdGFnczpzdHJpbmcgbGlzdFxuICAtPiBmaWxlbmFtZTpmaWxlbmFtZVxuICAtPiBsaW5lX251bWJlcjpsaW5lX251bWJlclxuICAtPiBzdGFydF9wb3M6c3RhcnRfcG9zXG4gIC0+IGVuZF9wb3M6ZW5kX3Bvc1xuICAtPiAnYVxuXG5tb2R1bGUgVGFnX3ByZWRpY2F0ZSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgcmVxdWlyZWRfdGFncyAgOiBzdHJpbmcgbGlzdFxuICAgIDsgZHJvcHBlZF90YWdzIDogc3RyaW5nIGxpc3RcbiAgICB9XG5cbiAgbGV0IGVuYWJsZV9ldmVyeXRoaW5nID0geyByZXF1aXJlZF90YWdzID0gW107IGRyb3BwZWRfdGFncyA9IFtdIH1cblxuICBsZXQgZHJvcCB0IHRhZyA9XG4gICAgeyBkcm9wcGVkX3RhZ3MgPSB0YWcgOjogdC5kcm9wcGVkX3RhZ3NcbiAgICA7IHJlcXVpcmVkX3RhZ3MgPSBMaXN0LmZpbHRlciAoKDw+KSB0YWcpIHQucmVxdWlyZWRfdGFnc1xuICAgIH1cblxuICBsZXQgcmVxdWlyZSB0IHRhZyA9XG4gICAgeyBkcm9wcGVkX3RhZ3MgPSBMaXN0LmZpbHRlciAoKDw+KSB0YWcpIHQuZHJvcHBlZF90YWdzXG4gICAgOyByZXF1aXJlZF90YWdzID0gdGFnIDo6IHQucmVxdWlyZWRfdGFnc1xuICAgIH1cblxuICBsZXQgZW50aXJlX21vZHVsZV9kaXNhYmxlZCB0IH5wYXJ0aWFsX3RhZ3M6dGFncyA9XG4gICAgTGlzdC5leGlzdHMgKGZ1biBkcm9wcGVkIC0+IExpc3QubWVtIGRyb3BwZWQgdGFncykgdC5kcm9wcGVkX3RhZ3NcblxuICBsZXQgZGlzYWJsZWQgdCB+Y29tcGxldGVfdGFnczp0YWdzID1cbiAgICBMaXN0LmV4aXN0cyAoZnVuIHJlcSAtPiBub3QgKExpc3QubWVtIHJlcSB0YWdzKSkgdC5yZXF1aXJlZF90YWdzXG4gICAgfHwgTGlzdC5leGlzdHMgKGZ1biBkcm9wcGVkIC0+IExpc3QubWVtIGRyb3BwZWQgdGFncykgdC5kcm9wcGVkX3RhZ3NcbmVuZFxuXG5cbnR5cGUgd2hpY2hfdGVzdHMgPVxuICB7IGxpYm5hbWUgOiBzdHJpbmdcbiAgOyBvbmx5X3Rlc3RfbG9jYXRpb24gOiAoZmlsZW5hbWUgKiBsaW5lX251bWJlciBvcHRpb24gKiBib29sIHJlZikgbGlzdFxuICA7IG5hbWVfZmlsdGVyIDogc3RyaW5nIGxpc3RcbiAgOyB3aGljaF90YWdzIDogVGFnX3ByZWRpY2F0ZS50XG4gIH1cbnR5cGUgdGVzdF9tb2RlID1cbiAgeyB3aGljaF90ZXN0cyA6IHdoaWNoX3Rlc3RzXG4gIDsgd2hhdF90b19kbyA6XG4gICAgICBbIGBSdW5fcGFydGl0aW9uIG9mIHN0cmluZyBvcHRpb25cbiAgICAgIHwgYExpc3RfcGFydGl0aW9uc1xuICAgICAgXVxuICB9XG5cbm1vZHVsZSBBY3Rpb24gOiBzaWdcbiAgdHlwZSB0ID0gW1xuICAgIHwgYElnbm9yZVxuICAgIHwgYFRlc3RfbW9kZSBvZiB0ZXN0X21vZGVcbiAgXVxuICB2YWwgZ2V0IDogdW5pdCAtPiB0XG4gIHZhbCBzZXQgOiB0IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBbXG4gICAgfCBgSWdub3JlXG4gICAgfCBgVGVzdF9tb2RlIG9mIHRlc3RfbW9kZVxuICBdXG4gIGxldCBhY3Rpb24gOiB0IHJlZiA9IHJlZiBgSWdub3JlXG4gIGxldCBmb3JjZV9kcm9wID1cbiAgICB0cnkgaWdub3JlIChTeXMuZ2V0ZW52IFwiRk9SQ0VfRFJPUF9JTkxJTkVfVEVTVFwiIDogc3RyaW5nKTsgdHJ1ZVxuICAgIHdpdGggTm90X2ZvdW5kIC0+IGZhbHNlXG4gIGxldCBnZXQgKCkgPVxuICAgICgqIFRoaXMgaXMgdXNlZnVsIHdoZW4gY29tcGlsaW5nIHRvIGphdmFzY3JpcHQuXG4gICAgICAgSnNfb2Zfb2NhbWwgY2FuIHN0YXRpY2FsbHkgZXZhbHVhdGUgW1N5cy5nZXRlbnYgXCJGT1JDRV9EUk9QX0lOTElORV9URVNUXCJdXG4gICAgICAgYW5kIGlubGluZSB0aGUgcmVzdWx0IChbYElnbm9yZV0pIHdoZW5ldmVyIFtnZXQgKCldIGlzIGNhbGxlZC5cbiAgICAgICBVbml0IHRlc3RzIGNhbiB0aGVuIGJlIHRyZWF0ZWQgYXMgZGVhZGNvZGUgc2luY2UgdGhlIGFyZ3VtZW50IFtmXSBvZiB0aGUgW3Rlc3RdXG4gICAgICAgZnVuY3Rpb24gYmVsb3cgaXMgbmV2ZXIgdXNlZC4gKilcbiAgICBpZiBmb3JjZV9kcm9wXG4gICAgdGhlbiBgSWdub3JlXG4gICAgZWxzZSAhYWN0aW9uXG5cbiAgbGV0IHNldCB2ID0gYWN0aW9uIDo9IHZcbmVuZFxuXG5tb2R1bGUgUGFydGl0aW9uIDogc2lnXG4gIHZhbCBmb3VuZF90ZXN0IDogdW5pdCAtPiB1bml0XG4gIHZhbCBzZXRfY3VycmVudCA6IHN0cmluZyAtPiB1bml0XG4gIHZhbCBpc19jdXJyZW50IDogc3RyaW5nIG9wdGlvbiAtPiBib29sXG4gIHZhbCBhbGwgOiB1bml0IC0+IHN0cmluZyBsaXN0XG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IGFsbCA9IEhhc2h0YmwuY3JlYXRlIDIzXG4gIGxldCBjdXJyZW50ID0gcmVmIFwiXCIgIGxldCBzZXRfY3VycmVudCB4ID0gY3VycmVudCA6PSB4XG4gIGxldCBmb3VuZF90ZXN0ICgpID1cbiAgICBpZiAhY3VycmVudCA8PiBcIlwiICYmIG5vdCAoSGFzaHRibC5tZW0gYWxsICFjdXJyZW50KSB0aGVuXG4gICAgICBIYXNodGJsLmFkZCBhbGwgIWN1cnJlbnQgKClcbiAgOztcbiAgbGV0IGlzX2N1cnJlbnQgPSBmdW5jdGlvblxuICAgIHwgTm9uZSAtPiB0cnVlXG4gICAgfCBTb21lIHAgLT4gcCA9ICFjdXJyZW50XG4gIDs7XG4gIGxldCBhbGwgKCkgPVxuICAgIExpc3Quc29ydCBTdHJpbmcuY29tcGFyZVxuICAgICAgKEhhc2h0YmwuZm9sZCAoZnVuIGsgKCkgYWNjIC0+IGsgOjogYWNjKSBhbGwgW10pXG4gIDs7XG5lbmRcblxubW9kdWxlIE1vZHVsZV9jb250ZXh0ID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSBvbmVfbW9kdWxlID1cbiAgICAgIHsgZGVzY3IgOiBzdHJpbmdcbiAgICAgIDsgdGFncyA6IHN0cmluZyBsaXN0XG4gICAgICB9XG5cbiAgICB0eXBlIHQgPSBvbmVfbW9kdWxlIGxpc3RcblxuICAgIGxldCBkZXNjciB0ID0gTGlzdC5tYXAgKGZ1biBtIC0+IG0uZGVzY3IpIHRcbiAgICBsZXQgdGFncyB0ID0gTGlzdC5jb25jYXQgKExpc3QubWFwIChmdW4gbSAtPiBtLnRhZ3MpIHQpXG4gIGVuZFxuXG4gIGxldCBjdXJyZW50IDogVC50IHJlZiA9IHJlZiBbXVxuXG4gIGxldCB3aXRoXyB+ZGVzY3IgfnRhZ3MgZiA9XG4gICAgbGV0IHByZXYgPSAhY3VycmVudCBpblxuICAgIGN1cnJlbnQgOj0geyBULiBkZXNjcjsgdGFncyB9IDo6IHByZXY7XG4gICAgdHJ5XG4gICAgICBsZXQgeCA9IGYgKCkgaW5cbiAgICAgIGN1cnJlbnQgOj0gcHJldjtcbiAgICAgIHhcbiAgICB3aXRoIGUgLT5cbiAgICAgIGN1cnJlbnQgOj0gcHJldjtcbiAgICAgIHJhaXNlIGVcblxuICBsZXQgY3VycmVudF9kZXNjciAoKSA9IFQuZGVzY3IgIWN1cnJlbnRcbiAgbGV0IGN1cnJlbnRfdGFncyAgKCkgPSBULnRhZ3MgICFjdXJyZW50XG5lbmRcblxubGV0IHZlcmJvc2UgPSByZWYgZmFsc2VcbmxldCBzdHJpY3QgPSByZWYgZmFsc2VcbmxldCBzaG93X2NvdW50cyA9IHJlZiBmYWxzZVxubGV0IGxpc3RfdGVzdF9uYW1lcyA9IHJlZiBmYWxzZVxubGV0IGRlbGF5ZWRfZXJyb3JzID0gcmVmIFtdXG5sZXQgc3RvcF9vbl9lcnJvciA9IHJlZiBmYWxzZVxuXG5sZXQgbG9nID0gcmVmIE5vbmVcblxubGV0IHRpbWVfc2VjID0gcmVmIDAuXG5cbmxldCB1c2VfY29sb3IgPSByZWYgdHJ1ZVxubGV0IGluX3BsYWNlICA9IHJlZiBmYWxzZVxubGV0IGRpZmZfY29tbWFuZCA9IHJlZiBOb25lXG5sZXQgc291cmNlX3RyZWVfcm9vdCA9IHJlZiBOb25lXG5sZXQgYWxsb3dfb3V0cHV0X3BhdHRlcm5zID0gcmVmIGZhbHNlXG5cbmxldCBkaXNwbGF5ZWRfZGVzY3IgKGxhenkgZGVzY3IpIGZpbGVuYW1lIGxpbmUgc3RhcnRfcG9zIGVuZF9wb3MgPVxuICBQcmludGYuc3ByaW50ZiBcIkZpbGUgJVMsIGxpbmUgJWQsIGNoYXJhY3RlcnMgJWQtJWQlc1wiXG4gICAgZmlsZW5hbWUgbGluZSBzdGFydF9wb3MgZW5kX3Bvc1xuICAgIChpZiBkZXNjciA9IFwiXCIgdGhlbiBcIlwiIGVsc2UgXCI6IFwiIF4gZGVzY3IpXG5sZXQgcGFyc2VfZGVzY3Igc3RyID1cbiAgdHJ5IFNvbWUgKFNjYW5mLnNzY2FuZiBzdHIgXCIgRmlsZSAlUyAsIGxpbmUgJWQgLCBjaGFyYWN0ZXJzICVkIC0gJWQgJSFcIlxuICAgICAgICAgICAgICAoZnVuIGZpbGUgbGluZSBfc3RhcnRfcG9zIF9lbmRfcG9zIC0+IGZpbGUsIFNvbWUgbGluZSkpXG4gIHdpdGggXyAtPlxuICB0cnkgU29tZSAoU2NhbmYuc3NjYW5mIHN0ciBcIiBGaWxlICVTICwgbGluZSAlZCAlIVwiIChmdW4gZmlsZSBsaW5lIC0+IGZpbGUsIFNvbWUgbGluZSkpXG4gIHdpdGggXyAtPlxuICB0cnkgU29tZSAoU2NhbmYuc3NjYW5mIHN0ciBcIiBGaWxlICVTICUhXCIgKGZ1biBmaWxlIC0+IGZpbGUsIE5vbmUpKVxuICB3aXRoIF8gLT4gTm9uZVxuXG5sZXQgKCkgPVxuICBtYXRjaCBBcnJheS50b19saXN0IFN5cy5hcmd2IHdpdGhcbiAgfCBuYW1lIDo6IFwiaW5saW5lLXRlc3QtcnVubmVyXCIgOjogbGliIDo6IHJlc3RcbiAgICB3aGVuIEJhc2UuRXhwb3J0ZWRfZm9yX3NwZWNpZmljX3VzZXMuYW1fdGVzdGluZyAtPiBiZWdpblxuICAgICAgKCogd2hlbiB3ZSBzZWUgdGhpcyBhcmd1bWVudCwgd2Ugc3dpdGNoIHRvIHRlc3QgbW9kZSAqKVxuICAgICAgbGV0IHRlc3RzID0gcmVmIFtdIGluXG4gICAgICBsZXQgbGlzdF9wYXJ0aXRpb25zID0gcmVmIGZhbHNlIGluXG4gICAgICBsZXQgcGFydGl0aW9uID0gcmVmIE5vbmUgaW5cbiAgICAgIGxldCB0YWdfcHJlZGljYXRlID0gcmVmIFRhZ19wcmVkaWNhdGUuZW5hYmxlX2V2ZXJ5dGhpbmcgaW5cbiAgICAgIGxldCBuYW1lX2ZpbHRlciA9IHJlZiBbXSBpblxuICAgICAgcGFyc2VfYXJndiAoQXJyYXkub2ZfbGlzdCAobmFtZSA6OiByZXN0KSkgKEFyZy5hbGlnbiBbXG4gICAgICAgIFwiLWxpc3QtdGVzdC1uYW1lc1wiLCBBcmcuVW5pdCAoZnVuICgpIC0+IGxpc3RfdGVzdF9uYW1lcyA6PSB0cnVlOyB2ZXJib3NlIDo9IHRydWUpLFxuICAgICAgICBcIiBEbyBub3QgcnVuIHRlc3RzIGJ1dCBzaG93IHdoYXQgd291bGQgaGF2ZSBiZWVuIHJ1blwiO1xuICAgICAgICBcIi1saXN0LXBhcnRpdGlvbnNcIiwgQXJnLlVuaXQgKGZ1biAoKSAtPiBsaXN0X3BhcnRpdGlvbnMgOj0gdHJ1ZSksXG4gICAgICAgIFwiIExpc3RzIGFsbCB0aGUgcGFydGl0aW9ucyB0aGF0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHRlc3Qgb3IgdGVzdF9tb2R1bGVcIjtcbiAgICAgICAgXCItcGFydGl0aW9uXCIsIEFyZy5TdHJpbmcgKGZ1biBpIC0+IHBhcnRpdGlvbiA6PSBTb21lIGkpLFxuICAgICAgICBcIiBPbmx5IHJ1biB0aGUgdGVzdHMgaW4gdGhlIGdpdmVuIHBhcnRpdGlvblwiO1xuICAgICAgICBcIi12ZXJib3NlXCIsIEFyZy5TZXQgdmVyYm9zZSwgXCIgU2hvdyB0aGUgdGVzdHMgYXMgdGhleSBydW5cIjtcbiAgICAgICAgXCItc3RvcC1vbi1lcnJvclwiLCBBcmcuU2V0IHN0b3Bfb25fZXJyb3IsIFwiIFJ1biB0ZXN0cyBvbmx5IHVwIHRvIHRoZSBmaXJzdCBlcnJvciBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZG9lc24ndCB3b3JrIGZvciBleHBlY3QgdGVzdHMpXCI7XG4gICAgICAgIFwiLXN0cmljdFwiLCBBcmcuU2V0IHN0cmljdCwgXCIgRW5kIHdpdGggYW4gZXJyb3IgaWYgbm8gdGVzdHMgd2VyZSBydW5cIjtcbiAgICAgICAgXCItc2hvdy1jb3VudHNcIiwgQXJnLlNldCBzaG93X2NvdW50cywgXCIgU2hvdyB0aGUgbnVtYmVyIG9mIHRlc3RzIHJhblwiO1xuICAgICAgICBcIi1sb2dcIiwgQXJnLlVuaXQgKGZ1biAoKSAtPlxuICAgICAgICAgICh0cnkgU3lzLnJlbW92ZSBcImlubGluZV90ZXN0cy5sb2dcIiB3aXRoIF8gLT4gKCkpO1xuICAgICAgICAgIGxvZyA6PSBTb21lIChvcGVuX291dCBcImlubGluZV90ZXN0cy5sb2dcIilcbiAgICAgICAgKSwgXCIgTG9nIHRoZSB0ZXN0cyBydW4gaW4gaW5saW5lX3Rlc3RzLmxvZ1wiO1xuICAgICAgICBcIi1kcm9wLXRhZ1wiLCBBcmcuU3RyaW5nIChmdW4gcyAtPlxuICAgICAgICAgIHRhZ19wcmVkaWNhdGUgOj0gVGFnX3ByZWRpY2F0ZS5kcm9wICF0YWdfcHJlZGljYXRlIHNcbiAgICAgICAgKSwgXCJ0YWcgT25seSBydW4gdGVzdHMgbm90IHRhZ2dlZCB3aXRoIFt0YWddIChvdmVycmlkZXMgcHJldmlvdXMgLXJlcXVpcmUtdGFnKVwiO1xuICAgICAgICBcIi1yZXF1aXJlLXRhZ1wiLCBBcmcuU3RyaW5nIChmdW4gcyAtPlxuICAgICAgICAgIHRhZ19wcmVkaWNhdGUgOj0gVGFnX3ByZWRpY2F0ZS5yZXF1aXJlICF0YWdfcHJlZGljYXRlIHNcbiAgICAgICAgKSwgXCJ0YWcgT25seSBydW4gdGVzdHMgdGFnZ2VkIHdpdGggW3RhZ10gKG92ZXJyaWRlcyBwcmV2aW91cyAtZHJvcC10YWcpXCI7XG4gICAgICAgIFwiLW1hdGNoaW5nXCIsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IG5hbWVfZmlsdGVyIDo9IHMgOjogIW5hbWVfZmlsdGVyKSxcbiAgICAgICAgXCJzdWJzdHJpbmcgT25seSBydW4gdGVzdHMgd2hvc2UgbmFtZXMgY29udGFpbiB0aGUgZ2l2ZW4gc3Vic3RyaW5nXCI7XG4gICAgICAgIFwiLW9ubHktdGVzdFwiLCBBcmcuU3RyaW5nIChmdW4gcyAtPlxuICAgICAgICAgIGxldCBmaWxlbmFtZSwgaW5kZXggPVxuICAgICAgICAgICAgbWF0Y2ggcGFyc2VfZGVzY3IgcyB3aXRoXG4gICAgICAgICAgICB8IFNvbWUgKGZpbGUsIGluZGV4KSAtPiBmaWxlLCBpbmRleFxuICAgICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICAgIGlmIFN0cmluZy5jb250YWlucyBzICc6JyB0aGVuXG4gICAgICAgICAgICAgICAgbGV0IGkgPSBTdHJpbmcuaW5kZXggcyAnOicgaW5cbiAgICAgICAgICAgICAgICBsZXQgZmlsZW5hbWUgPSBTdHJpbmcuc3ViIHMgMCBpIGluXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4X3N0cmluZyA9IFN0cmluZy5zdWIgcyAoaSArIDEpIChTdHJpbmcubGVuZ3RoIHMgLSBpIC0gMSkgaW5cbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPVxuICAgICAgICAgICAgICAgICAgdHJ5IGludF9vZl9zdHJpbmcgaW5kZXhfc3RyaW5nXG4gICAgICAgICAgICAgICAgICB3aXRoIEZhaWx1cmUgXyAtPlxuICAgICAgICAgICAgICAgICAgICBQcmludGYuZXByaW50ZlxuICAgICAgICAgICAgICAgICAgICAgIFwiQXJndW1lbnQgJXMgZG9lc24ndCBmaXQgdGhlIGZvcm1hdCBmaWxlbmFtZVs6bGluZV9udW1iZXJdXFxuJSFcIiBzO1xuICAgICAgICAgICAgICAgICAgICBleGl0IDFcbiAgICAgICAgICAgICAgICBpblxuICAgICAgICAgICAgICAgIGZpbGVuYW1lLCBTb21lIGluZGV4XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzLCBOb25lXG4gICAgICAgICAgaW5cbiAgICAgICAgICB0ZXN0cyA6PSAoZmlsZW5hbWUsIGluZGV4LCByZWYgZmFsc2UpIDo6ICF0ZXN0c1xuICAgICAgICApLCBcImxvY2F0aW9uIFJ1biBvbmx5IHRoZSB0ZXN0cyBzcGVjaWZpZWQgYnkgYWxsIHRoZSAtb25seS10ZXN0IG9wdGlvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgTG9jYXRpb25zIGNhbiBiZSBvbmUgb2YgdGhlc2UgZm9ybXM6XG4gICAgICAgICAgICAgICAgICAgICAgLSBmaWxlLm1sXG4gICAgICAgICAgICAgICAgICAgICAgLSBmaWxlLm1sOmxpbmVfbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgLSBGaWxlIFxcXCJmaWxlLm1sXFxcIlxuICAgICAgICAgICAgICAgICAgICAgIC0gRmlsZSBcXFwiZmlsZS5tbFxcXCIsIGxpbmUgMjNcbiAgICAgICAgICAgICAgICAgICAgICAtIEZpbGUgXFxcImZpbGUubWxcXFwiLCBsaW5lIDIzLCBjaGFyYWN0ZXJzIDItM1wiO1xuICAgICAgICBcIi1uby1jb2xvclwiLCBBcmcuQ2xlYXIgdXNlX2NvbG9yLCBcIiBTdW1tYXJpemUgdGVzdHMgd2l0aG91dCB1c2luZyBjb2xvclwiO1xuICAgICAgICBcIi1pbi1wbGFjZVwiLCBBcmcuU2V0IGluX3BsYWNlLCBcIiBVcGRhdGUgZXhwZWN0IHRlc3RzIGluIHBsYWNlXCI7XG4gICAgICAgIFwiLWRpZmYtY21kXCIsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IGRpZmZfY29tbWFuZCA6PSBTb21lIHMpLFxuICAgICAgICBcIiBEaWZmIGNvbW1hbmQgZm9yIHRlc3RzIHRoYXQgcmVxdWlyZSBkaWZmaW5nICh1c2UgLSB0byBkaXNhYmxlIGRpZmZpbmcpXCI7XG4gICAgICAgIFwiLWFsbG93LW91dHB1dC1wYXR0ZXJuc1wiLCBBcmcuU2V0IGFsbG93X291dHB1dF9wYXR0ZXJucyxcbiAgICAgICAgXCIgQWxsb3cgb3V0cHV0IHBhdHRlcm5zIGluIHRlc3RzIGV4cGVjdGF0aW9uc1wiO1xuICAgICAgICBcIi1zb3VyY2UtdHJlZS1yb290XCIsIEFyZy5TdHJpbmcgKGZ1biBzIC0+IHNvdXJjZV90cmVlX3Jvb3QgOj0gU29tZSBzKSxcbiAgICAgICAgXCIgUGF0aCB0byB0aGUgcm9vdCBvZiB0aGUgc291cmNlIHRyZWVcIlxuICAgICAgXSkgKGZ1biBhbm9uIC0+XG4gICAgICAgIFByaW50Zi5lcHJpbnRmIFwiJXM6IHVuZXhwZWN0ZWQgYW5vbnltb3VzIGFyZ3VtZW50ICVzXFxuJSFcIiBuYW1lIGFub247XG4gICAgICAgIGV4aXQgMVxuICAgICAgKSAoUHJpbnRmLnNwcmludGYgXCIlcyAlcyAlcyBbYXJnc11cIiBuYW1lIFwiaW5saW5lLXRlc3QtcnVubmVyXCIgbGliKTtcbiAgICAgIEFjdGlvbi5zZXQgKFxuICAgICAgICBgVGVzdF9tb2RlXG4gICAgICAgICAgeyB3aGljaF90ZXN0cyA9XG4gICAgICAgICAgICAgIHsgbGlibmFtZSA9IGxpYlxuICAgICAgICAgICAgICA7IG9ubHlfdGVzdF9sb2NhdGlvbiA9ICF0ZXN0cztcbiAgICAgICAgICAgICAgICB3aGljaF90YWdzID0gIXRhZ19wcmVkaWNhdGU7XG4gICAgICAgICAgICAgICAgbmFtZV9maWx0ZXIgPSAhbmFtZV9maWx0ZXJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIDsgd2hhdF90b19kbyA9XG4gICAgICAgICAgICAgIGlmICFsaXN0X3BhcnRpdGlvbnNcbiAgICAgICAgICAgICAgdGhlbiBgTGlzdF9wYXJ0aXRpb25zXG4gICAgICAgICAgICAgIGVsc2UgYFJ1bl9wYXJ0aXRpb24gIXBhcnRpdGlvblxuICAgICAgICAgIH0pXG4gICAgZW5kXG4gIHwgXyAtPlxuICAgICgpXG5cbmxldCBhbV90ZXN0X3J1bm5lciA9XG4gIG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICB8IGBUZXN0X21vZGUgXyAtPiB0cnVlXG4gIHwgYElnbm9yZSAtPiBmYWxzZVxuXG5sZXQgYW1fcnVubmluZ19pbmxpbmVfdGVzdF9lbnZfdmFyID1cbiAgKCogZm9yIGFwcHJveGltYXRlIGNvbXBhdGliaWxpdHksIGdpdmVuIHRoYXQgdGhlIHZhcmlhYmxlIGlzIG5vdCBleGFjdGx5IGVxdWl2YWxlbnRcbiAgICAgdG8gd2hhdCBQUFhfSU5MSU5FX1RFU1RfTElCX0FNX1JVTk5JTkdfSU5MSU5FX1RFU1QgdXNlZCB0byBiZSAqKVxuICBcIlRFU1RJTkdfRlJBTUVXT1JLXCJcblxuKCogVGhpcyB2YWx1ZSBpcyBkZXByZWNhdGVkIGluIHByaW5jaXBsZSwgaW4gZmF2b3Igb2YgQ29yZS5hbV9ydW5uaW5nX3Rlc3QsIHNvXG4gICB3ZSdyZSBnb2luZyB0byBsaXZlIHdpdGggdGhlIHVnbHkgcGF0dGVybiBtYXRjaC4gKilcbmxldCBhbV9ydW5uaW5nX2lubGluZV90ZXN0ID1cbiAgbWF0Y2ggU3lzLmdldGVudiBcIlBQWF9JTkxJTkVfVEVTVF9MSUJfQU1fUlVOTklOR19JTkxJTkVfVEVTVFwiIHdpdGhcbiAgfCAoXyA6IHN0cmluZykgLT4gdHJ1ZSAoKiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHBlb3BsZSBzZXR0aW5nIHRoaXMgdmFyaWFibGUgZGlyZWN0bHkgKilcbiAgfCBleGNlcHRpb24gTm90X2ZvdW5kIC0+XG4gICAgbWF0Y2ggU3lzLmdldGVudiBhbV9ydW5uaW5nX2lubGluZV90ZXN0X2Vudl92YXIgd2l0aFxuICAgIHwgXCJpbmxpbmUtdGVzdFwiIC0+IHRydWVcbiAgICB8IGV4Y2VwdGlvbiBOb3RfZm91bmQgLT4gZmFsc2VcbiAgICB8IF8gLT4gZmFsc2VcblxubGV0IHRlc3RpbmcgPVxuICBpZiBhbV90ZXN0X3J1bm5lclxuICB0aGVuIGBUZXN0aW5nIGBBbV90ZXN0X3J1bm5lclxuICBlbHNlXG4gICAgKGlmIGFtX3J1bm5pbmdfaW5saW5lX3Rlc3RcbiAgICAgdGhlbiBgVGVzdGluZyBgQW1fY2hpbGRfb2ZfdGVzdF9ydW5uZXJcbiAgICAgZWxzZSBgTm90X3Rlc3RpbmcpXG5cbmxldCB3YWxsX3RpbWVfY2xvY2tfbnMgKCkgPVxuICBUaW1lX25vdy5uYW5vc2Vjb25kc19zaW5jZV91bml4X2Vwb2NoICgpXG5cblxubGV0IHdoZXJlX3RvX2N1dF9iYWNrdHJhY2UgPSBsYXp5IChcbiAgQmFzZS5TdHJpbmcuU2VhcmNoX3BhdHRlcm4uY3JlYXRlIChfX01PRFVMRV9fIF4gXCIuXCIgXiBcInRpbWVfd2l0aG91dF9yZXNldHRpbmdfcmFuZG9tX3NlZWRzXCIpKVxuXG5sZXQgdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHMgZiA9XG4gIGxldCBiZWZvcmVfbnMgPSB3YWxsX3RpbWVfY2xvY2tfbnMgKCkgaW5cbiAgbGV0IHJlcyA9XG4gICAgKCogVG8gYXZvaWQgbm9pc2UgaW4gYmFja3RyYWNlcywgd2UgZG8gdHdvIHRoaW5ncy5cblxuICAgICAgIFdlIHVzZSBbd2hlcmVfdG9fY3V0X2JhY2t0cmFjZV0gYWJvdmUgdG8gcmVtb3ZlIHRoZSBzdGFjayBmcmFtZXMgZm9yIHRoZSBjdXJyZW50XG4gICAgICAgZnVuY3Rpb24gYW5kIGFueSBmdW5jdGlvbiBpdCBnZXRzIGlubGluZWQgaW50bywgYXMgaXQncyBub3Qgb2YgYW55IGludGVyZXN0IHRvIHRoZVxuICAgICAgIHVzZXIsIHNpbmNlIGl0J3Mgbm90IHRhbGtpbmcgYWJvdXQgdGhlaXIgdGVzdCBidXQgaW5zdGVhZCB0YWxraW5nIGFib3V0IHRoZVxuICAgICAgIHBweF9pbmxpbmVfdGVzdCBtYWNoaW5lcnkuXG5cbiAgICAgICBXZSBhbHNvIGF2b2lkIGluc2VydGluZyBhbnkgY29kZSBiZXR3ZWVuIHRoZSBbZl0gdGhhdCBjb21lcyBmcm9tIHRoZSB1c2VyJ3MgZmlsZVxuICAgICAgIGFuZCBncmFiYmluZyB0aGUgYmFja3RyYWNlIGZyb20gaXRzIGV4Y2VwdGlvbnMgKG5vIHdyYXBwaW5nIG9mIFtmXSB3aXRoIGhpZ2ggb3JkZXJcbiAgICAgICBmdW5jdGlvbnMgbGlrZSBFeG4ucHJvdGVjdCwgb3IgKGZ1biAoKSAtPiBmICgpOyB0cnVlKSkuICopXG4gICAgdHJ5IE9rIChmICgpKVxuICAgIHdpdGggZXhuIC0+IEVycm9yIChleG4sIFByaW50ZXhjLmdldF9iYWNrdHJhY2UgKCkpXG4gIGluXG4gIHRpbWVfc2VjIDo9IEJhc2UuSW50NjMuKHdhbGxfdGltZV9jbG9ja19ucyAoKSAtIGJlZm9yZV9ucyB8PiB0b19mbG9hdCkgIC8uIDFlOTtcbiAgcmVzXG5cblxubGV0IHNhdmVkX2NhbWxfcmFuZG9tX3N0YXRlID0gbGF6eSAoU3RkbGliLlJhbmRvbS5TdGF0ZS5tYWtlIFt8IDEwMDsgMjAwOyAzMDAgfF0pXG5sZXQgc2F2ZWRfYmFzZV9yYW5kb21fc3RhdGUgPSBsYXp5IChCYXNlLlJhbmRvbS5TdGF0ZS5tYWtlIFt8IDExMTsgMjIyOyAzMzMgfF0pXG5cbmxldCB0aW1lX2FuZF9yZXNldF9yYW5kb21fc2VlZHMgZiA9XG4gIGxldCBjYW1sX3JhbmRvbV9zdGF0ZSA9IFN0ZGxpYi5SYW5kb20uZ2V0X3N0YXRlICgpIGluXG4gIGxldCBiYXNlX3JhbmRvbV9zdGF0ZSA9IEJhc2UuUmFuZG9tLlN0YXRlLmNvcHkgQmFzZS5SYW5kb20uU3RhdGUuZGVmYXVsdCBpblxuICBTdGRsaWIuUmFuZG9tLnNldF9zdGF0ZSAoTGF6eS5mb3JjZSBzYXZlZF9jYW1sX3JhbmRvbV9zdGF0ZSk7XG4gIEJhc2UuUmFuZG9tLnNldF9zdGF0ZSAoTGF6eS5mb3JjZSBzYXZlZF9iYXNlX3JhbmRvbV9zdGF0ZSk7XG4gIGxldCByZXN1bHQgPSB0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkcyBmIGluXG4gIFN0ZGxpYi5SYW5kb20uc2V0X3N0YXRlIGNhbWxfcmFuZG9tX3N0YXRlO1xuICBCYXNlLlJhbmRvbS5zZXRfc3RhdGUgYmFzZV9yYW5kb21fc3RhdGU7XG4gIHJlc3VsdFxuXG5sZXQgc3RyaW5nX29mX21vZHVsZV9kZXNjciAoKSA9XG4gIFN0cmluZy5jb25jYXQgXCJcIiAoXG4gICAgTGlzdC5tYXAgKGZ1biBzIC0+IFwiICBpbiBURVNcIiBeIFwiVF9NT0RVTEUgYXQgXCIgXiBTdHJpbmcudW5jYXBpdGFsaXplX2FzY2lpIHMgXiBcIlxcblwiKVxuICAgICAgKE1vZHVsZV9jb250ZXh0LmN1cnJlbnRfZGVzY3IgKCkpXG4gIClcblxubGV0IHBvc2l0aW9uX21hdGNoIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgbCA9XG4gIExpc3QuZXhpc3RzIChmdW4gKGZpbGVuYW1lLCBsaW5lX251bWJlcl9vcHQsIHVzZWQpIC0+XG4gICAgbGV0IHBvc2l0aW9uX3N0YXJ0ID1cbiAgICAgIFN0cmluZy5sZW5ndGggZGVmX2ZpbGVuYW1lIC0gU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSBpblxuICAgIGxldCBmb3VuZCA9XG4gICAgICBwb3NpdGlvbl9zdGFydCA+PSAwICYmXG4gICAgICBsZXQgZW5kX29mX2RlZl9maWxlbmFtZSA9XG4gICAgICAgIFN0cmluZy5zdWIgZGVmX2ZpbGVuYW1lXG4gICAgICAgICAgcG9zaXRpb25fc3RhcnRcbiAgICAgICAgICAoU3RyaW5nLmxlbmd0aCBmaWxlbmFtZSkgaW5cbiAgICAgIGVuZF9vZl9kZWZfZmlsZW5hbWUgPSBmaWxlbmFtZVxuICAgICAgJiYgKHBvc2l0aW9uX3N0YXJ0ID0gMCB8fCBkZWZfZmlsZW5hbWUuW3Bvc2l0aW9uX3N0YXJ0IC0gMV0gPSAnLycpXG4gICAgICAmJiAobWF0Y2ggbGluZV9udW1iZXJfb3B0IHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICAgfCBTb21lIGxpbmVfbnVtYmVyIC0+IGRlZl9saW5lX251bWJlciA9IGxpbmVfbnVtYmVyKVxuICAgIGluXG4gICAgaWYgZm91bmQgdGhlbiB1c2VkIDo9IHRydWU7XG4gICAgZm91bmRcbiAgKSBsXG5cbmxldCBuYW1lX2ZpbHRlcl9tYXRjaCB+bmFtZV9maWx0ZXIgZGVzY3IgPVxuICBtYXRjaCBuYW1lX2ZpbHRlciB3aXRoXG4gIHwgW10gLT4gdHJ1ZVxuICB8IF8gOjogXyAtPlxuICAgIExpc3QuZXhpc3RzIChmdW4gc3Vic3RyaW5nIC0+IEJhc2UuU3RyaW5nLmlzX3N1YnN0cmluZyB+c3Vic3RyaW5nIGRlc2NyKSBuYW1lX2ZpbHRlclxuXG5sZXQgcHJpbnRfZGVsYXllZF9lcnJvcnMgKCkgPVxuICBtYXRjaCBMaXN0LnJldiAhZGVsYXllZF9lcnJvcnMgd2l0aFxuICB8IFtdIC0+ICgpXG4gIHwgXyA6OiBfIGFzIGRlbGF5ZWRfZXJyb3JzIC0+XG4gICAgUHJpbnRmLmVwcmludGYgXCJcXG4lc1xcbiUhXCIgKFN0cmluZy5tYWtlIDcwICc9Jyk7XG4gICAgTGlzdC5pdGVyIChmdW4gbWVzc2FnZSAtPlxuICAgICAgUHJpbnRmLmVwcmludGYgXCIlcyUhXCIgbWVzc2FnZVxuICAgICkgZGVsYXllZF9lcnJvcnNcblxubGV0IGVwcmludGZfb3JfZGVsYXkgZm10ID1cbiAgUHJpbnRmLmtzcHJpbnRmIChmdW4gcyAtPlxuICAgIGlmICF2ZXJib3NlIHRoZW4gZGVsYXllZF9lcnJvcnMgOj0gcyA6OiAhZGVsYXllZF9lcnJvcnNcbiAgICBlbHNlIFByaW50Zi5lcHJpbnRmIFwiJXMlIVwiIHM7XG4gICAgaWYgIXN0b3Bfb25fZXJyb3IgdGhlbiBiZWdpblxuICAgICAgcHJpbnRfZGVsYXllZF9lcnJvcnMgKCk7XG4gICAgICBleGl0IDJcbiAgICBlbmRcbiAgKSBmbXRcblxubGV0IGFkZF9ob29rcyAoKG1vZHVsZSBDKSA6IGNvbmZpZykgZiA9XG4gIGZ1biAoKSAtPiBDLnByZV90ZXN0X2hvb2sgKCk7IGYgKClcblxubGV0IGh1bV9iYWNrdHJhY2UgYmFja3RyYWNlID1cbiAgbGV0IG9wZW4gQmFzZSBpblxuICBiYWNrdHJhY2VcbiAgfD4gU3RyaW5nLnNwbGl0X2xpbmVzXG4gIHw+IExpc3QudGFrZV93aGlsZSB+ZjooZnVuIHN0ciAtPlxuICAgIG5vdCAoU3RyaW5nLlNlYXJjaF9wYXR0ZXJuLm1hdGNoZXMgKGZvcmNlIHdoZXJlX3RvX2N1dF9iYWNrdHJhY2UpIHN0cikpXG4gIHw+IExpc3QubWFwIH5mOihmdW4gc3RyIC0+IFwiICBcIiBeIHN0ciBeIFwiXFxuXCIpXG4gIHw+IFN0cmluZy5jb25jYXRcblxubGV0W0BpbmxpbmUgbmV2ZXJdIHRlc3RfaW5uZXIgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lOmRlZl9maWxlbmFtZSB+bGluZV9udW1iZXI6ZGVmX2xpbmVfbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICB+c3RhcnRfcG9zIH5lbmRfcG9zIGYgYm9vbF9vZl9mID1cbiAgbWF0Y2ggQWN0aW9uLmdldCAoKSB3aXRoXG4gIHwgYElnbm9yZSAtPiAoKVxuICB8IGBUZXN0X21vZGUgeyB3aGljaF90ZXN0cyA9IHsgbGlibmFtZTsgb25seV90ZXN0X2xvY2F0aW9uOyB3aGljaF90YWdzOyBuYW1lX2ZpbHRlciB9OyB3aGF0X3RvX2RvIH0gLT5cbiAgICBsZXQgZiA9IGFkZF9ob29rcyBjb25maWcgZiBpblxuICAgIGxldCBkZXNjciA9IGxhenkgKGRpc3BsYXllZF9kZXNjciBkZXNjciBkZWZfZmlsZW5hbWUgZGVmX2xpbmVfbnVtYmVyIHN0YXJ0X3BvcyBlbmRfcG9zKSBpblxuICAgIGxldCBjb21wbGV0ZV90YWdzID0gdGFncyBAIE1vZHVsZV9jb250ZXh0LmN1cnJlbnRfdGFncyAoKSBpblxuICAgIGxldCBzaG91bGRfcnVuID1cbiAgICAgIFNvbWUgbGlibmFtZSA9ICFkeW5hbWljX2xpYlxuICAgICAgJiYgYmVnaW4gbWF0Y2ggb25seV90ZXN0X2xvY2F0aW9uIHdpdGhcbiAgICAgICAgfCBbXSAtPiB0cnVlXG4gICAgICAgIHwgXyA6OiBfIC0+IHBvc2l0aW9uX21hdGNoIGRlZl9maWxlbmFtZSBkZWZfbGluZV9udW1iZXIgb25seV90ZXN0X2xvY2F0aW9uXG4gICAgICBlbmRcbiAgICAgICYmIG5vdCAoVGFnX3ByZWRpY2F0ZS5kaXNhYmxlZCB3aGljaF90YWdzIH5jb21wbGV0ZV90YWdzKVxuICAgICAgJiYgbmFtZV9maWx0ZXJfbWF0Y2ggfm5hbWVfZmlsdGVyIChMYXp5LmZvcmNlIGRlc2NyKVxuICAgIGluXG4gICAgaWYgc2hvdWxkX3J1biB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCB3aGF0X3RvX2RvIHdpdGhcbiAgICAgIHwgYExpc3RfcGFydGl0aW9ucyAtPiBQYXJ0aXRpb24uZm91bmRfdGVzdCAoKVxuICAgICAgfCBgUnVuX3BhcnRpdGlvbiBwYXJ0aXRpb24gLT5cbiAgICAgICAgaWYgUGFydGl0aW9uLmlzX2N1cnJlbnQgcGFydGl0aW9uIHRoZW4gYmVnaW5cbiAgICAgICAgICBsZXQgZGVzY3IgPSBMYXp5LmZvcmNlIGRlc2NyIGluXG4gICAgICAgICAgaW5jciB0ZXN0c19yYW47XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggIWxvZyB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+ICgpXG4gICAgICAgICAgfCBTb21lIGNoIC0+IFByaW50Zi5mcHJpbnRmIGNoIFwiJXNcXG4lc1wiIGRlc2NyIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKVxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBpZiAhdmVyYm9zZSB0aGVuIGJlZ2luXG4gICAgICAgICAgICBQcmludGYucHJpbnRmIFwiJXMlIVwiIGRlc2NyXG4gICAgICAgICAgZW5kO1xuICAgICAgICAgIGxldCByZXN1bHQgPVxuICAgICAgICAgICAgaWYgIWxpc3RfdGVzdF9uYW1lc1xuICAgICAgICAgICAgdGhlbiBPayB0cnVlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICgqIFNlZSBbdGltZV93aXRob3V0X3Jlc2V0dGluZ19yYW5kb21fc2VlZHNdIGZvciB3aHkgd2UgdXNlIFtib29sX29mX2ZdXG4gICAgICAgICAgICAgICAgIHJhdGhlciBoYXZlIHRoZSBjYWxsZXIgd3JhcCBbZl0gdG8gYWRqdXN0IGl0cyByZXR1cm4gdmFsdWUuICopXG4gICAgICAgICAgICAgIFJlc3VsdC5tYXAgYm9vbF9vZl9mICh0aW1lX2FuZF9yZXNldF9yYW5kb21fc2VlZHMgZilcbiAgICAgICAgICBpblxuICAgICAgICAgICgqIElmICFsaXN0X3Rlc3RfbmFtZXMsIHRoaXMgaXMgaXMgYSBoYXJtbGVzcyB6ZXJvLiAqKVxuICAgICAgICAgIGlmICF2ZXJib3NlIHRoZW4gUHJpbnRmLnByaW50ZiBcIiAoJS4zZiBzZWMpXFxuJSFcIiAhdGltZV9zZWM7XG4gICAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgICB8IE9rIHRydWUgLT4gKClcbiAgICAgICAgICB8IE9rIGZhbHNlIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RzX2ZhaWxlZDtcbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXkgXCIlcyBpcyBmYWxzZS5cXG4lc1xcbiUhXCIgZGVzY3JcbiAgICAgICAgICAgICAgKHN0cmluZ19vZl9tb2R1bGVfZGVzY3IgKCkpXG4gICAgICAgICAgfCBFcnJvciAoZXhuLCBiYWNrdHJhY2UpIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RzX2ZhaWxlZDtcbiAgICAgICAgICAgIGxldCBiYWNrdHJhY2UgPSBodW1fYmFja3RyYWNlIGJhY2t0cmFjZSBpblxuICAgICAgICAgICAgbGV0IGV4bl9zdHIgPSBTZXhwbGliMC5TZXhwX2NvbnYucHJpbnRleGNfcHJlZmVyX3NleHAgZXhuIGluXG4gICAgICAgICAgICBsZXQgc2VwID0gaWYgU3RyaW5nLmNvbnRhaW5zIGV4bl9zdHIgJ1xcbicgdGhlbiBcIlxcblwiIGVsc2UgXCIgXCIgaW5cbiAgICAgICAgICAgIGVwcmludGZfb3JfZGVsYXkgXCIlcyB0aHJldyVzJXMuXFxuJXMlc1xcbiUhXCIgZGVzY3Igc2VwIGV4bl9zdHJcbiAgICAgICAgICAgICAgYmFja3RyYWNlIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKVxuICAgICAgICBlbmRcbiAgICBlbmRcblxubGV0IHNldF9saWJfYW5kX3BhcnRpdGlvbiBzdGF0aWNfbGliIHBhcnRpdGlvbiA9XG4gIG1hdGNoICFkeW5hbWljX2xpYiB3aXRoXG4gIHwgU29tZSBfIC0+XG4gICAgKCogcG9zc2libGUgaWYgdGhlIGludGVyZmFjZSBpcyB1c2VkIGV4cGxpY2l0bHkgb3IgaWYgd2UgaGFwcGVuIHRvIGR5bmxpbmsgc29tZXRoaW5nXG4gICAgICAgdGhhdCBjb250YWluIHRlc3RzICopXG4gICAgKClcbiAgfCBOb25lIC0+XG4gICAgZHluYW1pY19saWIgOj0gU29tZSBzdGF0aWNfbGliO1xuICAgIG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICAgIHwgYElnbm9yZSAtPiAoKVxuICAgIHwgYFRlc3RfbW9kZSB7IHdoaWNoX3Rlc3RzOyB3aGF0X3RvX2RvIH0gLT5cbiAgICAgIGlmIHdoaWNoX3Rlc3RzLmxpYm5hbWUgPSBzdGF0aWNfbGliIHRoZW4gYmVnaW5cbiAgICAgICAgbGV0IHJlcXVpcmVzX3BhcnRpdGlvbiA9XG4gICAgICAgICAgbWF0Y2ggd2hhdF90b19kbyB3aXRoXG4gICAgICAgICAgfCBgTGlzdF9wYXJ0aXRpb25zIHwgYFJ1bl9wYXJ0aXRpb24gKFNvbWUgXykgLT4gdHJ1ZVxuICAgICAgICAgIHwgYFJ1bl9wYXJ0aXRpb24gTm9uZSAtPiBmYWxzZVxuICAgICAgICBpblxuICAgICAgICBpZiBwYXJ0aXRpb24gPSBcIlwiICYmIHJlcXVpcmVzX3BhcnRpdGlvblxuICAgICAgICB0aGVuIGZhaWx3aXRoIFwicHB4X2lubGluZV90ZXN0OiBjYW5ub3QgdXNlIC1saXN0LXBhcnRpdGlvbiBvciAtcGFydGl0aW9uIFxcXG4gICAgICAgICAgICAgICAgICAgICAgIHdpdGhvdXQgc3BlY2lmeWluZyBhIHBhcnRpdGlvbiBhdCBwcmVwcm9jZXNzaW5nIHRpbWVcIlxuICAgICAgICBlbHNlIFBhcnRpdGlvbi5zZXRfY3VycmVudCBwYXJ0aXRpb25cbiAgICAgIGVuZFxuXG5sZXQgdW5zZXRfbGliIHN0YXRpY19saWIgPVxuICBtYXRjaCAhZHluYW1pY19saWIgd2l0aFxuICB8IE5vbmUgLT5cbiAgICAoKiBub3QgZ2l2aW5nIGFuIGVycm9yLCBiZWNhdXNlIHdoZW4gc29tZSBhbm5veWluZyBwZW9wbGUgcHV0IHBhX291bml0IGluIHRoZWlyIGxpc3RcbiAgICAgICBvZiBwcmVwcm9jZXNzb3JzLCBwYV9vdW5pdCBpcyBzZXQgdXAgdHdpY2UgYW5kIHdlIGhhdmUgdHdvIGNhbGxzIHRvIHVuc2V0X2xpYiBhdFxuICAgICAgIHRoZSBlbmQgb2YgdGhlIGZpbGUsIGFuZCB0aGUgc2Vjb25kIG9uZSBjb21lcyBpbiB0aGlzIGJyYW5jaCAqKVxuICAgICgpXG4gIHwgU29tZSBsaWIgLT5cbiAgICBpZiBsaWIgPSBzdGF0aWNfbGliIHRoZW4gZHluYW1pY19saWIgOj0gTm9uZVxuXG5sZXQgdGVzdCB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3MgZiA9XG4gIHRlc3RfaW5uZXIgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lIH5saW5lX251bWJlciB+c3RhcnRfcG9zIH5lbmRfcG9zXG4gICAgZiAoZnVuIGIgLT4gYilcblxubGV0IHRlc3RfdW5pdCB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWUgfmxpbmVfbnVtYmVyIH5zdGFydF9wb3MgfmVuZF9wb3MgZiA9XG4gIHRlc3RfaW5uZXIgfmNvbmZpZyB+ZGVzY3IgfnRhZ3MgfmZpbGVuYW1lIH5saW5lX251bWJlciB+c3RhcnRfcG9zIH5lbmRfcG9zXG4gICAgZiAoZnVuICgpIC0+IHRydWUpXG5cbmxldFtAaW5saW5lIG5ldmVyXSB0ZXN0X21vZHVsZSB+Y29uZmlnIH5kZXNjciB+dGFncyB+ZmlsZW5hbWU6ZGVmX2ZpbGVuYW1lIH5saW5lX251bWJlcjpkZWZfbGluZV9udW1iZXJcbiAgICAgICAgICAgICAgICAgICAgIH5zdGFydF9wb3MgfmVuZF9wb3MgZiA9XG4gIG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICB8IGBJZ25vcmUgLT4gKClcbiAgfCBgVGVzdF9tb2RlIHsgd2hpY2hfdGVzdHMgPSB7IGxpYm5hbWU7IG9ubHlfdGVzdF9sb2NhdGlvbiA9IF87IG5hbWVfZmlsdGVyID0gXzsgd2hpY2hfdGFncyB9OyB3aGF0X3RvX2RvIH0gLT5cbiAgICBsZXQgZiA9IGFkZF9ob29rcyBjb25maWcgZiBpblxuICAgIGxldCBkZXNjciAoKSA9IGRpc3BsYXllZF9kZXNjciBkZXNjciBkZWZfZmlsZW5hbWUgZGVmX2xpbmVfbnVtYmVyIHN0YXJ0X3BvcyBlbmRfcG9zIGluXG4gICAgbGV0IHBhcnRpYWxfdGFncyA9IHRhZ3MgQCBNb2R1bGVfY29udGV4dC5jdXJyZW50X3RhZ3MgKCkgaW5cbiAgICBsZXQgc2hvdWxkX3J1biA9XG4gICAgICBTb21lIGxpYm5hbWUgPSAhZHluYW1pY19saWJcbiAgICAgICgqIElmLCBubyBtYXR0ZXIgd2hhdCB0YWdzIGEgdGVzdCBkZWZpbmVzLCB3ZSBjZXJ0YWlubHkgd2lsbCBkcm9wIGFsbCB0ZXN0cyB3aXRoaW5cbiAgICAgICAgIHRoaXMgbW9kdWxlLCB0aGVuIGRvbid0IHJ1biB0aGUgbW9kdWxlIGF0IGFsbC4gVGhpcyBtZWFucyBwZW9wbGUgY2FuIHdyaXRlXG4gICAgICAgICB0aGluZ3MgbGlrZSB0aGUgZm9sbG93aW5nIHdpdGhvdXQgYnJlYWtpbmcgdGhlIDMyLWJpdCBidWlsZDpcbiAgICAgICAgIGxldCV0ZXN0X21vZHVsZSBbQHRhZ3MgXCI2NC1iaXRzLW9ubHlcIl0gPSAobW9kdWxlIHN0cnVjdFxuICAgICAgICAgbGV0IGkgPSBJbnQ2NC50b19pbnRfZXhuIC4uLi5cbiAgICAgICAgIGVuZClcbiAgICAgICAgIFdlIGRvbid0IHNob3J0Y3V0IGJhc2VkIG9uIHBvc2l0aW9uLCBhcyB3ZSBjYW4ndCB0ZWxsIHdoYXQgcG9zaXRpb25zIHRoZVxuICAgICAgICAgaW5uZXIgdGVzdHMgd2lsbCBoYXZlLiAqKVxuICAgICAgJiYgbm90IChUYWdfcHJlZGljYXRlLmVudGlyZV9tb2R1bGVfZGlzYWJsZWQgd2hpY2hfdGFncyB+cGFydGlhbF90YWdzKVxuICAgIGluXG4gICAgaWYgc2hvdWxkX3J1biB0aGVuIGJlZ2luXG4gICAgICBtYXRjaCB3aGF0X3RvX2RvIHdpdGhcbiAgICAgIHwgYExpc3RfcGFydGl0aW9ucyAtPiBQYXJ0aXRpb24uZm91bmRfdGVzdCAoKVxuICAgICAgfCBgUnVuX3BhcnRpdGlvbiBwYXJ0aXRpb24gLT5cbiAgICAgICAgaWYgUGFydGl0aW9uLmlzX2N1cnJlbnQgcGFydGl0aW9uIHRoZW4gYmVnaW5cbiAgICAgICAgICBpbmNyIHRlc3RfbW9kdWxlc19yYW47XG4gICAgICAgICAgbGV0IGRlc2NyID0gZGVzY3IgKCkgaW5cbiAgICAgICAgICBtYXRjaFxuICAgICAgICAgICAgTW9kdWxlX2NvbnRleHQud2l0aF8gfmRlc2NyIH50YWdzIChmdW4gKCkgLT5cbiAgICAgICAgICAgICAgKCogV2UgZG8gbm90IHJlc2V0IHJhbmRvbSBzdGF0ZXMgdXBvbiBlbnRlcmluZyBbbGV0JXRlc3RfbW9kdWxlXS5cblxuICAgICAgICAgICAgICAgICBDb246IENvZGUgaW4gdGVzdCBtb2R1bGVzIGNhbiBhY2NpZGVudGFsbHkgZGVwZW5kIG9uIHRvcC1sZXZlbCByYW5kb21cbiAgICAgICAgICAgICAgICAgc3RhdGUgZWZmZWN0cy5cblxuICAgICAgICAgICAgICAgICBQcm9zOiAoMSkgV2UgZG9uJ3QgcmVzZXQgdG8gdGhlIHNhbWUgc2VlZCBvbiBlbnRlcmluZyBhIFtsZXQldGVzdF9tb2R1bGVdXG4gICAgICAgICAgICAgICAgIGFuZCB0aGVuIGEgW2xldCV0ZXN0XSBpbnNpZGUgdGhhdCBtb2R1bGUsIHdoaWNoIGNvdWxkIGxlYWQgdG9cbiAgICAgICAgICAgICAgICAgYWNjaWRlbnRhbGx5IHJhbmRvbWx5IGdlbmVyYXRpbmcgdGhlIHNhbWUgdmFsdWVzIGluIHNvbWUgdGVzdC4gKDIpIE1vdmluZ1xuICAgICAgICAgICAgICAgICBjb2RlIGludG8gYW5kIG91dCBvZiBbbGV0JXRlc3RfbW9kdWxlXSBkb2VzIG5vdCBjaGFuZ2UgaXRzIHJhbmRvbSBzZWVkLlxuICAgICAgICAgICAgICAqKVxuICAgICAgICAgICAgICB0aW1lX3dpdGhvdXRfcmVzZXR0aW5nX3JhbmRvbV9zZWVkcyBmKVxuICAgICAgICAgIHdpdGhcbiAgICAgICAgICB8IE9rICgpIC0+ICgpXG4gICAgICAgICAgfCBFcnJvciAoZXhuLCBiYWNrdHJhY2UpIC0+XG4gICAgICAgICAgICBpbmNyIHRlc3RfbW9kdWxlc19mYWlsZWQ7XG4gICAgICAgICAgICBsZXQgYmFja3RyYWNlID0gaHVtX2JhY2t0cmFjZSBiYWNrdHJhY2UgaW5cbiAgICAgICAgICAgIGxldCBleG5fc3RyID0gU2V4cGxpYjAuU2V4cF9jb252LnByaW50ZXhjX3ByZWZlcl9zZXhwIGV4biBpblxuICAgICAgICAgICAgbGV0IHNlcCA9IGlmIFN0cmluZy5jb250YWlucyBleG5fc3RyICdcXG4nIHRoZW4gXCJcXG5cIiBlbHNlIFwiIFwiIGluXG4gICAgICAgICAgICBlcHJpbnRmX29yX2RlbGF5IChcIlRFU1wiIF5eIFwiVF9NT0RVTEUgYXQgJXMgdGhyZXclcyVzLlxcbiVzJXNcXG4lIVwiKVxuICAgICAgICAgICAgICAoU3RyaW5nLnVuY2FwaXRhbGl6ZV9hc2NpaSBkZXNjcikgc2VwIGV4bl9zdHIgYmFja3RyYWNlIChzdHJpbmdfb2ZfbW9kdWxlX2Rlc2NyICgpKVxuICAgICAgICBlbmRcbiAgICBlbmRcblxubGV0IHN1bW1hcml6ZSAoKSA9XG4gIG1hdGNoIEFjdGlvbi5nZXQgKCkgd2l0aFxuICB8IGBJZ25vcmUgLT5cbiAgICBpZiBTeXMuYXJndiA8PiBbfHxdICYmIEZpbGVuYW1lLmJhc2VuYW1lIFN5cy5hcmd2LigwKSA9IFwiaW5saW5lX3Rlc3RzX3J1bm5lci5leGVcIiB0aGVuXG4gICAgICBQcmludGYuZXByaW50ZiBcImlubGluZV90ZXN0c19ydW5uZXIuZXhlIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBydW4gYnkgaGFuZCwgeW91IFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIHJ1biB0aGUgaW5saW5lX3Rlc3RzX3J1bm5lciBzY3JpcHQgaW5zdGVhZC5cXG4lIVwiXG4gICAgZWxzZVxuICAgICAgUHJpbnRmLmVwcmludGYgXCJZb3UgYXJlIGRvaW5nIHNvbWV0aGluZyB1bmV4cGVjdGVkIHdpdGggdGhlIHRlc3RzLiBObyB0ZXN0cyBoYXZlIFxcblxcXG4gICAgICAgICAgICAgICAgICAgICAgYmVlbiBydW4uIFlvdSBzaG91bGQgdXNlIHRoZSBpbmxpbmVfdGVzdHNfcnVubmVyIHNjcmlwdCB0byBydW4gXFxuXFxcbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0cy5cXG4lIVwiO1xuICAgIFRlc3RfcmVzdWx0LkVycm9yXG4gIHwgYFRlc3RfbW9kZSB7IHdoaWNoX3Rlc3RzID0gXzsgd2hhdF90b19kbyA9IGBMaXN0X3BhcnRpdGlvbnMgfSAtPlxuICAgIExpc3QuaXRlciAoUHJpbnRmLnByaW50ZiBcIiVzXFxuXCIpIChQYXJ0aXRpb24uYWxsICgpKTtcbiAgICBUZXN0X3Jlc3VsdC5TdWNjZXNzXG4gIHwgYFRlc3RfbW9kZSB7IHdoYXRfdG9fZG8gPSBgUnVuX3BhcnRpdGlvbiBfOyB3aGljaF90ZXN0cyB9IC0+IGJlZ2luXG4gICAgICBiZWdpbiBtYXRjaCAhbG9nIHdpdGhcbiAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgfCBTb21lIGNoIC0+IGNsb3NlX291dCBjaFxuICAgICAgZW5kO1xuICAgICAgcHJpbnRfZGVsYXllZF9lcnJvcnMgKCk7XG4gICAgICBtYXRjaCAhdGVzdHNfZmFpbGVkLCAhdGVzdF9tb2R1bGVzX2ZhaWxlZCB3aXRoXG4gICAgICB8IDAsIDAgLT4gYmVnaW5cbiAgICAgICAgICBpZiAhc2hvd19jb3VudHMgdGhlbiBiZWdpblxuICAgICAgICAgICAgUHJpbnRmLmVwcmludGYgXCIlZCB0ZXN0cyByYW4sICVkIHRlc3RfbW9kdWxlcyByYW5cXG4lIVwiICF0ZXN0c19yYW4gIXRlc3RfbW9kdWxlc19yYW5cbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgbGV0IGVycm9ycyA9XG4gICAgICAgICAgICBsZXQgdW51c2VkX3Rlc3RzID1cbiAgICAgICAgICAgICAgTGlzdC5maWx0ZXIgKGZ1biAoXywgXywgdXNlZCkgLT4gbm90ICF1c2VkKSB3aGljaF90ZXN0cy5vbmx5X3Rlc3RfbG9jYXRpb25cbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBtYXRjaCB1bnVzZWRfdGVzdHMgd2l0aFxuICAgICAgICAgICAgfCBbXSAtPiBOb25lXG4gICAgICAgICAgICB8IF8gOjogXyAtPiBTb21lIHVudXNlZF90ZXN0c1xuICAgICAgICAgIGluXG4gICAgICAgICAgbWF0Y2ggZXJyb3JzIHdpdGhcbiAgICAgICAgICB8IFNvbWUgdGVzdHMgLT5cbiAgICAgICAgICAgIFByaW50Zi5lcHJpbnRmIFwicHB4X2lubGluZV90ZXN0IGVycm9yOiB0aGUgZm9sbG93aW5nIC1vbmx5LXRlc3QgZmxhZ3MgbWF0Y2hlZCBub3RoaW5nOlwiO1xuICAgICAgICAgICAgTGlzdC5pdGVyIChmdW4gKGZpbGVuYW1lLCBsaW5lX251bWJlcl9vcHQsIF8pIC0+XG4gICAgICAgICAgICAgIG1hdGNoIGxpbmVfbnVtYmVyX29wdCB3aXRoXG4gICAgICAgICAgICAgIHwgTm9uZSAtPiBQcmludGYuZXByaW50ZiBcIiAlc1wiIGZpbGVuYW1lXG4gICAgICAgICAgICAgIHwgU29tZSBsaW5lX251bWJlciAtPiBQcmludGYuZXByaW50ZiBcIiAlczolZFwiIGZpbGVuYW1lIGxpbmVfbnVtYmVyXG4gICAgICAgICAgICApIHRlc3RzO1xuICAgICAgICAgICAgUHJpbnRmLmVwcmludGYgXCIuXFxuJSFcIjtcbiAgICAgICAgICAgIFRlc3RfcmVzdWx0LkVycm9yXG4gICAgICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgICBpZiAhdGVzdHNfcmFuID0gMCAmJiAhc3RyaWN0IHRoZW4gYmVnaW5cbiAgICAgICAgICAgICAgUHJpbnRmLmVwcmludGYgXCJwcHhfaW5saW5lX3Rlc3QgZXJyb3I6IG5vIHRlc3RzIGhhdmUgYmVlbiBydW4uXFxuJSFcIjtcbiAgICAgICAgICAgICAgVGVzdF9yZXN1bHQuRXJyb3JcbiAgICAgICAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgICAgICAgIFRlc3RfcmVzdWx0LlN1Y2Nlc3NcbiAgICAgICAgICAgIGVuZFxuICAgICAgICBlbmRcbiAgICAgIHwgY291bnQsIGNvdW50X3Rlc3RfbW9kdWxlcyAtPlxuICAgICAgICBQcmludGYuZXByaW50ZiBcIkZBSUxFRCAlZCAvICVkIHRlc3RzJXNcXG4lIVwiIGNvdW50ICF0ZXN0c19yYW5cbiAgICAgICAgICAoaWYgY291bnRfdGVzdF9tb2R1bGVzID0gMCB0aGVuIFwiXCIgZWxzZSBQcmludGYuc3ByaW50ZiAoXCIsICVkIFRFU1wiIF5eIFwiVF9NT0RVTEVTXCIpIGNvdW50X3Rlc3RfbW9kdWxlcyk7XG4gICAgICAgIFRlc3RfcmVzdWx0LkZhaWx1cmVcbiAgICBlbmRcblxubGV0IHVzZV9jb2xvciA9ICF1c2VfY29sb3JcbmxldCBpbl9wbGFjZSAgPSAhaW5fcGxhY2VcbmxldCBkaWZmX2NvbW1hbmQgPSAhZGlmZl9jb21tYW5kXG5sZXQgc291cmNlX3RyZWVfcm9vdCA9ICFzb3VyY2VfdHJlZV9yb290XG5sZXQgYWxsb3dfb3V0cHV0X3BhdHRlcm5zID0gIWFsbG93X291dHB1dF9wYXR0ZXJuc1xuXG5sZXQgZXZhbHVhdG9ycyA9IHJlZiBbc3VtbWFyaXplXVxubGV0IGFkZF9ldmFsdWF0b3IgfmYgPSBldmFsdWF0b3JzIDo9IGYgOjogIWV2YWx1YXRvcnNcbmxldCBleGl0ICgpID1cbiAgTGlzdC5tYXAgKGZ1biBmIC0+IGYgKCkpIChMaXN0LnJldiAhZXZhbHVhdG9ycylcbiAgfD4gVGVzdF9yZXN1bHQuY29tYmluZV9hbGxcbiAgfD4gVGVzdF9yZXN1bHQudG9fZXhpdF9jb2RlXG4gIHw+IGV4aXRcbiJdfQ==
