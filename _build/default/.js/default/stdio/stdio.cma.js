// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.1.1

//# unitInfo: Provides: Stdio__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Stdio = [0];
   runtime.caml_register_global(0, Stdio, "Stdio__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdio__In_channel
//# unitInfo: Requires: Base, Base__Buffer, Base__Char, Base__Exn, Base__List, Base__String, Caml, Stdlib, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    flags = [0, 0, 0],
    Base_List = global_data.Base__List,
    Caml = global_data.Caml,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Base_Buffer = global_data.Base__Buffer,
    Stdlib = global_data.Stdlib,
    Base_Exn = global_data.Base__Exn,
    Base = global_data.Base;
   function equal(t1, t2){return caml_call2(Base[203], t1, t2);}
   var
    seek = Caml[96][4],
    pos = Caml[96][5],
    length = Caml[96][6],
    stdin = Caml[38];
   function create(opt, file){
    if(opt) var sth = opt[1], binary = sth; else var binary = 1;
    var flags$0 = binary ? [0, 6, flags] : flags;
    return caml_call3(Caml[81], flags$0, 0, file);
   }
   var close = Caml[93];
   function with_file(binary, file, f){
    var _i_ = create(binary, file);
    return caml_call3(Base_Exn[12], f, _i_, close);
   }
   function may_eof(f){
    try{var _g_ = [0, caml_call1(f, 0)]; return _g_;}
    catch(_h_){
     var _f_ = caml_wrap_exception(_h_);
     if(_f_ === Stdlib[12]) return 0;
     throw caml_maybe_attach_backtrace(_f_, 0);
    }
   }
   function input(t, buf, pos, len){
    return caml_call4(Caml[84], t, buf, pos, len);
   }
   function really_input(t, buf, pos, len){
    return may_eof
            (function(param){return caml_call4(Caml[85], t, buf, pos, len);});
   }
   function really_input_exn(t, buf, pos, len){
    return caml_call4(Caml[85], t, buf, pos, len);
   }
   function input_byte(t){
    return may_eof(function(param){return caml_call1(Caml[87], t);});
   }
   function input_char(t){
    return may_eof(function(param){return caml_call1(Caml[82], t);});
   }
   function input_binary_int(t){
    return may_eof(function(param){return caml_call1(Caml[88], t);});
   }
   function unsafe_input_value(t){
    return may_eof(function(param){return caml_call1(Caml[89], t);});
   }
   function input_buffer(t, buf, len){
    return may_eof
            (function(param){
              return caml_call3(Stdlib_Buffer[22], buf, t, len);
             });
   }
   var set_binary_mode = Caml[95];
   function input_all(t){
    var buffer = caml_call1(Base_Buffer[2], 65536), chunk_size = 65536;
    try{for(;;) caml_call3(Stdlib_Buffer[22], buffer, t, chunk_size);}
    catch(_e_){
     var _d_ = caml_wrap_exception(_e_);
     if(_d_ === Stdlib[12]) return caml_call1(Base_Buffer[3], buffer);
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function trim(fix_win_eol, line){
    if(! fix_win_eol) return line;
    var len = runtime.caml_ml_string_length(line);
    if(0 < len){
     var _c_ = runtime.caml_string_get(line, len - 1 | 0);
     if(caml_call2(Base_Char[15], _c_, 13))
      return caml_call3(Base_String[2], line, 0, len - 1 | 0);
    }
    return line;
   }
   function input_line(opt, t){
    if(opt) var sth = opt[1], fix_win_eol = sth; else var fix_win_eol = 1;
    var match = may_eof(function(param){return caml_call1(Caml[83], t);});
    if(! match) return 0;
    var line = match[1];
    return [0, trim(fix_win_eol, line)];
   }
   function input_line_exn(opt, t){
    if(opt) var sth = opt[1], fix_win_eol = sth; else var fix_win_eol = 1;
    var line = caml_call1(Caml[83], t);
    return trim(fix_win_eol, line);
   }
   function fold_lines(fix_win_eol, t, init, f){
    var ac = init;
    for(;;){
     var match = input_line(fix_win_eol, t);
     if(! match) return ac;
     var line = match[1], ac$0 = caml_call2(f, ac, line), ac = ac$0;
    }
   }
   function input_lines(fix_win_eol, t){
    var
     _b_ =
       fold_lines
        (fix_win_eol, t, 0, function(lines, line){return [0, line, lines];});
    return caml_call1(Base_List[38], _b_);
   }
   function iter_lines(fix_win_eol, t, f){
    return fold_lines
            (fix_win_eol,
             t,
             0,
             function(param, line){return caml_call1(f, line);});
   }
   function read_lines(fix_win_eol, fname){
    return with_file
            (0, fname, function(_a_){return input_lines(fix_win_eol, _a_);});
   }
   function read_all(fname){return with_file(0, fname, input_all);}
   var
    Stdio_In_channel =
      [0,
       equal,
       stdin,
       create,
       with_file,
       close,
       input,
       really_input,
       really_input_exn,
       input_char,
       input_byte,
       input_binary_int,
       unsafe_input_value,
       input_buffer,
       input_all,
       input_line,
       input_line_exn,
       fold_lines,
       input_lines,
       iter_lines,
       seek,
       pos,
       length,
       set_binary_mode,
       read_lines,
       read_all];
   runtime.caml_register_global(10, Stdio_In_channel, "Stdio__In_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdio__Out_channel
//# unitInfo: Requires: Base, Base__Exn, Base__List, Caml, Stdlib__Buffer, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "\n",
    flags = [0, 1, [0, 3, 0]],
    Base_Exn = global_data.Base__Exn,
    Base = global_data.Base,
    Base_List = global_data.Base__List,
    Caml = global_data.Caml,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Printf = global_data.Stdlib__Printf,
    _a_ = [0, "<stderr>"],
    _b_ = [0, "<stdout>"],
    _c_ = [0, "<Out_channel.t>"];
   function equal(t1, t2){return caml_call2(Base[203], t1, t2);}
   var
    seek = Caml[96][1],
    pos = Caml[96][2],
    length = Caml[96][3],
    stdout = Caml[39],
    stderr = Caml[40];
   function sexp_of_t(t){
    return caml_call2(Base[203], t, stderr)
            ? _a_
            : caml_call2(Base[203], t, stdout) ? _b_ : _c_;
   }
   function create(opt, _j_, _i_, _h_, file){
    if(opt) var sth = opt[1], binary = sth; else var binary = 1;
    if(_j_) var sth$0 = _j_[1], append = sth$0; else var append = 0;
    if(_i_)
     var sth$1 = _i_[1], fail_if_exists = sth$1;
    else
     var fail_if_exists = 0;
    if(_h_) var sth$2 = _h_[1], perm = sth$2; else var perm = 438;
    var
     _k_ = binary ? 6 : 7,
     flags$0 = [0, _k_, flags],
     _l_ = append ? 2 : 4,
     flags$1 = [0, _l_, flags$0],
     flags$2 = fail_if_exists ? [0, 5, flags$1] : flags$1;
    return caml_call3(Caml[62], flags$2, perm, file);
   }
   var
    set_binary_mode = Caml[78],
    flush = Caml[63],
    close = Caml[76],
    close_no_err = Caml[77];
   function output(t, buf, pos, len){
    return caml_call4(Caml[68], t, buf, pos, len);
   }
   function output_substring(t, buf, pos, len){
    return caml_call4(Caml[69], t, buf, pos, len);
   }
   var
    output_string = Caml[66],
    output_bytes = Caml[67],
    output_char = Caml[65],
    output_byte = Caml[70],
    output_binary_int = Caml[71],
    output_buffer = Stdlib_Buffer[10],
    output_value = Caml[72];
   function newline(t){return caml_call2(output_string, t, cst);}
   function output_lines(t, lines){
    function _g_(line){caml_call2(output_string, t, line); return newline(t);}
    return caml_call2(Base_List[9], lines, _g_);
   }
   var
    printf = Stdlib_Printf[2],
    eprintf = Stdlib_Printf[3],
    fprintf = Stdlib_Printf[1],
    kfprintf = Stdlib_Printf[8],
    print_string = Caml[42],
    print_endline = Caml[46],
    prerr_endline = Caml[53];
   function print_s(mach, sexp){
    var
     _f_ =
       mach
        ? caml_call1(Base[84][14], sexp)
        : caml_call2(Base[84][13], 0, sexp);
    return caml_call1(print_endline, _f_);
   }
   function eprint_s(mach, sexp){
    var
     _e_ =
       mach
        ? caml_call1(Base[84][14], sexp)
        : caml_call2(Base[84][13], 0, sexp);
    return caml_call1(prerr_endline, _e_);
   }
   function with_file(binary, append, fail_if_exists, perm, file, f){
    var _d_ = create(binary, append, fail_if_exists, perm, file);
    return caml_call3(Base_Exn[12], f, _d_, close);
   }
   function write_lines(file, lines){
    return with_file
            (0, 0, 0, 0, file, function(t){return output_lines(t, lines);});
   }
   function write_all(file, data){
    return with_file
            (0,
             0,
             0,
             0,
             file,
             function(t){return caml_call2(output_string, t, data);});
   }
   var
    Stdio_Out_channel =
      [0,
       sexp_of_t,
       equal,
       stdout,
       stderr,
       create,
       with_file,
       close,
       close_no_err,
       set_binary_mode,
       flush,
       output,
       output_string,
       output_substring,
       output_bytes,
       output_char,
       output_byte,
       output_binary_int,
       output_buffer,
       output_value,
       newline,
       output_lines,
       fprintf,
       printf,
       print_s,
       eprint_s,
       eprintf,
       kfprintf,
       print_string,
       print_endline,
       prerr_endline,
       seek,
       pos,
       length,
       write_lines,
       write_all];
   runtime.caml_register_global(11, Stdio_Out_channel, "Stdio__Out_channel");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Stdio
//# unitInfo: Requires: Stdio__In_channel, Stdio__Out_channel
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdio_In_channel = global_data.Stdio__In_channel,
    Stdio_Out_channel = global_data.Stdio__Out_channel,
    stdin = Stdio_In_channel[2],
    stdout = Stdio_Out_channel[3],
    stderr = Stdio_Out_channel[4],
    eprintf = Stdio_Out_channel[26],
    printf = Stdio_Out_channel[23],
    print_s = Stdio_Out_channel[24],
    eprint_s = Stdio_Out_channel[25],
    print_string = Stdio_Out_channel[28],
    print_endline = Stdio_Out_channel[29],
    prerr_endline = Stdio_Out_channel[30],
    Stdio =
      [0,
       stdin,
       stdout,
       stderr,
       printf,
       print_s,
       eprint_s,
       eprintf,
       print_string,
       print_endline,
       prerr_endline];
   runtime.caml_register_global(2, Stdio, "Stdio");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzdGRpby5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZmxhZ3MiLCJlcXVhbCIsInQxIiwidDIiLCJzZWVrIiwicG9zIiwibGVuZ3RoIiwic3RkaW4iLCJjcmVhdGUiLCJvcHQiLCJmaWxlIiwic3RoIiwiYmluYXJ5IiwiZmxhZ3MkMCIsImNsb3NlIiwid2l0aF9maWxlIiwiZiIsIm1heV9lb2YiLCJpbnB1dCIsInQiLCJidWYiLCJsZW4iLCJyZWFsbHlfaW5wdXQiLCJyZWFsbHlfaW5wdXRfZXhuIiwiaW5wdXRfYnl0ZSIsImlucHV0X2NoYXIiLCJpbnB1dF9iaW5hcnlfaW50IiwidW5zYWZlX2lucHV0X3ZhbHVlIiwiaW5wdXRfYnVmZmVyIiwic2V0X2JpbmFyeV9tb2RlIiwiaW5wdXRfYWxsIiwiYnVmZmVyIiwiY2h1bmtfc2l6ZSIsInRyaW0iLCJmaXhfd2luX2VvbCIsImxpbmUiLCJpbnB1dF9saW5lIiwiaW5wdXRfbGluZV9leG4iLCJmb2xkX2xpbmVzIiwiaW5pdCIsImFjIiwiYWMkMCIsImlucHV0X2xpbmVzIiwibGluZXMiLCJpdGVyX2xpbmVzIiwicmVhZF9saW5lcyIsImZuYW1lIiwicmVhZF9hbGwiLCJzdGRvdXQiLCJzdGRlcnIiLCJzZXhwX29mX3QiLCJzdGgkMCIsImFwcGVuZCIsInN0aCQxIiwiZmFpbF9pZl9leGlzdHMiLCJzdGgkMiIsInBlcm0iLCJmbGFncyQxIiwiZmxhZ3MkMiIsImZsdXNoIiwiY2xvc2Vfbm9fZXJyIiwib3V0cHV0Iiwib3V0cHV0X3N1YnN0cmluZyIsIm91dHB1dF9zdHJpbmciLCJvdXRwdXRfYnl0ZXMiLCJvdXRwdXRfY2hhciIsIm91dHB1dF9ieXRlIiwib3V0cHV0X2JpbmFyeV9pbnQiLCJvdXRwdXRfYnVmZmVyIiwib3V0cHV0X3ZhbHVlIiwibmV3bGluZSIsIm91dHB1dF9saW5lcyIsInByaW50ZiIsImVwcmludGYiLCJmcHJpbnRmIiwia2ZwcmludGYiLCJwcmludF9zdHJpbmciLCJwcmludF9lbmRsaW5lIiwicHJlcnJfZW5kbGluZSIsInByaW50X3MiLCJtYWNoIiwic2V4cCIsImVwcmludF9zIiwid3JpdGVfbGluZXMiLCJ3cml0ZV9hbGwiLCJkYXRhIl0sInNvdXJjZXMiOlsiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL3N0ZGlvL2luX2NoYW5uZWwubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvc3RkaW8vb3V0X2NoYW5uZWwubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQVdNQTs7Ozs7Ozs7OztZQVBGQyxNQUFPQyxJQUFRQyxJQUFLLDZCQUFiRCxJQUFRQyxJQUFxQjs7SUFDcENDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBRUFDLE9BQVNDLEtBQWVDO0lBQzFCLEdBRFdELFNBQVNFLE1BQVRGLGlCQUFTRSxjQUFUQztJQUVYLElBQUlDLFVBRk9ELGdCQUNQWjtJQUVKLDRCQURJYSxZQUZzQkg7R0FHTztPQUcvQkk7WUFDQUMsVUFBV0gsUUFBT0YsTUFBTU07SUFBaUIsVUFQekNSLE9BT1dJLFFBQU9GO29DQUFNTSxRQUR4QkY7R0FDZ0Y7WUFFaEZHLFFBQVFEO0lBQ1YsSUFBSSxjQUFLLFdBRENBLFFBQ047Ozs0QkFDYTs7O0dBQUk7WUFHbkJFLE1BQU1DLEdBQUdDLEtBQUtmLEtBQUtnQjtJQUFNLDRCQUFuQkYsR0FBR0MsS0FBS2YsS0FBS2dCO0dBQThCO1lBQ2pEQyxhQUFhSCxHQUFHQyxLQUFLZixLQUFLZ0I7SUFBTSxPQU5oQ0o7NkJBTW1ELE9BQW5CLHFCQUFuQkUsR0FBR0MsS0FBS2YsS0FBS2dCLEtBQXdEO0dBQUM7WUFDbkZFLGlCQUFpQkosR0FBR0MsS0FBS2YsS0FBS2dCO0lBQU0sNEJBQW5CRixHQUFHQyxLQUFLZixLQUFLZ0I7R0FBcUM7WUFDbkVHLFdBQVdMO0lBQUksT0FSZkYsd0JBUWtDLE9BQW5CLHFCQUFKRSxHQUF3QztHQUFDO1lBQ3BETSxXQUFXTjtJQUFJLE9BVGZGLHdCQVNrQyxPQUFuQixxQkFBSkUsR0FBd0M7R0FBQztZQUNwRE8saUJBQWlCUDtJQUFJLE9BVnJCRix3QkFVd0MsT0FBbkIscUJBQUpFLEdBQThDO0dBQUM7WUFDaEVRLG1CQUFtQlI7SUFBSSxPQVh2QkYsd0JBVzBDLE9BQW5CLHFCQUFKRSxHQUF5QztHQUFDO1lBQzdEUyxhQUFhVCxHQUFFQyxLQUFLQztJQUFNLE9BWjFCSjs7Y0FZNkMsT0FBbkIsOEJBQVhHLEtBQUZELEdBQU9FO2FBQTBEO0dBQUM7T0FDL0VRO1lBRUFDLFVBQVVYO0lBRVosSUFDSVksU0FBUyxtQ0FEVEM7SUFNSixJQUhFLHNDQUZFRCxRQUhRWixHQUVSYTs7OzRCQU9hLGtDQU5iRDs7O0dBTW1DO1lBR3JDRSxLQUFNQyxhQUFZQztJQUNwQixLQURRRCxhQU9ILE9BUGVDO1FBR2RkLG9DQUhjYztJQUlsQixPQURJZDtLQUNxQixrQ0FKUGMsTUFHZGQ7S0FDVTtNQUNULGtDQUxhYyxTQUdkZDs7SUFHQyxPQU5hYztHQU9YO1lBR1BDLFdBQWEzQixLQUFvQlU7SUFDbkMsR0FEZVYsU0FBY0UsTUFBZEYsc0JBQWNFLGNBQWR1QjtJQUNULFlBdENKakIsd0JBc0N1QixPQUF6QixxQkFEbUNFLEdBQ087Z0JBQ2hDO1FBQ0hnQjtJQUFRLFdBYmJGLEtBVWFDLGFBR1JDO0dBQXFDO1lBRzFDRSxlQUFpQjVCLEtBQW9CVTtJQUN2QyxHQURtQlYsU0FBY0UsTUFBZEYsc0JBQWNFLGNBQWR1QjtJQUNSLElBQVBDLE9BQU8scUJBRDRCaEI7SUFFdkMsT0FsQkVjLEtBZ0JpQkMsYUFDZkM7R0FDa0I7WUFHcEJHLFdBQVlKLGFBQVlmLEdBQ2JvQixNQURzQnZCO0lBQ25DLElBQWF3QjtJQUNYO0tBQU0sWUFiTkosV0FXWUYsYUFBWWY7aUJBR2QsT0FGQ3FCO0tBR1MsSUFBYkwsaUJBSElNLE9BR1MsV0FKYXpCLEdBQ3RCd0IsSUFHSkwsT0FISUs7O0dBS0o7WUFHUEUsWUFBYVIsYUFBWWY7SUFDbEI7O09BVlBtQjtTQVNhSixhQUFZZixlQUMwQndCLE9BQU1SLE1BQVEsV0FBUkEsTUFBTlEsT0FBMkI7SUFBdkU7R0FBeUU7WUFHaEZDLFdBQVlWLGFBQVlmLEdBQUdIO0lBQzdCLE9BZEVzQjthQWFZSjthQUFZZjs7NkJBQ29CZ0IsTUFBUSxrQkFEekJuQixHQUNpQm1CLE1BQWM7R0FBQztZQUczRFUsV0FBWVgsYUFBWVk7SUFBUSxPQW5FaEMvQjtnQkFtRXdCK0IscUIsT0FSeEJKLFlBUVlSO0dBQWlFO1lBQzdFYSxTQUFTRCxPQUFRLE9BcEVqQi9CLGFBb0VTK0IsT0FuRFRoQixXQW1ENkM7Ozs7T0FqRjdDN0I7T0FJQU07T0FFQUM7T0FPQU87T0FEQUQ7T0FRQUk7T0FDQUk7T0FDQUM7T0FFQUU7T0FEQUQ7T0FFQUU7T0FDQUM7T0FDQUM7T0FHQUU7T0FzQkFNO09BTUFDO09BS0FDO09BU0FJO09BSUFFO09BM0VBeEM7T0FDQUM7T0FDQUM7T0F5QkF1QjtPQW9EQWdCO09BQ0FFOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUN4REUvQzs7Ozs7Ozs7OztZQXpCRkMsTUFBT0MsSUFBUUMsSUFBSyw2QkFBYkQsSUFBUUMsSUFBcUI7O0lBQ3BDQztJQUNBQztJQUNBQztJQUNBMEM7SUFDQUM7WUFFQUMsVUFBVS9CO0lBQ1osT0FBRyxzQkFEU0EsR0FGVjhCOztjQUtNLHNCQUhJOUIsR0FIVjZCO0dBUThCO1lBTTlCeEMsT0FDSUMsb0JBSUZDO0lBRUosR0FOTUQsU0FBU0UsTUFBVEYsaUJBQVNFLGNBQVRDO0lBTU4sWUFMZXVDLGdCQUFUQyxTQUFTRCxnQkFBVEM7SUFLTjtTQUp1QkMsZ0JBQWpCQyxpQkFBaUJEOztTQUFqQkM7SUFJTixZQUhhQyxnQkFBUEMsT0FBT0QsZ0JBQVBDO0lBSU07V0FQTjVDO0tBT0ZDLG1CQURBYjtXQUxFb0Q7S0FPRkssbUJBREE1QztLQUVBNkMsVUFQRUosd0JBTUZHO0lBRUosNEJBRElDLFNBTkVGLE1BQ0Y5QztHQU02Qjs7SUFHL0JtQjtJQUNBOEI7SUFDQTdDO0lBQ0E4QztZQUNBQyxPQUFPMUMsR0FBR0MsS0FBS2YsS0FBS2dCO0lBQU0sNEJBQW5CRixHQUFHQyxLQUFLZixLQUFLZ0I7R0FBK0I7WUFDbkR5QyxpQkFBaUIzQyxHQUFHQyxLQUFLZixLQUFLZ0I7SUFBTSw0QkFBbkJGLEdBQUdDLEtBQUtmLEtBQUtnQjtHQUF5Qzs7SUFDdkUwQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztZQUNBQyxRQUFRbkQsR0FBSSxrQkFQWjRDLGVBT1E1QyxRQUF3QjtZQUVoQ29ELGFBQWFwRCxHQUFFd0I7aUJBQ09SLE1BQ3RCLFdBWEE0QixlQVNhNUMsR0FDU2dCLE9BQXhCLE9BSEVtQyxRQUVhbkQsR0FHSjtJQUZRLGdDQURGd0I7R0FHTDs7SUFHVjZCO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO1lBRUFDLFFBQVNDLE1BQUtDO0lBQ2hCOztPQURXRDtVQUdLLHlCQUhBQztVQUlILDRCQUpHQTtJQUlILGtCQVBYSjtHQU9tQztZQUduQ0ssU0FBVUYsTUFBS0M7SUFDakI7O09BRFlEO1VBR0kseUJBSENDO1VBSUosNEJBSklBO0lBSUosa0JBYlhIO0dBYW1DO1lBR25DL0QsVUFBV0gsUUFBUXdDLFFBQVFFLGdCQUFnQkUsTUFBSzlDLE1BQU1NO0lBQzNDLFVBMURYUixPQXlEV0ksUUFBUXdDLFFBQVFFLGdCQUFnQkUsTUFBSzlDO29DQUFNTSxRQXpDdERGO0dBMENnRjtZQUdoRnFFLFlBQVl6RSxNQUFLaUM7SUFBUSxPQUp6QjVCO3lCQUlZTCxlQUFvQ1MsR0FBSyxPQWhDckRvRCxhQWdDZ0RwRCxHQUEvQndCLE9BQXdEO0dBQUM7WUFDMUV5QyxVQUFVMUUsTUFBTTJFO0lBQU8sT0FMdkJ0RTs7Ozs7YUFLVUw7c0JBQW9DUyxHQUFLLE9BQTVCLFdBMUN2QjRDLGVBMEM4QzVDLEdBQTlCa0UsTUFBdUQ7R0FBQzs7OztPQXpFeEVuQztPQVBBakQ7T0FJQStDO09BQ0FDO09BYUF6QztPQXlEQU87T0F6Q0FEO09BQ0E4QztPQUhBL0I7T0FDQThCO09BR0FFO09BRUFFO09BREFEO09BRUFFO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BQ0FDO09BRUFDO09BUUFHO09BRkFGO09BUUFPO09BT0FHO09BZEFUO09BRUFFO09BQ0FDO09BQ0FDO09BQ0FDO09BMURBMUU7T0FDQUM7T0FDQUM7T0E0RUE2RTtPQUNBQzs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJvcGVuISBCYXNlXG5cbnR5cGUgdCA9IENhbWwuaW5fY2hhbm5lbFxuXG5sZXQgZXF1YWwgKHQxIDogdCkgdDIgPSBwaHlzX2VxdWFsIHQxIHQyXG5sZXQgc2VlayA9IENhbWwuTGFyZ2VGaWxlLnNlZWtfaW5cbmxldCBwb3MgPSBDYW1sLkxhcmdlRmlsZS5wb3NfaW5cbmxldCBsZW5ndGggPSBDYW1sLkxhcmdlRmlsZS5pbl9jaGFubmVsX2xlbmd0aFxubGV0IHN0ZGluID0gQ2FtbC5zdGRpblxuXG5sZXQgY3JlYXRlID8oYmluYXJ5ID0gdHJ1ZSkgZmlsZSA9XG4gIGxldCBmbGFncyA9IFsgT3Blbl9yZG9ubHkgXSBpblxuICBsZXQgZmxhZ3MgPSBpZiBiaW5hcnkgdGhlbiBPcGVuX2JpbmFyeSA6OiBmbGFncyBlbHNlIGZsYWdzIGluXG4gIENhbWwub3Blbl9pbl9nZW4gZmxhZ3MgMG8wMDAgZmlsZVxuOztcblxubGV0IGNsb3NlID0gQ2FtbC5jbG9zZV9pblxubGV0IHdpdGhfZmlsZSA/YmluYXJ5IGZpbGUgfmYgPSBFeG4ucHJvdGVjdHggKGNyZWF0ZSA/YmluYXJ5IGZpbGUpIH5mIH5maW5hbGx5OmNsb3NlXG5cbmxldCBtYXlfZW9mIGYgPVxuICB0cnkgU29tZSAoZiAoKSkgd2l0aFxuICB8IEVuZF9vZl9maWxlIC0+IE5vbmVcbjs7XG5cbmxldCBpbnB1dCB0IH5idWYgfnBvcyB+bGVuID0gQ2FtbC5pbnB1dCB0IGJ1ZiBwb3MgbGVuXG5sZXQgcmVhbGx5X2lucHV0IHQgfmJ1ZiB+cG9zIH5sZW4gPSBtYXlfZW9mIChmdW4gKCkgLT4gQ2FtbC5yZWFsbHlfaW5wdXQgdCBidWYgcG9zIGxlbilcbmxldCByZWFsbHlfaW5wdXRfZXhuIHQgfmJ1ZiB+cG9zIH5sZW4gPSBDYW1sLnJlYWxseV9pbnB1dCB0IGJ1ZiBwb3MgbGVuXG5sZXQgaW5wdXRfYnl0ZSB0ID0gbWF5X2VvZiAoZnVuICgpIC0+IENhbWwuaW5wdXRfYnl0ZSB0KVxubGV0IGlucHV0X2NoYXIgdCA9IG1heV9lb2YgKGZ1biAoKSAtPiBDYW1sLmlucHV0X2NoYXIgdClcbmxldCBpbnB1dF9iaW5hcnlfaW50IHQgPSBtYXlfZW9mIChmdW4gKCkgLT4gQ2FtbC5pbnB1dF9iaW5hcnlfaW50IHQpXG5sZXQgdW5zYWZlX2lucHV0X3ZhbHVlIHQgPSBtYXlfZW9mIChmdW4gKCkgLT4gQ2FtbC5pbnB1dF92YWx1ZSB0KVxubGV0IGlucHV0X2J1ZmZlciB0IGJ1ZiB+bGVuID0gbWF5X2VvZiAoZnVuICgpIC0+IENhbWwuQnVmZmVyLmFkZF9jaGFubmVsIGJ1ZiB0IGxlbilcbmxldCBzZXRfYmluYXJ5X21vZGUgPSBDYW1sLnNldF9iaW5hcnlfbW9kZV9pblxuXG5sZXQgaW5wdXRfYWxsIHQgPVxuICAoKiBXZSB1c2UgNjU1MzYgYmVjYXVzZSB0aGF0IGlzIHRoZSBzaXplIG9mIE9DYW1sJ3MgSU8gYnVmZmVycy4gKilcbiAgbGV0IGNodW5rX3NpemUgPSA2NTUzNiBpblxuICBsZXQgYnVmZmVyID0gQnVmZmVyLmNyZWF0ZSBjaHVua19zaXplIGluXG4gIGxldCByZWMgbG9vcCAoKSA9XG4gICAgQ2FtbC5CdWZmZXIuYWRkX2NoYW5uZWwgYnVmZmVyIHQgY2h1bmtfc2l6ZTtcbiAgICBsb29wICgpXG4gIGluXG4gIHRyeSBsb29wICgpIHdpdGhcbiAgfCBFbmRfb2ZfZmlsZSAtPiBCdWZmZXIuY29udGVudHMgYnVmZmVyXG47O1xuXG5sZXQgdHJpbSB+Zml4X3dpbl9lb2wgbGluZSA9XG4gIGlmIGZpeF93aW5fZW9sXG4gIHRoZW4gKFxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIGxpbmUgaW5cbiAgICBpZiBsZW4gPiAwICYmIENoYXIuZXF1YWwgKFN0cmluZy5nZXQgbGluZSAobGVuIC0gMSkpICdcXHInXG4gICAgdGhlbiBTdHJpbmcuc3ViIGxpbmUgfnBvczowIH5sZW46KGxlbiAtIDEpXG4gICAgZWxzZSBsaW5lKVxuICBlbHNlIGxpbmVcbjs7XG5cbmxldCBpbnB1dF9saW5lID8oZml4X3dpbl9lb2wgPSB0cnVlKSB0ID1cbiAgbWF0Y2ggbWF5X2VvZiAoZnVuICgpIC0+IENhbWwuaW5wdXRfbGluZSB0KSB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBsaW5lIC0+IFNvbWUgKHRyaW0gfmZpeF93aW5fZW9sIGxpbmUpXG47O1xuXG5sZXQgaW5wdXRfbGluZV9leG4gPyhmaXhfd2luX2VvbCA9IHRydWUpIHQgPVxuICBsZXQgbGluZSA9IENhbWwuaW5wdXRfbGluZSB0IGluXG4gIHRyaW0gfmZpeF93aW5fZW9sIGxpbmVcbjs7XG5cbmxldCBmb2xkX2xpbmVzID9maXhfd2luX2VvbCB0IH5pbml0IH5mID1cbiAgbGV0IHJlYyBsb29wIGFjID1cbiAgICBtYXRjaCBpbnB1dF9saW5lID9maXhfd2luX2VvbCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gYWNcbiAgICB8IFNvbWUgbGluZSAtPiBsb29wIChmIGFjIGxpbmUpXG4gIGluXG4gIGxvb3AgaW5pdFxuOztcblxubGV0IGlucHV0X2xpbmVzID9maXhfd2luX2VvbCB0ID1cbiAgTGlzdC5yZXYgKGZvbGRfbGluZXMgP2ZpeF93aW5fZW9sIHQgfmluaXQ6W10gfmY6KGZ1biBsaW5lcyBsaW5lIC0+IGxpbmUgOjogbGluZXMpKVxuOztcblxubGV0IGl0ZXJfbGluZXMgP2ZpeF93aW5fZW9sIHQgfmYgPVxuICBmb2xkX2xpbmVzID9maXhfd2luX2VvbCB0IH5pbml0OigpIH5mOihmdW4gKCkgbGluZSAtPiBmIGxpbmUpXG47O1xuXG5sZXQgcmVhZF9saW5lcyA/Zml4X3dpbl9lb2wgZm5hbWUgPSB3aXRoX2ZpbGUgZm5hbWUgfmY6KGlucHV0X2xpbmVzID9maXhfd2luX2VvbClcbmxldCByZWFkX2FsbCBmbmFtZSA9IHdpdGhfZmlsZSBmbmFtZSB+ZjppbnB1dF9hbGxcbiIsIm9wZW4hIEJhc2VcblxudHlwZSB0ID0gQ2FtbC5vdXRfY2hhbm5lbFxuXG5sZXQgZXF1YWwgKHQxIDogdCkgdDIgPSBwaHlzX2VxdWFsIHQxIHQyXG5sZXQgc2VlayA9IENhbWwuTGFyZ2VGaWxlLnNlZWtfb3V0XG5sZXQgcG9zID0gQ2FtbC5MYXJnZUZpbGUucG9zX291dFxubGV0IGxlbmd0aCA9IENhbWwuTGFyZ2VGaWxlLm91dF9jaGFubmVsX2xlbmd0aFxubGV0IHN0ZG91dCA9IENhbWwuc3Rkb3V0XG5sZXQgc3RkZXJyID0gQ2FtbC5zdGRlcnJcblxubGV0IHNleHBfb2ZfdCB0ID1cbiAgaWYgcGh5c19lcXVhbCB0IHN0ZGVyclxuICB0aGVuIFNleHAuQXRvbSBcIjxzdGRlcnI+XCJcbiAgZWxzZSBpZiBwaHlzX2VxdWFsIHQgc3Rkb3V0XG4gIHRoZW4gU2V4cC5BdG9tIFwiPHN0ZG91dD5cIlxuICBlbHNlIFNleHAuQXRvbSBcIjxPdXRfY2hhbm5lbC50PlwiXG47O1xuXG50eXBlICdhIHdpdGhfY3JlYXRlX2FyZ3MgPVxuICA/YmluYXJ5OmJvb2wgLT4gP2FwcGVuZDpib29sIC0+ID9mYWlsX2lmX2V4aXN0czpib29sIC0+ID9wZXJtOmludCAtPiAnYVxuXG5sZXQgY3JlYXRlXG4gICAgICA/KGJpbmFyeSA9IHRydWUpXG4gICAgICA/KGFwcGVuZCA9IGZhbHNlKVxuICAgICAgPyhmYWlsX2lmX2V4aXN0cyA9IGZhbHNlKVxuICAgICAgPyhwZXJtID0gMG82NjYpXG4gICAgICBmaWxlXG4gID1cbiAgbGV0IGZsYWdzID0gWyBPcGVuX3dyb25seTsgT3Blbl9jcmVhdCBdIGluXG4gIGxldCBmbGFncyA9IChpZiBiaW5hcnkgdGhlbiBPcGVuX2JpbmFyeSBlbHNlIE9wZW5fdGV4dCkgOjogZmxhZ3MgaW5cbiAgbGV0IGZsYWdzID0gKGlmIGFwcGVuZCB0aGVuIE9wZW5fYXBwZW5kIGVsc2UgT3Blbl90cnVuYykgOjogZmxhZ3MgaW5cbiAgbGV0IGZsYWdzID0gaWYgZmFpbF9pZl9leGlzdHMgdGhlbiBPcGVuX2V4Y2wgOjogZmxhZ3MgZWxzZSBmbGFncyBpblxuICBDYW1sLm9wZW5fb3V0X2dlbiBmbGFncyBwZXJtIGZpbGVcbjs7XG5cbmxldCBzZXRfYmluYXJ5X21vZGUgPSBDYW1sLnNldF9iaW5hcnlfbW9kZV9vdXRcbmxldCBmbHVzaCA9IENhbWwuZmx1c2hcbmxldCBjbG9zZSA9IENhbWwuY2xvc2Vfb3V0XG5sZXQgY2xvc2Vfbm9fZXJyID0gQ2FtbC5jbG9zZV9vdXRfbm9lcnJcbmxldCBvdXRwdXQgdCB+YnVmIH5wb3MgfmxlbiA9IENhbWwub3V0cHV0IHQgYnVmIHBvcyBsZW5cbmxldCBvdXRwdXRfc3Vic3RyaW5nIHQgfmJ1ZiB+cG9zIH5sZW4gPSBDYW1sLm91dHB1dF9zdWJzdHJpbmcgdCBidWYgcG9zIGxlblxubGV0IG91dHB1dF9zdHJpbmcgPSBDYW1sLm91dHB1dF9zdHJpbmdcbmxldCBvdXRwdXRfYnl0ZXMgPSBDYW1sLm91dHB1dF9ieXRlc1xubGV0IG91dHB1dF9jaGFyID0gQ2FtbC5vdXRwdXRfY2hhclxubGV0IG91dHB1dF9ieXRlID0gQ2FtbC5vdXRwdXRfYnl0ZVxubGV0IG91dHB1dF9iaW5hcnlfaW50ID0gQ2FtbC5vdXRwdXRfYmluYXJ5X2ludFxubGV0IG91dHB1dF9idWZmZXIgPSBDYW1sLkJ1ZmZlci5vdXRwdXRfYnVmZmVyXG5sZXQgb3V0cHV0X3ZhbHVlID0gQ2FtbC5vdXRwdXRfdmFsdWVcbmxldCBuZXdsaW5lIHQgPSBvdXRwdXRfc3RyaW5nIHQgXCJcXG5cIlxuXG5sZXQgb3V0cHV0X2xpbmVzIHQgbGluZXMgPVxuICBMaXN0Lml0ZXIgbGluZXMgfmY6KGZ1biBsaW5lIC0+XG4gICAgb3V0cHV0X3N0cmluZyB0IGxpbmU7XG4gICAgbmV3bGluZSB0KVxuOztcblxubGV0IHByaW50ZiA9IENhbWwuUHJpbnRmLnByaW50ZlxubGV0IGVwcmludGYgPSBDYW1sLlByaW50Zi5lcHJpbnRmXG5sZXQgZnByaW50ZiA9IENhbWwuUHJpbnRmLmZwcmludGZcbmxldCBrZnByaW50ZiA9IENhbWwuUHJpbnRmLmtmcHJpbnRmXG5sZXQgcHJpbnRfc3RyaW5nID0gQ2FtbC5wcmludF9zdHJpbmdcbmxldCBwcmludF9lbmRsaW5lID0gQ2FtbC5wcmludF9lbmRsaW5lXG5sZXQgcHJlcnJfZW5kbGluZSA9IENhbWwucHJlcnJfZW5kbGluZVxuXG5sZXQgcHJpbnRfcyA/bWFjaCBzZXhwID1cbiAgcHJpbnRfZW5kbGluZVxuICAgIChtYXRjaCBtYWNoIHdpdGhcbiAgICAgfCBTb21lICgpIC0+IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cFxuICAgICB8IE5vbmUgLT4gU2V4cC50b19zdHJpbmdfaHVtIHNleHApXG47O1xuXG5sZXQgZXByaW50X3MgP21hY2ggc2V4cCA9XG4gIHByZXJyX2VuZGxpbmVcbiAgICAobWF0Y2ggbWFjaCB3aXRoXG4gICAgIHwgU29tZSAoKSAtPiBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHBcbiAgICAgfCBOb25lIC0+IFNleHAudG9fc3RyaW5nX2h1bSBzZXhwKVxuOztcblxubGV0IHdpdGhfZmlsZSA/YmluYXJ5ID9hcHBlbmQgP2ZhaWxfaWZfZXhpc3RzID9wZXJtIGZpbGUgfmYgPVxuICBFeG4ucHJvdGVjdHggKGNyZWF0ZSA/YmluYXJ5ID9hcHBlbmQgP2ZhaWxfaWZfZXhpc3RzID9wZXJtIGZpbGUpIH5mIH5maW5hbGx5OmNsb3NlXG47O1xuXG5sZXQgd3JpdGVfbGluZXMgZmlsZSBsaW5lcyA9IHdpdGhfZmlsZSBmaWxlIH5mOihmdW4gdCAtPiBvdXRwdXRfbGluZXMgdCBsaW5lcylcbmxldCB3cml0ZV9hbGwgZmlsZSB+ZGF0YSA9IHdpdGhfZmlsZSBmaWxlIH5mOihmdW4gdCAtPiBvdXRwdXRfc3RyaW5nIHQgZGF0YSlcbiJdfQ==
