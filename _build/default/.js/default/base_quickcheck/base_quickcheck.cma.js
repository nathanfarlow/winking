// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.1.1

//# unitInfo: Provides: Base_quickcheck__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_quickcheck = [0];
   runtime.caml_register_global(0, Base_quickcheck, "Base_quickcheck__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__With_basic_types
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Base_quickcheck_With_basic_typ = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_With_basic_typ, "Base_quickcheck__With_basic_types");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Bigarray_helpers
//# unitInfo: Requires: Base, Base__Array, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_dim_2 = runtime.caml_ba_dim_2,
    caml_ba_get_1 = runtime.caml_ba_get_1,
    caml_ba_get_2 = runtime.caml_ba_get_2,
    caml_ba_layout = runtime.caml_ba_layout;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Base_Array = global_data.Base__Array,
    Stdlib_Bigarray = global_data.Stdlib__Bigarray;
   function offset(param){return param ? 1 : 0;}
   var Layout = [0, offset];
   function iteri(t, f){
    var
     _v_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _v_),
     _x_ = caml_ba_dim_1(t) - 1 | 0,
     _w_ = 0;
    if(_x_ >= 0){
     var i = _w_;
     for(;;){
      caml_call2(f, i + offset | 0, caml_ba_get_1(t, i + offset | 0));
      var _y_ = i + 1 | 0;
      if(_x_ !== i){var i = _y_; continue;}
      break;
     }
    }
    return 0;
   }
   function init(kind, layout, dim, f){
    var t = caml_call3(Stdlib_Bigarray[19][1], kind, layout, dim);
    iteri
     (t,
      function(i, param){
       return runtime.caml_ba_set_1(t, i, caml_call1(f, i));
      });
    return t;
   }
   function fold(t, init, f){
    var init$0 = [0, init];
    iteri
     (t,
      function(i, param){
       var _u_ = caml_ba_get_1(t, i);
       init$0[1] = caml_call2(f, init$0[1], _u_);
       return 0;
      });
    return init$0[1];
   }
   function to_array(t){
    var _r_ = caml_ba_layout(t), offset = caml_call1(Layout[1], _r_);
    function _s_(i){return caml_ba_get_1(t, i + offset | 0);}
    var _t_ = caml_ba_dim_1(t);
    return caml_call2(Base_Array[27], _t_, _s_);
   }
   function sexp_of_t(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_001 = to_array(t);
    return caml_call2(Base[90], sexp_of_elt, x_001);
   }
   function hash_fold(hash_fold_elt, state, t){
    var _q_ = caml_ba_dim_1(t), state$0 = caml_call2(Base[116], state, _q_);
    return fold(t, state$0, hash_fold_elt);
   }
   function iteri$0(t, f){
    var
     _j_ = caml_ba_layout(t),
     offset = caml_call1(Layout[1], _j_),
     _l_ = caml_ba_dim_1(t) - 1 | 0,
     _k_ = 0;
    if(_l_ >= 0){
     var i = _k_;
     for(;;){
      var _n_ = caml_ba_dim_2(t) - 1 | 0, _m_ = 0;
      if(_n_ >= 0){
       var j = _m_;
       for(;;){
        caml_call3
         (f,
          i + offset | 0,
          j + offset | 0,
          caml_ba_get_2(t, i + offset | 0, j + offset | 0));
        var _p_ = j + 1 | 0;
        if(_n_ !== j){var j = _p_; continue;}
        break;
       }
      }
      var _o_ = i + 1 | 0;
      if(_l_ !== i){var i = _o_; continue;}
      break;
     }
    }
    return 0;
   }
   function init$0(kind, layout, dim1, dim2, f){
    var t = caml_call4(Stdlib_Bigarray[20][1], kind, layout, dim1, dim2);
    iteri$0
     (t,
      function(i, j, param){
       return runtime.caml_ba_set_2(t, i, j, caml_call2(f, i, j));
      });
    return t;
   }
   function fold$0(t, init, f){
    var init$0 = [0, init];
    iteri$0
     (t,
      function(param, _i_, elt){
       init$0[1] = caml_call2(f, init$0[1], elt);
       return 0;
      });
    return init$0[1];
   }
   function to_array$0(t){
    var _d_ = caml_ba_layout(t), offset = caml_call1(Layout[1], _d_);
    function _e_(i){
     function _g_(j){return caml_ba_get_2(t, i + offset | 0, j + offset | 0);}
     var _h_ = caml_ba_dim_2(t);
     return caml_call2(Base_Array[27], _h_, _g_);
    }
    var _f_ = caml_ba_dim_1(t);
    return caml_call2(Base_Array[27], _f_, _e_);
   }
   function sexp_of_t$0(sexp_of_elt, sexp_of_pack, sexp_of_layout, t){
    var x_002 = to_array$0(t), _c_ = caml_call1(Base[90], sexp_of_elt);
    return caml_call2(Base[90], _c_, x_002);
   }
   function hash_fold$0(hash_fold_elt, state, t){
    var
     _a_ = caml_ba_dim_1(t),
     state$0 = caml_call2(Base[116], state, _a_),
     _b_ = caml_ba_dim_2(t),
     state$1 = caml_call2(Base[116], state$0, _b_);
    return fold$0(t, state$1, hash_fold_elt);
   }
   var
    Base_quickcheck_Bigarray_helpe =
      [0,
       Layout,
       [0, sexp_of_t, init, iteri, fold, to_array, hash_fold],
       [0, sexp_of_t$0, init$0, iteri$0, fold$0, to_array$0, hash_fold$0]];
   runtime.caml_register_global
    (3, Base_quickcheck_Bigarray_helpe, "Base_quickcheck__Bigarray_helpers");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer0
//# unitInfo: Requires: Base, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    _a_ = [0, "size"],
    cst_Base_quickcheck_Observer_o =
      "Base_quickcheck.Observer.observe: size < 0";
   function create(f){return f;}
   function observe(t, x, size, hash){
    if(0 <= size) return caml_call3(t, x, size, hash);
    var
     _c_ = [0, [1, [0, _a_, [0, caml_call1(Base[119], size), 0]]], 0],
     _d_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Observer_o),
         _c_]];
    return caml_call1(Base[202], _d_);
   }
   function opaque(param, _b_, hash){return hash;}
   var Base_quickcheck_Observer0 = [0, opaque, create, observe];
   runtime.caml_register_global
    (4, Base_quickcheck_Observer0, "Base_quickcheck__Observer0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Generator
//# unitInfo: Requires: Assert_failure, Base, Base__Applicative, Base__Array, Base__Bytes, Base__Char, Base__Either, Base__Error, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__Lazy, Base__List, Base__Map, Base__Monad, Base__Nativeint, Base__Option, Base__Sequence, Base__Set, Base__Staged, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Observer0, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_lower_bound = "lower_bound",
    cst_src_generator_ml = "src/generator.ml",
    cst_upper_bound = "upper_bound",
    cst_weight = "weight",
    caml_check_bound = runtime.caml_check_bound,
    caml_div = runtime.caml_div,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_div = runtime.caml_int64_div,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul,
    caml_notequal = runtime.caml_notequal,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_Array = global_data.Base__Array,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Set = global_data.Base__Set,
    Base_List = global_data.Base__List,
    Base_String = global_data.Base__String,
    Base_Float = global_data.Base__Float,
    Splittable_random = global_data.Splittable_random,
    Base = global_data.Base,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Int63 = global_data.Base__Int63,
    Base_Char = global_data.Base__Char,
    Base_Lazy = global_data.Base__Lazy,
    Base_Int = global_data.Base__Int,
    Base_Either = global_data.Base__Either,
    Base_Option = global_data.Base__Option,
    Assert_failure = global_data.Assert_failure,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Error = global_data.Base__Error,
    Base_Hash = global_data.Base__Hash,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Staged = global_data.Base__Staged,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Bytes = global_data.Base__Bytes,
    _az_ = [0, 0, 0],
    _au_ = [0, cst_upper_bound],
    _av_ = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_bo =
      "Float.uniform_exclusive: bounds are not finite",
    _aw_ = [0, cst_upper_bound],
    _ax_ = [0, cst_lower_bound],
    cst_Float_uniform_exclusive_re =
      "Float.uniform_exclusive: requested range is empty",
    _h_ = [0, 0],
    _g_ = [0, 1],
    _f_ = [0, cst_src_generator_ml, 198, 4],
    _e_ = [0, cst_src_generator_ml, 225, 6],
    cst_Base_quickcheck_Generator_$5 =
      "Base_quickcheck.Generator.weighted_recursive_union: lists must be non-empty",
    _d_ = [0, cst_src_generator_ml, 160, 14],
    _b_ = [0, cst_weight],
    cst_Base_quickcheck_Generator_$2 =
      "Base_quickcheck.Generator.of_weighted_list: weight is not finite",
    _c_ = [0, cst_weight],
    cst_Base_quickcheck_Generator_$3 =
      "Base_quickcheck.Generator.of_weighted_list: weight is negative",
    cst_Base_quickcheck_Generator_$1 =
      "Base_quickcheck.Generator.of_weighted_list: empty list",
    cst_Base_quickcheck_Generator_$4 =
      "Base_quickcheck.Generator.of_weighted_list: total weight is zero",
    cst_Base_quickcheck_Generator_$0 =
      "Base_quickcheck.Generator.of_list: empty list",
    _a_ = [0, "size"],
    cst_Base_quickcheck_Generator_ =
      "Base_quickcheck.Generator.generate: size < 0";
   function create(f){return caml_call1(Base_Staged[1], f);}
   function generate(t, size, random){
    if(0 <= size) return caml_call3(Base_Staged[2], t, size, random);
    var
     _dv_ = [0, [1, [0, _a_, [0, caml_call1(Base[119], size), 0]]], 0],
     _dw_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_),
         _dv_]];
    return caml_call1(Base[202], _dw_);
   }
   var size = create(function(size, param){return size;});
   function fn(dom, rng){
    return create
            (function(size, random){
              var random$0 = caml_call1(Splittable_random[1][5], random);
              return function(x){
               var
                _dt_ = caml_call1(Base_Hash[7], 0),
                hash =
                  caml_call4(Base_quickcheck_Observer0[3], dom, x, size, _dt_),
                random = caml_call1(Splittable_random[1][4], random$0),
                _du_ = caml_call1(Base_Hash[9], hash);
               caml_call2(Splittable_random[1][3], random, _du_);
               return generate(rng, size, random);};
             });
   }
   function with_size(t, size){
    return create(function(param, random){return generate(t, size, random);});
   }
   function perturb(t, salt){
    return create
            (function(size, random){
              caml_call2(Splittable_random[1][3], random, salt);
              return generate(t, size, random);
             });
   }
   function filter_map(t, f){
    function loop(size, random){
     var size$0 = size;
     for(;;){
      var x = generate(t, size$0, random), match = caml_call1(f, x);
      if(match){var y = match[1]; return y;}
      var size$1 = size$0 + 1 | 0, size$0 = size$1;
     }
    }
    return create(loop);
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function return$0(x){return create(function(param, _ds_){return x;});}
   function map(t, f){
    return create
            (function(size, random){
              return caml_call1(f, generate(t, size, random));
             });
   }
   function apply(tf, tx){
    return create
            (function(size, random){
              var
               f = generate(tf, size, random),
               x = generate(tx, size, random);
              return caml_call1(f, x);
             });
   }
   function bind(t, f){
    return create
            (function(size, random){
              var x = generate(t, size, random);
              return generate(caml_call1(f, x), size, random);
             });
   }
   function all(list){
    return create
            (function(size, random){
              function _dq_(_dr_){return generate(_dr_, size, random);}
              return caml_call2(Base_List[76], list, _dq_);
             });
   }
   function all_unit(list){
    return create
            (function(size, random){
              function _do_(_dp_){return generate(_dp_, size, random);}
              return caml_call2(Base_List[9], list, _do_);
             });
   }
   var
    map$0 = [0, -198771759, map],
    For_applicative =
      caml_call1(Base_Applicative[5], [0, return$0, apply, map$0]),
    both = For_applicative[3],
    map2 = For_applicative[9],
    map3 = For_applicative[10],
    include = For_applicative[13],
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    map$1 = [0, -198771759, map],
    For_monad = caml_call1(Base_Monad[1], [0, bind, return$0, map$1]),
    ignore_m = For_monad[8],
    join = For_monad[7],
    include$0 = For_monad[3],
    symbol_bind = include$0[1],
    symbol_map = include$0[2];
   function of_list(list){
    if(caml_call1(Base_List[8], list)){
     var
      _dn_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$0);
     caml_call1(Base_Error[30], _dn_);
    }
    var
     array = caml_call1(Base_Array[39], list),
     hi = array.length - 1 - 1 | 0,
     lo = 0;
    return create
            (function(param, random){
              var index = caml_call3(Splittable_random[3], random, lo, hi);
              return caml_check_bound(array, index)[1 + index];
             });
   }
   function union(list){return caml_call1(join, of_list(list));}
   function of_weighted_list(alist){
    if(caml_call1(Base_List[8], alist)){
     var
      _df_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$1);
     caml_call1(Base_Error[30], _df_);
    }
    var
     match = caml_call1(Base_List[92], alist),
     values = match[2],
     weights = match[1],
     value_array = caml_call1(Base_Array[39], values);
    function _dg_(param){return 0.;}
    var array = caml_call2(Base_Array[27], value_array.length - 1, _dg_);
    function _dh_(index, acc, weight){
     if(1 - caml_call1(Base_Float[84], weight)){
      var
       _dj_ = [0, [1, [0, _b_, [0, caml_call1(Base[112], weight), 0]]], 0],
       _dk_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$2),
           _dj_]];
      caml_call1(Base_Error[30], _dk_);
     }
     if(caml_call2(Base_Float[13], weight, 0.)){
      var
       _dl_ = [0, [1, [0, _c_, [0, caml_call1(Base[112], weight), 0]]], 0],
       _dm_ =
         [1,
          [0,
           caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$3),
           _dl_]];
      caml_call1(Base_Error[30], _dm_);
     }
     var cumulative = caml_call2(Base[190], acc, weight);
     runtime.caml_array_set(array, index, cumulative);
     return cumulative;
    }
    var sum = caml_call3(Base_List[99], weights, 0., _dh_);
    if(caml_call2(Base_Float[10], sum, 0.)){
     var
      _di_ =
        caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$4);
     caml_call1(Base_Error[30], _di_);
    }
    return create
            (function(param, random){
              var
               choice = caml_call3(Splittable_random[8], random, 0., sum),
               match =
                 caml_call6
                  (Base_Array[5],
                   0,
                   0,
                   array,
                   Base_Float[16],
                   926943384,
                   choice);
              if(! match)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
              var index = match[1];
              return caml_check_bound(value_array, index)[1 + index];
             });
   }
   function weighted_union(alist){
    return caml_call1(join, of_weighted_list(alist));
   }
   function of_lazy(lazy_t){
    return create
            (function(size, random){
              var
               _dd_ = caml_obj_tag(lazy_t),
               _de_ =
                 250 === _dd_
                  ? lazy_t[1]
                  : 246
                    === _dd_
                    ? caml_call1(CamlinternalLazy[2], lazy_t)
                    : lazy_t;
              return generate(_de_, size, random);
             });
   }
   function fixed_point(of_generator){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246,
       function(param){return caml_call1(of_generator, of_lazy(lazy_t));}]);
    var _dc_ = caml_obj_tag(lazy_t);
    return 250 === _dc_
            ? lazy_t[1]
            : 246 === _dc_ ? caml_call1(CamlinternalLazy[2], lazy_t) : lazy_t;
   }
   function weighted_recursive_union(nonrec_list, f){
    return fixed_point
            (function(self){
              function _c7_(param){
               var t = param[2], w = param[1];
               function _db_(n){return with_size(t, n - 1 | 0);}
               return [0, w, caml_call2(For_monad[11][4][2], size, _db_)];
              }
              var
               _c8_ = caml_call1(f, self),
               rec_list = caml_call2(Base_List[76], _c8_, _c7_),
               _c9_ = caml_call1(Base_List[8], nonrec_list),
               _c__ = _c9_ || caml_call1(Base_List[8], rec_list);
              if(_c__){
               var
                _c$_ =
                  caml_call1
                   (Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Generator_$5);
               caml_call1(Base[202], _c$_);
              }
              var
               nonrec_gen = weighted_union(nonrec_list),
               rec_gen =
                 weighted_union(caml_call2(Base[178], nonrec_list, rec_list));
              function _da_(param){return 0 === param ? nonrec_gen : rec_gen;}
              return caml_call2(For_monad[11][4][2], size, _da_);
             });
   }
   function recursive_union(nonrec_list, f){
    function weighted(list){
     function _c6_(t){return [0, 1., t];}
     return caml_call2(Base_List[76], list, _c6_);
    }
    function _c5_(self){return weighted(caml_call1(f, self));}
    return weighted_recursive_union(weighted(nonrec_list), _c5_);
   }
   function sizes(opt, _cS_, param){
    if(opt) var sth = opt[1], min_length = sth; else var min_length = 0;
    if(_cS_)
     var sth$0 = _cS_[1], max_length = sth$0;
    else
     var max_length = Base_Int[60];
    return create
            (function(size, random){
              if(min_length > max_length)
               throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
              var
               upper_bound = min_length + size | 0,
               max_length$0 =
                 min_length <= upper_bound
                  ? caml_call2(Base[189], max_length, upper_bound)
                  : max_length,
               len =
                 caml_call3
                  (Splittable_random[10][1], random, min_length, max_length$0);
              if(0 === len) return 0;
              function _cT_(param){return 0;}
              var
               sizes = caml_call2(Base_Array[27], len, _cT_),
               remaining = size - (len - min_length | 0) | 0,
               max_index = len - 1 | 0,
               _cU_ = 1;
              if(remaining >= 1){
               var for$0 = _cU_;
               for(;;){
                var
                 index =
                   caml_call3(Splittable_random[10][1], random, 0, max_index);
                sizes[1 + index] =
                 caml_check_bound(sizes, index)[1 + index] + 1 | 0;
                var _c1_ = for$0 + 1 | 0;
                if(remaining !== for$0){var for$0 = _c1_; continue;}
                break;
               }
              }
              var _cW_ = max_index - 1 | 0, _cV_ = 0;
              if(_cW_ >= 0){
               var i = _cV_;
               for(;;){
                var
                 j = caml_call3(Splittable_random[3], random, i, max_index);
                caml_call3(Base_Array[74], sizes, i, j);
                var _c0_ = i + 1 | 0;
                if(_cW_ !== i){var i = _c0_; continue;}
                break;
               }
              }
              var _cX_ = len - min_length | 0;
              function _cY_(_c4_){return _c4_;}
              function _cZ_(_c3_, _c2_){return _c3_ + _c2_ | 0;}
              if
               ((caml_call3
                 (Base_Array[16], [0, Base_Int[74], _cZ_], sizes, _cY_)
                + _cX_
                | 0)
                === size)
               return caml_call1(Base_Array[19], sizes);
              throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
             });
   }
   var
    unit = caml_call1(For_monad[11][1], 0),
    bool =
      create
       (function(param, random){
         return caml_call1(Splittable_random[2], random);
        });
   function option(value_t){
    var _cR_ = [0, map(value_t, Base_Option[20]), 0];
    return union([0, caml_call1(For_monad[11][1], 0), _cR_]);
   }
   function either(fst_t, snd_t){
    var _cQ_ = [0, map(snd_t, Base_Either[18]), 0];
    return union([0, map(fst_t, Base_Either[17]), _cQ_]);
   }
   function result(ok_t, err_t){
    function _cP_(param){
     if(0 === param[0]){var ok = param[1]; return [0, ok];}
     var err = param[1];
     return [1, err];
    }
    return map(either(ok_t, err_t), _cP_);
   }
   function list_generic(min_length, max_length, elt_gen){
    function _cM_(sizes){
     function _cO_(size){return with_size(elt_gen, size);}
     return all(caml_call2(Base_List[76], sizes, _cO_));
    }
    var _cN_ = sizes(min_length, max_length, 0);
    return caml_call2(For_monad[11][4][2], _cN_, _cM_);
   }
   function list(elt_gen){return list_generic(0, 0, elt_gen);}
   function list_non_empty(elt_gen){return list_generic(_g_, 0, elt_gen);}
   function list_with_length(elt_gen, length){
    return list_generic([0, length], [0, length], elt_gen);
   }
   function list_filtered(elts){
    var
     elts$0 = caml_call1(Base_Array[39], elts),
     length_of_input = elts$0.length - 1;
    return create
            (function(param, random){
              var
               length_of_output =
                 caml_call3(Splittable_random[3], random, 0, length_of_input);
              function _cF_(_cL_){return _cL_;}
              var
               indices = caml_call2(Base_Array[27], length_of_input, _cF_),
               _cH_ = length_of_output - 1 | 0,
               _cG_ = 0;
              if(_cH_ >= 0){
               var i = _cG_;
               for(;;){
                var
                 j =
                   caml_call3
                    (Splittable_random[3], random, i, length_of_input - 1 | 0);
                caml_call3(Base_Array[74], indices, i, j);
                var _cJ_ = i + 1 | 0;
                if(_cH_ !== i){var i = _cJ_; continue;}
                break;
               }
              }
              caml_call4
               (Base_Array[49],
                _h_,
                [0, length_of_output],
                indices,
                Base_Int[13]);
              function _cI_(i){
               var _cK_ = caml_check_bound(indices, i)[1 + i];
               return caml_check_bound(elts$0, _cK_)[1 + _cK_];
              }
              return caml_call2(Base_List[123], length_of_output, _cI_);
             });
   }
   function list_permutations(list){
    return create
            (function(param, random){
              var
               array = caml_call1(Base_Array[39], list),
               _cD_ = array.length - 1 - 1 | 0,
               _cC_ = 1;
              if(_cD_ >= 1){
               var i = _cC_;
               for(;;){
                var j = caml_call3(Splittable_random[3], random, 0, i);
                caml_call3(Base_Array[74], array, i, j);
                var _cE_ = i + 1 | 0;
                if(_cD_ !== i){var i = _cE_; continue;}
                break;
               }
              }
              return caml_call1(Base_Array[19], array);
             });
   }
   function array(t){var _cB_ = Base_Array[39]; return map(list(t), _cB_);}
   function ref(t){return map(t, function(_cA_){return [0, _cA_];});}
   function lazy_t(t){return map(t, Base_Lazy[21]);}
   function char_uniform_inclusive(lo, hi){
    return create
            (function(param, random){
              var
               _cx_ = caml_call1(Base_Char[29], hi),
               _cy_ = caml_call1(Base_Char[29], lo),
               _cz_ = caml_call3(Splittable_random[3], random, _cy_, _cx_);
              return caml_call1(Base_Char[32], _cz_);
             });
   }
   var
    char_uppercase = char_uniform_inclusive(65, 90),
    char_lowercase = char_uniform_inclusive(97, 122),
    char_digit = char_uniform_inclusive(48, 57),
    char_print_uniform = char_uniform_inclusive(32, 126),
    char_uniform = char_uniform_inclusive(Base_Char[50], Base_Char[51]),
    char_alpha = union([0, char_lowercase, [0, char_uppercase, 0]]),
    char_alphanum =
      weighted_union([0, [0, 52., char_alpha], [0, [0, 10., char_digit], 0]]),
    char_whitespace =
      of_list(caml_call2(Base_List[54], Base_Char[1], Base_Char[42])),
    char_print =
      weighted_union
       ([0, [0, 10., char_alphanum], [0, [0, 1., char_print_uniform], 0]]),
    _i_ = [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[51])], 0],
    char$0 =
      weighted_union
       ([0,
         [0, 100., char_print],
         [0,
          [0, 10., char_uniform],
          [0, [0, 1., caml_call1(For_monad[11][1], Base_Char[50])], _i_]]]);
   function small_int(allow_zero){
    return create
            (function(size, random){
              var
               lower_bound = allow_zero ? 0 : 1,
               upper_bound = size + 1 | 0,
               weighted_low =
                 caml_call3
                  (Splittable_random[10][1],
                   random,
                   0,
                   upper_bound - lower_bound | 0),
               weighted_high = upper_bound - weighted_low | 0;
              return weighted_high;
             });
   }
   var
    small_positive_or_zero_int = small_int(1),
    small_strictly_positive_int = small_int(0);
   function For_integer(Integer){
    function uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[96], random, lo, hi);
              });
    }
    function log_uniform_inclusive(lo, hi){
     return create
             (function(param, random){
               return caml_call3(Integer[97], random, lo, hi);
              });
    }
    function non_uniform(f, lo, hi){
     var
      _cv_ = [0, [0, 0.9, caml_call2(f, lo, hi)], 0],
      _cw_ = [0, [0, 0.05, caml_call1(For_monad[11][1], hi)], _cv_];
     return weighted_union
             ([0, [0, 0.05, caml_call1(For_monad[11][1], lo)], _cw_]);
    }
    function inclusive(_ct_, _cu_){
     return non_uniform(uniform_inclusive, _ct_, _cu_);
    }
    function log_inclusive(_cr_, _cs_){
     return non_uniform(log_uniform_inclusive, _cr_, _cs_);
    }
    var
     uniform_all = uniform_inclusive(Integer[85], Integer[84]),
     let_syntax_004 = log_inclusive(Integer[38], Integer[84]);
    function _cp_(param){
     var magnitude = param[2], negative = param[1];
     return negative ? caml_call1(Integer[70], magnitude) : magnitude;
    }
    var
     _cq_ = caml_call2(For_monad[11][4][4], bool, let_syntax_004),
     all = caml_call2(For_monad[11][4][3], _cq_, _cp_);
    return [0,
            uniform_inclusive,
            log_uniform_inclusive,
            non_uniform,
            inclusive,
            log_inclusive,
            uniform_all,
            all];
   }
   var
    t_sexp_grammar = Base_Int[1],
    of_float = Base_Int[2],
    to_float = Base_Int[3],
    of_int_exn = Base_Int[4],
    to_int_exn = Base_Int[5],
    hash_fold_t = Base_Int[6],
    hash = Base_Int[7],
    t_of_sexp = Base_Int[8],
    sexp_of_t = Base_Int[9],
    of_string = Base_Int[10],
    to_string = Base_Int[11],
    equal = Base_Int[12],
    compare = Base_Int[13],
    min = Base_Int[14],
    max = Base_Int[15],
    ascending = Base_Int[16],
    descending = Base_Int[17],
    between = Base_Int[18],
    clamp_exn = Base_Int[19],
    clamp = Base_Int[20],
    comparator = Base_Int[21],
    pp = Base_Int[22],
    hashable = Base_Int[23],
    is_positive = Base_Int[24],
    is_non_negative = Base_Int[25],
    is_negative = Base_Int[26],
    is_non_positive = Base_Int[27],
    sign = Base_Int[28],
    invariant = Base_Int[29],
    Hex = Base_Int[30],
    to_string_hum = Base_Int[31],
    one = Base_Int[32],
    minus_one = Base_Int[33],
    rem = Base_Int[34],
    round = Base_Int[35],
    round_towards_zero = Base_Int[36],
    round_down = Base_Int[37],
    round_up = Base_Int[38],
    round_nearest = Base_Int[39],
    succ = Base_Int[40],
    pred = Base_Int[41],
    pow = Base_Int[42],
    bit_and = Base_Int[43],
    bit_or = Base_Int[44],
    bit_xor = Base_Int[45],
    bit_not = Base_Int[46],
    popcount = Base_Int[47],
    shift_left = Base_Int[48],
    shift_right = Base_Int[49],
    decr = Base_Int[50],
    incr = Base_Int[51],
    of_int32_exn = Base_Int[52],
    to_int32_exn = Base_Int[53],
    of_int64_exn = Base_Int[54],
    to_int64 = Base_Int[55],
    of_nativeint_exn = Base_Int[56],
    to_nativeint_exn = Base_Int[57],
    of_float_unchecked = Base_Int[58],
    num_bits = Base_Int[59],
    max_value = Base_Int[60],
    min_value = Base_Int[61],
    shift_right_logical = Base_Int[62],
    ceil_pow2 = Base_Int[63],
    floor_pow2 = Base_Int[64],
    ceil_log2 = Base_Int[65],
    floor_log2 = Base_Int[66],
    is_pow2 = Base_Int[67],
    clz = Base_Int[68],
    ctz = Base_Int[69],
    O = Base_Int[70],
    symbol$2 = Base_Int[71],
    lnot = Base_Int[72],
    abs = Base_Int[73],
    zero = Base_Int[74],
    symbol$3 = Base_Int[75],
    symbol$4 = Base_Int[76],
    symbol$5 = Base_Int[77],
    uniform = Splittable_random[3],
    log_uniform = Splittable_random[10][1];
   function _j_(_co_, _cn_){return _co_ >>> _cn_ | 0;}
   function _k_(_cm_, _cl_){return _cm_ >> _cl_;}
   function _l_(_ck_, _cj_){return _ck_ << _cj_;}
   var _m_ = O[2];
   function _n_(_ci_, _ch_){return _ci_ ^ _ch_;}
   function _o_(_cg_, _cf_){return _cg_ | _cf_;}
   function _p_(_ce_, _cd_){return _ce_ & _cd_;}
   var _q_ = O[7], _r_ = O[6], _s_ = O[5], _t_ = O[4];
   function _u_(_cc_){return - _cc_ | 0;}
   var _v_ = O[3];
   function _w_(_cb_, _ca_){return _cb_ !== _ca_ ? 1 : 0;}
   function _x_(_b$_, _b__){return _b$_ < _b__ ? 1 : 0;}
   function _y_(_b9_, _b8_){return _b8_ < _b9_ ? 1 : 0;}
   function _z_(_b7_, _b6_){return _b7_ === _b6_ ? 1 : 0;}
   function _A_(_b5_, _b4_){return _b5_ <= _b4_ ? 1 : 0;}
   function _B_(_b3_, _b2_){return _b2_ <= _b3_ ? 1 : 0;}
   var _C_ = O[1];
   function _D_(_b1_){return - _b1_ | 0;}
   var _E_ = caml_div, _F_ = caml_mul;
   function _G_(_b0_, _bZ_){return _b0_ - _bZ_ | 0;}
   var
    _H_ =
      [0,
       function(_bY_, _bX_){return _bY_ + _bX_ | 0;},
       _G_,
       _F_,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       _x_,
       _w_,
       _v_,
       _u_,
       _t_,
       _s_,
       _r_,
       _q_,
       _p_,
       _o_,
       _n_,
       _m_,
       _l_,
       _k_,
       _j_];
   function _I_(_bW_, _bV_){return _bW_ >>> _bV_ | 0;}
   function _J_(_bU_, _bT_){return _bU_ >> _bT_;}
   function _K_(_bS_, _bR_){return _bS_ << _bR_;}
   function _L_(_bQ_, _bP_){return _bQ_ ^ _bP_;}
   function _M_(_bO_, _bN_){return _bO_ | _bN_;}
   function _N_(_bM_, _bL_){return _bM_ & _bL_;}
   var _O_ = caml_div;
   function _P_(_bK_){return - _bK_ | 0;}
   function _Q_(_bJ_){return - _bJ_ | 0;}
   var _R_ = caml_mul;
   function _S_(_bI_, _bH_){return _bI_ - _bH_ | 0;}
   function _T_(_bG_, _bF_){return _bG_ + _bF_ | 0;}
   function _U_(_bE_, _bD_){return _bE_ !== _bD_ ? 1 : 0;}
   function _V_(_bC_, _bB_){return _bC_ < _bB_ ? 1 : 0;}
   function _W_(_bA_, _bz_){return _bz_ < _bA_ ? 1 : 0;}
   function _X_(_by_, _bx_){return _by_ === _bx_ ? 1 : 0;}
   function _Y_(_bw_, _bv_){return _bw_ <= _bv_ ? 1 : 0;}
   var
    For_int =
      For_integer
       ([0,
         t_sexp_grammar,
         of_float,
         to_float,
         of_int_exn,
         to_int_exn,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         function(_bu_, _bt_){return _bt_ <= _bu_ ? 1 : 0;},
         _Y_,
         _X_,
         _W_,
         _V_,
         _U_,
         equal,
         compare,
         min,
         max,
         ascending,
         descending,
         between,
         clamp_exn,
         clamp,
         comparator,
         pp,
         hashable,
         is_positive,
         is_non_negative,
         is_negative,
         is_non_positive,
         sign,
         invariant,
         Hex,
         to_string_hum,
         zero,
         one,
         minus_one,
         _T_,
         _S_,
         _R_,
         symbol$2,
         _Q_,
         _P_,
         symbol$4,
         symbol$3,
         _O_,
         rem,
         symbol$5,
         _N_,
         _M_,
         _L_,
         lnot,
         _K_,
         _J_,
         round,
         round_towards_zero,
         round_down,
         round_up,
         round_nearest,
         abs,
         succ,
         pred,
         pow,
         bit_and,
         bit_or,
         bit_xor,
         bit_not,
         popcount,
         shift_left,
         shift_right,
         decr,
         incr,
         of_int32_exn,
         to_int32_exn,
         of_int64_exn,
         to_int64,
         of_nativeint_exn,
         to_nativeint_exn,
         of_float_unchecked,
         num_bits,
         max_value,
         min_value,
         _I_,
         shift_right_logical,
         ceil_pow2,
         floor_pow2,
         ceil_log2,
         floor_log2,
         is_pow2,
         clz,
         ctz,
         _H_,
         uniform,
         log_uniform]),
    int$0 = For_int[7],
    int_uniform = For_int[6],
    int_inclusive = For_int[4],
    int_uniform_inclusive = For_int[1],
    int_log_inclusive = For_int[5],
    int_log_uniform_inclusive = For_int[2],
    t_sexp_grammar$0 = Base_Int32[1],
    of_float$0 = Base_Int32[2],
    to_float$0 = Base_Int32[3],
    of_int_exn$0 = Base_Int32[4],
    to_int_exn$0 = Base_Int32[5],
    hash_fold_t$0 = Base_Int32[6],
    hash$0 = Base_Int32[7],
    t_of_sexp$0 = Base_Int32[8],
    sexp_of_t$0 = Base_Int32[9],
    of_string$0 = Base_Int32[10],
    to_string$0 = Base_Int32[11],
    symbol$6 = Base_Int32[12],
    symbol$7 = Base_Int32[13],
    symbol$8 = Base_Int32[14],
    symbol$9 = Base_Int32[15],
    symbol$10 = Base_Int32[16],
    symbol$11 = Base_Int32[17],
    equal$0 = Base_Int32[18],
    compare$0 = Base_Int32[19],
    min$0 = Base_Int32[20],
    max$0 = Base_Int32[21],
    ascending$0 = Base_Int32[22],
    descending$0 = Base_Int32[23],
    between$0 = Base_Int32[24],
    clamp_exn$0 = Base_Int32[25],
    clamp$0 = Base_Int32[26],
    comparator$0 = Base_Int32[27],
    pp$0 = Base_Int32[28],
    hashable$0 = Base_Int32[29],
    is_positive$0 = Base_Int32[30],
    is_non_negative$0 = Base_Int32[31],
    is_negative$0 = Base_Int32[32],
    is_non_positive$0 = Base_Int32[33],
    sign$0 = Base_Int32[34],
    invariant$0 = Base_Int32[35],
    Hex$0 = Base_Int32[36],
    to_string_hum$0 = Base_Int32[37],
    zero$0 = Base_Int32[38],
    one$0 = Base_Int32[39],
    minus_one$0 = Base_Int32[40],
    symbol$12 = Base_Int32[41],
    symbol$13 = Base_Int32[42],
    symbol$14 = Base_Int32[43],
    symbol$15 = Base_Int32[44],
    neg = Base_Int32[45],
    symbol$16 = Base_Int32[46],
    symbol$17 = Base_Int32[47],
    symbol$18 = Base_Int32[48],
    symbol$19 = Base_Int32[49],
    rem$0 = Base_Int32[50],
    symbol$20 = Base_Int32[51],
    land = Base_Int32[52],
    lor = Base_Int32[53],
    lxor = Base_Int32[54],
    lnot$0 = Base_Int32[55],
    lsl = Base_Int32[56],
    asr = Base_Int32[57],
    round$0 = Base_Int32[58],
    round_towards_zero$0 = Base_Int32[59],
    round_down$0 = Base_Int32[60],
    round_up$0 = Base_Int32[61],
    round_nearest$0 = Base_Int32[62],
    abs$0 = Base_Int32[63],
    succ$0 = Base_Int32[64],
    pred$0 = Base_Int32[65],
    pow$0 = Base_Int32[66],
    bit_and$0 = Base_Int32[67],
    bit_or$0 = Base_Int32[68],
    bit_xor$0 = Base_Int32[69],
    bit_not$0 = Base_Int32[70],
    popcount$0 = Base_Int32[71],
    shift_left$0 = Base_Int32[72],
    shift_right$0 = Base_Int32[73],
    decr$0 = Base_Int32[74],
    incr$0 = Base_Int32[75],
    of_int32_exn$0 = Base_Int32[76],
    to_int32_exn$0 = Base_Int32[77],
    of_int64_exn$0 = Base_Int32[78],
    to_int64$0 = Base_Int32[79],
    of_nativeint_exn$0 = Base_Int32[80],
    to_nativeint_exn$0 = Base_Int32[81],
    of_float_unchecked$0 = Base_Int32[82],
    num_bits$0 = Base_Int32[83],
    max_value$0 = Base_Int32[84],
    min_value$0 = Base_Int32[85],
    lsr = Base_Int32[86],
    shift_right_logical$0 = Base_Int32[87],
    ceil_pow2$0 = Base_Int32[88],
    floor_pow2$0 = Base_Int32[89],
    ceil_log2$0 = Base_Int32[90],
    floor_log2$0 = Base_Int32[91],
    is_pow2$0 = Base_Int32[92],
    clz$0 = Base_Int32[93],
    ctz$0 = Base_Int32[94],
    O$0 = Base_Int32[95],
    uniform$0 = Splittable_random[4],
    log_uniform$0 = Splittable_random[10][2],
    For_int32 =
      For_integer
       ([0,
         t_sexp_grammar$0,
         of_float$0,
         to_float$0,
         of_int_exn$0,
         to_int_exn$0,
         hash_fold_t$0,
         hash$0,
         t_of_sexp$0,
         sexp_of_t$0,
         of_string$0,
         to_string$0,
         symbol$6,
         symbol$7,
         symbol$8,
         symbol$9,
         symbol$10,
         symbol$11,
         equal$0,
         compare$0,
         min$0,
         max$0,
         ascending$0,
         descending$0,
         between$0,
         clamp_exn$0,
         clamp$0,
         comparator$0,
         pp$0,
         hashable$0,
         is_positive$0,
         is_non_negative$0,
         is_negative$0,
         is_non_positive$0,
         sign$0,
         invariant$0,
         Hex$0,
         to_string_hum$0,
         zero$0,
         one$0,
         minus_one$0,
         symbol$12,
         symbol$13,
         symbol$14,
         symbol$15,
         neg,
         symbol$16,
         symbol$17,
         symbol$18,
         symbol$19,
         rem$0,
         symbol$20,
         land,
         lor,
         lxor,
         lnot$0,
         lsl,
         asr,
         round$0,
         round_towards_zero$0,
         round_down$0,
         round_up$0,
         round_nearest$0,
         abs$0,
         succ$0,
         pred$0,
         pow$0,
         bit_and$0,
         bit_or$0,
         bit_xor$0,
         bit_not$0,
         popcount$0,
         shift_left$0,
         shift_right$0,
         decr$0,
         incr$0,
         of_int32_exn$0,
         to_int32_exn$0,
         of_int64_exn$0,
         to_int64$0,
         of_nativeint_exn$0,
         to_nativeint_exn$0,
         of_float_unchecked$0,
         num_bits$0,
         max_value$0,
         min_value$0,
         lsr,
         shift_right_logical$0,
         ceil_pow2$0,
         floor_pow2$0,
         ceil_log2$0,
         floor_log2$0,
         is_pow2$0,
         clz$0,
         ctz$0,
         O$0,
         uniform$0,
         log_uniform$0]),
    int32 = For_int32[7],
    int32_uniform = For_int32[6],
    int32_inclusive = For_int32[4],
    int32_uniform_inclusive = For_int32[1],
    int32_log_inclusive = For_int32[5],
    int32_log_uniform_inclusive = For_int32[2],
    t_sexp_grammar$1 = Base_Int63[1],
    of_float$1 = Base_Int63[2],
    to_float$1 = Base_Int63[3],
    of_int_exn$1 = Base_Int63[4],
    to_int_exn$1 = Base_Int63[5],
    hash_fold_t$1 = Base_Int63[6],
    hash$1 = Base_Int63[7],
    t_of_sexp$1 = Base_Int63[8],
    sexp_of_t$1 = Base_Int63[9],
    of_string$1 = Base_Int63[10],
    to_string$1 = Base_Int63[11],
    symbol$21 = Base_Int63[12],
    symbol$22 = Base_Int63[13],
    symbol$23 = Base_Int63[14],
    symbol$24 = Base_Int63[15],
    symbol$25 = Base_Int63[16],
    symbol$26 = Base_Int63[17],
    equal$1 = Base_Int63[18],
    compare$1 = Base_Int63[19],
    min$1 = Base_Int63[20],
    max$1 = Base_Int63[21],
    ascending$1 = Base_Int63[22],
    descending$1 = Base_Int63[23],
    between$1 = Base_Int63[24],
    clamp_exn$1 = Base_Int63[25],
    clamp$1 = Base_Int63[26],
    comparator$1 = Base_Int63[27],
    pp$1 = Base_Int63[28],
    hashable$1 = Base_Int63[29],
    is_positive$1 = Base_Int63[30],
    is_non_negative$1 = Base_Int63[31],
    is_negative$1 = Base_Int63[32],
    is_non_positive$1 = Base_Int63[33],
    sign$1 = Base_Int63[34],
    invariant$1 = Base_Int63[35],
    Hex$1 = Base_Int63[36],
    to_string_hum$1 = Base_Int63[37],
    zero$1 = Base_Int63[38],
    one$1 = Base_Int63[39],
    minus_one$1 = Base_Int63[40],
    symbol$27 = Base_Int63[41],
    symbol$28 = Base_Int63[42],
    symbol$29 = Base_Int63[43],
    symbol$30 = Base_Int63[44],
    neg$0 = Base_Int63[45],
    symbol$31 = Base_Int63[46],
    symbol$32 = Base_Int63[47],
    symbol$33 = Base_Int63[48],
    symbol$34 = Base_Int63[49],
    rem$1 = Base_Int63[50],
    symbol$35 = Base_Int63[51],
    land$0 = Base_Int63[52],
    lor$0 = Base_Int63[53],
    lxor$0 = Base_Int63[54],
    lnot$1 = Base_Int63[55],
    lsl$0 = Base_Int63[56],
    asr$0 = Base_Int63[57],
    round$1 = Base_Int63[58],
    round_towards_zero$1 = Base_Int63[59],
    round_down$1 = Base_Int63[60],
    round_up$1 = Base_Int63[61],
    round_nearest$1 = Base_Int63[62],
    abs$1 = Base_Int63[63],
    succ$1 = Base_Int63[64],
    pred$1 = Base_Int63[65],
    pow$1 = Base_Int63[66],
    bit_and$1 = Base_Int63[67],
    bit_or$1 = Base_Int63[68],
    bit_xor$1 = Base_Int63[69],
    bit_not$1 = Base_Int63[70],
    popcount$1 = Base_Int63[71],
    shift_left$1 = Base_Int63[72],
    shift_right$1 = Base_Int63[73],
    decr$1 = Base_Int63[74],
    incr$1 = Base_Int63[75],
    of_int32_exn$1 = Base_Int63[76],
    to_int32_exn$1 = Base_Int63[77],
    of_int64_exn$1 = Base_Int63[78],
    to_int64$1 = Base_Int63[79],
    of_nativeint_exn$1 = Base_Int63[80],
    to_nativeint_exn$1 = Base_Int63[81],
    of_float_unchecked$1 = Base_Int63[82],
    num_bits$1 = Base_Int63[83],
    max_value$1 = Base_Int63[84],
    min_value$1 = Base_Int63[85],
    lsr$0 = Base_Int63[86],
    shift_right_logical$1 = Base_Int63[87],
    ceil_pow2$1 = Base_Int63[88],
    floor_pow2$1 = Base_Int63[89],
    ceil_log2$1 = Base_Int63[90],
    is_pow2$1 = Base_Int63[91],
    clz$1 = Base_Int63[92],
    ctz$1 = Base_Int63[93],
    O$1 = Base_Int63[94],
    floor_log2$1 = Base_Int63[113],
    uniform$1 = Splittable_random[5],
    log_uniform$1 = Splittable_random[10][3],
    For_int63 =
      For_integer
       ([0,
         t_sexp_grammar$1,
         of_float$1,
         to_float$1,
         of_int_exn$1,
         to_int_exn$1,
         hash_fold_t$1,
         hash$1,
         t_of_sexp$1,
         sexp_of_t$1,
         of_string$1,
         to_string$1,
         symbol$21,
         symbol$22,
         symbol$23,
         symbol$24,
         symbol$25,
         symbol$26,
         equal$1,
         compare$1,
         min$1,
         max$1,
         ascending$1,
         descending$1,
         between$1,
         clamp_exn$1,
         clamp$1,
         comparator$1,
         pp$1,
         hashable$1,
         is_positive$1,
         is_non_negative$1,
         is_negative$1,
         is_non_positive$1,
         sign$1,
         invariant$1,
         Hex$1,
         to_string_hum$1,
         zero$1,
         one$1,
         minus_one$1,
         symbol$27,
         symbol$28,
         symbol$29,
         symbol$30,
         neg$0,
         symbol$31,
         symbol$32,
         symbol$33,
         symbol$34,
         rem$1,
         symbol$35,
         land$0,
         lor$0,
         lxor$0,
         lnot$1,
         lsl$0,
         asr$0,
         round$1,
         round_towards_zero$1,
         round_down$1,
         round_up$1,
         round_nearest$1,
         abs$1,
         succ$1,
         pred$1,
         pow$1,
         bit_and$1,
         bit_or$1,
         bit_xor$1,
         bit_not$1,
         popcount$1,
         shift_left$1,
         shift_right$1,
         decr$1,
         incr$1,
         of_int32_exn$1,
         to_int32_exn$1,
         of_int64_exn$1,
         to_int64$1,
         of_nativeint_exn$1,
         to_nativeint_exn$1,
         of_float_unchecked$1,
         num_bits$1,
         max_value$1,
         min_value$1,
         lsr$0,
         shift_right_logical$1,
         ceil_pow2$1,
         floor_pow2$1,
         ceil_log2$1,
         floor_log2$1,
         is_pow2$1,
         clz$1,
         ctz$1,
         O$1,
         uniform$1,
         log_uniform$1]),
    int63 = For_int63[7],
    int63_uniform = For_int63[6],
    int63_inclusive = For_int63[4],
    int63_uniform_inclusive = For_int63[1],
    int63_log_inclusive = For_int63[5],
    int63_log_uniform_inclusive = For_int63[2],
    t_sexp_grammar$2 = Base_Int64[1],
    of_float$2 = Base_Int64[2],
    to_float$2 = Base_Int64[3],
    of_int_exn$2 = Base_Int64[4],
    to_int_exn$2 = Base_Int64[5],
    hash_fold_t$2 = Base_Int64[6],
    hash$2 = Base_Int64[7],
    t_of_sexp$2 = Base_Int64[8],
    sexp_of_t$2 = Base_Int64[9],
    of_string$2 = Base_Int64[10],
    to_string$2 = Base_Int64[11],
    equal$2 = Base_Int64[12],
    compare$2 = Base_Int64[13],
    min$2 = Base_Int64[14],
    max$2 = Base_Int64[15],
    ascending$2 = Base_Int64[16],
    descending$2 = Base_Int64[17],
    between$2 = Base_Int64[18],
    clamp_exn$2 = Base_Int64[19],
    clamp$2 = Base_Int64[20],
    comparator$2 = Base_Int64[21],
    pp$2 = Base_Int64[22],
    hashable$2 = Base_Int64[23],
    is_positive$2 = Base_Int64[24],
    is_non_negative$2 = Base_Int64[25],
    is_negative$2 = Base_Int64[26],
    is_non_positive$2 = Base_Int64[27],
    sign$2 = Base_Int64[28],
    invariant$2 = Base_Int64[29],
    Hex$2 = Base_Int64[30],
    to_string_hum$2 = Base_Int64[31],
    one$2 = Base_Int64[32],
    minus_one$2 = Base_Int64[33],
    rem$2 = Base_Int64[34],
    round$2 = Base_Int64[35],
    round_towards_zero$2 = Base_Int64[36],
    round_down$2 = Base_Int64[37],
    round_up$2 = Base_Int64[38],
    round_nearest$2 = Base_Int64[39],
    succ$2 = Base_Int64[40],
    pred$2 = Base_Int64[41],
    pow$2 = Base_Int64[42],
    bit_and$2 = Base_Int64[43],
    bit_or$2 = Base_Int64[44],
    bit_xor$2 = Base_Int64[45],
    bit_not$2 = Base_Int64[46],
    popcount$2 = Base_Int64[47],
    shift_left$2 = Base_Int64[48],
    shift_right$2 = Base_Int64[49],
    decr$2 = Base_Int64[50],
    incr$2 = Base_Int64[51],
    of_int32_exn$2 = Base_Int64[52],
    to_int32_exn$2 = Base_Int64[53],
    of_int64_exn$2 = Base_Int64[54],
    to_int64$2 = Base_Int64[55],
    of_nativeint_exn$2 = Base_Int64[56],
    to_nativeint_exn$2 = Base_Int64[57],
    of_float_unchecked$2 = Base_Int64[58],
    num_bits$2 = Base_Int64[59],
    max_value$2 = Base_Int64[60],
    min_value$2 = Base_Int64[61],
    shift_right_logical$2 = Base_Int64[62],
    ceil_pow2$2 = Base_Int64[63],
    floor_pow2$2 = Base_Int64[64],
    ceil_log2$2 = Base_Int64[65],
    floor_log2$2 = Base_Int64[66],
    is_pow2$2 = Base_Int64[67],
    clz$2 = Base_Int64[68],
    ctz$2 = Base_Int64[69],
    O$2 = Base_Int64[70],
    symbol$36 = Base_Int64[71],
    lnot$2 = Base_Int64[72],
    abs$2 = Base_Int64[73],
    zero$2 = Base_Int64[74],
    symbol$37 = Base_Int64[75],
    symbol$38 = Base_Int64[76],
    symbol$39 = Base_Int64[77],
    uniform$2 = Splittable_random[6],
    log_uniform$2 = Splittable_random[10][4],
    For_int64 =
      For_integer
       ([0,
         t_sexp_grammar$2,
         of_float$2,
         to_float$2,
         of_int_exn$2,
         to_int_exn$2,
         hash_fold_t$2,
         hash$2,
         t_of_sexp$2,
         sexp_of_t$2,
         of_string$2,
         to_string$2,
         caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         caml_notequal,
         equal$2,
         compare$2,
         min$2,
         max$2,
         ascending$2,
         descending$2,
         between$2,
         clamp_exn$2,
         clamp$2,
         comparator$2,
         pp$2,
         hashable$2,
         is_positive$2,
         is_non_negative$2,
         is_negative$2,
         is_non_positive$2,
         sign$2,
         invariant$2,
         Hex$2,
         to_string_hum$2,
         zero$2,
         one$2,
         minus_one$2,
         caml_int64_add,
         caml_int64_sub,
         caml_int64_mul,
         symbol$36,
         caml_int64_neg,
         caml_int64_neg,
         symbol$38,
         symbol$37,
         caml_int64_div,
         rem$2,
         symbol$39,
         caml_int64_and,
         caml_int64_or,
         caml_int64_xor,
         lnot$2,
         caml_int64_shift_left,
         caml_int64_shift_right,
         round$2,
         round_towards_zero$2,
         round_down$2,
         round_up$2,
         round_nearest$2,
         abs$2,
         succ$2,
         pred$2,
         pow$2,
         bit_and$2,
         bit_or$2,
         bit_xor$2,
         bit_not$2,
         popcount$2,
         shift_left$2,
         shift_right$2,
         decr$2,
         incr$2,
         of_int32_exn$2,
         to_int32_exn$2,
         of_int64_exn$2,
         to_int64$2,
         of_nativeint_exn$2,
         to_nativeint_exn$2,
         of_float_unchecked$2,
         num_bits$2,
         max_value$2,
         min_value$2,
         caml_int64_shift_right_unsigne,
         shift_right_logical$2,
         ceil_pow2$2,
         floor_pow2$2,
         ceil_log2$2,
         floor_log2$2,
         is_pow2$2,
         clz$2,
         ctz$2,
         [0,
          caml_int64_add,
          caml_int64_sub,
          caml_int64_mul,
          caml_int64_div,
          caml_int64_neg,
          O$2[1],
          caml_greaterequal,
          caml_lessequal,
          caml_equal,
          caml_greaterthan,
          caml_lessthan,
          caml_notequal,
          O$2[3],
          caml_int64_neg,
          O$2[4],
          O$2[5],
          O$2[6],
          O$2[7],
          caml_int64_and,
          caml_int64_or,
          caml_int64_xor,
          O$2[2],
          caml_int64_shift_left,
          caml_int64_shift_right,
          caml_int64_shift_right_unsigne],
         uniform$2,
         log_uniform$2]),
    int64 = For_int64[7],
    int64_uniform = For_int64[6],
    int64_inclusive = For_int64[4],
    int64_uniform_inclusive = For_int64[1],
    int64_log_inclusive = For_int64[5],
    int64_log_uniform_inclusive = For_int64[2],
    t_sexp_grammar$3 = Base_Nativeint[1],
    of_float$3 = Base_Nativeint[2],
    to_float$3 = Base_Nativeint[3],
    of_int_exn$3 = Base_Nativeint[4],
    to_int_exn$3 = Base_Nativeint[5],
    hash_fold_t$3 = Base_Nativeint[6],
    hash$3 = Base_Nativeint[7],
    t_of_sexp$3 = Base_Nativeint[8],
    sexp_of_t$3 = Base_Nativeint[9],
    of_string$3 = Base_Nativeint[10],
    to_string$3 = Base_Nativeint[11],
    symbol$40 = Base_Nativeint[12],
    symbol$41 = Base_Nativeint[13],
    symbol$42 = Base_Nativeint[14],
    symbol$43 = Base_Nativeint[15],
    symbol$44 = Base_Nativeint[16],
    symbol$45 = Base_Nativeint[17],
    equal$3 = Base_Nativeint[18],
    compare$3 = Base_Nativeint[19],
    min$3 = Base_Nativeint[20],
    max$3 = Base_Nativeint[21],
    ascending$3 = Base_Nativeint[22],
    descending$3 = Base_Nativeint[23],
    between$3 = Base_Nativeint[24],
    clamp_exn$3 = Base_Nativeint[25],
    clamp$3 = Base_Nativeint[26],
    comparator$3 = Base_Nativeint[27],
    pp$3 = Base_Nativeint[28],
    hashable$3 = Base_Nativeint[29],
    is_positive$3 = Base_Nativeint[30],
    is_non_negative$3 = Base_Nativeint[31],
    is_negative$3 = Base_Nativeint[32],
    is_non_positive$3 = Base_Nativeint[33],
    sign$3 = Base_Nativeint[34],
    invariant$3 = Base_Nativeint[35],
    Hex$3 = Base_Nativeint[36],
    to_string_hum$3 = Base_Nativeint[37],
    zero$3 = Base_Nativeint[38],
    one$3 = Base_Nativeint[39],
    minus_one$3 = Base_Nativeint[40],
    symbol$46 = Base_Nativeint[41],
    symbol$47 = Base_Nativeint[42],
    symbol$48 = Base_Nativeint[43],
    symbol$49 = Base_Nativeint[44],
    neg$1 = Base_Nativeint[45],
    symbol$50 = Base_Nativeint[46],
    symbol$51 = Base_Nativeint[47],
    symbol$52 = Base_Nativeint[48],
    symbol$53 = Base_Nativeint[49],
    rem$3 = Base_Nativeint[50],
    symbol$54 = Base_Nativeint[51],
    land$1 = Base_Nativeint[52],
    lor$1 = Base_Nativeint[53],
    lxor$1 = Base_Nativeint[54],
    lnot$3 = Base_Nativeint[55],
    lsl$1 = Base_Nativeint[56],
    asr$1 = Base_Nativeint[57],
    round$3 = Base_Nativeint[58],
    round_towards_zero$3 = Base_Nativeint[59],
    round_down$3 = Base_Nativeint[60],
    round_up$3 = Base_Nativeint[61],
    round_nearest$3 = Base_Nativeint[62],
    abs$3 = Base_Nativeint[63],
    succ$3 = Base_Nativeint[64],
    pred$3 = Base_Nativeint[65],
    pow$3 = Base_Nativeint[66],
    bit_and$3 = Base_Nativeint[67],
    bit_or$3 = Base_Nativeint[68],
    bit_xor$3 = Base_Nativeint[69],
    bit_not$3 = Base_Nativeint[70],
    popcount$3 = Base_Nativeint[71],
    shift_left$3 = Base_Nativeint[72],
    shift_right$3 = Base_Nativeint[73],
    decr$3 = Base_Nativeint[74],
    incr$3 = Base_Nativeint[75],
    of_int32_exn$3 = Base_Nativeint[76],
    to_int32_exn$3 = Base_Nativeint[77],
    of_int64_exn$3 = Base_Nativeint[78],
    to_int64$3 = Base_Nativeint[79],
    of_nativeint_exn$3 = Base_Nativeint[80],
    to_nativeint_exn$3 = Base_Nativeint[81],
    of_float_unchecked$3 = Base_Nativeint[82],
    num_bits$3 = Base_Nativeint[83],
    max_value$3 = Base_Nativeint[84],
    min_value$3 = Base_Nativeint[85],
    lsr$1 = Base_Nativeint[86],
    shift_right_logical$3 = Base_Nativeint[87],
    ceil_pow2$3 = Base_Nativeint[88],
    floor_pow2$3 = Base_Nativeint[89],
    ceil_log2$3 = Base_Nativeint[90],
    floor_log2$3 = Base_Nativeint[91],
    is_pow2$3 = Base_Nativeint[92],
    clz$3 = Base_Nativeint[93],
    ctz$3 = Base_Nativeint[94],
    O$3 = Base_Nativeint[95],
    uniform$3 = Splittable_random[7],
    log_uniform$3 = Splittable_random[10][5],
    For_nativeint =
      For_integer
       ([0,
         t_sexp_grammar$3,
         of_float$3,
         to_float$3,
         of_int_exn$3,
         to_int_exn$3,
         hash_fold_t$3,
         hash$3,
         t_of_sexp$3,
         sexp_of_t$3,
         of_string$3,
         to_string$3,
         symbol$40,
         symbol$41,
         symbol$42,
         symbol$43,
         symbol$44,
         symbol$45,
         equal$3,
         compare$3,
         min$3,
         max$3,
         ascending$3,
         descending$3,
         between$3,
         clamp_exn$3,
         clamp$3,
         comparator$3,
         pp$3,
         hashable$3,
         is_positive$3,
         is_non_negative$3,
         is_negative$3,
         is_non_positive$3,
         sign$3,
         invariant$3,
         Hex$3,
         to_string_hum$3,
         zero$3,
         one$3,
         minus_one$3,
         symbol$46,
         symbol$47,
         symbol$48,
         symbol$49,
         neg$1,
         symbol$50,
         symbol$51,
         symbol$52,
         symbol$53,
         rem$3,
         symbol$54,
         land$1,
         lor$1,
         lxor$1,
         lnot$3,
         lsl$1,
         asr$1,
         round$3,
         round_towards_zero$3,
         round_down$3,
         round_up$3,
         round_nearest$3,
         abs$3,
         succ$3,
         pred$3,
         pow$3,
         bit_and$3,
         bit_or$3,
         bit_xor$3,
         bit_not$3,
         popcount$3,
         shift_left$3,
         shift_right$3,
         decr$3,
         incr$3,
         of_int32_exn$3,
         to_int32_exn$3,
         of_int64_exn$3,
         to_int64$3,
         of_nativeint_exn$3,
         to_nativeint_exn$3,
         of_float_unchecked$3,
         num_bits$3,
         max_value$3,
         min_value$3,
         lsr$1,
         shift_right_logical$3,
         ceil_pow2$3,
         floor_pow2$3,
         ceil_log2$3,
         floor_log2$3,
         is_pow2$3,
         clz$3,
         ctz$3,
         O$3,
         uniform$3,
         log_uniform$3]),
    nativeint = For_nativeint[7],
    nativeint_uniform = For_nativeint[6],
    nativeint_inclusive = For_nativeint[4],
    nativeint_uniform_inclusive = For_nativeint[1],
    nativeint_log_inclusive = For_nativeint[5],
    nativeint_log_uniform_inclusiv = For_nativeint[2],
    float_zero_exponent = caml_call1(Base_Float[121], 0.),
    float_zero_mantissa = caml_call1(Base_Float[122], 0.),
    float_max_positive_subnormal_v =
      caml_call2(Base_Float[51], 759637122, Base_Float[47]),
    float_subnormal_exponent = caml_call1(Base_Float[121], Base_Float[46]),
    float_min_subnormal_mantissa = caml_call1(Base_Float[122], Base_Float[46]),
    float_max_subnormal_mantissa =
      caml_call1(Base_Float[122], float_max_positive_subnormal_v),
    float_max_positive_normal_valu = Base_Float[45],
    float_min_normal_exponent = caml_call1(Base_Float[121], Base_Float[47]),
    float_max_normal_exponent =
      caml_call1(Base_Float[121], float_max_positive_normal_valu),
    float_max_normal_mantissa =
      caml_call1(Base_Float[122], float_max_positive_normal_valu),
    float_inf_exponent = caml_call1(Base_Float[121], Base_Float[33]),
    float_inf_mantissa = caml_call1(Base_Float[122], Base_Float[33]),
    float_nan_exponent = caml_call1(Base_Float[121], Base_Float[32]),
    float_min_nan_mantissa = caml_call1(Base_Int63[64], float_inf_mantissa),
    float_num_mantissa_bits = 52;
   function _Z_(num_bits){
    function _bp_(bits){
     return caml_call2(Base_Int63[72], bits, 52 - num_bits | 0);
    }
    var
     _bq_ = caml_call2(Base_Int63[72], Base_Int63[39], num_bits),
     _br_ = caml_call1(Base_Int63[65], _bq_),
     _bs_ = caml_call2(For_int63[4], Base_Int63[38], _br_);
    return caml_call2(For_monad[11][4][3], _bs_, _bp_);
   }
   var
    ___ = caml_call2(For_int[1], 0, float_num_mantissa_bits),
    float_normal_mantissa = caml_call2(For_monad[11][4][2], ___, _Z_),
    lower_bound = caml_call1(Base_Float[121], 1.),
    _ad_ = 0;
   function _$_(offset){return lower_bound + offset | 0;}
   var
    _aa_ =
      caml_call2(For_int[5], 0, float_max_normal_exponent - lower_bound | 0),
    _ae_ = [0, caml_call2(For_monad[11][4][3], _aa_, _$_), _ad_];
   function _ab_(offset){return lower_bound - offset | 0;}
   var
    _ac_ =
      caml_call2(For_int[5], 0, lower_bound - float_min_normal_exponent | 0),
    float_exponent =
      union([0, caml_call2(For_monad[11][4][3], _ac_, _ab_), _ae_]);
   function _af_(negative){
    return caml_call3
            (Base_Float[119],
             negative,
             float_zero_exponent,
             float_zero_mantissa);
   }
   var
    float_zero = caml_call2(For_monad[11][4][3], bool, _af_),
    let_syntax_012 = caml_call1(For_monad[11][1], float_subnormal_exponent),
    let_syntax_013 =
      caml_call2
       (For_int63[5],
        float_min_subnormal_mantissa,
        float_max_subnormal_mantissa);
   function _ag_(param){
    var
     match = param[2],
     mantissa = match[2],
     exponent = match[1],
     negative = param[1];
    return caml_call3(Base_Float[119], negative, exponent, mantissa);
   }
   var
    _ah_ = caml_call2(For_monad[11][4][4], let_syntax_012, let_syntax_013),
    _ai_ = caml_call2(For_monad[11][4][4], bool, _ah_),
    float_subnormal = caml_call2(For_monad[11][4][3], _ai_, _ag_);
   function _aj_(param){
    var
     match = param[2],
     mantissa = match[2],
     exponent = match[1],
     negative = param[1];
    return caml_call3(Base_Float[119], negative, exponent, mantissa);
   }
   var
    _ak_ =
      caml_call2(For_monad[11][4][4], float_exponent, float_normal_mantissa),
    _al_ = caml_call2(For_monad[11][4][4], bool, _ak_),
    float_normal = caml_call2(For_monad[11][4][3], _al_, _aj_);
   function _am_(negative){
    return caml_call3
            (Base_Float[119],
             negative,
             float_inf_exponent,
             float_inf_mantissa);
   }
   var
    float_infinite = caml_call2(For_monad[11][4][3], bool, _am_),
    let_syntax_021 = caml_call1(For_monad[11][1], float_nan_exponent),
    let_syntax_022 =
      caml_call2
       (For_int63[4], float_min_nan_mantissa, float_max_normal_mantissa);
   function _an_(param){
    var
     match = param[2],
     mantissa = match[2],
     exponent = match[1],
     negative = param[1];
    return caml_call3(Base_Float[119], negative, exponent, mantissa);
   }
   var
    _ao_ = caml_call2(For_monad[11][4][4], let_syntax_021, let_syntax_022),
    _ap_ = caml_call2(For_monad[11][4][4], bool, _ao_),
    float_nan = caml_call2(For_monad[11][4][3], _ap_, _an_);
   function float_of_class(c){
    switch(c){
      case 0:
       return float_infinite;
      case 1:
       return float_nan;
      case 2:
       return float_normal;
      case 3:
       return float_subnormal;
      default: return float_zero;
    }
   }
   function float_matching_classes(filter){
    function _bm_(c){
     if(! caml_call1(filter, c)) return 0;
     var _bn_ = float_of_class(c);
     switch(c){
       case 0:
        var _bo_ = 1.; break;
       case 1:
        var _bo_ = 1.; break;
       case 2:
        var _bo_ = 100.; break;
       case 3:
        var _bo_ = 10.; break;
       default: var _bo_ = 1.;
     }
     return [0, [0, _bo_, _bn_]];
    }
    return weighted_union
            (caml_call2(Base_List[126], Base_Float[113][2], _bm_));
   }
   var
    float_finite =
      float_matching_classes(function(param){return 2 <= param ? 1 : 0;}),
    float_without_nan =
      float_matching_classes(function(param){return 1 === param ? 0 : 1;}),
    float$0 = float_matching_classes(function(param){return 1;}),
    float_finite_non_zero =
      float_matching_classes
       (function(param){return 1 < param - 2 >>> 0 ? 0 : 1;});
   function _aq_(t){return caml_call1(Base_Float[102], t);}
   var
    float_strictly_positive =
      caml_call2(For_monad[11][4][3], float_finite_non_zero, _aq_);
   function _ar_(t){
    var _bl_ = caml_call1(Base_Float[102], t);
    return caml_call1(Base[196], _bl_);
   }
   var
    float_strictly_negative =
      caml_call2(For_monad[11][4][3], float_finite_non_zero, _ar_);
   function _as_(t){return caml_call1(Base_Float[102], t);}
   var
    float_positive_or_zero =
      caml_call2(For_monad[11][4][3], float_finite, _as_);
   function _at_(t){
    var _bk_ = caml_call1(Base_Float[102], t);
    return caml_call1(Base[196], _bk_);
   }
   var
    float_negative_or_zero =
      caml_call2(For_monad[11][4][3], float_finite, _at_);
   function float_uniform_exclusive(lower_bound, upper_bound){
    var
     _bc_ = 1 - caml_call1(Base_Float[84], lower_bound),
     _bd_ = _bc_ || 1 - caml_call1(Base_Float[84], upper_bound);
    if(_bd_){
     var
      _be_ =
        [0, [1, [0, _au_, [0, caml_call1(Base[112], upper_bound), 0]]], 0],
      _bf_ =
        [0, [1, [0, _av_, [0, caml_call1(Base[112], lower_bound), 0]]], _be_],
      _bg_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Float_uniform_exclusive_bo),
          _bf_]];
     caml_call1(Base[202], _bg_);
    }
    var
     lower_inclusive = caml_call2(Base_Float[51], 19067, lower_bound),
     upper_inclusive = caml_call2(Base_Float[51], 759637122, upper_bound);
    if(caml_call2(Base_Float[103][11], lower_inclusive, upper_inclusive)){
     var
      _bh_ =
        [0, [1, [0, _aw_, [0, caml_call1(Base[112], upper_bound), 0]]], 0],
      _bi_ =
        [0, [1, [0, _ax_, [0, caml_call1(Base[112], lower_bound), 0]]], _bh_],
      _bj_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Float_uniform_exclusive_re),
          _bi_]];
     caml_call1(Base[202], _bj_);
    }
    return create
            (function(param, random){
              return caml_call3
                      (Splittable_random[8],
                       random,
                       lower_inclusive,
                       upper_inclusive);
             });
   }
   function float_inclusive(lower_bound, upper_bound){
    if(caml_call2(Base_Float[15], lower_bound, upper_bound))
     return caml_call1(For_monad[11][1], lower_bound);
    var _a__ = caml_call2(Base_Float[51], 19067, lower_bound);
    if(caml_call2(Base_Float[11], _a__, upper_bound)){
     var _a$_ = [0, caml_call1(For_monad[11][1], upper_bound), 0];
     return union([0, caml_call1(For_monad[11][1], lower_bound), _a$_]);
    }
    var
     _ba_ =
       [0, [0, 0.9, float_uniform_exclusive(lower_bound, upper_bound)], 0],
     _bb_ = [0, [0, 0.05, caml_call1(For_monad[11][1], upper_bound)], _ba_];
    return weighted_union
            ([0, [0, 0.05, caml_call1(For_monad[11][1], lower_bound)], _bb_]);
   }
   function string_with_length_of(char_gen, length){
    var _a9_ = list_with_length(char_gen, length);
    return map(_a9_, Base_String[123]);
   }
   function string_of(char_gen){
    return bind
            (small_positive_or_zero_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   function string_non_empty_of(char_gen){
    return bind
            (small_strictly_positive_int,
             function(length){return string_with_length_of(char_gen, length);});
   }
   var
    string = string_of(char$0),
    string_non_empty = string_non_empty_of(char$0);
   function string_with_length(length){
    return string_with_length_of(char$0, length);
   }
   var bytes = map(string, Base_Bytes[25]);
   function sexp_of(atom){
    return fixed_point
            (function(self){
              function _a3_(size){
               function _a4_(param){
                if(0 === param){
                 var _a6_ = function(atom){return [0, atom];};
                 return caml_call2(For_monad[11][4][3], atom, _a6_);
                }
                function _a7_(list){return [1, list];}
                var _a8_ = list(self);
                return caml_call2(For_monad[11][4][3], _a8_, _a7_);
               }
               var _a5_ = caml_call2(For_int[2], 0, size + 1 | 0);
               return caml_call2(For_monad[11][4][2], _a5_, _a4_);
              }
              return caml_call2(For_monad[11][4][2], size, _a3_);
             });
   }
   var sexp = sexp_of(string);
   function map_tree_using_comparator(comparator, key_gen, data_gen){
    function _aX_(keys){
     var keys$0 = caml_call2(Base_List[114], keys, comparator[1]);
     function _aZ_(data){
      var
       _a1_ = caml_call2(Base_List[95], keys$0, data),
       _a2_ = caml_call2(Base_Map[104][3][9], comparator, _a1_);
      return caml_call1(For_monad[11][1], _a2_);
     }
     var _a0_ = list_with_length(data_gen, caml_call1(Base_List[7], keys$0));
     return caml_call2(For_monad[11][4][2], _a0_, _aZ_);
    }
    var _aY_ = list(key_gen);
    return caml_call2(For_monad[11][4][2], _aY_, _aX_);
   }
   function set_tree_using_comparator(comparator, elt_gen){
    var _aW_ = caml_call1(Base_Set[74][3][54], comparator);
    return map(list(elt_gen), _aW_);
   }
   function map_t_m(m, key_gen, data_gen){
    var
     comparator = m[1],
     _aV_ = map_tree_using_comparator(comparator, key_gen, data_gen);
    return map(_aV_, caml_call1(Base_Map[104][95], comparator));
   }
   function set_t_m(m, elt_gen){
    var
     comparator = m[1],
     _aU_ = set_tree_using_comparator(comparator, elt_gen);
    return map(_aU_, caml_call1(Base_Set[74][64], comparator));
   }
   function bigarray1(t, kind, layout){
    function _aQ_(elts){
     var
      elts$0 = caml_call1(Base_Array[39], elts),
      dim = elts$0.length - 1,
      offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
     function _aS_(i){
      var _aT_ = i - offset | 0;
      return caml_check_bound(elts$0, _aT_)[1 + _aT_];
     }
     return caml_call4
             (Base_quickcheck_Bigarray_helpe[2][2], kind, layout, dim, _aS_);
    }
    var _aR_ = list(t);
    return caml_call2(For_monad[11][4][3], _aR_, _aQ_);
   }
   var
    bigstring = bigarray1(char$0, 12, 0),
    float32_vec = bigarray1(float$0, 0, 1),
    float64_vec = bigarray1(float$0, 1, 1);
   function _ay_(max_total_size){
    if(0 === max_total_size) return caml_call1(For_monad[11][1], _az_);
    function _aJ_(a){
     function _aL_(b){
      function _aP_(param){return param ? [0, a, b] : [0, b, a];}
      return caml_call2(For_monad[11][4][3], bool, _aP_);
     }
     var max_b = caml_div(max_total_size, a);
     function _aM_(b_weighted_low){return max_b - b_weighted_low | 0;}
     var
      _aN_ = caml_call2(int_log_uniform_inclusive, 0, max_b),
      _aO_ = caml_call2(For_monad[11][4][3], _aN_, _aM_);
     return caml_call2(For_monad[11][4][2], _aO_, _aL_);
    }
    var _aK_ = caml_call2(int_log_uniform_inclusive, 1, max_total_size);
    return caml_call2(For_monad[11][4][2], _aK_, _aJ_);
   }
   var bigarray2_dim = caml_call2(For_monad[11][4][2], size, _ay_);
   function bigarray2(t, kind, layout){
    function _aD_(param){
     var dim2 = param[2], dim1 = param[1];
     function _aE_(elts){
      var
       elts$0 = caml_call2(Base_Array[78], elts, Base_Array[39]),
       offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
      function _aG_(i, j){
       var _aH_ = j - offset | 0, _aI_ = i - offset | 0;
       return caml_check_bound(caml_check_bound(elts$0, _aI_)[1 + _aI_], _aH_)
               [1 + _aH_];
      }
      return caml_call5
              (Base_quickcheck_Bigarray_helpe[3][2],
               kind,
               layout,
               dim1,
               dim2,
               _aG_);
     }
     var _aF_ = list_with_length(list_with_length(t, dim2), dim1);
     return caml_call2(For_monad[11][4][3], _aF_, _aE_);
    }
    return caml_call2(For_monad[11][4][2], bigarray2_dim, _aD_);
   }
   var
    float32_mat = bigarray2(float$0, 0, 1),
    float64_mat = bigarray2(float$0, 1, 1);
   function coverage(Cmp){
    return function(sample){
     function _aA_(counts, value){
      function _aC_(param){
       if(! param) return 1;
       var prev = param[1];
       return prev + 1 | 0;
      }
      return caml_call3(Base_Map[35], counts, value, _aC_);
     }
     var _aB_ = caml_call1(Base_Map[6], Cmp);
     return caml_call3(Base_Sequence[8], sample, _aB_, _aA_);};
   }
   function monitor(t, f){
    return map(t, function(value){caml_call1(f, value); return value;});
   }
   var
    Debug = [0, coverage, monitor],
    Base_quickcheck_Generator =
      [0,
       unit,
       bool,
       char$0,
       string,
       bytes,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t_m,
       set_t_m,
       map_tree_using_comparator,
       set_tree_using_comparator,
       of_list,
       union,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply,
       map2,
       map3,
       For_applicative[13],
       symbol_bind,
       symbol_map,
       For_monad[3],
       bind,
       return$0,
       map,
       join,
       ignore_m,
       all,
       all_unit,
       For_monad[11],
       size,
       with_size,
       sizes,
       filter,
       filter_map,
       recursive_union,
       fixed_point,
       of_lazy,
       of_weighted_list,
       weighted_union,
       weighted_recursive_union,
       small_positive_or_zero_int,
       small_strictly_positive_int,
       int_uniform,
       int32_uniform,
       int63_uniform,
       int64_uniform,
       nativeint_uniform,
       int_inclusive,
       int32_inclusive,
       int63_inclusive,
       int64_inclusive,
       nativeint_inclusive,
       int_uniform_inclusive,
       int32_uniform_inclusive,
       int63_uniform_inclusive,
       int64_uniform_inclusive,
       nativeint_uniform_inclusive,
       int_log_uniform_inclusive,
       int32_log_uniform_inclusive,
       int63_log_uniform_inclusive,
       int64_log_uniform_inclusive,
       nativeint_log_uniform_inclusiv,
       int_log_inclusive,
       int32_log_inclusive,
       int63_log_inclusive,
       int64_log_inclusive,
       nativeint_log_inclusive,
       float_inclusive,
       float_uniform_exclusive,
       float_without_nan,
       float_finite,
       float_strictly_positive,
       float_strictly_negative,
       float_positive_or_zero,
       float_negative_or_zero,
       float_of_class,
       char_lowercase,
       char_uppercase,
       char_digit,
       char_alpha,
       char_alphanum,
       char_whitespace,
       char_print,
       char_uniform_inclusive,
       string_non_empty,
       string_with_length,
       string_of,
       string_non_empty_of,
       string_with_length_of,
       sexp_of,
       list_non_empty,
       list_with_length,
       list_filtered,
       list_permutations,
       perturb,
       create,
       generate,
       Debug];
   runtime.caml_register_global
    (79, Base_quickcheck_Generator, "Base_quickcheck__Generator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Shrinker
//# unitInfo: Requires: Base__Array, Base__Bytes, Base__Either, Base__Field, Base__Int, Base__Lazy, Base__List, Base__Map, Base__Option, Base__Sequence, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, CamlinternalLazy, Stdlib__Bigarray
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_ba_dim_1 = runtime.caml_ba_dim_1,
    caml_ba_kind = runtime.caml_ba_kind,
    caml_ba_layout = runtime.caml_ba_layout,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_Sequence = global_data.Base__Sequence,
    Base_List = global_data.Base__List,
    Base_Either = global_data.Base__Either,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Lazy = global_data.Base__Lazy,
    Base_Array = global_data.Base__Array,
    Base_Option = global_data.Base__Option,
    Base_Field = global_data.Base__Field,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Int = global_data.Base__Int,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes,
    cst_dim2 = "dim2",
    cst_dim1 = "dim1";
   function atomic(param){return Base_Sequence[38];}
   function create(_ax_){return _ax_;}
   function shrink(_aw_){return _aw_;}
   function map(t, f, f_inverse){
    return function(x){
     var _av_ = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[32], _av_, f);};
   }
   function filter(t, f){
    return function(x){
     var _au_ = caml_call1(t, x);
     return caml_call2(Base_Sequence[51], _au_, f);};
   }
   function filter_map(t, f, f_inverse){
    return function(x){
     var _at_ = caml_call1(t, caml_call1(f_inverse, x));
     return caml_call2(Base_Sequence[78], _at_, f);};
   }
   function of_lazy(lazy_t){
    return function(x){
     var
      _ap_ =
        [246,
         function(_aq_){
          var
           _ar_ = caml_obj_tag(lazy_t),
           _as_ =
             250 === _ar_
              ? lazy_t[1]
              : 246
                === _ar_
                ? caml_call1(CamlinternalLazy[2], lazy_t)
                : lazy_t;
          return caml_call1(_as_, x);
         }];
     return caml_call1(Base_Sequence[105], _ap_);};
   }
   function fixed_point(of_shrinker){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(of_shrinker, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   function both(fst_t, snd_t){
    return function(param){
     var snd = param[2], fst = param[1], _ai_ = 0;
     function _aj_(snd){return [0, fst, snd];}
     var
      _ak_ = caml_call1(snd_t, snd),
      _al_ = [0, caml_call2(Base_Sequence[32], _ak_, _aj_), _ai_];
     function _am_(fst){return [0, fst, snd];}
     var
      _an_ = caml_call1(fst_t, fst),
      _ao_ = [0, caml_call2(Base_Sequence[32], _an_, _am_), _al_];
     return caml_call1(Base_Sequence[68], _ao_);};
   }
   function float32_vec(src){
    var dim = caml_ba_dim_1(src);
    if(0 === dim) return Base_Sequence[38];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout);
    function _ag_(to_skip){
     var to_skip$0 = to_skip + offset | 0;
     function _ah_(i){
      var i$0 = i < to_skip$0 ? i : i + 1 | 0;
      return runtime.caml_ba_get_1(src, i$0);
     }
     return caml_call4
             (Base_quickcheck_Bigarray_helpe[2][2],
              kind,
              layout,
              dim - 1 | 0,
              _ah_);
    }
    return caml_call2(Base_Sequence[77], dim, _ag_);
   }
   function dim2(r){return r[2];}
   function dim1(r){return r[1];}
   function _a_(r, v){return [0, r[1], v];}
   var
    _b_ = 0,
    dim2$0 = [0, function(param){return 0;}, cst_dim2, _b_, dim2, _a_];
   function _c_(r, v){return [0, v, r[2]];}
   var
    _d_ = 0,
    dim1$0 = [0, function(param){return 0;}, cst_dim1, _d_, dim1, _c_];
   function shrink$0(field, src){
    var
     _ac_ = runtime.caml_ba_dim_2(src),
     dims = [0, caml_ba_dim_1(src), _ac_];
    if(0 === caml_call2(Base_Field[3], field, dims)) return Base_Sequence[38];
    var
     kind = caml_ba_kind(src),
     layout = caml_ba_layout(src),
     offset = caml_call1(Base_quickcheck_Bigarray_helpe[1][1], layout),
     match = caml_call3(Base_Field[6], field, dims, Base_Int[41]),
     dim2 = match[2],
     dim1 = match[1];
    function _ad_(to_skip){
     var to_skip$0 = to_skip + offset | 0;
     function skip(i){return i < to_skip$0 ? i : i + 1 | 0;}
     function _af_(dim1, dim2){
      var
       match = caml_call3(Base_Field[6], field, [0, dim1, dim2], skip),
       dim2$0 = match[2],
       dim1$0 = match[1];
      return runtime.caml_ba_get_2(src, dim1$0, dim2$0);
     }
     return caml_call5
             (Base_quickcheck_Bigarray_helpe[3][2],
              kind,
              layout,
              dim1,
              dim2,
              _af_);
    }
    var _ae_ = caml_call2(Base_Field[3], field, dims);
    return caml_call2(Base_Sequence[77], _ae_, _ad_);
   }
   function float32_mat(src){
    var
     _aa_ = [0, shrink$0(dim2$0, src), 0],
     _ab_ = [0, shrink$0(dim1$0, src), _aa_];
    return caml_call1(Base_Sequence[68], _ab_);
   }
   function option(value_t){
    return function(param){
     if(! param) return Base_Sequence[38];
     var
      value = param[1],
      _Y_ = Base_Option[20],
      _Z_ = caml_call1(value_t, value),
      ___ = caml_call2(Base_Sequence[32], _Z_, _Y_),
      _$_ = caml_call1(Base_Sequence[99], 0);
     return caml_call2(Base_Sequence[63], _$_, ___);};
   }
   function list(elt_t){
    return fixed_point
            (function(list_t){
              return function(param){
               if(! param) return Base_Sequence[38];
               var tail = param[2], head = param[1], _Q_ = 0;
               function _R_(tail){return [0, head, tail];}
               var
                _S_ = caml_call1(list_t, tail),
                _T_ = [0, caml_call2(Base_Sequence[32], _S_, _R_), _Q_];
               function _U_(head){return [0, head, tail];}
               var
                _V_ = caml_call1(elt_t, head),
                _W_ = [0, caml_call2(Base_Sequence[32], _V_, _U_), _T_],
                _X_ = [0, caml_call1(Base_Sequence[99], tail), _W_];
               return caml_call1(Base_Sequence[68], _X_);};
             });
   }
   var
    _e_ = Base_String[16],
    _f_ = Base_String[123],
    string = map(list(atomic), _f_, _e_),
    bytes = map(string, Base_Bytes[25], Base_Bytes[26]);
   function array(t){
    var _O_ = Base_Array[19], _P_ = Base_Array[39];
    return map(list(t), _P_, _O_);
   }
   function ref(t){
    function _L_(_N_){return _N_[1];}
    return map(t, function(_M_){return [0, _M_];}, _L_);
   }
   function lazy_t(t){
    function _I_(_J_){
     var _K_ = caml_obj_tag(_J_);
     return 250 === _K_
             ? _J_[1]
             : 246 === _K_ ? caml_call1(CamlinternalLazy[2], _J_) : _J_;
    }
    return map(t, Base_Lazy[21], _I_);
   }
   var
    sexp =
      fixed_point
       (function(shrinker){
         return function(param){
          if(0 === param[0]) return Base_Sequence[38];
          var
           l = param[1],
           _G_ = caml_call1(list(shrinker), l),
           _H_ = Base_Sequence[32],
           shrink_list = caml_call2(_H_, _G_, function(l){return [1, l];}),
           shrink_tree = caml_call1(Base_Sequence[104], l);
          return caml_call1
                  (Base_Sequence[68], [0, shrink_list, [0, shrink_tree, 0]]);};
        });
   function either(fst_t, snd_t){
    return function(either){
     if(0 === either[0]){
      var
       fst = either[1],
       _C_ = Base_Either[17],
       _D_ = caml_call1(fst_t, fst);
      return caml_call2(Base_Sequence[32], _D_, _C_);
     }
     var snd = either[1], _E_ = Base_Either[18], _F_ = caml_call1(snd_t, snd);
     return caml_call2(Base_Sequence[32], _F_, _E_);};
   }
   function result(ok_t, err_t){
    function _A_(param){
     if(0 === param[0]){var ok = param[1]; return [0, ok];}
     var err = param[1];
     return [1, err];
    }
    function _B_(param){
     if(0 === param[0]){var ok = param[1]; return [0, ok];}
     var err = param[1];
     return [1, err];
    }
    return map(either(ok_t, err_t), _B_, _A_);
   }
   function map_tree_using_comparator(comparator, key_t, data_t){
    return function(tree){
     var alist = caml_call2(Base_Map[104][3][66], 0, tree);
     function _q_(param){
      var k = param[1];
      return caml_call3(Base_Map[104][3][39], comparator, tree, k);
     }
     var
      _r_ = caml_call1(Base_Sequence[104], alist),
      drop_keys = caml_call2(Base_Sequence[32], _r_, _q_);
     function _s_(param){
      var
       data = param[2],
       key = param[1],
       tree$0 = caml_call3(Base_Map[104][3][39], comparator, tree, key);
      function _y_(smaller_key){
       var
        match =
          caml_call4
           (Base_Map[104][3][29], comparator, tree$0, smaller_key, data);
       if(typeof match === "number") return 0;
       var tree = match[2];
       return [0, tree];
      }
      var _z_ = caml_call1(key_t, key);
      return caml_call2(Base_Sequence[78], _z_, _y_);
     }
     var
      _t_ = caml_call2(Base_List[76], alist, _s_),
      shrink_keys = caml_call1(Base_Sequence[68], _t_);
     function _u_(param){
      var data = param[2], key = param[1];
      function _w_(smaller_data){
       return caml_call4
               (Base_Map[104][3][31], comparator, tree, key, smaller_data);
      }
      var _x_ = caml_call1(data_t, data);
      return caml_call2(Base_Sequence[32], _x_, _w_);
     }
     var
      _v_ = caml_call2(Base_List[76], alist, _u_),
      shrink_data = caml_call1(Base_Sequence[68], _v_);
     return caml_call1
             (Base_Sequence[68],
              [0, drop_keys, [0, shrink_keys, [0, shrink_data, 0]]]);};
   }
   function set_tree_using_comparator(comparator, elt_t){
    return function(tree){
     var list = caml_call1(Base_Set[74][3][15], tree);
     function _k_(elt){
      return caml_call3(Base_Set[74][3][20], comparator, tree, elt);
     }
     var
      _l_ = caml_call1(Base_Sequence[104], list),
      drop_elts = caml_call2(Base_Sequence[32], _l_, _k_);
     function _m_(elt){
      var tree$0 = caml_call3(Base_Set[74][3][20], comparator, tree, elt);
      function _o_(smaller_elt){
       return caml_call3(Base_Set[74][3][18], comparator, tree$0, smaller_elt)
               ? 0
               : [0,
                 caml_call3
                  (Base_Set[74][3][19], comparator, tree$0, smaller_elt)];
      }
      var _p_ = caml_call1(elt_t, elt);
      return caml_call2(Base_Sequence[78], _p_, _o_);
     }
     var
      _n_ = caml_call2(Base_List[76], list, _m_),
      shrink_elts = caml_call1(Base_Sequence[68], _n_);
     return caml_call1(Base_Sequence[68], [0, drop_elts, [0, shrink_elts, 0]]);};
   }
   function map_t(key_t, data_t){
    return function(map_t){
     var
      comparator = caml_call1(Base_Map[5], map_t),
      _i_ = Base_Map[104][68],
      _j_ = caml_call1(Base_Map[104][95], comparator),
      t = map(map_tree_using_comparator(comparator, key_t, data_t), _j_, _i_);
     return caml_call1(t, map_t);};
   }
   function set_t(elt_t){
    return function(set_t){
     var
      comparator = caml_call1(Base_Set[4], set_t),
      _g_ = Base_Set[74][47],
      _h_ = caml_call1(Base_Set[74][64], comparator),
      t = map(set_tree_using_comparator(comparator, elt_t), _h_, _g_);
     return caml_call1(t, set_t);};
   }
   var
    Base_quickcheck_Shrinker =
      [0,
       atomic,
       atomic,
       atomic,
       atomic,
       string,
       bytes,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       atomic,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       float32_vec,
       float32_vec,
       float32_vec,
       float32_mat,
       float32_mat,
       map_t,
       set_t,
       map_tree_using_comparator,
       set_tree_using_comparator,
       map,
       filter,
       filter_map,
       fixed_point,
       of_lazy,
       create,
       shrink];
   runtime.caml_register_global
    (17, Base_quickcheck_Shrinker, "Base_quickcheck__Shrinker");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_quickcheck_Test_intf = [0];
   runtime.caml_register_global
    (0, Base_quickcheck_Test_intf, "Base_quickcheck__Test_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Test
//# unitInfo: Requires: Base, Base__Backtrace, Base__Error, Base__Field, Base__List, Base__Or_error, Base__Random, Base__Sequence, Base__String, Base_quickcheck__Generator, Base_quickcheck__Shrinker, Base_quickcheck__Test_intf, CamlinternalLazy, Sexplib0__Sexp_conv, Splittable_random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_seed$0 = "seed",
    cst_shrink_count$0 = "shrink_count",
    cst_sizes$0 = "sizes",
    cst_test_count$0 = "test_count";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "...",
    names =
      [0,
       cst_seed$0,
       [0, cst_test_count$0, [0, cst_shrink_count$0, [0, cst_sizes$0, 0]]]],
    Base_Backtrace = global_data.Base__Backtrace,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Sequence = global_data.Base__Sequence,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    Base = global_data.Base,
    Splittable_random = global_data.Splittable_random,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Random = global_data.Base__Random,
    Base_Field = global_data.Base__Field,
    Base_List = global_data.Base__List,
    _w_ = [0, 0],
    _x_ = [0, "error"],
    _y_ = [0, "input"],
    cst_Base_quickcheck_Test_run_t = "Base_quickcheck.Test.run: test failed",
    _u_ = [0, 0],
    _v_ = [0, 0],
    _s_ = [0, "number_of_size_values"],
    _t_ = [0, cst_test_count$0],
    cst_Base_quickcheck_Test_run_i =
      "Base_quickcheck.Test.run: insufficient size values for test count",
    _k_ = [0, cst_sizes$0],
    _l_ = [0, cst_shrink_count$0],
    _m_ = [0, cst_test_count$0],
    _n_ = [0, cst_seed$0],
    _a_ = [0, "Deterministic"],
    _b_ = [0, "Nondeterministic"],
    cst_sizes = cst_sizes$0,
    cst_shrink_count = cst_shrink_count$0,
    cst_test_count = cst_test_count$0,
    cst_seed = cst_seed$0,
    _o_ = [0, 104758188],
    _p_ = [0, 104758188],
    _r_ = [0, "an arbitrary but deterministic string"];
   function sexp_of_t(param){
    if(! param) return _b_;
    var arg0_001 = param[1], res0_002 = caml_call1(Base[164], arg0_001);
    return [1, [0, _a_, [0, res0_002, 0]]];
   }
   var Seed = [0, sexp_of_t];
   function sizes(r){return r[4];}
   function shrink_count(r){return r[3];}
   function test_count(r){return r[2];}
   function seed(r){return r[1];}
   function _c_(r, v){return [0, r[1], r[2], r[3], v];}
   var
    _d_ = 0,
    sizes$0 = [0, function(param){return 0;}, cst_sizes, _d_, sizes, _c_];
   function _e_(r, v){return [0, r[1], r[2], v, r[4]];}
   var
    _f_ = 0,
    shrink_count$0 =
      [0,
       function(param){return 0;},
       cst_shrink_count,
       _f_,
       shrink_count,
       _e_];
   function _g_(r, v){return [0, r[1], v, r[3], r[4]];}
   var
    _h_ = 0,
    test_count$0 =
      [0, function(param){return 0;}, cst_test_count, _h_, test_count, _g_];
   function _i_(r, v){return [0, v, r[2], r[3], r[4]];}
   var
    _j_ = 0,
    seed$0 = [0, function(param){return 0;}, cst_seed, _j_, seed, _i_];
   function make_creator
   (seed_fun, test_count_fun, shrink_count_fun, sizes_fun, compile_acc){
    var
     match = caml_call2(seed_fun, seed$0, compile_acc),
     compile_acc$0 = match[2],
     seed_gen = match[1],
     match$0 = caml_call2(test_count_fun, test_count$0, compile_acc$0),
     compile_acc$1 = match$0[2],
     test_count_gen = match$0[1],
     match$1 = caml_call2(shrink_count_fun, shrink_count$0, compile_acc$1),
     compile_acc$2 = match$1[2],
     shrink_count_gen = match$1[1],
     match$2 = caml_call2(sizes_fun, sizes$0, compile_acc$2),
     compile_acc$3 = match$2[2],
     sizes_gen = match$2[1];
    return [0,
            function(acc){
             var
              seed = caml_call1(seed_gen, acc),
              test_count = caml_call1(test_count_gen, acc),
              shrink_count = caml_call1(shrink_count_gen, acc),
              sizes = caml_call1(sizes_gen, acc);
             return [0, seed, test_count, shrink_count, sizes];
            },
            compile_acc$3];
   }
   function create(seed, test_count, shrink_count, sizes){return [0, seed, test_count, shrink_count, sizes];
   }
   function map(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _aA_ = caml_call1(sizes_fun, sizes$0),
     _aB_ = caml_call1(shrink_count_fun, shrink_count$0),
     _aC_ = caml_call1(test_count_fun, test_count$0);
    return [0, caml_call1(seed_fun, seed$0), _aC_, _aB_, _aA_];
   }
   function iter(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    caml_call1(seed_fun, seed$0);
    caml_call1(test_count_fun, test_count$0);
    caml_call1(shrink_count_fun, shrink_count$0);
    return caml_call1(sizes_fun, sizes$0);
   }
   function fold(init, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    return caml_call2
            (sizes_fun,
             caml_call2
              (shrink_count_fun,
               caml_call2
                (test_count_fun,
                 caml_call2(seed_fun, init, seed$0),
                 test_count$0),
               shrink_count$0),
             sizes$0);
   }
   function map_poly(record){
    var
     _ax_ = [0, caml_call1(record[1], sizes$0), 0],
     _ay_ = [0, caml_call1(record[1], shrink_count$0), _ax_],
     _az_ = [0, caml_call1(record[1], test_count$0), _ay_];
    return [0, caml_call1(record[1], seed$0), _az_];
   }
   function for_all(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _au_ = caml_call1(seed_fun, seed$0),
     _av_ = _au_ ? caml_call1(test_count_fun, test_count$0) : _au_,
     _aw_ = _av_ ? caml_call1(shrink_count_fun, shrink_count$0) : _av_;
    return _aw_ ? caml_call1(sizes_fun, sizes$0) : _aw_;
   }
   function exists(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _at_ = caml_call1(seed_fun, seed$0),
     _ar_ = _at_ || caml_call1(test_count_fun, test_count$0),
     _as_ = _ar_ || caml_call1(shrink_count_fun, shrink_count$0);
    return _as_ ? _as_ : caml_call1(sizes_fun, sizes$0);
   }
   function to_list(seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ao_ = [0, caml_call1(sizes_fun, sizes$0), 0],
     _ap_ = [0, caml_call1(shrink_count_fun, shrink_count$0), _ao_],
     _aq_ = [0, caml_call1(test_count_fun, test_count$0), _ap_];
    return [0, caml_call1(seed_fun, seed$0), _aq_];
   }
   function iter$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    caml_call3(seed_fun, seed$0, record, record[1]);
    caml_call3(test_count_fun, test_count$0, record, record[2]);
    caml_call3(shrink_count_fun, shrink_count$0, record, record[3]);
    return caml_call3(sizes_fun, sizes$0, record, record[4]);
   }
   function fold$0
   (record, init, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var _al_ = record[4], _am_ = record[3], _an_ = record[2];
    return caml_call4
            (sizes_fun,
             caml_call4
              (shrink_count_fun,
               caml_call4
                (test_count_fun,
                 caml_call4(seed_fun, init, seed$0, record, record[1]),
                 test_count$0,
                 record,
                 _an_),
               shrink_count$0,
               record,
               _am_),
             sizes$0,
             record,
             _al_);
   }
   function for_all$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ai_ = caml_call3(seed_fun, seed$0, record, record[1]),
     _aj_ =
       _ai_
        ? caml_call3(test_count_fun, test_count$0, record, record[2])
        : _ai_,
     _ak_ =
       _aj_
        ? caml_call3(shrink_count_fun, shrink_count$0, record, record[3])
        : _aj_;
    return _ak_ ? caml_call3(sizes_fun, sizes$0, record, record[4]) : _ak_;
   }
   function exists$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ah_ = caml_call3(seed_fun, seed$0, record, record[1]),
     _af_ =
       _ah_ || caml_call3(test_count_fun, test_count$0, record, record[2]),
     _ag_ =
       _af_ || caml_call3(shrink_count_fun, shrink_count$0, record, record[3]);
    return _ag_ ? _ag_ : caml_call3(sizes_fun, sizes$0, record, record[4]);
   }
   function to_list$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _ac_ = [0, caml_call3(sizes_fun, sizes$0, record, record[4]), 0],
     _ad_ =
       [0,
        caml_call3(shrink_count_fun, shrink_count$0, record, record[3]),
        _ac_],
     _ae_ =
       [0, caml_call3(test_count_fun, test_count$0, record, record[2]), _ad_];
    return [0, caml_call3(seed_fun, seed$0, record, record[1]), _ae_];
   }
   function map$0
   (record, seed_fun, test_count_fun, shrink_count_fun, sizes_fun){
    var
     _$_ = caml_call3(sizes_fun, sizes$0, record, record[4]),
     _aa_ = caml_call3(shrink_count_fun, shrink_count$0, record, record[3]),
     _ab_ = caml_call3(test_count_fun, test_count$0, record, record[2]);
    return [0,
            caml_call3(seed_fun, seed$0, record, record[1]),
            _ab_,
            _aa_,
            _$_];
   }
   function set_all_mutable_fields(record){
    caml_call1(Base_Field[1][1], record);
    return 0;
   }
   var
    Direct =
      [0,
       iter$0,
       fold$0,
       for_all$0,
       exists$0,
       to_list$0,
       map$0,
       set_all_mutable_fields];
   function sexp_of_t$0(param){
    var
     sizes_010 = param[4],
     shrink_count_008 = param[3],
     test_count_006 = param[2],
     seed_004 = param[1],
     sexp_of_elt = Base[119],
     match = caml_call2(Base_Sequence[88], sizes_010, 100),
     suffix = match[2],
     prefix = match[1],
     prefix$0 = caml_call2(Base_List[76], prefix, sexp_of_elt),
     bnds_003 = 0,
     suffix$0 =
       caml_call1(Base_Sequence[6], suffix)
        ? 0
        : [0, caml_call1(Sexplib0_Sexp_conv[7], cst), 0],
     arg_011 = [1, caml_call2(Base[178], prefix$0, suffix$0)],
     bnds_003$0 = [0, [1, [0, _k_, [0, arg_011, 0]]], bnds_003],
     arg_009 = caml_call1(Base[119], shrink_count_008),
     bnds_003$1 = [0, [1, [0, _l_, [0, arg_009, 0]]], bnds_003$0],
     arg_007 = caml_call1(Base[119], test_count_006),
     bnds_003$2 = [0, [1, [0, _m_, [0, arg_007, 0]]], bnds_003$1],
     arg_005 = caml_call1(Seed[1], seed_004),
     bnds_003$3 = [0, [1, [0, _n_, [0, arg_005, 0]]], bnds_003$2];
    return [1, bnds_003$3];
   }
   var
    _q_ = caml_call5(Base_List[121], 0, _p_, _o_, 0, 30),
    default_config =
      [0, _r_, 10000, 10000, caml_call1(Base_Sequence[97], _q_)],
    lazy_nondeterministic_state =
      [246, function(___){return caml_call2(Base_Random[18][3], 0, 0);}];
   function with_sample(f, opt, _W_, generator){
    if(opt) var sth = opt[1], config = sth; else var config = default_config;
    if(_W_) var sth$0 = _W_[1], examples = sth$0; else var examples = 0;
    var match = config[1];
    if(match)
     var
      string = match[1],
      _O_ = runtime.Base_hash_string(string),
      random = caml_call1(Splittable_random[1][2], _O_);
    else
     var
      _P_ = runtime.caml_obj_tag(lazy_nondeterministic_state),
      _Q_ =
        250 === _P_
         ? lazy_nondeterministic_state[1]
         : 246
           === _P_
           ? caml_call1(CamlinternalLazy[2], lazy_nondeterministic_state)
           : lazy_nondeterministic_state,
      random = caml_call1(Splittable_random[1][1], _Q_);
    function _R_(param){
     var number_of_size_values = param[2], sizes = param[1];
     if(config[2] <= number_of_size_values) return 0;
     var match = caml_call1(Base_Sequence[39], sizes);
     if(match){
      var match$0 = match[1], remaining_sizes = match$0[2], size = match$0[1];
      return [0,
              [0, size, [0, remaining_sizes, number_of_size_values + 1 | 0]]];
     }
     var
      _X_ =
        [0,
         [1, [0, _s_, [0, caml_call1(Base[119], number_of_size_values), 0]]],
         0],
      _Y_ = [0, [1, [0, _t_, [0, caml_call1(Base[119], config[2]), 0]]], _X_],
      _Z_ =
        [1,
         [0,
          caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Test_run_i),
          _Y_]];
     return caml_call1(Base[202], _Z_);
    }
    var
     _S_ = caml_call2(Base_Sequence[42], [0, config[4], 0], _R_),
     _T_ = Base_Sequence[32],
     _U_ =
       caml_call2
        (_T_,
         _S_,
         function(size){
          return caml_call3
                  (Base_quickcheck_Generator[118], generator, size, random);
         }),
     _V_ = caml_call1(Base_Sequence[104], examples),
     sequence = caml_call2(Base_Sequence[63], _V_, _U_);
    return caml_call1(f, sequence);
   }
   function result(f, opt, _J_, m){
    if(opt) var sth = opt[1], config = sth; else var config = default_config;
    if(_J_) var sth$0 = _J_[1], examples = sth$0; else var examples = 0;
    var _K_ = m[2], _L_ = [0, examples], _M_ = [0, config];
    return with_sample
            (function(sequence){
              function _N_(param, input){
               var match = caml_call1(f, input);
               if(0 === match[0]) return _u_;
               var error = match[1];
               return [1, [0, input, error]];
              }
              var match$2 = caml_call3(Base_Sequence[9], sequence, 0, _N_);
              if(0 === match$2[0]) return _v_;
              var
               match$3 = match$2[1],
               error$1 = match$3[2],
               input$0 = match$3[1],
               shrinker = m[3],
               shrink_count$1 = config[3],
               alternates$2 =
                 caml_call2(Base_quickcheck_Shrinker[37], shrinker, input$0),
               shrink_count = shrink_count$1,
               alternates = alternates$2,
               input = input$0,
               error = error$1;
              for(;;){
               if(0 !== shrink_count){
                var
                 shrink_count$0 = shrink_count - 1 | 0,
                 match = caml_call1(Base_Sequence[39], alternates);
                if(match){
                 var
                  match$0 = match[1],
                  alternates$0 = match$0[2],
                  alternate = match$0[1],
                  match$1 = caml_call1(f, alternate);
                 if(0 === match$1[0]){
                  var
                   shrink_count = shrink_count$0,
                   alternates = alternates$0;
                  continue;
                 }
                 var
                  error$0 = match$1[1],
                  alternates$1 =
                    caml_call2
                     (Base_quickcheck_Shrinker[37], shrinker, alternate),
                  shrink_count = shrink_count$0,
                  alternates = alternates$1,
                  input = alternate,
                  error = error$0;
                 continue;
                }
               }
               return [1, [0, input, error]];
              }
             },
             _M_,
             _L_,
             _K_);
   }
   function run(f, config, examples, M){
    function f$0(x){
     function _H_(param){return caml_call1(f, x);}
     var _I_ = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return caml_call2(Base_Or_error[29], _I_, _H_);
    }
    var match = result(f$0, config, examples, M);
    if(0 === match[0]) return _w_;
    var
     match$0 = match[1],
     error = match$0[2],
     input = match$0[1],
     _E_ = [0, [1, [0, _x_, [0, caml_call1(Base_Error[6], error), 0]]], 0],
     _F_ = [0, [1, [0, _y_, [0, caml_call1(M[1], input), 0]]], _E_],
     _G_ =
       [1,
        [0,
         caml_call1(Sexplib0_Sexp_conv[7], cst_Base_quickcheck_Test_run_t),
         _F_]];
    return caml_call1(Base_Or_error[35], _G_);
   }
   function with_sample_exn(f, config, examples, generator){
    function f$0(x){
     function _D_(param){return caml_call1(f, x);}
     return caml_call2(Base_Or_error[28], 0, _D_);
    }
    var _C_ = with_sample(f$0, config, examples, generator);
    return caml_call1(Base_Or_error[31], _C_);
   }
   function run_exn(f, config, examples, testable){
    function f$0(x){
     function _A_(param){return caml_call1(f, x);}
     var _B_ = [0, caml_call1(Base_Backtrace[6][1], 0)];
     return caml_call2(Base_Or_error[28], _B_, _A_);
    }
    var _z_ = run(f$0, config, examples, testable);
    return caml_call1(Base_Or_error[31], _z_);
   }
   var
    Base_quickcheck_Test =
      [0,
       [0,
        Seed,
        sizes,
        shrink_count,
        test_count,
        seed,
        [0,
         names,
         sizes$0,
         shrink_count$0,
         test_count$0,
         seed$0,
         fold,
         make_creator,
         create,
         map,
         iter,
         for_all,
         exists,
         to_list,
         map_poly,
         Direct],
        sexp_of_t$0],
       default_config,
       run,
       run_exn,
       result,
       with_sample,
       with_sample_exn];
   runtime.caml_register_global
    (37, Base_quickcheck_Test, "Base_quickcheck__Test");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Observer
//# unitInfo: Requires: Base, Base__Array, Base__Bool, Base__Bytes, Base__Char, Base__Float, Base__Hash, Base__Int, Base__Int32, Base__Int63, Base__Int64, Base__List, Base__Map, Base__Nativeint, Base__Set, Base__String, Base_quickcheck__Bigarray_helpers, Base_quickcheck__Generator, Base_quickcheck__Observer0, CamlinternalLazy, Splittable_random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Set = global_data.Base__Set,
    Base_Map = global_data.Base__Map,
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_Hash = global_data.Base__Hash,
    Splittable_random = global_data.Splittable_random,
    Base_List = global_data.Base__List,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Array = global_data.Base__Array,
    Base = global_data.Base,
    Base_quickcheck_Observer0 = global_data.Base_quickcheck__Observer0,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int63 = global_data.Base__Int63,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_Float = global_data.Base__Float,
    Base_String = global_data.Base__String,
    Base_quickcheck_Bigarray_helpe =
      global_data.Base_quickcheck__Bigarray_helpers,
    Base_Bytes = global_data.Base__Bytes,
    opaque = Base_quickcheck_Observer0[1],
    create = Base_quickcheck_Observer0[2],
    observe = Base_quickcheck_Observer0[3],
    _a_ = [0, 0];
   function unmap(t, f){
    return caml_call1
            (create,
             function(x, size, hash){
              return caml_call4(observe, t, caml_call1(f, x), size, hash);
             });
   }
   function of_hash_fold(f){
    return caml_call1
            (create, function(x, param, hash){return caml_call2(f, hash, x);});
   }
   function of_lazy(lazy_t){
    return caml_call1
            (create,
             function(x, size, hash){
              var
               _s_ = caml_obj_tag(lazy_t),
               _t_ =
                 250 === _s_
                  ? lazy_t[1]
                  : 246
                    === _s_
                    ? caml_call1(CamlinternalLazy[2], lazy_t)
                    : lazy_t;
              return caml_call4(observe, _t_, x, size, hash);
             });
   }
   function fixed_point(wrap){
    var lazy_t = [];
    runtime.caml_update_dummy
     (lazy_t,
      [246, function(param){return caml_call1(wrap, of_lazy(lazy_t));}]);
    return of_lazy(lazy_t);
   }
   var
    bool = of_hash_fold(Base_Bool[3]),
    char$0 = of_hash_fold(Base_Char[3]),
    int$0 = of_hash_fold(Base_Int[6]),
    int32 = of_hash_fold(Base_Int32[6]),
    int63 = of_hash_fold(Base_Int63[6]),
    int64 = of_hash_fold(Base_Int64[6]),
    nativeint = of_hash_fold(Base_Nativeint[6]),
    float$0 = of_hash_fold(Base_Float[4]),
    string = of_hash_fold(Base_String[26]),
    sexp = of_hash_fold(Base[84][1]),
    bigstring =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[101])),
    float32_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[109])),
    float64_vec =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[2][6], Base[109])),
    float32_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[109])),
    float64_mat =
      of_hash_fold
       (caml_call1(Base_quickcheck_Bigarray_helpe[3][6], Base[109])),
    bytes = unmap(string, Base_Bytes[26]);
   function either(fst_t, snd_t){
    return caml_call1
            (create,
             function(either, size, hash){
              if(0 === either[0]){
               var fst = either[1];
               return caml_call4
                       (observe, fst_t, fst, size, caml_call2(Base[116], hash, 1));
              }
              var snd = either[1];
              return caml_call4
                      (observe, snd_t, snd, size, caml_call2(Base[116], hash, 2));
             });
   }
   function result(ok_t, err_t){
    function _r_(param){
     if(0 === param[0]){var ok = param[1]; return [0, ok];}
     var err = param[1];
     return [1, err];
    }
    return unmap(either(ok_t, err_t), _r_);
   }
   function both(fst_t, snd_t){
    return caml_call1
            (create,
             function(param, size, hash){
              var
               snd = param[2],
               fst = param[1],
               hash$0 = caml_call4(observe, fst_t, fst, size, hash),
               hash$1 = caml_call4(observe, snd_t, snd, size, hash$0);
              return hash$1;
             });
   }
   function option(value_t){
    function _q_(param){
     if(! param) return _a_;
     var value = param[1];
     return [1, value];
    }
    return unmap(either(opaque, value_t), _q_);
   }
   function list(elt_t){
    return caml_call1
            (create,
             function(list, size, hash){
              var
               _m_ = caml_call1(Base_Hash[9], hash),
               random = caml_call1(Splittable_random[1][2], _m_),
               length = caml_call1(Base_List[7], list),
               _n_ =
                 caml_call3
                  (Base_quickcheck_Generator[53], [0, length], [0, length], 0),
               sizes =
                 caml_call3(Base_quickcheck_Generator[118], _n_, size, random);
              function _o_(hash, elt, size){
               return caml_call4
                       (observe, elt_t, elt, size, caml_call2(Base[116], hash, 1));
              }
              var _p_ = caml_call2(Base[116], hash, 0);
              return caml_call4(Base_List[46], list, sizes, _p_, _o_);
             });
   }
   function array(t){var _l_ = Base_Array[19]; return unmap(list(t), _l_);}
   function ref(t){return unmap(t, function(_k_){return _k_[1];});}
   function lazy_t(t){
    return unmap
            (t,
             function(_i_){
              var _j_ = caml_obj_tag(_i_);
              return 250 === _j_
                      ? _i_[1]
                      : 246 === _j_ ? caml_call1(CamlinternalLazy[2], _i_) : _i_;
             });
   }
   function fn(dom, rng){
    return caml_call1
            (create,
             function(f, size, hash){
              var
               _f_ = caml_call1(Base_Hash[9], hash),
               random = caml_call1(Splittable_random[1][2], _f_),
               _g_ = caml_call3(Base_quickcheck_Generator[53], 0, 0, 0),
               sizes =
                 caml_call3
                  (Base_quickcheck_Generator[118], _g_, size * 2 | 0, random);
              function _h_(hash, size){
               var
                x =
                  caml_call3
                   (Base_quickcheck_Generator[118], dom, size, random);
               return caml_call4(observe, rng, caml_call1(f, x), size, hash);
              }
              return caml_call3(Base_List[10], sizes, hash, _h_);
             });
   }
   function map_tree(key_obs, data_obs){
    var arg = Base_Map[104][3][66];
    function _e_(eta){return caml_call2(arg, 0, eta);}
    return unmap(list(both(key_obs, data_obs)), _e_);
   }
   function set_tree(elt_obs){
    var _d_ = Base_Set[74][3][15];
    return unmap(list(elt_obs), _d_);
   }
   function map_t(key_obs, data_obs){
    var _c_ = Base_Map[104][68];
    return unmap(map_tree(key_obs, data_obs), _c_);
   }
   function set_t(elt_obs){
    var _b_ = Base_Set[74][47];
    return unmap(set_tree(elt_obs), _b_);
   }
   var
    Base_quickcheck_Observer =
      [0,
       opaque,
       opaque,
       bool,
       char$0,
       string,
       bytes,
       int$0,
       int32,
       int63,
       int64,
       nativeint,
       float$0,
       sexp,
       option,
       list,
       array,
       ref,
       lazy_t,
       both,
       either,
       result,
       bigstring,
       float32_vec,
       float64_vec,
       float32_mat,
       float64_mat,
       fn,
       map_t,
       set_t,
       map_tree,
       set_tree,
       of_hash_fold,
       unmap,
       fixed_point,
       of_lazy,
       create,
       observe];
   runtime.caml_register_global
    (22, Base_quickcheck_Observer, "Base_quickcheck__Observer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck__Export
//# unitInfo: Requires: Base_quickcheck__Generator, Base_quickcheck__Observer, Base_quickcheck__Shrinker
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Generator = global_data.Base_quickcheck__Generator,
    Base_quickcheck_Observer = global_data.Base_quickcheck__Observer,
    Base_quickcheck_Shrinker = global_data.Base_quickcheck__Shrinker,
    quickcheck_generator_unit = Base_quickcheck_Generator[1],
    quickcheck_generator_bool = Base_quickcheck_Generator[2],
    quickcheck_generator_char = Base_quickcheck_Generator[3],
    quickcheck_generator_string = Base_quickcheck_Generator[4],
    quickcheck_generator_bytes = Base_quickcheck_Generator[5],
    quickcheck_generator_int = Base_quickcheck_Generator[6],
    quickcheck_generator_int32 = Base_quickcheck_Generator[7],
    quickcheck_generator_int64 = Base_quickcheck_Generator[9],
    quickcheck_generator_nativeint = Base_quickcheck_Generator[10],
    quickcheck_generator_float = Base_quickcheck_Generator[11],
    quickcheck_generator_option = Base_quickcheck_Generator[13],
    quickcheck_generator_list = Base_quickcheck_Generator[14],
    quickcheck_generator_array = Base_quickcheck_Generator[15],
    quickcheck_generator_ref = Base_quickcheck_Generator[16],
    quickcheck_generator_lazy_t = Base_quickcheck_Generator[17],
    quickcheck_observer_unit = Base_quickcheck_Observer[2],
    quickcheck_observer_bool = Base_quickcheck_Observer[3],
    quickcheck_observer_char = Base_quickcheck_Observer[4],
    quickcheck_observer_string = Base_quickcheck_Observer[5],
    quickcheck_observer_bytes = Base_quickcheck_Observer[6],
    quickcheck_observer_int = Base_quickcheck_Observer[7],
    quickcheck_observer_int32 = Base_quickcheck_Observer[8],
    quickcheck_observer_int64 = Base_quickcheck_Observer[10],
    quickcheck_observer_nativeint = Base_quickcheck_Observer[11],
    quickcheck_observer_float = Base_quickcheck_Observer[12],
    quickcheck_observer_option = Base_quickcheck_Observer[14],
    quickcheck_observer_list = Base_quickcheck_Observer[15],
    quickcheck_observer_array = Base_quickcheck_Observer[16],
    quickcheck_observer_ref = Base_quickcheck_Observer[17],
    quickcheck_observer_lazy_t = Base_quickcheck_Observer[18],
    quickcheck_shrinker_unit = Base_quickcheck_Shrinker[2],
    quickcheck_shrinker_bool = Base_quickcheck_Shrinker[3],
    quickcheck_shrinker_char = Base_quickcheck_Shrinker[4],
    quickcheck_shrinker_string = Base_quickcheck_Shrinker[5],
    quickcheck_shrinker_bytes = Base_quickcheck_Shrinker[6],
    quickcheck_shrinker_int = Base_quickcheck_Shrinker[7],
    quickcheck_shrinker_int32 = Base_quickcheck_Shrinker[8],
    quickcheck_shrinker_int64 = Base_quickcheck_Shrinker[10],
    quickcheck_shrinker_nativeint = Base_quickcheck_Shrinker[11],
    quickcheck_shrinker_float = Base_quickcheck_Shrinker[12],
    quickcheck_shrinker_option = Base_quickcheck_Shrinker[14],
    quickcheck_shrinker_list = Base_quickcheck_Shrinker[15],
    quickcheck_shrinker_array = Base_quickcheck_Shrinker[16],
    quickcheck_shrinker_ref = Base_quickcheck_Shrinker[17],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Shrinker[18],
    Base_quickcheck_Export =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t];
   runtime.caml_register_global
    (3, Base_quickcheck_Export, "Base_quickcheck__Export");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base_quickcheck
//# unitInfo: Requires: Base_quickcheck__Export
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_quickcheck_Export = global_data.Base_quickcheck__Export,
    quickcheck_generator_unit = Base_quickcheck_Export[1],
    quickcheck_generator_bool = Base_quickcheck_Export[2],
    quickcheck_generator_char = Base_quickcheck_Export[3],
    quickcheck_generator_string = Base_quickcheck_Export[4],
    quickcheck_generator_bytes = Base_quickcheck_Export[5],
    quickcheck_generator_int = Base_quickcheck_Export[6],
    quickcheck_generator_int32 = Base_quickcheck_Export[7],
    quickcheck_generator_int64 = Base_quickcheck_Export[8],
    quickcheck_generator_nativeint = Base_quickcheck_Export[9],
    quickcheck_generator_float = Base_quickcheck_Export[10],
    quickcheck_observer_unit = Base_quickcheck_Export[11],
    quickcheck_observer_bool = Base_quickcheck_Export[12],
    quickcheck_observer_char = Base_quickcheck_Export[13],
    quickcheck_observer_string = Base_quickcheck_Export[14],
    quickcheck_observer_bytes = Base_quickcheck_Export[15],
    quickcheck_observer_int = Base_quickcheck_Export[16],
    quickcheck_observer_int32 = Base_quickcheck_Export[17],
    quickcheck_observer_int64 = Base_quickcheck_Export[18],
    quickcheck_observer_nativeint = Base_quickcheck_Export[19],
    quickcheck_observer_float = Base_quickcheck_Export[20],
    quickcheck_shrinker_unit = Base_quickcheck_Export[21],
    quickcheck_shrinker_bool = Base_quickcheck_Export[22],
    quickcheck_shrinker_char = Base_quickcheck_Export[23],
    quickcheck_shrinker_string = Base_quickcheck_Export[24],
    quickcheck_shrinker_bytes = Base_quickcheck_Export[25],
    quickcheck_shrinker_int = Base_quickcheck_Export[26],
    quickcheck_shrinker_int32 = Base_quickcheck_Export[27],
    quickcheck_shrinker_int64 = Base_quickcheck_Export[28],
    quickcheck_shrinker_nativeint = Base_quickcheck_Export[29],
    quickcheck_shrinker_float = Base_quickcheck_Export[30],
    quickcheck_generator_option = Base_quickcheck_Export[31],
    quickcheck_generator_list = Base_quickcheck_Export[32],
    quickcheck_generator_array = Base_quickcheck_Export[33],
    quickcheck_generator_ref = Base_quickcheck_Export[34],
    quickcheck_generator_lazy_t = Base_quickcheck_Export[35],
    quickcheck_observer_option = Base_quickcheck_Export[36],
    quickcheck_observer_list = Base_quickcheck_Export[37],
    quickcheck_observer_array = Base_quickcheck_Export[38],
    quickcheck_observer_ref = Base_quickcheck_Export[39],
    quickcheck_observer_lazy_t = Base_quickcheck_Export[40],
    quickcheck_shrinker_option = Base_quickcheck_Export[41],
    quickcheck_shrinker_list = Base_quickcheck_Export[42],
    quickcheck_shrinker_array = Base_quickcheck_Export[43],
    quickcheck_shrinker_ref = Base_quickcheck_Export[44],
    quickcheck_shrinker_lazy_t = Base_quickcheck_Export[45],
    Private = [0],
    Base_quickcheck =
      [0,
       quickcheck_generator_unit,
       quickcheck_generator_bool,
       quickcheck_generator_char,
       quickcheck_generator_string,
       quickcheck_generator_bytes,
       quickcheck_generator_int,
       quickcheck_generator_int32,
       quickcheck_generator_int64,
       quickcheck_generator_nativeint,
       quickcheck_generator_float,
       quickcheck_observer_unit,
       quickcheck_observer_bool,
       quickcheck_observer_char,
       quickcheck_observer_string,
       quickcheck_observer_bytes,
       quickcheck_observer_int,
       quickcheck_observer_int32,
       quickcheck_observer_int64,
       quickcheck_observer_nativeint,
       quickcheck_observer_float,
       quickcheck_shrinker_unit,
       quickcheck_shrinker_bool,
       quickcheck_shrinker_char,
       quickcheck_shrinker_string,
       quickcheck_shrinker_bytes,
       quickcheck_shrinker_int,
       quickcheck_shrinker_int32,
       quickcheck_shrinker_int64,
       quickcheck_shrinker_nativeint,
       quickcheck_shrinker_float,
       quickcheck_generator_option,
       quickcheck_generator_list,
       quickcheck_generator_array,
       quickcheck_generator_ref,
       quickcheck_generator_lazy_t,
       quickcheck_observer_option,
       quickcheck_observer_list,
       quickcheck_observer_array,
       quickcheck_observer_ref,
       quickcheck_observer_lazy_t,
       quickcheck_shrinker_option,
       quickcheck_shrinker_list,
       quickcheck_shrinker_array,
       quickcheck_shrinker_ref,
       quickcheck_shrinker_lazy_t,
       Private];
   runtime.caml_register_global(1, Base_quickcheck, "Base_quickcheck");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlX3F1aWNrY2hlY2suY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIm9mZnNldCIsIml0ZXJpIiwidCIsImYiLCJpIiwiaW5pdCIsImtpbmQiLCJsYXlvdXQiLCJkaW0iLCJmb2xkIiwiaW5pdCQwIiwidG9fYXJyYXkiLCJzZXhwX29mX3QiLCJzZXhwX29mX2VsdCIsInNleHBfb2ZfcGFjayIsInNleHBfb2ZfbGF5b3V0IiwieF8wMDEiLCJoYXNoX2ZvbGQiLCJoYXNoX2ZvbGRfZWx0Iiwic3RhdGUiLCJzdGF0ZSQwIiwiaXRlcmkkMCIsImoiLCJkaW0xIiwiZGltMiIsImZvbGQkMCIsImVsdCIsInRvX2FycmF5JDAiLCJzZXhwX29mX3QkMCIsInhfMDAyIiwiaGFzaF9mb2xkJDAiLCJzdGF0ZSQxIiwiY3JlYXRlIiwib2JzZXJ2ZSIsIngiLCJzaXplIiwiaGFzaCIsIm9wYXF1ZSIsImdlbmVyYXRlIiwicmFuZG9tIiwiZm4iLCJkb20iLCJybmciLCJyYW5kb20kMCIsIndpdGhfc2l6ZSIsInBlcnR1cmIiLCJzYWx0IiwiZmlsdGVyX21hcCIsImxvb3AiLCJzaXplJDAiLCJ5Iiwic2l6ZSQxIiwiZmlsdGVyIiwicmV0dXJuJDAiLCJtYXAiLCJhcHBseSIsInRmIiwidHgiLCJiaW5kIiwiYWxsIiwibGlzdCIsImFsbF91bml0IiwibWFwJDAiLCJib3RoIiwibWFwMiIsIm1hcDMiLCJtYXAkMSIsImlnbm9yZV9tIiwiam9pbiIsIm9mX2xpc3QiLCJhcnJheSIsImhpIiwibG8iLCJpbmRleCIsInVuaW9uIiwib2Zfd2VpZ2h0ZWRfbGlzdCIsImFsaXN0IiwidmFsdWVzIiwid2VpZ2h0cyIsInZhbHVlX2FycmF5IiwiYWNjIiwid2VpZ2h0IiwiY3VtdWxhdGl2ZSIsInN1bSIsImNob2ljZSIsIndlaWdodGVkX3VuaW9uIiwib2ZfbGF6eSIsImxhenlfdCIsImZpeGVkX3BvaW50Iiwib2ZfZ2VuZXJhdG9yIiwid2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uIiwibm9ucmVjX2xpc3QiLCJzZWxmIiwidyIsIm4iLCJyZWNfbGlzdCIsIm5vbnJlY19nZW4iLCJyZWNfZ2VuIiwicmVjdXJzaXZlX3VuaW9uIiwid2VpZ2h0ZWQiLCJzaXplcyIsIm9wdCIsInN0aCIsIm1pbl9sZW5ndGgiLCJzdGgkMCIsIm1heF9sZW5ndGgiLCJ1cHBlcl9ib3VuZCIsIm1heF9sZW5ndGgkMCIsImxlbiIsInJlbWFpbmluZyIsIm1heF9pbmRleCIsInVuaXQiLCJib29sIiwib3B0aW9uIiwidmFsdWVfdCIsImVpdGhlciIsImZzdF90Iiwic25kX3QiLCJyZXN1bHQiLCJva190IiwiZXJyX3QiLCJvayIsImVyciIsImxpc3RfZ2VuZXJpYyIsImVsdF9nZW4iLCJsaXN0X25vbl9lbXB0eSIsImxpc3Rfd2l0aF9sZW5ndGgiLCJsZW5ndGgiLCJsaXN0X2ZpbHRlcmVkIiwiZWx0cyIsImVsdHMkMCIsImxlbmd0aF9vZl9pbnB1dCIsImxlbmd0aF9vZl9vdXRwdXQiLCJpbmRpY2VzIiwibGlzdF9wZXJtdXRhdGlvbnMiLCJyZWYiLCJjaGFyX3VuaWZvcm1faW5jbHVzaXZlIiwiY2hhcl91cHBlcmNhc2UiLCJjaGFyX2xvd2VyY2FzZSIsImNoYXJfZGlnaXQiLCJjaGFyX3ByaW50X3VuaWZvcm0iLCJjaGFyX3VuaWZvcm0iLCJjaGFyX2FscGhhIiwiY2hhcl9hbHBoYW51bSIsImNoYXJfd2hpdGVzcGFjZSIsImNoYXJfcHJpbnQiLCJjaGFyJDAiLCJzbWFsbF9pbnQiLCJhbGxvd196ZXJvIiwibG93ZXJfYm91bmQiLCJ3ZWlnaHRlZF9sb3ciLCJ3ZWlnaHRlZF9oaWdoIiwic21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQiLCJzbWFsbF9zdHJpY3RseV9wb3NpdGl2ZV9pbnQiLCJ1bmlmb3JtX2luY2x1c2l2ZSIsImxvZ191bmlmb3JtX2luY2x1c2l2ZSIsIm5vbl91bmlmb3JtIiwiaW5jbHVzaXZlIiwibG9nX2luY2x1c2l2ZSIsInVuaWZvcm1fYWxsIiwibGV0X3N5bnRheF8wMDQiLCJtYWduaXR1ZGUiLCJuZWdhdGl2ZSIsInVuaWZvcm0iLCJsb2dfdW5pZm9ybSIsImludCQwIiwiaW50X3VuaWZvcm0iLCJpbnRfaW5jbHVzaXZlIiwiaW50X3VuaWZvcm1faW5jbHVzaXZlIiwiaW50X2xvZ19pbmNsdXNpdmUiLCJpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIiwidW5pZm9ybSQwIiwibG9nX3VuaWZvcm0kMCIsImludDMyIiwiaW50MzJfdW5pZm9ybSIsImludDMyX2luY2x1c2l2ZSIsImludDMyX3VuaWZvcm1faW5jbHVzaXZlIiwiaW50MzJfbG9nX2luY2x1c2l2ZSIsImludDMyX2xvZ191bmlmb3JtX2luY2x1c2l2ZSIsInVuaWZvcm0kMSIsImxvZ191bmlmb3JtJDEiLCJpbnQ2MyIsImludDYzX3VuaWZvcm0iLCJpbnQ2M19pbmNsdXNpdmUiLCJpbnQ2M191bmlmb3JtX2luY2x1c2l2ZSIsImludDYzX2xvZ19pbmNsdXNpdmUiLCJpbnQ2M19sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJzeW1ib2wkMzYiLCJsbm90JDIiLCJhYnMkMiIsInplcm8kMiIsInN5bWJvbCQzNyIsInN5bWJvbCQzOCIsInN5bWJvbCQzOSIsInVuaWZvcm0kMiIsImxvZ191bmlmb3JtJDIiLCJpbnQ2NCIsImludDY0X3VuaWZvcm0iLCJpbnQ2NF9pbmNsdXNpdmUiLCJpbnQ2NF91bmlmb3JtX2luY2x1c2l2ZSIsImludDY0X2xvZ19pbmNsdXNpdmUiLCJpbnQ2NF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUiLCJ1bmlmb3JtJDMiLCJsb2dfdW5pZm9ybSQzIiwibmF0aXZlaW50IiwibmF0aXZlaW50X3VuaWZvcm0iLCJuYXRpdmVpbnRfaW5jbHVzaXZlIiwibmF0aXZlaW50X3VuaWZvcm1faW5jbHVzaXZlIiwibmF0aXZlaW50X2xvZ19pbmNsdXNpdmUiLCJuYXRpdmVpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXYiLCJmbG9hdF96ZXJvX2V4cG9uZW50IiwiZmxvYXRfemVyb19tYW50aXNzYSIsImZsb2F0X21heF9wb3NpdGl2ZV9zdWJub3JtYWxfdiIsImZsb2F0X3N1Ym5vcm1hbF9leHBvbmVudCIsImZsb2F0X21pbl9zdWJub3JtYWxfbWFudGlzc2EiLCJmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1IiwiZmxvYXRfbWluX25vcm1hbF9leHBvbmVudCIsImZsb2F0X21heF9ub3JtYWxfZXhwb25lbnQiLCJmbG9hdF9tYXhfbm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfaW5mX2V4cG9uZW50IiwiZmxvYXRfaW5mX21hbnRpc3NhIiwiZmxvYXRfbmFuX2V4cG9uZW50IiwiZmxvYXRfbWluX25hbl9tYW50aXNzYSIsImZsb2F0X251bV9tYW50aXNzYV9iaXRzIiwibnVtX2JpdHMiLCJiaXRzIiwiZmxvYXRfbm9ybWFsX21hbnRpc3NhIiwiZmxvYXRfZXhwb25lbnQiLCJmbG9hdF96ZXJvIiwibGV0X3N5bnRheF8wMTIiLCJsZXRfc3ludGF4XzAxMyIsIm1hbnRpc3NhIiwiZXhwb25lbnQiLCJmbG9hdF9zdWJub3JtYWwiLCJmbG9hdF9ub3JtYWwiLCJmbG9hdF9pbmZpbml0ZSIsImxldF9zeW50YXhfMDIxIiwibGV0X3N5bnRheF8wMjIiLCJmbG9hdF9uYW4iLCJmbG9hdF9vZl9jbGFzcyIsImMiLCJmbG9hdF9tYXRjaGluZ19jbGFzc2VzIiwiZmxvYXRfZmluaXRlIiwiZmxvYXRfd2l0aG91dF9uYW4iLCJmbG9hdCQwIiwiZmxvYXRfZmluaXRlX25vbl96ZXJvIiwiZmxvYXRfc3RyaWN0bHlfcG9zaXRpdmUiLCJmbG9hdF9zdHJpY3RseV9uZWdhdGl2ZSIsImZsb2F0X3Bvc2l0aXZlX29yX3plcm8iLCJmbG9hdF9uZWdhdGl2ZV9vcl96ZXJvIiwiZmxvYXRfdW5pZm9ybV9leGNsdXNpdmUiLCJsb3dlcl9pbmNsdXNpdmUiLCJ1cHBlcl9pbmNsdXNpdmUiLCJmbG9hdF9pbmNsdXNpdmUiLCJzdHJpbmdfd2l0aF9sZW5ndGhfb2YiLCJjaGFyX2dlbiIsInN0cmluZ19vZiIsInN0cmluZ19ub25fZW1wdHlfb2YiLCJzdHJpbmciLCJzdHJpbmdfbm9uX2VtcHR5Iiwic3RyaW5nX3dpdGhfbGVuZ3RoIiwiYnl0ZXMiLCJzZXhwX29mIiwiYXRvbSIsInNleHAiLCJtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIiwiY29tcGFyYXRvciIsImtleV9nZW4iLCJkYXRhX2dlbiIsImtleXMiLCJrZXlzJDAiLCJkYXRhIiwic2V0X3RyZWVfdXNpbmdfY29tcGFyYXRvciIsIm1hcF90X20iLCJtIiwic2V0X3RfbSIsImJpZ2FycmF5MSIsImJpZ3N0cmluZyIsImZsb2F0MzJfdmVjIiwiZmxvYXQ2NF92ZWMiLCJtYXhfdG90YWxfc2l6ZSIsImEiLCJiIiwibWF4X2IiLCJiX3dlaWdodGVkX2xvdyIsImJpZ2FycmF5Ml9kaW0iLCJiaWdhcnJheTIiLCJmbG9hdDMyX21hdCIsImZsb2F0NjRfbWF0IiwiY292ZXJhZ2UiLCJDbXAiLCJzYW1wbGUiLCJjb3VudHMiLCJ2YWx1ZSIsInByZXYiLCJtb25pdG9yIiwiYXRvbWljIiwic2hyaW5rIiwiZl9pbnZlcnNlIiwib2Zfc2hyaW5rZXIiLCJzbmQiLCJmc3QiLCJzcmMiLCJ0b19za2lwIiwidG9fc2tpcCQwIiwiaSQwIiwiciIsInYiLCJkaW0yJDAiLCJkaW0xJDAiLCJzaHJpbmskMCIsImZpZWxkIiwiZGltcyIsInNraXAiLCJlbHRfdCIsImxpc3RfdCIsInRhaWwiLCJoZWFkIiwic2hyaW5rZXIiLCJsIiwic2hyaW5rX2xpc3QiLCJzaHJpbmtfdHJlZSIsImtleV90IiwiZGF0YV90IiwidHJlZSIsImsiLCJkcm9wX2tleXMiLCJrZXkiLCJ0cmVlJDAiLCJzbWFsbGVyX2tleSIsInNocmlua19rZXlzIiwic21hbGxlcl9kYXRhIiwic2hyaW5rX2RhdGEiLCJkcm9wX2VsdHMiLCJzbWFsbGVyX2VsdCIsInNocmlua19lbHRzIiwibWFwX3QiLCJzZXRfdCIsIm5hbWVzIiwiYXJnMF8wMDEiLCJyZXMwXzAwMiIsInNocmlua19jb3VudCIsInRlc3RfY291bnQiLCJzZWVkIiwic2l6ZXMkMCIsInNocmlua19jb3VudCQwIiwidGVzdF9jb3VudCQwIiwic2VlZCQwIiwibWFrZV9jcmVhdG9yIiwic2VlZF9mdW4iLCJ0ZXN0X2NvdW50X2Z1biIsInNocmlua19jb3VudF9mdW4iLCJzaXplc19mdW4iLCJjb21waWxlX2FjYyIsImNvbXBpbGVfYWNjJDAiLCJzZWVkX2dlbiIsImNvbXBpbGVfYWNjJDEiLCJ0ZXN0X2NvdW50X2dlbiIsImNvbXBpbGVfYWNjJDIiLCJzaHJpbmtfY291bnRfZ2VuIiwiY29tcGlsZV9hY2MkMyIsInNpemVzX2dlbiIsIml0ZXIiLCJtYXBfcG9seSIsInJlY29yZCIsImZvcl9hbGwiLCJleGlzdHMiLCJ0b19saXN0IiwiaXRlciQwIiwiZm9yX2FsbCQwIiwiZXhpc3RzJDAiLCJ0b19saXN0JDAiLCJzZXRfYWxsX211dGFibGVfZmllbGRzIiwic2l6ZXNfMDEwIiwic2hyaW5rX2NvdW50XzAwOCIsInRlc3RfY291bnRfMDA2Iiwic2VlZF8wMDQiLCJzdWZmaXgiLCJwcmVmaXgiLCJwcmVmaXgkMCIsImJuZHNfMDAzIiwic3VmZml4JDAiLCJhcmdfMDExIiwiYm5kc18wMDMkMCIsImFyZ18wMDkiLCJibmRzXzAwMyQxIiwiYXJnXzAwNyIsImJuZHNfMDAzJDIiLCJhcmdfMDA1IiwiYm5kc18wMDMkMyIsImRlZmF1bHRfY29uZmlnIiwibGF6eV9ub25kZXRlcm1pbmlzdGljX3N0YXRlIiwid2l0aF9zYW1wbGUiLCJnZW5lcmF0b3IiLCJjb25maWciLCJleGFtcGxlcyIsIm51bWJlcl9vZl9zaXplX3ZhbHVlcyIsInJlbWFpbmluZ19zaXplcyIsInNlcXVlbmNlIiwiaW5wdXQiLCJlcnJvciIsImVycm9yJDEiLCJpbnB1dCQwIiwic2hyaW5rX2NvdW50JDEiLCJhbHRlcm5hdGVzJDIiLCJhbHRlcm5hdGVzIiwiYWx0ZXJuYXRlcyQwIiwiYWx0ZXJuYXRlIiwiZXJyb3IkMCIsImFsdGVybmF0ZXMkMSIsInJ1biIsIk0iLCJmJDAiLCJ3aXRoX3NhbXBsZV9leG4iLCJydW5fZXhuIiwidGVzdGFibGUiLCJ1bm1hcCIsIm9mX2hhc2hfZm9sZCIsIndyYXAiLCJoYXNoJDAiLCJoYXNoJDEiLCJtYXBfdHJlZSIsImtleV9vYnMiLCJkYXRhX29icyIsInNldF90cmVlIiwiZWx0X29icyJdLCJzb3VyY2VzIjpbIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlX3F1aWNrY2hlY2svYmlnYXJyYXlfaGVscGVycy5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlX3F1aWNrY2hlY2svb2JzZXJ2ZXIwLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2VfcXVpY2tjaGVjay9nZW5lcmF0b3IubWwiLCIvdXNyL2xpYi9vY2FtbC9pbnQ2NC5tbGkiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZV9xdWlja2NoZWNrL3Nocmlua2VyLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2VfcXVpY2tjaGVjay90ZXN0Lm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2VfcXVpY2tjaGVjay9vYnNlcnZlci5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlX3F1aWNrY2hlY2svYmFzZV9xdWlja2NoZWNrLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBS01BLG1DQUVzQjtHQUxaLGlCQUdWQTtZQVNBQyxNQUFNQyxHQUFHQztJQUNYO0tBQTJCLHFCQURuQkQ7S0FDSkYsU0FBUztLQUNBLG9CQUZMRTtLQUNLOztTQUNiRTs7TUFDRSxXQUhTRCxHQUVYQyxJQURJSixZQUVhLGNBSFRFLEdBRVJFLElBRElKO01BRUYsVUFERkk7Ozs7OztHQUVJO1lBR0ZDLEtBQWlCQyxNQUErQkMsUUFBT0MsS0FB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUtJQztJQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBREFEO1NBQ0FDO0lBR0pDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFLSUM7SUFDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTQURBRDtTQUNBQztJQUdKQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUN0WUZDO0lBVUFDO0lBQ0FDO0lBRUFDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lEMlhNQztJQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7U0MvWE5MOzs7Ozs7U0FiQUg7OztTQWVBSztTQURBRDs7O1NBRUFFOzs7O1NBTkFMOzs7Ozs7OztTQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztTRGdZTUs7U0FDQUM7SUFHSkM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUtJQztJQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QWpHO09BQ0FRO09BQ0FRO09BQ0FlO09BQ0FRO09BQ0F5QztPQUVBb0I7T0E0QkF4SjtPQU1BckQ7T0FZQVU7T0FDQWlFO09BQ0FoRDtPQTNCQXhCO09BYkFvRDtPQU9BRztPQWRBZ0s7T0FDQUM7T0FDQUM7T0FDQVE7T0FDQUM7T0E2Q0F6UDtPQW1CQXlTO09BSUFDO09BVkFvRjtPQUlBRztPQXJGQVA7T0FEQUQ7T0FJQXpVO09BRkFGOzs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dDT2E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIm9wZW4hIEJhc2VcblxubW9kdWxlIExheW91dCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBCaWdhcnJheS5sYXlvdXRcblxuICBsZXQgb2Zmc2V0IDogdHlwZSBhLiBhIHQgLT4gaW50ID0gZnVuY3Rpb25cbiAgICB8IEJpZ2FycmF5LkZvcnRyYW5fbGF5b3V0IC0+IDFcbiAgICB8IEJpZ2FycmF5LkNfbGF5b3V0IC0+IDBcbiAgOztcbmVuZFxuXG5tb2R1bGUgQXJyYXkxID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgQmlnYXJyYXkuQXJyYXkxLnRcblxuICBsZXQgaXRlcmkgdCB+ZiA9XG4gICAgbGV0IG9mZnNldCA9IExheW91dC5vZmZzZXQgKEJpZ2FycmF5LkFycmF5MS5sYXlvdXQgdCkgaW5cbiAgICBmb3IgaSA9IDAgdG8gQmlnYXJyYXkuQXJyYXkxLmRpbSB0IC0gMSBkb1xuICAgICAgZiAoaSArIG9mZnNldCkgdC57aSArIG9mZnNldH1cbiAgICBkb25lXG4gIDs7XG5cbiAgbGV0IGluaXQgKHR5cGUgZWx0KSAoa2luZCA6IChlbHQsIF8pIEJpZ2FycmF5LmtpbmQpIGxheW91dCBkaW0gfmYgPVxuICAgIGxldCB0ID0gQmlnYXJyYXkuQXJyYXkxLmNyZWF0ZSBraW5kIGxheW91dCBkaW0gaW5cbiAgICBpdGVyaSB0IH5mOihmdW4gaSAoXyA6IGVsdCkgLT4gdC57aX0gPC0gZiBpKTtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGZvbGQgKHR5cGUgZWx0KSAodCA6IChlbHQsIF8sIF8pIHQpIH5pbml0IH5mID1cbiAgICBsZXQgaW5pdCA9IHJlZiBpbml0IGluXG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgKF8gOiBlbHQpIC0+IGluaXQgOj0gZiAhaW5pdCB0LntpfSk7XG4gICAgIWluaXRcbiAgOztcblxuICBsZXQgdG9fYXJyYXkgdCA9XG4gICAgbGV0IG9mZnNldCA9IExheW91dC5vZmZzZXQgKEJpZ2FycmF5LkFycmF5MS5sYXlvdXQgdCkgaW5cbiAgICBBcnJheS5pbml0IChCaWdhcnJheS5BcnJheTEuZGltIHQpIH5mOihmdW4gaSAtPiB0LntpICsgb2Zmc2V0fSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZWx0IF9zZXhwX29mX3BhY2sgX3NleHBfb2ZfbGF5b3V0IHQgPVxuICAgIFslc2V4cCAodG9fYXJyYXkgdCA6IGVsdCBhcnJheSldXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZCBoYXNoX2ZvbGRfZWx0IHN0YXRlIHQgPVxuICAgIGxldCBzdGF0ZSA9IGhhc2hfZm9sZF9pbnQgc3RhdGUgKEJpZ2FycmF5LkFycmF5MS5kaW0gdCkgaW5cbiAgICBmb2xkIHQgfmluaXQ6c3RhdGUgfmY6aGFzaF9mb2xkX2VsdFxuICA7O1xuZW5kXG5cbm1vZHVsZSBBcnJheTIgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IsICdjKSBCaWdhcnJheS5BcnJheTIudFxuXG4gIGxldCBpdGVyaSB0IH5mID1cbiAgICBsZXQgb2Zmc2V0ID0gTGF5b3V0Lm9mZnNldCAoQmlnYXJyYXkuQXJyYXkyLmxheW91dCB0KSBpblxuICAgIGZvciBpID0gMCB0byBCaWdhcnJheS5BcnJheTIuZGltMSB0IC0gMSBkb1xuICAgICAgZm9yIGogPSAwIHRvIEJpZ2FycmF5LkFycmF5Mi5kaW0yIHQgLSAxIGRvXG4gICAgICAgIGYgKGkgKyBvZmZzZXQpIChqICsgb2Zmc2V0KSB0LntpICsgb2Zmc2V0LCBqICsgb2Zmc2V0fVxuICAgICAgZG9uZVxuICAgIGRvbmVcbiAgOztcblxuICBsZXQgaW5pdCAodHlwZSBlbHQpIChraW5kIDogKGVsdCwgXykgQmlnYXJyYXkua2luZCkgbGF5b3V0IGRpbTEgZGltMiB+ZiA9XG4gICAgbGV0IHQgPSBCaWdhcnJheS5BcnJheTIuY3JlYXRlIGtpbmQgbGF5b3V0IGRpbTEgZGltMiBpblxuICAgIGl0ZXJpIHQgfmY6KGZ1biBpIGogKF8gOiBlbHQpIC0+IHQue2ksIGp9IDwtIGYgaSBqKTtcbiAgICB0XG4gIDs7XG5cbiAgbGV0IGZvbGQgKHR5cGUgZWx0KSAodCA6IChlbHQsIF8sIF8pIHQpIH5pbml0IH5mID1cbiAgICBsZXQgaW5pdCA9IHJlZiBpbml0IGluXG4gICAgaXRlcmkgdCB+ZjooZnVuIChfIDogaW50KSAoXyA6IGludCkgZWx0IC0+IGluaXQgOj0gZiAhaW5pdCBlbHQpO1xuICAgICFpbml0XG4gIDs7XG5cbiAgbGV0IHRvX2FycmF5IHQgPVxuICAgIGxldCBvZmZzZXQgPSBMYXlvdXQub2Zmc2V0IChCaWdhcnJheS5BcnJheTIubGF5b3V0IHQpIGluXG4gICAgQXJyYXkuaW5pdCAoQmlnYXJyYXkuQXJyYXkyLmRpbTEgdCkgfmY6KGZ1biBpIC0+XG4gICAgICBBcnJheS5pbml0IChCaWdhcnJheS5BcnJheTIuZGltMiB0KSB+ZjooZnVuIGogLT4gdC57aSArIG9mZnNldCwgaiArIG9mZnNldH0pKVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9lbHQgX3NleHBfb2ZfcGFjayBfc2V4cF9vZl9sYXlvdXQgdCA9XG4gICAgWyVzZXhwICh0b19hcnJheSB0IDogZWx0IGFycmF5IGFycmF5KV1cbiAgOztcblxuICBsZXQgaGFzaF9mb2xkIGhhc2hfZm9sZF9lbHQgc3RhdGUgdCA9XG4gICAgbGV0IHN0YXRlID0gaGFzaF9mb2xkX2ludCBzdGF0ZSAoQmlnYXJyYXkuQXJyYXkyLmRpbTEgdCkgaW5cbiAgICBsZXQgc3RhdGUgPSBoYXNoX2ZvbGRfaW50IHN0YXRlIChCaWdhcnJheS5BcnJheTIuZGltMiB0KSBpblxuICAgIGZvbGQgdCB+aW5pdDpzdGF0ZSB+ZjpoYXNoX2ZvbGRfZWx0XG4gIDs7XG5lbmRcbiIsIm9wZW4hIEJhc2VcblxudHlwZSAnYSB0ID0gJ2EgLT4gc2l6ZTppbnQgLT4gaGFzaDpIYXNoLnN0YXRlIC0+IEhhc2guc3RhdGVcblxubGV0IGNyZWF0ZSBmIDogXyB0ID0gZlxuXG5sZXQgb2JzZXJ2ZSAodCA6IF8gdCkgeCB+c2l6ZSB+aGFzaCA9XG4gIGlmIHNpemUgPCAwXG4gIHRoZW4gcmFpc2VfcyBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suT2JzZXJ2ZXIub2JzZXJ2ZTogc2l6ZSA8IDBcIiAoc2l6ZSA6IGludCldXG4gIGVsc2UgdCB4IH5zaXplIH5oYXNoXG47O1xuXG5sZXQgb3BhcXVlIF8gfnNpemU6XyB+aGFzaCA9IGhhc2hcbiIsIm9wZW4hIEJhc2VcblxubW9kdWxlIFQgOiBzaWdcbiAgdHlwZSArJ2EgdFxuXG4gIHZhbCBjcmVhdGUgOiAoc2l6ZTppbnQgLT4gcmFuZG9tOlNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnQgLT4gJ2EpIC0+ICdhIHRcbiAgdmFsIGdlbmVyYXRlIDogJ2EgdCAtPiBzaXplOmludCAtPiByYW5kb206U3BsaXR0YWJsZV9yYW5kb20uU3RhdGUudCAtPiAnYVxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9IChzaXplOmludCAtPiByYW5kb206U3BsaXR0YWJsZV9yYW5kb20uU3RhdGUudCAtPiAnYSkgU3RhZ2VkLnRcblxuICBsZXQgY3JlYXRlIGYgOiBfIHQgPSBTdGFnZWQuc3RhZ2UgZlxuXG4gIGxldCBnZW5lcmF0ZSAodCA6IF8gdCkgfnNpemUgfnJhbmRvbSA9XG4gICAgaWYgc2l6ZSA8IDBcbiAgICB0aGVuIHJhaXNlX3MgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5nZW5lcmF0ZTogc2l6ZSA8IDBcIiAoc2l6ZSA6IGludCldXG4gICAgZWxzZSBTdGFnZWQudW5zdGFnZSB0IH5zaXplIH5yYW5kb21cbiAgOztcbmVuZFxuXG5pbmNsdWRlIFRcblxubGV0IHNpemUgPSBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tOl8gLT4gc2l6ZSlcblxubGV0IGZuIGRvbSBybmcgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IHJhbmRvbSA9IFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnNwbGl0IHJhbmRvbSBpblxuICAgIGZ1biB4IC0+XG4gICAgICBsZXQgaGFzaCA9IE9ic2VydmVyMC5vYnNlcnZlIGRvbSB4IH5zaXplIH5oYXNoOihIYXNoLmFsbG9jICgpKSBpblxuICAgICAgbGV0IHJhbmRvbSA9IFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLmNvcHkgcmFuZG9tIGluXG4gICAgICBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS5wZXJ0dXJiIHJhbmRvbSAoSGFzaC5nZXRfaGFzaF92YWx1ZSBoYXNoKTtcbiAgICAgIGdlbmVyYXRlIHJuZyB+c2l6ZSB+cmFuZG9tKVxuOztcblxubGV0IHdpdGhfc2l6ZSB0IH5zaXplID0gY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+IGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSlcblxubGV0IHBlcnR1cmIgdCBzYWx0ID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIFNwbGl0dGFibGVfcmFuZG9tLlN0YXRlLnBlcnR1cmIgcmFuZG9tIHNhbHQ7XG4gICAgZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tKVxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCB+c2l6ZSB+cmFuZG9tID1cbiAgICBsZXQgeCA9IGdlbmVyYXRlIHQgfnNpemUgfnJhbmRvbSBpblxuICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgfCBTb21lIHkgLT4geVxuICAgIHwgTm9uZSAtPiBsb29wIH5zaXplOihzaXplICsgMSkgfnJhbmRvbVxuICBpblxuICBjcmVhdGUgbG9vcFxuOztcblxubGV0IGZpbHRlciB0IH5mID0gZmlsdGVyX21hcCB0IH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBOb25lKVxubGV0IHJldHVybiB4ID0gY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tOl8gLT4geClcbmxldCBtYXAgdCB+ZiA9IGNyZWF0ZSAoZnVuIH5zaXplIH5yYW5kb20gLT4gZiAoZ2VuZXJhdGUgdCB+c2l6ZSB+cmFuZG9tKSlcblxubGV0IGFwcGx5IHRmIHR4ID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIGxldCBmID0gZ2VuZXJhdGUgdGYgfnNpemUgfnJhbmRvbSBpblxuICAgIGxldCB4ID0gZ2VuZXJhdGUgdHggfnNpemUgfnJhbmRvbSBpblxuICAgIGYgeClcbjs7XG5cbmxldCBiaW5kIHQgfmYgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IHggPSBnZW5lcmF0ZSB0IH5zaXplIH5yYW5kb20gaW5cbiAgICBnZW5lcmF0ZSAoZiB4KSB+c2l6ZSB+cmFuZG9tKVxuOztcblxubGV0IGFsbCBsaXN0ID0gY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPiBMaXN0Lm1hcCBsaXN0IH5mOihnZW5lcmF0ZSB+c2l6ZSB+cmFuZG9tKSlcblxubGV0IGFsbF91bml0IGxpc3QgPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+IExpc3QuaXRlciBsaXN0IH5mOihnZW5lcmF0ZSB+c2l6ZSB+cmFuZG9tKSlcbjs7XG5cbm1vZHVsZSBGb3JfYXBwbGljYXRpdmUgPSBBcHBsaWNhdGl2ZS5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBhcHBseSA9IGFwcGx5XG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubGV0IGJvdGggPSBGb3JfYXBwbGljYXRpdmUuYm90aFxubGV0IG1hcDIgPSBGb3JfYXBwbGljYXRpdmUubWFwMlxubGV0IG1hcDMgPSBGb3JfYXBwbGljYXRpdmUubWFwM1xuXG5tb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBGb3JfYXBwbGljYXRpdmUuQXBwbGljYXRpdmVfaW5maXhcbmluY2x1ZGUgQXBwbGljYXRpdmVfaW5maXhcblxubW9kdWxlIEZvcl9tb25hZCA9IE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gIGVuZClcblxubGV0IGlnbm9yZV9tID0gRm9yX21vbmFkLmlnbm9yZV9tXG5sZXQgam9pbiA9IEZvcl9tb25hZC5qb2luXG5cbm1vZHVsZSBNb25hZF9pbmZpeCA9IEZvcl9tb25hZC5Nb25hZF9pbmZpeFxuaW5jbHVkZSBNb25hZF9pbmZpeFxubW9kdWxlIExldF9zeW50YXggPSBGb3JfbW9uYWQuTGV0X3N5bnRheFxub3BlbiBMZXRfc3ludGF4XG5cbmxldCBvZl9saXN0IGxpc3QgPVxuICBpZiBMaXN0LmlzX2VtcHR5IGxpc3RcbiAgdGhlbiBFcnJvci5yYWlzZV9zIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2ZfbGlzdDogZW1wdHkgbGlzdFwiXTtcbiAgbGV0IGFycmF5ID0gQXJyYXkub2ZfbGlzdCBsaXN0IGluXG4gIGxldCBsbyA9IDAgaW5cbiAgbGV0IGhpID0gQXJyYXkubGVuZ3RoIGFycmF5IC0gMSBpblxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBsZXQgaW5kZXggPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbyB+aGkgaW5cbiAgICBhcnJheS4oaW5kZXgpKVxuOztcblxubGV0IHVuaW9uIGxpc3QgPSBqb2luIChvZl9saXN0IGxpc3QpXG5cbmxldCBvZl93ZWlnaHRlZF9saXN0IGFsaXN0ID1cbiAgaWYgTGlzdC5pc19lbXB0eSBhbGlzdFxuICB0aGVuIEVycm9yLnJhaXNlX3MgWyVtZXNzYWdlIFwiQmFzZV9xdWlja2NoZWNrLkdlbmVyYXRvci5vZl93ZWlnaHRlZF9saXN0OiBlbXB0eSBsaXN0XCJdO1xuICBsZXQgd2VpZ2h0cywgdmFsdWVzID0gTGlzdC51bnppcCBhbGlzdCBpblxuICBsZXQgdmFsdWVfYXJyYXkgPSBBcnJheS5vZl9saXN0IHZhbHVlcyBpblxuICBsZXQgdG90YWxfd2VpZ2h0LCBjdW11bGF0aXZlX3dlaWdodF9hcnJheSA9XG4gICAgbGV0IGFycmF5ID0gQXJyYXkuaW5pdCAoQXJyYXkubGVuZ3RoIHZhbHVlX2FycmF5KSB+ZjooZnVuIF8gLT4gMC4pIGluXG4gICAgbGV0IHN1bSA9XG4gICAgICBMaXN0LmZvbGRpIHdlaWdodHMgfmluaXQ6MC4gfmY6KGZ1biBpbmRleCBhY2Mgd2VpZ2h0IC0+XG4gICAgICAgIGlmIG5vdCAoRmxvYXQuaXNfZmluaXRlIHdlaWdodClcbiAgICAgICAgdGhlblxuICAgICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogd2VpZ2h0IGlzIG5vdCBmaW5pdGVcIlxuICAgICAgICAgICAgICAgICh3ZWlnaHQgOiBmbG9hdCldO1xuICAgICAgICBpZiBGbG9hdC4oIDwgKSB3ZWlnaHQgMC5cbiAgICAgICAgdGhlblxuICAgICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgICBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogd2VpZ2h0IGlzIG5lZ2F0aXZlXCJcbiAgICAgICAgICAgICAgICAod2VpZ2h0IDogZmxvYXQpXTtcbiAgICAgICAgbGV0IGN1bXVsYXRpdmUgPSBhY2MgKy4gd2VpZ2h0IGluXG4gICAgICAgIGFycmF5LihpbmRleCkgPC0gY3VtdWxhdGl2ZTtcbiAgICAgICAgY3VtdWxhdGl2ZSlcbiAgICBpblxuICAgIGlmIEZsb2F0LiggPD0gKSBzdW0gMC5cbiAgICB0aGVuXG4gICAgICBFcnJvci5yYWlzZV9zXG4gICAgICAgIFslbWVzc2FnZSBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iub2Zfd2VpZ2h0ZWRfbGlzdDogdG90YWwgd2VpZ2h0IGlzIHplcm9cIl07XG4gICAgc3VtLCBhcnJheVxuICBpblxuICBjcmVhdGUgKGZ1biB+c2l6ZTpfIH5yYW5kb20gLT5cbiAgICBsZXQgY2hvaWNlID0gU3BsaXR0YWJsZV9yYW5kb20uZmxvYXQgcmFuZG9tIH5sbzowLiB+aGk6dG90YWxfd2VpZ2h0IGluXG4gICAgbWF0Y2hcbiAgICAgIEFycmF5LmJpbmFyeV9zZWFyY2hcbiAgICAgICAgY3VtdWxhdGl2ZV93ZWlnaHRfYXJyYXlcbiAgICAgICAgfmNvbXBhcmU6RmxvYXQuY29tcGFyZVxuICAgICAgICBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvXG4gICAgICAgIGNob2ljZVxuICAgIHdpdGhcbiAgICB8IFNvbWUgaW5kZXggLT4gdmFsdWVfYXJyYXkuKGluZGV4KVxuICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5sZXQgd2VpZ2h0ZWRfdW5pb24gYWxpc3QgPSBqb2luIChvZl93ZWlnaHRlZF9saXN0IGFsaXN0KVxubGV0IG9mX2xhenkgbGF6eV90ID0gY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPiBnZW5lcmF0ZSAoZm9yY2UgbGF6eV90KSB+c2l6ZSB+cmFuZG9tKVxuXG5sZXQgZml4ZWRfcG9pbnQgb2ZfZ2VuZXJhdG9yID1cbiAgbGV0IHJlYyBsYXp5X3QgPSBsYXp5IChvZl9nZW5lcmF0b3IgKG9mX2xhenkgbGF6eV90KSkgaW5cbiAgZm9yY2UgbGF6eV90XG47O1xuXG5sZXQgd2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uIG5vbnJlY19saXN0IH5mID1cbiAgZml4ZWRfcG9pbnQgKGZ1biBzZWxmIC0+XG4gICAgbGV0IHJlY19saXN0ID1cbiAgICAgIExpc3QubWFwIChmIHNlbGYpIH5mOihmdW4gKHcsIHQpIC0+XG4gICAgICAgICggd1xuICAgICAgICAsIGxldCViaW5kIG4gPSBzaXplIGluXG4gICAgICAgICAgd2l0aF9zaXplIH5zaXplOihuIC0gMSkgdCApKVxuICAgIGluXG4gICAgaWYgTGlzdC5pc19lbXB0eSBub25yZWNfbGlzdCB8fCBMaXN0LmlzX2VtcHR5IHJlY19saXN0XG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICBbJW1lc3NhZ2VcbiAgICAgICAgICBcIkJhc2VfcXVpY2tjaGVjay5HZW5lcmF0b3Iud2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uOiBsaXN0cyBtdXN0IGJlIG5vbi1lbXB0eVwiXTtcbiAgICBsZXQgbm9ucmVjX2dlbiA9IHdlaWdodGVkX3VuaW9uIG5vbnJlY19saXN0IGluXG4gICAgbGV0IHJlY19nZW4gPSB3ZWlnaHRlZF91bmlvbiAobm9ucmVjX2xpc3QgQCByZWNfbGlzdCkgaW5cbiAgICBtYXRjaCViaW5kIHNpemUgd2l0aFxuICAgIHwgMCAtPiBub25yZWNfZ2VuXG4gICAgfCBfIC0+IHJlY19nZW4pXG47O1xuXG5sZXQgcmVjdXJzaXZlX3VuaW9uIG5vbnJlY19saXN0IH5mID1cbiAgbGV0IHdlaWdodGVkIGxpc3QgPSBMaXN0Lm1hcCBsaXN0IH5mOihmdW4gdCAtPiAxLiwgdCkgaW5cbiAgd2VpZ2h0ZWRfcmVjdXJzaXZlX3VuaW9uICh3ZWlnaHRlZCBub25yZWNfbGlzdCkgfmY6KGZ1biBzZWxmIC0+IHdlaWdodGVkIChmIHNlbGYpKVxuOztcblxubGV0IHNpemVzID8obWluX2xlbmd0aCA9IDApID8obWF4X2xlbmd0aCA9IEludC5tYXhfdmFsdWUpICgpID1cbiAgY3JlYXRlIChmdW4gfnNpemUgfnJhbmRvbSAtPlxuICAgIGFzc2VydCAobWluX2xlbmd0aCA8PSBtYXhfbGVuZ3RoKTtcbiAgICBsZXQgdXBwZXJfYm91bmQgPSBtaW5fbGVuZ3RoICsgc2l6ZSBpblxuICAgIGxldCBtYXhfbGVuZ3RoID1cbiAgICAgIGlmIHVwcGVyX2JvdW5kID49IG1pbl9sZW5ndGggKCogZ3VhcmQgYWdhaW5zdCBvdmVyZmxvdyAqKVxuICAgICAgdGhlbiBtaW4gbWF4X2xlbmd0aCB1cHBlcl9ib3VuZFxuICAgICAgZWxzZSBtYXhfbGVuZ3RoXG4gICAgaW5cbiAgICAoKiBwaWNrIGEgbGVuZ3RoLCB3ZWlnaHRlZCBsb3cgc28gdGhhdCBtb3N0IG9mIHRoZSBzaXplIGlzIHNwZW50IG9uIGVsZW1lbnRzICopXG4gICAgbGV0IGxlbiA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludCByYW5kb20gfmxvOm1pbl9sZW5ndGggfmhpOm1heF9sZW5ndGggaW5cbiAgICAoKiBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudHMgcmV0dXJuIGFuIGVtcHR5IGFycmF5LCBvdGhlcndpc2UgcmV0dXJuIGEgbm9uLWVtcHR5IGFycmF5XG4gICAgICAgd2l0aCB0aGUgc2l6ZSBkaXN0cmlidXRlZCBhbW9uZyB0aGUgZWxlbWVudHMgKilcbiAgICBpZiBsZW4gPSAwXG4gICAgdGhlbiBbXVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHNpemVzID0gQXJyYXkuaW5pdCBsZW4gfmY6KGZ1biBfIC0+IDApIGluXG4gICAgICBsZXQgcmVtYWluaW5nID0gc2l6ZSAtIChsZW4gLSBtaW5fbGVuZ3RoKSBpblxuICAgICAgbGV0IG1heF9pbmRleCA9IGxlbiAtIDEgaW5cbiAgICAgIGZvciBfID0gMSB0byByZW1haW5pbmcgZG9cbiAgICAgICAgKCogcGljayBhbiBpbmRleCwgd2VpZ2h0ZWQgbG93IHNvIHRoYXQgd2Ugc2VlIHVuYmFsYW5jZWQgZGlzdHJpYnV0aW9ucyBvZnRlbiAqKVxuICAgICAgICBsZXQgaW5kZXggPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQgcmFuZG9tIH5sbzowIH5oaTptYXhfaW5kZXggaW5cbiAgICAgICAgc2l6ZXMuKGluZGV4KSA8LSBzaXplcy4oaW5kZXgpICsgMVxuICAgICAgZG9uZTtcbiAgICAgICgqIHBlcm11dGUgdGhlIGFycmF5IHNvIHRoYXQgbm8gaW5kZXggaXMgZmF2b3JlZCBvdmVyIGFub3RoZXIgKilcbiAgICAgIGZvciBpID0gMCB0byBtYXhfaW5kZXggLSAxIGRvXG4gICAgICAgIGxldCBqID0gU3BsaXR0YWJsZV9yYW5kb20uaW50IHJhbmRvbSB+bG86aSB+aGk6bWF4X2luZGV4IGluXG4gICAgICAgIEFycmF5LnN3YXAgc2l6ZXMgaSBqXG4gICAgICBkb25lO1xuICAgICAgYXNzZXJ0IChBcnJheS5zdW0gKG1vZHVsZSBJbnQpIHNpemVzIH5mOkZuLmlkICsgKGxlbiAtIG1pbl9sZW5ndGgpID0gc2l6ZSk7XG4gICAgICBBcnJheS50b19saXN0IHNpemVzKSlcbjs7XG5cbmxldCB1bml0ID0gcmV0dXJuICgpXG5sZXQgYm9vbCA9IGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPiBTcGxpdHRhYmxlX3JhbmRvbS5ib29sIHJhbmRvbSlcbmxldCBvcHRpb24gdmFsdWVfdCA9IHVuaW9uIFsgcmV0dXJuIE5vbmU7IG1hcCB2YWx1ZV90IH5mOk9wdGlvbi5yZXR1cm4gXVxubGV0IGVpdGhlciBmc3RfdCBzbmRfdCA9IHVuaW9uIFsgbWFwIGZzdF90IH5mOkVpdGhlci5maXJzdDsgbWFwIHNuZF90IH5mOkVpdGhlci5zZWNvbmQgXVxuXG5sZXQgcmVzdWx0IG9rX3QgZXJyX3QgPVxuICBtYXAgKGVpdGhlciBva190IGVycl90KSB+ZjooZnVuY3Rpb25cbiAgICB8IEZpcnN0IG9rIC0+IE9rIG9rXG4gICAgfCBTZWNvbmQgZXJyIC0+IEVycm9yIGVycilcbjs7XG5cbmxldCBsaXN0X2dlbmVyaWMgP21pbl9sZW5ndGggP21heF9sZW5ndGggZWx0X2dlbiA9XG4gIGxldCViaW5kIHNpemVzID0gc2l6ZXMgP21pbl9sZW5ndGggP21heF9sZW5ndGggKCkgaW5cbiAgTGlzdC5tYXAgc2l6ZXMgfmY6KGZ1biBzaXplIC0+IHdpdGhfc2l6ZSB+c2l6ZSBlbHRfZ2VuKSB8PiBhbGxcbjs7XG5cbmxldCBsaXN0IGVsdF9nZW4gPSBsaXN0X2dlbmVyaWMgZWx0X2dlblxubGV0IGxpc3Rfbm9uX2VtcHR5IGVsdF9nZW4gPSBsaXN0X2dlbmVyaWMgfm1pbl9sZW5ndGg6MSBlbHRfZ2VuXG5cbmxldCBsaXN0X3dpdGhfbGVuZ3RoIGVsdF9nZW4gfmxlbmd0aCA9XG4gIGxpc3RfZ2VuZXJpYyB+bWluX2xlbmd0aDpsZW5ndGggfm1heF9sZW5ndGg6bGVuZ3RoIGVsdF9nZW5cbjs7XG5cbmxldCBsaXN0X2ZpbHRlcmVkIGVsdHMgPVxuICBsZXQgZWx0cyA9IEFycmF5Lm9mX2xpc3QgZWx0cyBpblxuICBsZXQgbGVuZ3RoX29mX2lucHV0ID0gQXJyYXkubGVuZ3RoIGVsdHMgaW5cbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgbGV0IGxlbmd0aF9vZl9vdXRwdXQgPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzowIH5oaTpsZW5ndGhfb2ZfaW5wdXQgaW5cbiAgICBsZXQgaW5kaWNlcyA9IEFycmF5LmluaXQgbGVuZ3RoX29mX2lucHV0IH5mOkZuLmlkIGluXG4gICAgKCogQ2hvb3NlIFtsZW5ndGhfb2Zfb3V0cHV0XSByYW5kb20gdmFsdWVzIGluIHRoZSBwcmVmaXggb2YgW2luZGljZXNdLiAqKVxuICAgIGZvciBpID0gMCB0byBsZW5ndGhfb2Zfb3V0cHV0IC0gMSBkb1xuICAgICAgbGV0IGogPSBTcGxpdHRhYmxlX3JhbmRvbS5pbnQgcmFuZG9tIH5sbzppIH5oaToobGVuZ3RoX29mX2lucHV0IC0gMSkgaW5cbiAgICAgIEFycmF5LnN3YXAgaW5kaWNlcyBpIGpcbiAgICBkb25lO1xuICAgICgqIFNvcnQgdGhlIGNob3NlbiBpbmRpY2VzIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCB0byByZW9yZGVyIHRoZW0uICopXG4gICAgQXJyYXkuc29ydCBpbmRpY2VzIH5wb3M6MCB+bGVuOmxlbmd0aF9vZl9vdXRwdXQgfmNvbXBhcmU6SW50LmNvbXBhcmU7XG4gICAgKCogUmV0dXJuIHRoZSBjaG9zZW4gZWxlbWVudHMuICopXG4gICAgTGlzdC5pbml0IGxlbmd0aF9vZl9vdXRwdXQgfmY6KGZ1biBpIC0+IGVsdHMuKGluZGljZXMuKGkpKSkpXG47O1xuXG5sZXQgbGlzdF9wZXJtdXRhdGlvbnMgbGlzdCA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIGxldCBhcnJheSA9IEFycmF5Lm9mX2xpc3QgbGlzdCBpblxuICAgIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyYXkgLSAxIGRvXG4gICAgICBsZXQgaiA9IFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOjAgfmhpOmkgaW5cbiAgICAgIEFycmF5LnN3YXAgYXJyYXkgaSBqXG4gICAgZG9uZTtcbiAgICBBcnJheS50b19saXN0IGFycmF5KVxuOztcblxubGV0IGFycmF5IHQgPSBtYXAgKGxpc3QgdCkgfmY6QXJyYXkub2ZfbGlzdFxubGV0IHJlZiB0ID0gbWFwIHQgfmY6UmVmLmNyZWF0ZVxubGV0IGxhenlfdCB0ID0gbWFwIHQgfmY6TGF6eS5mcm9tX3ZhbFxuXG5sZXQgY2hhcl91bmlmb3JtX2luY2x1c2l2ZSBsbyBoaSA9XG4gIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPlxuICAgIFNwbGl0dGFibGVfcmFuZG9tLmludCByYW5kb20gfmxvOihDaGFyLnRvX2ludCBsbykgfmhpOihDaGFyLnRvX2ludCBoaSlcbiAgICB8PiBDaGFyLnVuc2FmZV9vZl9pbnQpXG47O1xuXG5sZXQgY2hhcl91cHBlcmNhc2UgPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICdBJyAnWidcbmxldCBjaGFyX2xvd2VyY2FzZSA9IGNoYXJfdW5pZm9ybV9pbmNsdXNpdmUgJ2EnICd6J1xubGV0IGNoYXJfZGlnaXQgPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICcwJyAnOSdcbmxldCBjaGFyX3ByaW50X3VuaWZvcm0gPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlICcgJyAnfidcbmxldCBjaGFyX3VuaWZvcm0gPSBjaGFyX3VuaWZvcm1faW5jbHVzaXZlIENoYXIubWluX3ZhbHVlIENoYXIubWF4X3ZhbHVlXG5sZXQgY2hhcl9hbHBoYSA9IHVuaW9uIFsgY2hhcl9sb3dlcmNhc2U7IGNoYXJfdXBwZXJjYXNlIF1cblxubGV0IGNoYXJfYWxwaGFudW0gPVxuICB3ZWlnaHRlZF91bmlvblxuICAgICgqIE1vc3QgcGVvcGxlIHByb2JhYmx5IGV4cGVjdCB0aGlzIHRvIGJlIGEgdW5pZm9ybSBkaXN0cmlidXRpb24sIG5vdCB3ZWlnaHRlZFxuICAgICAgIHRvd2FyZCBkaWdpdHMgbGlrZSB3ZSB3b3VsZCBnZXQgd2l0aCBbdW5pb25dIChzaW5jZSB0aGVyZSBhcmUgZmV3ZXIgZGlnaXRzIHRoYW5cbiAgICAgICBsZXR0ZXJzKS4gKilcbiAgICBbIDUyLiwgY2hhcl9hbHBoYTsgMTAuLCBjaGFyX2RpZ2l0IF1cbjs7XG5cbmxldCBjaGFyX3doaXRlc3BhY2UgPSBvZl9saXN0IChMaXN0LmZpbHRlciBDaGFyLmFsbCB+ZjpDaGFyLmlzX3doaXRlc3BhY2UpXG5sZXQgY2hhcl9wcmludCA9IHdlaWdodGVkX3VuaW9uIFsgMTAuLCBjaGFyX2FscGhhbnVtOyAxLiwgY2hhcl9wcmludF91bmlmb3JtIF1cblxubGV0IGNoYXIgPVxuICB3ZWlnaHRlZF91bmlvblxuICAgIFsgMTAwLiwgY2hhcl9wcmludFxuICAgIDsgMTAuLCBjaGFyX3VuaWZvcm1cbiAgICA7IDEuLCByZXR1cm4gQ2hhci5taW5fdmFsdWVcbiAgICA7IDEuLCByZXR1cm4gQ2hhci5tYXhfdmFsdWVcbiAgICBdXG47O1xuXG4oKiBQcm9kdWNlcyBhIG51bWJlciBmcm9tIDAgb3IgMSB0byBzaXplICsgMSwgd2VpZ2h0ZWQgaGlnaC4gV2UgaGF2ZSBmb3VuZCB0aGlzXG4gICBkaXN0cmlidXRpb24gZW1waXJpY2FsbHkgdXNlZnVsIGZvciBzdHJpbmcgbGVuZ3Rocy4gKilcbmxldCBzbWFsbF9pbnQgfmFsbG93X3plcm8gPVxuICBjcmVhdGUgKGZ1biB+c2l6ZSB+cmFuZG9tIC0+XG4gICAgbGV0IGxvd2VyX2JvdW5kID0gaWYgYWxsb3dfemVybyB0aGVuIDAgZWxzZSAxIGluXG4gICAgbGV0IHVwcGVyX2JvdW5kID0gc2l6ZSArIDEgaW5cbiAgICBsZXQgd2VpZ2h0ZWRfbG93ID1cbiAgICAgIFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludCByYW5kb20gfmxvOjAgfmhpOih1cHBlcl9ib3VuZCAtIGxvd2VyX2JvdW5kKVxuICAgIGluXG4gICAgbGV0IHdlaWdodGVkX2hpZ2ggPSB1cHBlcl9ib3VuZCAtIHdlaWdodGVkX2xvdyBpblxuICAgIHdlaWdodGVkX2hpZ2gpXG47O1xuXG5sZXQgc21hbGxfcG9zaXRpdmVfb3JfemVyb19pbnQgPSBzbWFsbF9pbnQgfmFsbG93X3plcm86dHJ1ZVxubGV0IHNtYWxsX3N0cmljdGx5X3Bvc2l0aXZlX2ludCA9IHNtYWxsX2ludCB+YWxsb3dfemVybzpmYWxzZVxuXG5tb2R1bGUgdHlwZSBJbnRfd2l0aF9yYW5kb20gPSBzaWdcbiAgaW5jbHVkZSBJbnQuU1xuXG4gIHZhbCB1bmlmb3JtIDogU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUudCAtPiBsbzp0IC0+IGhpOnQgLT4gdFxuICB2YWwgbG9nX3VuaWZvcm0gOiBTcGxpdHRhYmxlX3JhbmRvbS5TdGF0ZS50IC0+IGxvOnQgLT4gaGk6dCAtPiB0XG5lbmRcblxubW9kdWxlIEZvcl9pbnRlZ2VyIChJbnRlZ2VyIDogSW50X3dpdGhfcmFuZG9tKSA9IHN0cnVjdFxuICBsZXQgdW5pZm9ybV9pbmNsdXNpdmUgbG8gaGkgPVxuICAgIGNyZWF0ZSAoZnVuIH5zaXplOl8gfnJhbmRvbSAtPiBJbnRlZ2VyLnVuaWZvcm0gcmFuZG9tIH5sbyB+aGkpXG4gIDs7XG5cbiAgbGV0IGxvZ191bmlmb3JtX2luY2x1c2l2ZSBsbyBoaSA9XG4gICAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+IEludGVnZXIubG9nX3VuaWZvcm0gcmFuZG9tIH5sbyB+aGkpXG4gIDs7XG5cbiAgbGV0IG5vbl91bmlmb3JtIGYgbG8gaGkgPVxuICAgIHdlaWdodGVkX3VuaW9uIFsgMC4wNSwgcmV0dXJuIGxvOyAwLjA1LCByZXR1cm4gaGk7IDAuOSwgZiBsbyBoaSBdXG4gIDs7XG5cbiAgbGV0IGluY2x1c2l2ZSA9IG5vbl91bmlmb3JtIHVuaWZvcm1faW5jbHVzaXZlXG4gIGxldCBsb2dfaW5jbHVzaXZlID0gbm9uX3VuaWZvcm0gbG9nX3VuaWZvcm1faW5jbHVzaXZlXG4gIGxldCB1bmlmb3JtX2FsbCA9IHVuaWZvcm1faW5jbHVzaXZlIEludGVnZXIubWluX3ZhbHVlIEludGVnZXIubWF4X3ZhbHVlXG5cbiAgbGV0IGFsbCA9XG4gICAgWyVtYXBcbiAgICAgIGxldCBuZWdhdGl2ZSA9IGJvb2xcbiAgICAgIGFuZCBtYWduaXR1ZGUgPSBsb2dfaW5jbHVzaXZlIEludGVnZXIuemVybyBJbnRlZ2VyLm1heF92YWx1ZSBpblxuICAgICAgaWYgbmVnYXRpdmUgdGhlbiBJbnRlZ2VyLmJpdF9ub3QgbWFnbml0dWRlIGVsc2UgbWFnbml0dWRlXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBGb3JfaW50ID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50XG5cbiAgICBsZXQgdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLmludFxuICAgIGxldCBsb2dfdW5pZm9ybSA9IFNwbGl0dGFibGVfcmFuZG9tLkxvZ191bmlmb3JtLmludFxuICBlbmQpXG5cbmxldCBpbnQgPSBGb3JfaW50LmFsbFxubGV0IGludF91bmlmb3JtID0gRm9yX2ludC51bmlmb3JtX2FsbFxubGV0IGludF9pbmNsdXNpdmUgPSBGb3JfaW50LmluY2x1c2l2ZVxubGV0IGludF91bmlmb3JtX2luY2x1c2l2ZSA9IEZvcl9pbnQudW5pZm9ybV9pbmNsdXNpdmVcbmxldCBpbnRfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQubG9nX2luY2x1c2l2ZVxubGV0IGludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfaW50LmxvZ191bmlmb3JtX2luY2x1c2l2ZVxuXG5tb2R1bGUgRm9yX2ludDMyID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50MzJcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50MzJcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQzMlxuICBlbmQpXG5cbmxldCBpbnQzMiA9IEZvcl9pbnQzMi5hbGxcbmxldCBpbnQzMl91bmlmb3JtID0gRm9yX2ludDMyLnVuaWZvcm1fYWxsXG5sZXQgaW50MzJfaW5jbHVzaXZlID0gRm9yX2ludDMyLmluY2x1c2l2ZVxubGV0IGludDMyX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDMyLnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50MzJfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQzMi5sb2dfaW5jbHVzaXZlXG5sZXQgaW50MzJfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDMyLmxvZ191bmlmb3JtX2luY2x1c2l2ZVxuXG5tb2R1bGUgRm9yX2ludDYzID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50NjNcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50NjNcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQ2M1xuICBlbmQpXG5cbmxldCBpbnQ2MyA9IEZvcl9pbnQ2My5hbGxcbmxldCBpbnQ2M191bmlmb3JtID0gRm9yX2ludDYzLnVuaWZvcm1fYWxsXG5sZXQgaW50NjNfaW5jbHVzaXZlID0gRm9yX2ludDYzLmluY2x1c2l2ZVxubGV0IGludDYzX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDYzLnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50NjNfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQ2My5sb2dfaW5jbHVzaXZlXG5sZXQgaW50NjNfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDYzLmxvZ191bmlmb3JtX2luY2x1c2l2ZVxuXG5tb2R1bGUgRm9yX2ludDY0ID0gRm9yX2ludGVnZXIgKHN0cnVjdFxuICAgIGluY2x1ZGUgSW50NjRcblxuICAgIGxldCB1bmlmb3JtID0gU3BsaXR0YWJsZV9yYW5kb20uaW50NjRcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5pbnQ2NFxuICBlbmQpXG5cbmxldCBpbnQ2NCA9IEZvcl9pbnQ2NC5hbGxcbmxldCBpbnQ2NF91bmlmb3JtID0gRm9yX2ludDY0LnVuaWZvcm1fYWxsXG5sZXQgaW50NjRfaW5jbHVzaXZlID0gRm9yX2ludDY0LmluY2x1c2l2ZVxubGV0IGludDY0X3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDY0LnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgaW50NjRfbG9nX2luY2x1c2l2ZSA9IEZvcl9pbnQ2NC5sb2dfaW5jbHVzaXZlXG5sZXQgaW50NjRfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX2ludDY0LmxvZ191bmlmb3JtX2luY2x1c2l2ZVxuXG5tb2R1bGUgRm9yX25hdGl2ZWludCA9IEZvcl9pbnRlZ2VyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE5hdGl2ZWludFxuXG4gICAgbGV0IHVuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5uYXRpdmVpbnRcbiAgICBsZXQgbG9nX3VuaWZvcm0gPSBTcGxpdHRhYmxlX3JhbmRvbS5Mb2dfdW5pZm9ybS5uYXRpdmVpbnRcbiAgZW5kKVxuXG5sZXQgbmF0aXZlaW50ID0gRm9yX25hdGl2ZWludC5hbGxcbmxldCBuYXRpdmVpbnRfdW5pZm9ybSA9IEZvcl9uYXRpdmVpbnQudW5pZm9ybV9hbGxcbmxldCBuYXRpdmVpbnRfaW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC5pbmNsdXNpdmVcbmxldCBuYXRpdmVpbnRfdW5pZm9ybV9pbmNsdXNpdmUgPSBGb3JfbmF0aXZlaW50LnVuaWZvcm1faW5jbHVzaXZlXG5sZXQgbmF0aXZlaW50X2xvZ19pbmNsdXNpdmUgPSBGb3JfbmF0aXZlaW50LmxvZ19pbmNsdXNpdmVcbmxldCBuYXRpdmVpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlID0gRm9yX25hdGl2ZWludC5sb2dfdW5pZm9ybV9pbmNsdXNpdmVcbmxldCBmbG9hdF96ZXJvX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCAwLlxubGV0IGZsb2F0X3plcm9fbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIDAuXG5cbmxldCBmbG9hdF9tYXhfcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlID1cbiAgRmxvYXQub25lX3VscCBgRG93biBGbG9hdC5taW5fcG9zaXRpdmVfbm9ybWFsX3ZhbHVlXG47O1xuXG5sZXQgZmxvYXRfc3Vibm9ybWFsX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBGbG9hdC5taW5fcG9zaXRpdmVfc3Vibm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWluX3N1Ym5vcm1hbF9tYW50aXNzYSA9IEZsb2F0LmllZWVfbWFudGlzc2EgRmxvYXQubWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZVxubGV0IGZsb2F0X21heF9zdWJub3JtYWxfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIGZsb2F0X21heF9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9tYXhfcG9zaXRpdmVfbm9ybWFsX3ZhbHVlID0gRmxvYXQubWF4X2Zpbml0ZV92YWx1ZVxubGV0IGZsb2F0X21pbl9ub3JtYWxfZXhwb25lbnQgPSBGbG9hdC5pZWVlX2V4cG9uZW50IEZsb2F0Lm1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWVcbmxldCBmbG9hdF9tYXhfbm9ybWFsX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBmbG9hdF9tYXhfcG9zaXRpdmVfbm9ybWFsX3ZhbHVlXG5sZXQgZmxvYXRfbWF4X25vcm1hbF9tYW50aXNzYSA9IEZsb2F0LmllZWVfbWFudGlzc2EgZmxvYXRfbWF4X3Bvc2l0aXZlX25vcm1hbF92YWx1ZVxubGV0IGZsb2F0X2luZl9leHBvbmVudCA9IEZsb2F0LmllZWVfZXhwb25lbnQgRmxvYXQuaW5maW5pdHlcbmxldCBmbG9hdF9pbmZfbWFudGlzc2EgPSBGbG9hdC5pZWVlX21hbnRpc3NhIEZsb2F0LmluZmluaXR5XG5sZXQgZmxvYXRfbmFuX2V4cG9uZW50ID0gRmxvYXQuaWVlZV9leHBvbmVudCBGbG9hdC5uYW5cbmxldCBmbG9hdF9taW5fbmFuX21hbnRpc3NhID0gSW50NjMuc3VjYyBmbG9hdF9pbmZfbWFudGlzc2FcbmxldCBmbG9hdF9tYXhfbmFuX21hbnRpc3NhID0gZmxvYXRfbWF4X25vcm1hbF9tYW50aXNzYVxubGV0IGZsb2F0X251bV9tYW50aXNzYV9iaXRzID0gNTJcblxuKCogV2Ugd2VpZ2h0IG1hbnRpc3NhcyBzbyB0aGF0IFwiaW50ZWdlci1saWtlXCIgdmFsdWVzLCBhbmQgdmFsdWVzIHdpdGggb25seSBhIGZldyBkaWdpdHNcbiAgIHBhc3QgdGhlIGRlY2ltYWwsIGFyZSByZWFzb25hYmx5IGNvbW1vbi4gKilcbmxldCBmbG9hdF9ub3JtYWxfbWFudGlzc2EgPVxuICBsZXQlYmluZCBudW1fYml0cyA9IEZvcl9pbnQudW5pZm9ybV9pbmNsdXNpdmUgMCBmbG9hdF9udW1fbWFudGlzc2FfYml0cyBpblxuICBsZXQlbWFwIGJpdHMgPVxuICAgIEZvcl9pbnQ2My5pbmNsdXNpdmUgSW50NjMuemVybyAoSW50NjMucHJlZCAoSW50NjMuc2hpZnRfbGVmdCBJbnQ2My5vbmUgbnVtX2JpdHMpKVxuICBpblxuICBJbnQ2My5zaGlmdF9sZWZ0IGJpdHMgKEludC4oIC0gKSBmbG9hdF9udW1fbWFudGlzc2FfYml0cyBudW1fYml0cylcbjs7XG5cbmxldCBmbG9hdF9leHBvbmVudF93ZWlnaHRlZF9sb3cgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBsZXQlbWFwIG9mZnNldCA9IEZvcl9pbnQubG9nX2luY2x1c2l2ZSAwIChJbnQuKCAtICkgdXBwZXJfYm91bmQgbG93ZXJfYm91bmQpIGluXG4gIEludC4oICsgKSBsb3dlcl9ib3VuZCBvZmZzZXRcbjs7XG5cbmxldCBmbG9hdF9leHBvbmVudF93ZWlnaHRlZF9oaWdoIGxvd2VyX2JvdW5kIHVwcGVyX2JvdW5kID1cbiAgbGV0JW1hcCBvZmZzZXQgPSBGb3JfaW50LmxvZ19pbmNsdXNpdmUgMCAoSW50LiggLSApIHVwcGVyX2JvdW5kIGxvd2VyX2JvdW5kKSBpblxuICBJbnQuKCAtICkgdXBwZXJfYm91bmQgb2Zmc2V0XG47O1xuXG4oKiBXZSB3ZWlnaHQgZXhwb25lbnRzIHN1Y2ggdGhhdCB2YWx1ZXMgbmVhciAxIGFyZSBtb3JlIGxpa2VseS4gKilcbmxldCBmbG9hdF9leHBvbmVudCA9XG4gIGxldCBtaWRwb2ludCA9IEZsb2F0LmllZWVfZXhwb25lbnQgMS4gaW5cbiAgdW5pb25cbiAgICBbIGZsb2F0X2V4cG9uZW50X3dlaWdodGVkX2hpZ2ggZmxvYXRfbWluX25vcm1hbF9leHBvbmVudCBtaWRwb2ludFxuICAgIDsgZmxvYXRfZXhwb25lbnRfd2VpZ2h0ZWRfbG93IG1pZHBvaW50IGZsb2F0X21heF9ub3JtYWxfZXhwb25lbnRcbiAgICBdXG47O1xuXG5sZXQgZmxvYXRfemVybyA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4blxuICAgIH5uZWdhdGl2ZVxuICAgIH5leHBvbmVudDpmbG9hdF96ZXJvX2V4cG9uZW50XG4gICAgfm1hbnRpc3NhOmZsb2F0X3plcm9fbWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9zdWJub3JtYWwgPVxuICBsZXQlbWFwIG5lZ2F0aXZlID0gYm9vbFxuICBhbmQgZXhwb25lbnQgPSByZXR1cm4gZmxvYXRfc3Vibm9ybWFsX2V4cG9uZW50XG4gIGFuZCBtYW50aXNzYSA9XG4gICAgRm9yX2ludDYzLmxvZ19pbmNsdXNpdmUgZmxvYXRfbWluX3N1Ym5vcm1hbF9tYW50aXNzYSBmbG9hdF9tYXhfc3Vibm9ybWFsX21hbnRpc3NhXG4gIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYVxuOztcblxubGV0IGZsb2F0X25vcm1hbCA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sXG4gIGFuZCBleHBvbmVudCA9IGZsb2F0X2V4cG9uZW50XG4gIGFuZCBtYW50aXNzYSA9IGZsb2F0X25vcm1hbF9tYW50aXNzYSBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9pbmZpbml0ZSA9XG4gIGxldCVtYXAgbmVnYXRpdmUgPSBib29sIGluXG4gIEZsb2F0LmNyZWF0ZV9pZWVlX2V4blxuICAgIH5uZWdhdGl2ZVxuICAgIH5leHBvbmVudDpmbG9hdF9pbmZfZXhwb25lbnRcbiAgICB+bWFudGlzc2E6ZmxvYXRfaW5mX21hbnRpc3NhXG47O1xuXG5sZXQgZmxvYXRfbmFuID1cbiAgbGV0JW1hcCBuZWdhdGl2ZSA9IGJvb2xcbiAgYW5kIGV4cG9uZW50ID0gcmV0dXJuIGZsb2F0X25hbl9leHBvbmVudFxuICBhbmQgbWFudGlzc2EgPSBGb3JfaW50NjMuaW5jbHVzaXZlIGZsb2F0X21pbl9uYW5fbWFudGlzc2EgZmxvYXRfbWF4X25hbl9tYW50aXNzYSBpblxuICBGbG9hdC5jcmVhdGVfaWVlZV9leG4gfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2Fcbjs7XG5cbmxldCBmbG9hdF9vZl9jbGFzcyBjID1cbiAgbWF0Y2ggKGMgOiBGbG9hdC5DbGFzcy50KSB3aXRoXG4gIHwgWmVybyAtPiBmbG9hdF96ZXJvXG4gIHwgU3Vibm9ybWFsIC0+IGZsb2F0X3N1Ym5vcm1hbFxuICB8IE5vcm1hbCAtPiBmbG9hdF9ub3JtYWxcbiAgfCBJbmZpbml0ZSAtPiBmbG9hdF9pbmZpbml0ZVxuICB8IE5hbiAtPiBmbG9hdF9uYW5cbjs7XG5cbmxldCBmbG9hdF93ZWlnaHRfb2ZfY2xhc3MgYyA9XG4gIG1hdGNoIChjIDogRmxvYXQuQ2xhc3MudCkgd2l0aFxuICB8IFplcm8gLT4gMS5cbiAgfCBTdWJub3JtYWwgLT4gMTAuXG4gIHwgTm9ybWFsIC0+IDEwMC5cbiAgfCBJbmZpbml0ZSAtPiAxLlxuICB8IE5hbiAtPiAxLlxuOztcblxubGV0IGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgZmlsdGVyID1cbiAgTGlzdC5maWx0ZXJfbWFwIEZsb2F0LkNsYXNzLmFsbCB+ZjooZnVuIGMgLT5cbiAgICBpZiBmaWx0ZXIgYyB0aGVuIFNvbWUgKGZsb2F0X3dlaWdodF9vZl9jbGFzcyBjLCBmbG9hdF9vZl9jbGFzcyBjKSBlbHNlIE5vbmUpXG4gIHw+IHdlaWdodGVkX3VuaW9uXG47O1xuXG5sZXQgZmxvYXRfZmluaXRlID1cbiAgZmxvYXRfbWF0Y2hpbmdfY2xhc3NlcyAoZnVuY3Rpb25cbiAgICB8IFplcm8gfCBTdWJub3JtYWwgfCBOb3JtYWwgLT4gdHJ1ZVxuICAgIHwgSW5maW5pdGUgfCBOYW4gLT4gZmFsc2UpXG47O1xuXG5sZXQgZmxvYXRfd2l0aG91dF9uYW4gPVxuICBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIChmdW5jdGlvblxuICAgIHwgWmVybyB8IFN1Ym5vcm1hbCB8IE5vcm1hbCB8IEluZmluaXRlIC0+IHRydWVcbiAgICB8IE5hbiAtPiBmYWxzZSlcbjs7XG5cbmxldCBmbG9hdCA9IGZsb2F0X21hdGNoaW5nX2NsYXNzZXMgKGZ1biBfIC0+IHRydWUpXG5cbmxldCBmbG9hdF9maW5pdGVfbm9uX3plcm8gPVxuICBmbG9hdF9tYXRjaGluZ19jbGFzc2VzIChmdW5jdGlvblxuICAgIHwgU3Vibm9ybWFsIHwgTm9ybWFsIC0+IHRydWVcbiAgICB8IFplcm8gfCBJbmZpbml0ZSB8IE5hbiAtPiBmYWxzZSlcbjs7XG5cbmxldCBmbG9hdF9zdHJpY3RseV9wb3NpdGl2ZSA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZV9ub25femVybyBpblxuICBGbG9hdC5hYnMgdFxuOztcblxubGV0IGZsb2F0X3N0cmljdGx5X25lZ2F0aXZlID1cbiAgbGV0JW1hcCB0ID0gZmxvYXRfZmluaXRlX25vbl96ZXJvIGluXG4gIH4tLihGbG9hdC5hYnMgdClcbjs7XG5cbmxldCBmbG9hdF9wb3NpdGl2ZV9vcl96ZXJvID1cbiAgbGV0JW1hcCB0ID0gZmxvYXRfZmluaXRlIGluXG4gIEZsb2F0LmFicyB0XG47O1xuXG5sZXQgZmxvYXRfbmVnYXRpdmVfb3JfemVybyA9XG4gIGxldCVtYXAgdCA9IGZsb2F0X2Zpbml0ZSBpblxuICB+LS4oRmxvYXQuYWJzIHQpXG47O1xuXG5sZXQgZmxvYXRfdW5pZm9ybV9leGNsdXNpdmUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBsZXQgb3BlbiBGbG9hdC5PIGluXG4gIGlmIChub3QgKEZsb2F0LmlzX2Zpbml0ZSBsb3dlcl9ib3VuZCkpIHx8IG5vdCAoRmxvYXQuaXNfZmluaXRlIHVwcGVyX2JvdW5kKVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiRmxvYXQudW5pZm9ybV9leGNsdXNpdmU6IGJvdW5kcyBhcmUgbm90IGZpbml0ZVwiXG4gICAgICAgICAgKGxvd2VyX2JvdW5kIDogZmxvYXQpXG4gICAgICAgICAgKHVwcGVyX2JvdW5kIDogZmxvYXQpXTtcbiAgbGV0IGxvd2VyX2luY2x1c2l2ZSA9IEZsb2F0Lm9uZV91bHAgYFVwIGxvd2VyX2JvdW5kIGluXG4gIGxldCB1cHBlcl9pbmNsdXNpdmUgPSBGbG9hdC5vbmVfdWxwIGBEb3duIHVwcGVyX2JvdW5kIGluXG4gIGlmIGxvd2VyX2luY2x1c2l2ZSA+IHVwcGVyX2luY2x1c2l2ZVxuICB0aGVuXG4gICAgcmFpc2Vfc1xuICAgICAgWyVtZXNzYWdlXG4gICAgICAgIFwiRmxvYXQudW5pZm9ybV9leGNsdXNpdmU6IHJlcXVlc3RlZCByYW5nZSBpcyBlbXB0eVwiXG4gICAgICAgICAgKGxvd2VyX2JvdW5kIDogZmxvYXQpXG4gICAgICAgICAgKHVwcGVyX2JvdW5kIDogZmxvYXQpXTtcbiAgY3JlYXRlIChmdW4gfnNpemU6XyB+cmFuZG9tIC0+XG4gICAgU3BsaXR0YWJsZV9yYW5kb20uZmxvYXQgcmFuZG9tIH5sbzpsb3dlcl9pbmNsdXNpdmUgfmhpOnVwcGVyX2luY2x1c2l2ZSlcbjs7XG5cbmxldCBmbG9hdF9pbmNsdXNpdmUgbG93ZXJfYm91bmQgdXBwZXJfYm91bmQgPVxuICBpZiBGbG9hdC5lcXVhbCBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZFxuICB0aGVuIHJldHVybiBsb3dlcl9ib3VuZFxuICBlbHNlIGlmIEZsb2F0LiggPSApIChGbG9hdC5vbmVfdWxwIGBVcCBsb3dlcl9ib3VuZCkgdXBwZXJfYm91bmRcbiAgdGhlbiB1bmlvbiBbIHJldHVybiBsb3dlcl9ib3VuZDsgcmV0dXJuIHVwcGVyX2JvdW5kIF1cbiAgZWxzZVxuICAgIHdlaWdodGVkX3VuaW9uXG4gICAgICBbIDAuMDUsIHJldHVybiBsb3dlcl9ib3VuZFxuICAgICAgOyAwLjA1LCByZXR1cm4gdXBwZXJfYm91bmRcbiAgICAgIDsgMC45LCBmbG9hdF91bmlmb3JtX2V4Y2x1c2l2ZSBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZFxuICAgICAgXVxuOztcblxubGV0IHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyX2dlbiB+bGVuZ3RoID1cbiAgbGlzdF93aXRoX2xlbmd0aCBjaGFyX2dlbiB+bGVuZ3RoIHw+IG1hcCB+ZjpTdHJpbmcub2ZfY2hhcl9saXN0XG47O1xuXG5sZXQgc3RyaW5nX29mIGNoYXJfZ2VuID1cbiAgYmluZCBzbWFsbF9wb3NpdGl2ZV9vcl96ZXJvX2ludCB+ZjooZnVuIGxlbmd0aCAtPlxuICAgIHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyX2dlbiB+bGVuZ3RoKVxuOztcblxubGV0IHN0cmluZ19ub25fZW1wdHlfb2YgY2hhcl9nZW4gPVxuICBiaW5kIHNtYWxsX3N0cmljdGx5X3Bvc2l0aXZlX2ludCB+ZjooZnVuIGxlbmd0aCAtPlxuICAgIHN0cmluZ193aXRoX2xlbmd0aF9vZiBjaGFyX2dlbiB+bGVuZ3RoKVxuOztcblxubGV0IHN0cmluZyA9IHN0cmluZ19vZiBjaGFyXG5sZXQgc3RyaW5nX25vbl9lbXB0eSA9IHN0cmluZ19ub25fZW1wdHlfb2YgY2hhclxubGV0IHN0cmluZ193aXRoX2xlbmd0aCB+bGVuZ3RoID0gc3RyaW5nX3dpdGhfbGVuZ3RoX29mIGNoYXIgfmxlbmd0aFxubGV0IGJ5dGVzID0gbWFwIHN0cmluZyB+ZjpCeXRlcy5vZl9zdHJpbmdcblxubGV0IHNleHBfb2YgYXRvbSA9XG4gIGZpeGVkX3BvaW50IChmdW4gc2VsZiAtPlxuICAgIGxldCViaW5kIHNpemUgPSBzaXplIGluXG4gICAgKCogY2hvb3NlIGEgbnVtYmVyIHdlaWdodGVkIGxvdyBzbyB3ZSBoYXZlIGEgZGVjcmVhc2luZywgYnV0IG5vdCB2YW5pc2hpbmcsIGNoYW5jZVxuICAgICAgIHRvIGdlbmVyYXRlIGF0b21zIGFzIHNpemUgZ3Jvd3MgKilcbiAgICBtYXRjaCViaW5kIEZvcl9pbnQubG9nX3VuaWZvcm1faW5jbHVzaXZlIDAgKHNpemUgKyAxKSB3aXRoXG4gICAgKCogZ2VuZXJhdGUgYW4gYXRvbSB1c2luZyB0aGUgZ2l2ZW4gc2l6ZSAqKVxuICAgIHwgMCAtPlxuICAgICAgbGV0JW1hcCBhdG9tID0gYXRvbSBpblxuICAgICAgU2V4cC5BdG9tIGF0b21cbiAgICAoKiByZWx5aW5nIG9uIFtMaXN0Lmdlbl0gdG8gZGlzdHJpYnV0ZSBbc2l6ZV0gb3ZlciBzdWItc2V4cHMgKilcbiAgICB8IF8gLT5cbiAgICAgIGxldCVtYXAgbGlzdCA9IGxpc3Qgc2VsZiBpblxuICAgICAgU2V4cC5MaXN0IGxpc3QpXG47O1xuXG5sZXQgc2V4cCA9IHNleHBfb2Ygc3RyaW5nXG5cbmxldCBtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV9nZW4gZGF0YV9nZW4gPVxuICBsZXQlYmluZCBrZXlzID0gbGlzdCBrZXlfZ2VuIGluXG4gIGxldCBrZXlzID0gTGlzdC5kZWR1cF9hbmRfc29ydCBrZXlzIH5jb21wYXJlOmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gIGxldCViaW5kIGRhdGEgPSBsaXN0X3dpdGhfbGVuZ3RoIGRhdGFfZ2VuIH5sZW5ndGg6KExpc3QubGVuZ3RoIGtleXMpIGluXG4gIHJldHVybiAoTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5vZl9hbGlzdF9leG4gfmNvbXBhcmF0b3IgKExpc3QuemlwX2V4biBrZXlzIGRhdGEpKVxuOztcblxubGV0IHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X2dlbiA9XG4gIG1hcCAobGlzdCBlbHRfZ2VuKSB+ZjooU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5vZl9saXN0IH5jb21wYXJhdG9yKVxuOztcblxubGV0IGNvbXBhcmF0b3Jfb2ZfbVxuICAgICAgKHR5cGUgYSBjKVxuICAgICAgKG1vZHVsZSBNIDogQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gYSBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjKVxuICA9XG4gIE0uY29tcGFyYXRvclxuOztcblxubGV0IG1hcF90X20gbSBrZXlfZ2VuIGRhdGFfZ2VuID1cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yX29mX20gbSBpblxuICBtYXBfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGtleV9nZW4gZGF0YV9nZW5cbiAgfD4gbWFwIH5mOihNYXAuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuOztcblxubGV0IHNldF90X20gbSBlbHRfZ2VuID1cbiAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yX29mX20gbSBpblxuICBzZXRfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGVsdF9nZW5cbiAgfD4gbWFwIH5mOihTZXQuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuOztcblxubGV0IGJpZ2FycmF5MSB0IGtpbmQgbGF5b3V0ID1cbiAgbGV0JW1hcCBlbHRzID0gbGlzdCB0IGluXG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBkaW0gPSBBcnJheS5sZW5ndGggZWx0cyBpblxuICBsZXQgb2Zmc2V0ID0gQmlnYXJyYXlfaGVscGVycy5MYXlvdXQub2Zmc2V0IGxheW91dCBpblxuICBCaWdhcnJheV9oZWxwZXJzLkFycmF5MS5pbml0IGtpbmQgbGF5b3V0IGRpbSB+ZjooZnVuIGkgLT4gZWx0cy4oaSAtIG9mZnNldCkpXG47O1xuXG5sZXQgYmlnc3RyaW5nID0gYmlnYXJyYXkxIGNoYXIgQ2hhciBDX2xheW91dFxubGV0IGZsb2F0MzJfdmVjID0gYmlnYXJyYXkxIGZsb2F0IEZsb2F0MzIgRm9ydHJhbl9sYXlvdXRcbmxldCBmbG9hdDY0X3ZlYyA9IGJpZ2FycmF5MSBmbG9hdCBGbG9hdDY0IEZvcnRyYW5fbGF5b3V0XG5cbmxldCBiaWdhcnJheTJfZGltID1cbiAgbWF0Y2glYmluZCBzaXplIHdpdGhcbiAgfCAwIC0+IHJldHVybiAoMCwgMClcbiAgfCBtYXhfdG90YWxfc2l6ZSAtPlxuICAgIGxldCViaW5kIGEgPVxuICAgICAgKCogY2hvb3NlIGEgZGltZW5zaW9uIHVwIHRvIFttYXhfdG90YWxfc2l6ZV0sIHdlaWdodGVkIGxvdyB0byBnaXZlIHRoZSBvdGhlclxuICAgICAgICAgZGltZW5zaW9uIGEgZ29vZCBjaGFuY2Ugb2YgYmVpbmcgY29tcGFyYXRpdmVseSBoaWdoICopXG4gICAgICBpbnRfbG9nX3VuaWZvcm1faW5jbHVzaXZlIDEgbWF4X3RvdGFsX3NpemVcbiAgICBpblxuICAgIGxldCViaW5kIGIgPVxuICAgICAgKCogY2hvb3NlIGEgZGltZW5zaW9uIHVwIHRvIFttYXhfdG90YWxfc2l6ZSAvIGFdLCB3ZWlnaHRlZCBoaWdoIHRvIHJlYWNoIGNsb3NlIHRvXG4gICAgICAgICBbbWF4X3RvdGFsX3NpemVdIG1vc3Qgb2YgdGhlIHRpbWUgKilcbiAgICAgIGxldCBtYXhfYiA9IG1heF90b3RhbF9zaXplIC8gYSBpblxuICAgICAgbGV0JW1hcCBiX3dlaWdodGVkX2xvdyA9IGludF9sb2dfdW5pZm9ybV9pbmNsdXNpdmUgMCBtYXhfYiBpblxuICAgICAgbWF4X2IgLSBiX3dlaWdodGVkX2xvd1xuICAgIGluXG4gICAgKCogYXZvaWQgYW55IHNrZXcgb2YgYSB2cyBiIGJ5IHJhbmRvbWx5IHN3YXBwaW5nICopXG4gICAgaWYlbWFwIGJvb2wgdGhlbiBhLCBiIGVsc2UgYiwgYVxuOztcblxubGV0IGJpZ2FycmF5MiB0IGtpbmQgbGF5b3V0ID1cbiAgbGV0JWJpbmQgZGltMSwgZGltMiA9IGJpZ2FycmF5Ml9kaW0gaW5cbiAgbGV0JW1hcCBlbHRzID0gbGlzdF93aXRoX2xlbmd0aCB+bGVuZ3RoOmRpbTEgKGxpc3Rfd2l0aF9sZW5ndGggfmxlbmd0aDpkaW0yIHQpIGluXG4gIGxldCBlbHRzID0gQXJyYXkub2ZfbGlzdF9tYXAgfmY6QXJyYXkub2ZfbGlzdCBlbHRzIGluXG4gIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gIEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkyLmluaXQga2luZCBsYXlvdXQgZGltMSBkaW0yIH5mOihmdW4gaSBqIC0+XG4gICAgZWx0cy4oaSAtIG9mZnNldCkuKGogLSBvZmZzZXQpKVxuOztcblxubGV0IGZsb2F0MzJfbWF0ID0gYmlnYXJyYXkyIGZsb2F0IEZsb2F0MzIgRm9ydHJhbl9sYXlvdXRcbmxldCBmbG9hdDY0X21hdCA9IGJpZ2FycmF5MiBmbG9hdCBGbG9hdDY0IEZvcnRyYW5fbGF5b3V0XG5cbm1vZHVsZSBEZWJ1ZyA9IHN0cnVjdFxuICBsZXQgY292ZXJhZ2VcbiAgICAgICAgKHR5cGUgayBjbXApXG4gICAgICAgIChtb2R1bGUgQ21wIDogQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0ID0gayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXApXG4gICAgICAgIHNhbXBsZVxuICAgID1cbiAgICBTZXF1ZW5jZS5mb2xkXG4gICAgICBzYW1wbGVcbiAgICAgIH5pbml0OihNYXAuZW1wdHkgKG1vZHVsZSBDbXApKVxuICAgICAgfmY6KGZ1biBjb3VudHMgdmFsdWUgLT5cbiAgICAgICAgTWFwLnVwZGF0ZSBjb3VudHMgdmFsdWUgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgfCBOb25lIC0+IDFcbiAgICAgICAgICB8IFNvbWUgcHJldiAtPiBwcmV2ICsgMSkpXG4gIDs7XG5cbiAgbGV0IG1vbml0b3IgdCB+ZiA9XG4gICAgbWFwIHQgfmY6KGZ1biB2YWx1ZSAtPlxuICAgICAgZiB2YWx1ZTtcbiAgICAgIHZhbHVlKVxuICA7O1xuZW5kXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9DYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICBYYXZpZXIgTGVyb3ksIHByb2pldCBDcmlzdGFsLCBJTlJJQSBSb2NxdWVuY291cnQgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIENvcHlyaWdodCAxOTk2IEluc3RpdHV0IE5hdGlvbmFsIGRlIFJlY2hlcmNoZSBlbiBJbmZvcm1hdGlxdWUgZXQgICAgICopXG4oKiAgICAgZW4gQXV0b21hdGlxdWUuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mICAgICopXG4oKiAgIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAyLjEsIHdpdGggdGhlICAgICAgICAgICopXG4oKiAgIHNwZWNpYWwgZXhjZXB0aW9uIG9uIGxpbmtpbmcgZGVzY3JpYmVkIGluIHRoZSBmaWxlIExJQ0VOU0UuICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqKiA2NC1iaXQgaW50ZWdlcnMuXG5cbiAgIFRoaXMgbW9kdWxlIHByb3ZpZGVzIG9wZXJhdGlvbnMgb24gdGhlIHR5cGUgW2ludDY0XSBvZlxuICAgc2lnbmVkIDY0LWJpdCBpbnRlZ2Vycy4gIFVubGlrZSB0aGUgYnVpbHQtaW4gW2ludF0gdHlwZSxcbiAgIHRoZSB0eXBlIFtpbnQ2NF0gaXMgZ3VhcmFudGVlZCB0byBiZSBleGFjdGx5IDY0LWJpdCB3aWRlIG9uIGFsbFxuICAgcGxhdGZvcm1zLiAgQWxsIGFyaXRobWV0aWMgb3BlcmF0aW9ucyBvdmVyIFtpbnQ2NF0gYXJlIHRha2VuXG4gICBtb2R1bG8gMnteNjR9XG5cbiAgIFBlcmZvcm1hbmNlIG5vdGljZTogdmFsdWVzIG9mIHR5cGUgW2ludDY0XSBvY2N1cHkgbW9yZSBtZW1vcnlcbiAgIHNwYWNlIHRoYW4gdmFsdWVzIG9mIHR5cGUgW2ludF0sIGFuZCBhcml0aG1ldGljIG9wZXJhdGlvbnMgb25cbiAgIFtpbnQ2NF0gYXJlIGdlbmVyYWxseSBzbG93ZXIgdGhhbiB0aG9zZSBvbiBbaW50XS4gIFVzZSBbaW50NjRdXG4gICBvbmx5IHdoZW4gdGhlIGFwcGxpY2F0aW9uIHJlcXVpcmVzIGV4YWN0IDY0LWJpdCBhcml0aG1ldGljLlxuXG4gICAgTGl0ZXJhbHMgZm9yIDY0LWJpdCBpbnRlZ2VycyBhcmUgc3VmZml4ZWQgYnkgTDpcbiAgICB7W1xuICAgICAgbGV0IHplcm86IGludDY0ID0gMExcbiAgICAgIGxldCBvbmU6IGludDY0ID0gMUxcbiAgICAgIGxldCBtX29uZTogaW50NjQgPSAtMUxcbiAgICBdfVxuKilcblxudmFsIHplcm8gOiBpbnQ2NFxuKCoqIFRoZSA2NC1iaXQgaW50ZWdlciAwLiAqKVxuXG52YWwgb25lIDogaW50NjRcbigqKiBUaGUgNjQtYml0IGludGVnZXIgMS4gKilcblxudmFsIG1pbnVzX29uZSA6IGludDY0XG4oKiogVGhlIDY0LWJpdCBpbnRlZ2VyIC0xLiAqKVxuXG5leHRlcm5hbCBuZWcgOiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X25lZ1wiXG4oKiogVW5hcnkgbmVnYXRpb24uICopXG5cbmV4dGVybmFsIGFkZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYWRkXCJcbigqKiBBZGRpdGlvbi4gKilcblxuZXh0ZXJuYWwgc3ViIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9zdWJcIlxuKCoqIFN1YnRyYWN0aW9uLiAqKVxuXG5leHRlcm5hbCBtdWwgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NCA9IFwiJWludDY0X211bFwiXG4oKiogTXVsdGlwbGljYXRpb24uICopXG5cbmV4dGVybmFsIGRpdiA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfZGl2XCJcbigqKiBJbnRlZ2VyIGRpdmlzaW9uLlxuICAgQHJhaXNlIERpdmlzaW9uX2J5X3plcm8gaWYgdGhlIHNlY29uZFxuICAgYXJndW1lbnQgaXMgemVyby4gIFRoaXMgZGl2aXNpb24gcm91bmRzIHRoZSByZWFsIHF1b3RpZW50IG9mXG4gICBpdHMgYXJndW1lbnRzIHRvd2FyZHMgemVybywgYXMgc3BlY2lmaWVkIGZvciB7IVN0ZGxpYi4oLyl9LiAqKVxuXG52YWwgdW5zaWduZWRfZGl2IDogaW50NjQgLT4gaW50NjQgLT4gaW50NjRcbigqKiBTYW1lIGFzIHshZGl2fSwgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFuZCByZXN1bHQgYXJlIGludGVycHJldGVkIGFzIHtlXG4gICAgdW5zaWduZWR9IDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgIEBzaW5jZSA0LjA4LjAgKilcblxuZXh0ZXJuYWwgcmVtIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF9tb2RcIlxuKCoqIEludGVnZXIgcmVtYWluZGVyLiAgSWYgW3ldIGlzIG5vdCB6ZXJvLCB0aGUgcmVzdWx0XG4gICBvZiBbSW50NjQucmVtIHggeV0gc2F0aXNmaWVzIHRoZSBmb2xsb3dpbmcgcHJvcGVydHk6XG4gICBbeCA9IEludDY0LmFkZCAoSW50NjQubXVsIChJbnQ2NC5kaXYgeCB5KSB5KSAoSW50NjQucmVtIHggeSldLlxuICAgSWYgW3kgPSAwXSwgW0ludDY0LnJlbSB4IHldIHJhaXNlcyBbRGl2aXNpb25fYnlfemVyb10uICopXG5cbnZhbCB1bnNpZ25lZF9yZW0gOiBpbnQ2NCAtPiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIFNhbWUgYXMgeyFyZW19LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYW5kIHJlc3VsdCBhcmUgaW50ZXJwcmV0ZWQgYXMge2VcbiAgICB1bnNpZ25lZH0gNjQtYml0IGludGVnZXJzLlxuXG4gICAgQHNpbmNlIDQuMDguMCAqKVxuXG52YWwgc3VjYyA6IGludDY0IC0+IGludDY0XG4oKiogU3VjY2Vzc29yLiAgW0ludDY0LnN1Y2MgeF0gaXMgW0ludDY0LmFkZCB4IEludDY0Lm9uZV0uICopXG5cbnZhbCBwcmVkIDogaW50NjQgLT4gaW50NjRcbigqKiBQcmVkZWNlc3Nvci4gIFtJbnQ2NC5wcmVkIHhdIGlzIFtJbnQ2NC5zdWIgeCBJbnQ2NC5vbmVdLiAqKVxuXG52YWwgYWJzIDogaW50NjQgLT4gaW50NjRcbigqKiBSZXR1cm4gdGhlIGFic29sdXRlIHZhbHVlIG9mIGl0cyBhcmd1bWVudC4gKilcblxudmFsIG1heF9pbnQgOiBpbnQ2NFxuKCoqIFRoZSBncmVhdGVzdCByZXByZXNlbnRhYmxlIDY0LWJpdCBpbnRlZ2VyLCAye142M30gLSAxLiAqKVxuXG52YWwgbWluX2ludCA6IGludDY0XG4oKiogVGhlIHNtYWxsZXN0IHJlcHJlc2VudGFibGUgNjQtYml0IGludGVnZXIsIC0ye142M30uICopXG5cbmV4dGVybmFsIGxvZ2FuZCA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfYW5kXCJcbigqKiBCaXR3aXNlIGxvZ2ljYWwgYW5kLiAqKVxuXG5leHRlcm5hbCBsb2dvciA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCIlaW50NjRfb3JcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBvci4gKilcblxuZXh0ZXJuYWwgbG9neG9yIDogaW50NjQgLT4gaW50NjQgLT4gaW50NjQgPSBcIiVpbnQ2NF94b3JcIlxuKCoqIEJpdHdpc2UgbG9naWNhbCBleGNsdXNpdmUgb3IuICopXG5cbnZhbCBsb2dub3QgOiBpbnQ2NCAtPiBpbnQ2NFxuKCoqIEJpdHdpc2UgbG9naWNhbCBuZWdhdGlvbi4gKilcblxuZXh0ZXJuYWwgc2hpZnRfbGVmdCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzbFwiXG4oKiogW0ludDY0LnNoaWZ0X2xlZnQgeCB5XSBzaGlmdHMgW3hdIHRvIHRoZSBsZWZ0IGJ5IFt5XSBiaXRzLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgc2hpZnRfcmlnaHQgOiBpbnQ2NCAtPiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9hc3JcIlxuKCoqIFtJbnQ2NC5zaGlmdF9yaWdodCB4IHldIHNoaWZ0cyBbeF0gdG8gdGhlIHJpZ2h0IGJ5IFt5XSBiaXRzLlxuICAgVGhpcyBpcyBhbiBhcml0aG1ldGljIHNoaWZ0OiB0aGUgc2lnbiBiaXQgb2YgW3hdIGlzIHJlcGxpY2F0ZWRcbiAgIGFuZCBpbnNlcnRlZCBpbiB0aGUgdmFjYXRlZCBiaXRzLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IGludDY0IC0+IGludCAtPiBpbnQ2NCA9IFwiJWludDY0X2xzclwiXG4oKiogW0ludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCB5XSBzaGlmdHMgW3hdIHRvIHRoZSByaWdodCBieSBbeV0gYml0cy5cbiAgIFRoaXMgaXMgYSBsb2dpY2FsIHNoaWZ0OiB6ZXJvZXMgYXJlIGluc2VydGVkIGluIHRoZSB2YWNhdGVkIGJpdHNcbiAgIHJlZ2FyZGxlc3Mgb2YgdGhlIHNpZ24gb2YgW3hdLlxuICAgVGhlIHJlc3VsdCBpcyB1bnNwZWNpZmllZCBpZiBbeSA8IDBdIG9yIFt5ID49IDY0XS4gKilcblxuZXh0ZXJuYWwgb2ZfaW50IDogaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfaW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBpbnRlZ2VyICh0eXBlIFtpbnRdKSB0byBhIDY0LWJpdCBpbnRlZ2VyXG4gICAgKHR5cGUgW2ludDY0XSkuICopXG5cbmV4dGVybmFsIHRvX2ludCA6IGludDY0IC0+IGludCA9IFwiJWludDY0X3RvX2ludFwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkgdG8gYW5cbiAgIGludGVnZXIgKHR5cGUgW2ludF0pLiAgT24gNjQtYml0IHBsYXRmb3JtcywgdGhlIDY0LWJpdCBpbnRlZ2VyXG4gICBpcyB0YWtlbiBtb2R1bG8gMnteNjN9LCBpLmUuIHRoZSBoaWdoLW9yZGVyIGJpdCBpcyBsb3N0XG4gICBkdXJpbmcgdGhlIGNvbnZlcnNpb24uICBPbiAzMi1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye14zMX0sIGkuZS4gdGhlIHRvcCAzMyBiaXRzIGFyZSBsb3N0XG4gICBkdXJpbmcgdGhlIGNvbnZlcnNpb24uICopXG5cbnZhbCB1bnNpZ25lZF90b19pbnQgOiBpbnQ2NCAtPiBpbnQgb3B0aW9uXG4oKiogU2FtZSBhcyB7IXRvX2ludH0sIGJ1dCBpbnRlcnByZXRzIHRoZSBhcmd1bWVudCBhcyBhbiB7ZSB1bnNpZ25lZH0gaW50ZWdlci5cbiAgICBSZXR1cm5zIFtOb25lXSBpZiB0aGUgdW5zaWduZWQgdmFsdWUgb2YgdGhlIGFyZ3VtZW50IGNhbm5vdCBmaXQgaW50byBhblxuICAgIFtpbnRdLlxuXG4gICAgQHNpbmNlIDQuMDguMCAqKVxuXG5leHRlcm5hbCBvZl9mbG9hdCA6IGZsb2F0IC0+IGludDY0XG4gID0gXCJjYW1sX2ludDY0X29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X29mX2Zsb2F0X3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIGZsb2F0aW5nLXBvaW50IG51bWJlciB0byBhIDY0LWJpdCBpbnRlZ2VyLFxuICAgZGlzY2FyZGluZyB0aGUgZnJhY3Rpb25hbCBwYXJ0ICh0cnVuY2F0ZSB0b3dhcmRzIDApLlxuICAgVGhlIHJlc3VsdCBvZiB0aGUgY29udmVyc2lvbiBpcyB1bmRlZmluZWQgaWYsIGFmdGVyIHRydW5jYXRpb24sXG4gICB0aGUgbnVtYmVyIGlzIG91dHNpZGUgdGhlIHJhbmdlIFxcW3shSW50NjQubWluX2ludH0sIHshSW50NjQubWF4X2ludH1cXF0uICopXG5cbmV4dGVybmFsIHRvX2Zsb2F0IDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfdG9fZmxvYXRcIiBcImNhbWxfaW50NjRfdG9fZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgdG8gYSBmbG9hdGluZy1wb2ludCBudW1iZXIuICopXG5cblxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiAzMi1iaXQgaW50ZWdlciAodHlwZSBbaW50MzJdKVxuICAgdG8gYSA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKS4gKilcblxuZXh0ZXJuYWwgdG9faW50MzIgOiBpbnQ2NCAtPiBpbnQzMiA9IFwiJWludDY0X3RvX2ludDMyXCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiA2NC1iaXQgaW50ZWdlciAodHlwZSBbaW50NjRdKSB0byBhXG4gICAzMi1iaXQgaW50ZWdlciAodHlwZSBbaW50MzJdKS4gVGhlIDY0LWJpdCBpbnRlZ2VyXG4gICBpcyB0YWtlbiBtb2R1bG8gMnteMzJ9LCBpLmUuIHRoZSB0b3AgMzIgYml0cyBhcmUgbG9zdFxuICAgZHVyaW5nIHRoZSBjb252ZXJzaW9uLiAgKilcblxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50IDogbmF0aXZlaW50IC0+IGludDY0ID0gXCIlaW50NjRfb2ZfbmF0aXZlaW50XCJcbigqKiBDb252ZXJ0IHRoZSBnaXZlbiBuYXRpdmUgaW50ZWdlciAodHlwZSBbbmF0aXZlaW50XSlcbiAgIHRvIGEgNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkuICopXG5cbmV4dGVybmFsIHRvX25hdGl2ZWludCA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG4oKiogQ29udmVydCB0aGUgZ2l2ZW4gNjQtYml0IGludGVnZXIgKHR5cGUgW2ludDY0XSkgdG8gYVxuICAgbmF0aXZlIGludGVnZXIuICBPbiAzMi1iaXQgcGxhdGZvcm1zLCB0aGUgNjQtYml0IGludGVnZXJcbiAgIGlzIHRha2VuIG1vZHVsbyAye14zMn0uICBPbiA2NC1iaXQgcGxhdGZvcm1zLFxuICAgdGhlIGNvbnZlcnNpb24gaXMgZXhhY3QuICopXG5cbmV4dGVybmFsIG9mX3N0cmluZyA6IHN0cmluZyAtPiBpbnQ2NCA9IFwiY2FtbF9pbnQ2NF9vZl9zdHJpbmdcIlxuKCoqIENvbnZlcnQgdGhlIGdpdmVuIHN0cmluZyB0byBhIDY0LWJpdCBpbnRlZ2VyLlxuICAgVGhlIHN0cmluZyBpcyByZWFkIGluIGRlY2ltYWwgKGJ5IGRlZmF1bHQsIG9yIGlmIHRoZSBzdHJpbmdcbiAgIGJlZ2lucyB3aXRoIFswdV0pIG9yIGluIGhleGFkZWNpbWFsLCBvY3RhbCBvciBiaW5hcnkgaWYgdGhlXG4gICBzdHJpbmcgYmVnaW5zIHdpdGggWzB4XSwgWzBvXSBvciBbMGJdIHJlc3BlY3RpdmVseS5cblxuICAgVGhlIFswdV0gcHJlZml4IHJlYWRzIHRoZSBpbnB1dCBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIHRoZSByYW5nZVxuICAgW1swLCAyKkludDY0Lm1heF9pbnQrMV1dLiAgSWYgdGhlIGlucHV0IGV4Y2VlZHMgeyFJbnQ2NC5tYXhfaW50fVxuICAgaXQgaXMgY29udmVydGVkIHRvIHRoZSBzaWduZWQgaW50ZWdlclxuICAgW0ludDY0Lm1pbl9pbnQgKyBpbnB1dCAtIEludDY0Lm1heF9pbnQgLSAxXS5cblxuICAgVGhlIFtfXSAodW5kZXJzY29yZSkgY2hhcmFjdGVyIGNhbiBhcHBlYXIgYW55d2hlcmUgaW4gdGhlIHN0cmluZ1xuICAgYW5kIGlzIGlnbm9yZWQuXG4gICBAcmFpc2UgRmFpbHVyZSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIG5vdFxuICAgYSB2YWxpZCByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLCBvciBpZiB0aGUgaW50ZWdlciByZXByZXNlbnRlZFxuICAgZXhjZWVkcyB0aGUgcmFuZ2Ugb2YgaW50ZWdlcnMgcmVwcmVzZW50YWJsZSBpbiB0eXBlIFtpbnQ2NF0uICopXG5cbnZhbCBvZl9zdHJpbmdfb3B0OiBzdHJpbmcgLT4gaW50NjQgb3B0aW9uXG4oKiogU2FtZSBhcyBbb2Zfc3RyaW5nXSwgYnV0IHJldHVybiBbTm9uZV0gaW5zdGVhZCBvZiByYWlzaW5nLlxuICAgIEBzaW5jZSA0LjA1ICopXG5cbnZhbCB0b19zdHJpbmcgOiBpbnQ2NCAtPiBzdHJpbmdcbigqKiBSZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBpdHMgYXJndW1lbnQsIGluIGRlY2ltYWwuICopXG5cbmV4dGVybmFsIGJpdHNfb2ZfZmxvYXQgOiBmbG9hdCAtPiBpbnQ2NFxuICA9IFwiY2FtbF9pbnQ2NF9iaXRzX29mX2Zsb2F0XCIgXCJjYW1sX2ludDY0X2JpdHNfb2ZfZmxvYXRfdW5ib3hlZFwiXG4gIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4oKiogUmV0dXJuIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZmxvYXQgYWNjb3JkaW5nXG4gICB0byB0aGUgSUVFRSA3NTQgZmxvYXRpbmctcG9pbnQgJ2RvdWJsZSBmb3JtYXQnIGJpdCBsYXlvdXQuXG4gICBCaXQgNjMgb2YgdGhlIHJlc3VsdCByZXByZXNlbnRzIHRoZSBzaWduIG9mIHRoZSBmbG9hdDtcbiAgIGJpdHMgNjIgdG8gNTIgcmVwcmVzZW50IHRoZSAoYmlhc2VkKSBleHBvbmVudDsgYml0cyA1MSB0byAwXG4gICByZXByZXNlbnQgdGhlIG1hbnRpc3NhLiAqKVxuXG5leHRlcm5hbCBmbG9hdF9vZl9iaXRzIDogaW50NjQgLT4gZmxvYXRcbiAgPSBcImNhbWxfaW50NjRfZmxvYXRfb2ZfYml0c1wiIFwiY2FtbF9pbnQ2NF9mbG9hdF9vZl9iaXRzX3VuYm94ZWRcIlxuICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuKCoqIFJldHVybiB0aGUgZmxvYXRpbmctcG9pbnQgbnVtYmVyIHdob3NlIGludGVybmFsIHJlcHJlc2VudGF0aW9uLFxuICAgYWNjb3JkaW5nIHRvIHRoZSBJRUVFIDc1NCBmbG9hdGluZy1wb2ludCAnZG91YmxlIGZvcm1hdCcgYml0IGxheW91dCxcbiAgIGlzIHRoZSBnaXZlbiBbaW50NjRdLiAqKVxuXG50eXBlIHQgPSBpbnQ2NFxuKCoqIEFuIGFsaWFzIGZvciB0aGUgdHlwZSBvZiA2NC1iaXQgaW50ZWdlcnMuICopXG5cbnZhbCBjb21wYXJlOiB0IC0+IHQgLT4gaW50XG4oKiogVGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIDY0LWJpdCBpbnRlZ2Vycywgd2l0aCB0aGUgc2FtZSBzcGVjaWZpY2F0aW9uIGFzXG4gICAgeyFTdGRsaWIuY29tcGFyZX0uICBBbG9uZyB3aXRoIHRoZSB0eXBlIFt0XSwgdGhpcyBmdW5jdGlvbiBbY29tcGFyZV1cbiAgICBhbGxvd3MgdGhlIG1vZHVsZSBbSW50NjRdIHRvIGJlIHBhc3NlZCBhcyBhcmd1bWVudCB0byB0aGUgZnVuY3RvcnNcbiAgICB7IVNldC5NYWtlfSBhbmQgeyFNYXAuTWFrZX0uICopXG5cbnZhbCB1bnNpZ25lZF9jb21wYXJlOiB0IC0+IHQgLT4gaW50XG4oKiogU2FtZSBhcyB7IWNvbXBhcmV9LCBleGNlcHQgdGhhdCBhcmd1bWVudHMgYXJlIGludGVycHJldGVkIGFzIHtlIHVuc2lnbmVkfVxuICAgIDY0LWJpdCBpbnRlZ2Vycy5cblxuICAgIEBzaW5jZSA0LjA4LjAgKilcblxudmFsIGVxdWFsOiB0IC0+IHQgLT4gYm9vbFxuKCoqIFRoZSBlcXVhbCBmdW5jdGlvbiBmb3IgaW50NjRzLlxuICAgIEBzaW5jZSA0LjAzLjAgKilcblxudmFsIG1pbjogdCAtPiB0IC0+IHRcbigqKiBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIG1heDogdCAtPiB0IC0+IHRcbigqKiBSZXR1cm4gdGhlIGdyZWF0ZXIgb2YgdGhlIHR3byBhcmd1bWVudHMuXG4gICAgQHNpbmNlIDQuMTMuMFxuICopXG5cbigqKi8qKilcblxuKCoqIHsxIERlcHJlY2F0ZWQgZnVuY3Rpb25zfSAqKVxuXG5leHRlcm5hbCBmb3JtYXQgOiBzdHJpbmcgLT4gaW50NjQgLT4gc3RyaW5nID0gXCJjYW1sX2ludDY0X2Zvcm1hdFwiXG4oKiogRG8gbm90IHVzZSB0aGlzIGRlcHJlY2F0ZWQgZnVuY3Rpb24uICBJbnN0ZWFkLFxuICAgdXNlZCB7IVByaW50Zi5zcHJpbnRmfSB3aXRoIGEgWyVMLi4uXSBmb3JtYXQuICopXG4iLCJvcGVuISBCYXNlXG5cbm1vZHVsZSBUIDogc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBhdG9taWMgOiBfIHRcbiAgdmFsIGNyZWF0ZSA6ICgnYSAtPiAnYSBTZXF1ZW5jZS50KSAtPiAnYSB0XG4gIHZhbCBzaHJpbmsgOiAnYSB0IC0+ICdhIC0+ICdhIFNlcXVlbmNlLnRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgbGV0IGF0b21pYyBfID0gU2VxdWVuY2UuZW1wdHlcbiAgbGV0IGNyZWF0ZSA9IEZuLmlkXG4gIGxldCBzaHJpbmsgPSBGbi5pZFxuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgbWFwIHQgfmYgfmZfaW52ZXJzZSA9IGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2UubWFwIH5mIChzaHJpbmsgdCAoZl9pbnZlcnNlIHgpKSlcbmxldCBmaWx0ZXIgdCB+ZiA9IGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2UuZmlsdGVyIH5mIChzaHJpbmsgdCB4KSlcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiB+Zl9pbnZlcnNlID1cbiAgY3JlYXRlIChmdW4geCAtPiBTZXF1ZW5jZS5maWx0ZXJfbWFwIH5mIChzaHJpbmsgdCAoZl9pbnZlcnNlIHgpKSlcbjs7XG5cbmxldCBvZl9sYXp5IGxhenlfdCA9IGNyZWF0ZSAoZnVuIHggLT4gU2VxdWVuY2Uub2ZfbGF6eSAobGF6eSAoc2hyaW5rIChmb3JjZSBsYXp5X3QpIHgpKSlcblxubGV0IGZpeGVkX3BvaW50IG9mX3Nocmlua2VyID1cbiAgbGV0IHJlYyBsYXp5X3QgPSBsYXp5IChvZl9zaHJpbmtlciAob2ZfbGF6eSBsYXp5X3QpKSBpblxuICBvZl9sYXp5IGxhenlfdFxuOztcblxubGV0IGJvdGggZnN0X3Qgc25kX3QgPVxuICBjcmVhdGUgKGZ1biAoZnN0LCBzbmQpIC0+XG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgIFsgU2VxdWVuY2UubWFwIChzaHJpbmsgZnN0X3QgZnN0KSB+ZjooZnVuIGZzdCAtPiBmc3QsIHNuZClcbiAgICAgIDsgU2VxdWVuY2UubWFwIChzaHJpbmsgc25kX3Qgc25kKSB+ZjooZnVuIHNuZCAtPiBmc3QsIHNuZClcbiAgICAgIF0pXG47O1xuXG5sZXQgdW5pdCA9IGF0b21pY1xubGV0IGJvb2wgPSBhdG9taWNcbmxldCBjaGFyID0gYXRvbWljXG5sZXQgaW50ID0gYXRvbWljXG5sZXQgaW50MzIgPSBhdG9taWNcbmxldCBpbnQ2MyA9IGF0b21pY1xubGV0IGludDY0ID0gYXRvbWljXG5sZXQgbmF0aXZlaW50ID0gYXRvbWljXG5sZXQgZmxvYXQgPSBhdG9taWNcblxubGV0IGJpZ2FycmF5MSBzcmMgPVxuICBsZXQgZGltID0gQmlnYXJyYXkuQXJyYXkxLmRpbSBzcmMgaW5cbiAgbWF0Y2ggZGltIHdpdGhcbiAgfCAwIC0+IFNlcXVlbmNlLmVtcHR5XG4gIHwgXyAtPlxuICAgIGxldCBraW5kID0gQmlnYXJyYXkuQXJyYXkxLmtpbmQgc3JjIGluXG4gICAgbGV0IGxheW91dCA9IEJpZ2FycmF5LkFycmF5MS5sYXlvdXQgc3JjIGluXG4gICAgbGV0IG9mZnNldCA9IEJpZ2FycmF5X2hlbHBlcnMuTGF5b3V0Lm9mZnNldCBsYXlvdXQgaW5cbiAgICBTZXF1ZW5jZS5pbml0IGRpbSB+ZjooZnVuIHRvX3NraXAgLT5cbiAgICAgIGxldCB0b19za2lwID0gdG9fc2tpcCArIG9mZnNldCBpblxuICAgICAgQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaW5pdCBraW5kIGxheW91dCAoZGltIC0gMSkgfmY6KGZ1biBpIC0+XG4gICAgICAgIHNyYy57aWYgaSA8IHRvX3NraXAgdGhlbiBpIGVsc2UgaSArIDF9KSlcbjs7XG5cbmxldCBiaWdzdHJpbmcgPSBjcmVhdGUgYmlnYXJyYXkxXG5sZXQgZmxvYXQzMl92ZWMgPSBjcmVhdGUgYmlnYXJyYXkxXG5sZXQgZmxvYXQ2NF92ZWMgPSBjcmVhdGUgYmlnYXJyYXkxXG5cbmxldCBiaWdhcnJheTIgPVxuICBsZXQgbW9kdWxlIERpbXMgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgeyBkaW0xIDogaW50XG4gICAgICA7IGRpbTIgOiBpbnRcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZyBmaWVsZHNdXG5cbiAgICBsZXQgY3JlYXRlIGEgPSBCaWdhcnJheS5BcnJheTIueyBkaW0xID0gZGltMSBhOyBkaW0yID0gZGltMiBhIH1cbiAgZW5kXG4gIGluXG4gIGxldCBzaHJpbmsgZmllbGQgc3JjID1cbiAgICBsZXQgZGltcyA9IERpbXMuY3JlYXRlIHNyYyBpblxuICAgIG1hdGNoIEZpZWxkLmdldCBmaWVsZCBkaW1zIHdpdGhcbiAgICB8IDAgLT4gU2VxdWVuY2UuZW1wdHlcbiAgICB8IF8gLT5cbiAgICAgIGxldCBraW5kID0gQmlnYXJyYXkuQXJyYXkyLmtpbmQgc3JjIGluXG4gICAgICBsZXQgbGF5b3V0ID0gQmlnYXJyYXkuQXJyYXkyLmxheW91dCBzcmMgaW5cbiAgICAgIGxldCBvZmZzZXQgPSBCaWdhcnJheV9oZWxwZXJzLkxheW91dC5vZmZzZXQgbGF5b3V0IGluXG4gICAgICBsZXQgKHsgZGltMTsgZGltMiB9IDogRGltcy50KSA9IEZpZWxkLm1hcCBmaWVsZCBkaW1zIH5mOkludC5wcmVkIGluXG4gICAgICBTZXF1ZW5jZS5pbml0IChGaWVsZC5nZXQgZmllbGQgZGltcykgfmY6KGZ1biB0b19za2lwIC0+XG4gICAgICAgIGxldCB0b19za2lwID0gdG9fc2tpcCArIG9mZnNldCBpblxuICAgICAgICBsZXQgc2tpcCBpID0gaWYgaSA8IHRvX3NraXAgdGhlbiBpIGVsc2UgaSArIDEgaW5cbiAgICAgICAgQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaW5pdCBraW5kIGxheW91dCBkaW0xIGRpbTIgfmY6KGZ1biBkaW0xIGRpbTIgLT5cbiAgICAgICAgICBsZXQgKHsgZGltMTsgZGltMiB9IDogRGltcy50KSA9IEZpZWxkLm1hcCBmaWVsZCB7IGRpbTE7IGRpbTIgfSB+Zjpza2lwIGluXG4gICAgICAgICAgc3JjLntkaW0xLCBkaW0yfSkpXG4gIGluXG4gIGZ1biBzcmMgLT5cbiAgICBTZXF1ZW5jZS5yb3VuZF9yb2JpbiBbIHNocmluayBEaW1zLkZpZWxkcy5kaW0xIHNyYzsgc2hyaW5rIERpbXMuRmllbGRzLmRpbTIgc3JjIF1cbjs7XG5cbmxldCBmbG9hdDMyX21hdCA9IGNyZWF0ZSBiaWdhcnJheTJcbmxldCBmbG9hdDY0X21hdCA9IGNyZWF0ZSBiaWdhcnJheTJcblxubGV0IG9wdGlvbiB2YWx1ZV90ID1cbiAgY3JlYXRlIChmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgIHwgU29tZSB2YWx1ZSAtPlxuICAgICAgU2VxdWVuY2UuYXBwZW5kXG4gICAgICAgIChTZXF1ZW5jZS5zaW5nbGV0b24gTm9uZSlcbiAgICAgICAgKFNlcXVlbmNlLm1hcCB+ZjpPcHRpb24ucmV0dXJuIChzaHJpbmsgdmFsdWVfdCB2YWx1ZSkpKVxuOztcblxubGV0IGxpc3QgZWx0X3QgPVxuICBmaXhlZF9wb2ludCAoZnVuIGxpc3RfdCAtPlxuICAgIGNyZWF0ZSAoZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gU2VxdWVuY2UuZW1wdHlcbiAgICAgIHwgaGVhZCA6OiB0YWlsIC0+XG4gICAgICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICAgICAgWyBTZXF1ZW5jZS5zaW5nbGV0b24gdGFpbFxuICAgICAgICAgIDsgU2VxdWVuY2UubWFwIChzaHJpbmsgZWx0X3QgaGVhZCkgfmY6KGZ1biBoZWFkIC0+IGhlYWQgOjogdGFpbClcbiAgICAgICAgICA7IFNlcXVlbmNlLm1hcCAoc2hyaW5rIGxpc3RfdCB0YWlsKSB+ZjooZnVuIHRhaWwgLT4gaGVhZCA6OiB0YWlsKVxuICAgICAgICAgIF0pKVxuOztcblxubGV0IHN0cmluZyA9IG1hcCAobGlzdCBjaGFyKSB+ZjpTdHJpbmcub2ZfY2hhcl9saXN0IH5mX2ludmVyc2U6U3RyaW5nLnRvX2xpc3RcbmxldCBieXRlcyA9IG1hcCBzdHJpbmcgfmY6Qnl0ZXMub2Zfc3RyaW5nIH5mX2ludmVyc2U6Qnl0ZXMudG9fc3RyaW5nXG5sZXQgYXJyYXkgdCA9IG1hcCAobGlzdCB0KSB+ZjpBcnJheS5vZl9saXN0IH5mX2ludmVyc2U6QXJyYXkudG9fbGlzdFxubGV0IHJlZiB0ID0gbWFwIHQgfmY6UmVmLmNyZWF0ZSB+Zl9pbnZlcnNlOlJlZi4oICEgKVxubGV0IGxhenlfdCB0ID0gbWFwIHQgfmY6TGF6eS5mcm9tX3ZhbCB+Zl9pbnZlcnNlOkxhenkuZm9yY2VcblxubGV0IHNleHAgPVxuICBmaXhlZF9wb2ludCAoZnVuIHNocmlua2VyIC0+XG4gICAgY3JlYXRlIChmdW5jdGlvblxuICAgICAgfCBTZXhwLkF0b20gXyAtPiBTZXF1ZW5jZS5lbXB0eVxuICAgICAgfCBTZXhwLkxpc3QgbCAtPlxuICAgICAgICBsZXQgc2hyaW5rX2xpc3QgPVxuICAgICAgICAgIHNocmluayAobGlzdCBzaHJpbmtlcikgbCB8PiBTZXF1ZW5jZS5tYXAgfmY6KGZ1biBsIC0+IFNleHAuTGlzdCBsKVxuICAgICAgICBpblxuICAgICAgICBsZXQgc2hyaW5rX3RyZWUgPSBTZXF1ZW5jZS5vZl9saXN0IGwgaW5cbiAgICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBzaHJpbmtfbGlzdDsgc2hyaW5rX3RyZWUgXSkpXG47O1xuXG5sZXQgZWl0aGVyIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gZWl0aGVyIC0+XG4gICAgbWF0Y2ggKGVpdGhlciA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICB8IEZpcnN0IGZzdCAtPiBTZXF1ZW5jZS5tYXAgKHNocmluayBmc3RfdCBmc3QpIH5mOkVpdGhlci5maXJzdFxuICAgIHwgU2Vjb25kIHNuZCAtPiBTZXF1ZW5jZS5tYXAgKHNocmluayBzbmRfdCBzbmQpIH5mOkVpdGhlci5zZWNvbmQpXG47O1xuXG5sZXQgcmVzdWx0IG9rX3QgZXJyX3QgPVxuICBtYXBcbiAgICAoZWl0aGVyIG9rX3QgZXJyX3QpXG4gICAgfmY6KGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IG9rIC0+IE9rIG9rXG4gICAgICB8IFNlY29uZCBlcnIgLT4gRXJyb3IgZXJyKVxuICAgIH5mX2ludmVyc2U6KGZ1bmN0aW9uXG4gICAgICB8IE9rIG9rIC0+IEZpcnN0IG9rXG4gICAgICB8IEVycm9yIGVyciAtPiBTZWNvbmQgZXJyKVxuOztcblxubGV0IG1hcF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3Iga2V5X3QgZGF0YV90ID1cbiAgY3JlYXRlIChmdW4gdHJlZSAtPlxuICAgIGxldCBhbGlzdCA9IE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fYWxpc3QgdHJlZSBpblxuICAgIGxldCBkcm9wX2tleXMgPVxuICAgICAgU2VxdWVuY2UubWFwIChTZXF1ZW5jZS5vZl9saXN0IGFsaXN0KSB+ZjooZnVuIChrLCBfKSAtPlxuICAgICAgICBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGspXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2tleXMgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgbGV0IHRyZWUgPSBNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnJlbW92ZSB+Y29tcGFyYXRvciB0cmVlIGtleSBpblxuICAgICAgICAgICBTZXF1ZW5jZS5maWx0ZXJfbWFwIChzaHJpbmsga2V5X3Qga2V5KSB+ZjooZnVuIHNtYWxsZXJfa2V5IC0+XG4gICAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgICAgIE1hcC5Vc2luZ19jb21wYXJhdG9yLlRyZWUuYWRkIH5jb21wYXJhdG9yIHRyZWUgfmtleTpzbWFsbGVyX2tleSB+ZGF0YVxuICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICB8IGBPayB0cmVlIC0+IFNvbWUgdHJlZVxuICAgICAgICAgICAgIHwgYER1cGxpY2F0ZSAtPiBOb25lKSkpXG4gICAgaW5cbiAgICBsZXQgc2hyaW5rX2RhdGEgPVxuICAgICAgU2VxdWVuY2Uucm91bmRfcm9iaW5cbiAgICAgICAgKExpc3QubWFwIGFsaXN0IH5mOihmdW4gKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgU2VxdWVuY2UubWFwIChzaHJpbmsgZGF0YV90IGRhdGEpIH5mOihmdW4gc21hbGxlcl9kYXRhIC0+XG4gICAgICAgICAgICAgTWFwLlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5zZXQgfmNvbXBhcmF0b3IgdHJlZSB+a2V5IH5kYXRhOnNtYWxsZXJfZGF0YSkpKVxuICAgIGluXG4gICAgU2VxdWVuY2Uucm91bmRfcm9iaW4gWyBkcm9wX2tleXM7IHNocmlua19rZXlzOyBzaHJpbmtfZGF0YSBdKVxuOztcblxubGV0IHNldF90cmVlX3VzaW5nX2NvbXBhcmF0b3IgfmNvbXBhcmF0b3IgZWx0X3QgPVxuICBjcmVhdGUgKGZ1biB0cmVlIC0+XG4gICAgbGV0IGxpc3QgPSBTZXQuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2xpc3QgdHJlZSBpblxuICAgIGxldCBkcm9wX2VsdHMgPVxuICAgICAgU2VxdWVuY2UubWFwIChTZXF1ZW5jZS5vZl9saXN0IGxpc3QpIH5mOihmdW4gZWx0IC0+XG4gICAgICAgIFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUucmVtb3ZlIH5jb21wYXJhdG9yIHRyZWUgZWx0KVxuICAgIGluXG4gICAgbGV0IHNocmlua19lbHRzID1cbiAgICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluXG4gICAgICAgIChMaXN0Lm1hcCBsaXN0IH5mOihmdW4gZWx0IC0+XG4gICAgICAgICAgIGxldCB0cmVlID0gU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5yZW1vdmUgfmNvbXBhcmF0b3IgdHJlZSBlbHQgaW5cbiAgICAgICAgICAgU2VxdWVuY2UuZmlsdGVyX21hcCAoc2hyaW5rIGVsdF90IGVsdCkgfmY6KGZ1biBzbWFsbGVyX2VsdCAtPlxuICAgICAgICAgICAgIG1hdGNoIFNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUubWVtIH5jb21wYXJhdG9yIHRyZWUgc21hbGxlcl9lbHQgd2l0aFxuICAgICAgICAgICAgIHwgdHJ1ZSAtPiBOb25lXG4gICAgICAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgICAgICAgU29tZSAoU2V0LlVzaW5nX2NvbXBhcmF0b3IuVHJlZS5hZGQgdHJlZSB+Y29tcGFyYXRvciBzbWFsbGVyX2VsdCkpKSlcbiAgICBpblxuICAgIFNlcXVlbmNlLnJvdW5kX3JvYmluIFsgZHJvcF9lbHRzOyBzaHJpbmtfZWx0cyBdKVxuOztcblxubGV0IG1hcF90IGtleV90IGRhdGFfdCA9XG4gIGNyZWF0ZSAoZnVuIG1hcF90IC0+XG4gICAgbGV0IGNvbXBhcmF0b3IgPSBNYXAuY29tcGFyYXRvciBtYXBfdCBpblxuICAgIGxldCB0ID1cbiAgICAgIG1hcFxuICAgICAgICAobWFwX3RyZWVfdXNpbmdfY29tcGFyYXRvciB+Y29tcGFyYXRvciBrZXlfdCBkYXRhX3QpXG4gICAgICAgIH5mOihNYXAuVXNpbmdfY29tcGFyYXRvci5vZl90cmVlIH5jb21wYXJhdG9yKVxuICAgICAgICB+Zl9pbnZlcnNlOk1hcC5Vc2luZ19jb21wYXJhdG9yLnRvX3RyZWVcbiAgICBpblxuICAgIHNocmluayB0IG1hcF90KVxuOztcblxubGV0IHNldF90IGVsdF90ID1cbiAgY3JlYXRlIChmdW4gc2V0X3QgLT5cbiAgICBsZXQgY29tcGFyYXRvciA9IFNldC5jb21wYXJhdG9yIHNldF90IGluXG4gICAgbGV0IHQgPVxuICAgICAgbWFwXG4gICAgICAgIChzZXRfdHJlZV91c2luZ19jb21wYXJhdG9yIH5jb21wYXJhdG9yIGVsdF90KVxuICAgICAgICB+ZjooU2V0LlVzaW5nX2NvbXBhcmF0b3Iub2ZfdHJlZSB+Y29tcGFyYXRvcilcbiAgICAgICAgfmZfaW52ZXJzZTpTZXQuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG4gICAgaW5cbiAgICBzaHJpbmsgdCBzZXRfdClcbjs7XG4iLCJvcGVuISBCYXNlXG5pbmNsdWRlIFRlc3RfaW50ZlxuXG5tb2R1bGUgQ29uZmlnID0gc3RydWN0XG4gIG1vZHVsZSBTZWVkID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgTm9uZGV0ZXJtaW5pc3RpY1xuICAgICAgfCBEZXRlcm1pbmlzdGljIG9mIHN0cmluZ1xuICAgIFtAQGRlcml2aW5nIHNleHBfb2ZdXG4gIGVuZFxuXG4gIG1vZHVsZSBQb3RlbnRpYWxseV9pbmZpbml0ZV9zZXF1ZW5jZSA9IHN0cnVjdFxuICAgIHR5cGUgJ2EgdCA9ICdhIFNlcXVlbmNlLnRcblxuICAgIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9lbHQgc2VxdWVuY2UgPVxuICAgICAgbGV0IHByZWZpeCwgc3VmZml4ID0gU2VxdWVuY2Uuc3BsaXRfbiBzZXF1ZW5jZSAxMDAgaW5cbiAgICAgIGxldCBwcmVmaXggPSBMaXN0Lm1hcCBwcmVmaXggfmY6c2V4cF9vZl9lbHQgaW5cbiAgICAgIGxldCBzdWZmaXggPVxuICAgICAgICBtYXRjaCBTZXF1ZW5jZS5pc19lbXB0eSBzdWZmaXggd2l0aFxuICAgICAgICB8IHRydWUgLT4gW11cbiAgICAgICAgfCBmYWxzZSAtPiBbIFslbWVzc2FnZSBcIi4uLlwiXSBdXG4gICAgICBpblxuICAgICAgU2V4cC5MaXN0IChwcmVmaXggQCBzdWZmaXgpXG4gICAgOztcbiAgZW5kXG5cbiAgdHlwZSB0ID1cbiAgICB7IHNlZWQgOiBTZWVkLnRcbiAgICA7IHRlc3RfY291bnQgOiBpbnRcbiAgICA7IHNocmlua19jb3VudCA6IGludFxuICAgIDsgc2l6ZXMgOiBpbnQgUG90ZW50aWFsbHlfaW5maW5pdGVfc2VxdWVuY2UudFxuICAgIH1cbiAgW0BAZGVyaXZpbmcgZmllbGRzLCBzZXhwX29mXVxuZW5kXG5cbmxldCBkZWZhdWx0X2NvbmZpZyA6IENvbmZpZy50ID1cbiAgeyBzZWVkID0gRGV0ZXJtaW5pc3RpYyBcImFuIGFyYml0cmFyeSBidXQgZGV0ZXJtaW5pc3RpYyBzdHJpbmdcIlxuICA7IHRlc3RfY291bnQgPSAxMF8wMDBcbiAgOyBzaHJpbmtfY291bnQgPSAxMF8wMDBcbiAgOyBzaXplcyA9IFNlcXVlbmNlLmN5Y2xlX2xpc3RfZXhuIChMaXN0LnJhbmdlIDAgfnN0YXJ0OmBpbmNsdXNpdmUgMzAgfnN0b3A6YGluY2x1c2l2ZSlcbiAgfVxuOztcblxubGV0IGxhenlfbm9uZGV0ZXJtaW5pc3RpY19zdGF0ZSA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcblxubGV0IGluaXRpYWxfcmFuZG9tX3N0YXRlIH5jb25maWcgPVxuICBtYXRjaCBDb25maWcuc2VlZCBjb25maWcgd2l0aFxuICB8IE5vbmRldGVybWluaXN0aWMgLT4gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUuY3JlYXRlIChmb3JjZSBsYXp5X25vbmRldGVybWluaXN0aWNfc3RhdGUpXG4gIHwgRGV0ZXJtaW5pc3RpYyBzdHJpbmcgLT4gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUub2ZfaW50IChTdHJpbmcuaGFzaCBzdHJpbmcpXG47O1xuXG5sZXQgb25lX3NpemVfcGVyX3Rlc3Qgfihjb25maWcgOiBDb25maWcudCkgPVxuICBTZXF1ZW5jZS51bmZvbGQgfmluaXQ6KGNvbmZpZy5zaXplcywgMCkgfmY6KGZ1biAoc2l6ZXMsIG51bWJlcl9vZl9zaXplX3ZhbHVlcykgLT5cbiAgICBtYXRjaCBudW1iZXJfb2Zfc2l6ZV92YWx1ZXMgPj0gY29uZmlnLnRlc3RfY291bnQgd2l0aFxuICAgIHwgdHJ1ZSAtPiBOb25lXG4gICAgfCBmYWxzZSAtPlxuICAgICAgKG1hdGNoIFNlcXVlbmNlLm5leHQgc2l6ZXMgd2l0aFxuICAgICAgIHwgU29tZSAoc2l6ZSwgcmVtYWluaW5nX3NpemVzKSAtPlxuICAgICAgICAgU29tZSAoc2l6ZSwgKHJlbWFpbmluZ19zaXplcywgbnVtYmVyX29mX3NpemVfdmFsdWVzICsgMSkpXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICByYWlzZV9zXG4gICAgICAgICAgIFslbWVzc2FnZVxuICAgICAgICAgICAgIFwiQmFzZV9xdWlja2NoZWNrLlRlc3QucnVuOiBpbnN1ZmZpY2llbnQgc2l6ZSB2YWx1ZXMgZm9yIHRlc3QgY291bnRcIlxuICAgICAgICAgICAgICAgfnRlc3RfY291bnQ6KGNvbmZpZy50ZXN0X2NvdW50IDogaW50KVxuICAgICAgICAgICAgICAgKG51bWJlcl9vZl9zaXplX3ZhbHVlcyA6IGludCldKSlcbjs7XG5cbmxldCBzaHJpbmtfZXJyb3IgfnNocmlua2VyIH5jb25maWcgfmYgaW5wdXQgZXJyb3IgPVxuICBsZXQgcmVjIGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvciA9XG4gICAgbWF0Y2ggc2hyaW5rX2NvdW50IHdpdGhcbiAgICB8IDAgLT4gaW5wdXQsIGVycm9yXG4gICAgfCBfIC0+XG4gICAgICBsZXQgc2hyaW5rX2NvdW50ID0gc2hyaW5rX2NvdW50IC0gMSBpblxuICAgICAgKG1hdGNoIFNlcXVlbmNlLm5leHQgYWx0ZXJuYXRlcyB3aXRoXG4gICAgICAgfCBOb25lIC0+IGlucHV0LCBlcnJvclxuICAgICAgIHwgU29tZSAoYWx0ZXJuYXRlLCBhbHRlcm5hdGVzKSAtPlxuICAgICAgICAgKG1hdGNoIGYgYWx0ZXJuYXRlIHdpdGhcbiAgICAgICAgICB8IE9rICgpIC0+IGxvb3AgfnNocmlua19jb3VudCB+YWx0ZXJuYXRlcyBpbnB1dCBlcnJvclxuICAgICAgICAgIHwgRXJyb3IgZXJyb3IgLT5cbiAgICAgICAgICAgIGxldCBhbHRlcm5hdGVzID0gU2hyaW5rZXIuc2hyaW5rIHNocmlua2VyIGFsdGVybmF0ZSBpblxuICAgICAgICAgICAgbG9vcCB+c2hyaW5rX2NvdW50IH5hbHRlcm5hdGVzIGFsdGVybmF0ZSBlcnJvcikpXG4gIGluXG4gIGxldCBzaHJpbmtfY291bnQgPSBDb25maWcuc2hyaW5rX2NvdW50IGNvbmZpZyBpblxuICBsZXQgYWx0ZXJuYXRlcyA9IFNocmlua2VyLnNocmluayBzaHJpbmtlciBpbnB1dCBpblxuICBsb29wIH5zaHJpbmtfY291bnQgfmFsdGVybmF0ZXMgaW5wdXQgZXJyb3Jcbjs7XG5cbmxldCBpbnB1dF9zZXF1ZW5jZSB+Y29uZmlnIH5leGFtcGxlcyB+Z2VuZXJhdG9yID1cbiAgbGV0IHJhbmRvbSA9IGluaXRpYWxfcmFuZG9tX3N0YXRlIH5jb25maWcgaW5cbiAgU2VxdWVuY2UuYXBwZW5kXG4gICAgKFNlcXVlbmNlLm9mX2xpc3QgZXhhbXBsZXMpXG4gICAgKG9uZV9zaXplX3Blcl90ZXN0IH5jb25maWdcbiAgICAgfD4gU2VxdWVuY2UubWFwIH5mOihmdW4gc2l6ZSAtPiBHZW5lcmF0b3IuZ2VuZXJhdGUgZ2VuZXJhdG9yIH5zaXplIH5yYW5kb20pKVxuOztcblxubGV0IHdpdGhfc2FtcGxlIH5mID8oY29uZmlnID0gZGVmYXVsdF9jb25maWcpID8oZXhhbXBsZXMgPSBbXSkgZ2VuZXJhdG9yID1cbiAgbGV0IHNlcXVlbmNlID0gaW5wdXRfc2VxdWVuY2UgfmNvbmZpZyB+ZXhhbXBsZXMgfmdlbmVyYXRvciBpblxuICBmIHNlcXVlbmNlXG47O1xuXG5sZXQgcmVzdWx0ICh0eXBlIGEpIH5mID8oY29uZmlnID0gZGVmYXVsdF9jb25maWcpID8oZXhhbXBsZXMgPSBbXSkgbSA9XG4gIGxldCAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPSBtIGluXG4gIHdpdGhfc2FtcGxlIE0ucXVpY2tjaGVja19nZW5lcmF0b3IgfmNvbmZpZyB+ZXhhbXBsZXMgfmY6KGZ1biBzZXF1ZW5jZSAtPlxuICAgIG1hdGNoXG4gICAgICBTZXF1ZW5jZS5mb2xkX3Jlc3VsdCBzZXF1ZW5jZSB+aW5pdDooKSB+ZjooZnVuICgpIGlucHV0IC0+XG4gICAgICAgIG1hdGNoIGYgaW5wdXQgd2l0aFxuICAgICAgICB8IE9rICgpIC0+IE9rICgpXG4gICAgICAgIHwgRXJyb3IgZXJyb3IgLT4gRXJyb3IgKGlucHV0LCBlcnJvcikpXG4gICAgd2l0aFxuICAgIHwgT2sgKCkgLT4gT2sgKClcbiAgICB8IEVycm9yIChpbnB1dCwgZXJyb3IpIC0+XG4gICAgICBsZXQgc2hyaW5rZXIgPSBNLnF1aWNrY2hlY2tfc2hyaW5rZXIgaW5cbiAgICAgIGxldCBpbnB1dCwgZXJyb3IgPSBzaHJpbmtfZXJyb3IgfnNocmlua2VyIH5jb25maWcgfmYgaW5wdXQgZXJyb3IgaW5cbiAgICAgIEVycm9yIChpbnB1dCwgZXJyb3IpKVxuOztcblxubGV0IHJ1biAodHlwZSBhKSB+ZiA/Y29uZmlnID9leGFtcGxlcyAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPVxuICBsZXQgZiB4ID1cbiAgICBPcl9lcnJvci50cnlfd2l0aF9qb2luIH5iYWNrdHJhY2U6KEJhY2t0cmFjZS5FeG4uYW1fcmVjb3JkaW5nICgpKSAoZnVuICgpIC0+IGYgeClcbiAgaW5cbiAgbWF0Y2ggcmVzdWx0IH5mID9jb25maWcgP2V4YW1wbGVzIChtb2R1bGUgTSkgd2l0aFxuICB8IE9rICgpIC0+IE9rICgpXG4gIHwgRXJyb3IgKGlucHV0LCBlcnJvcikgLT5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICBbJW1lc3NhZ2UgXCJCYXNlX3F1aWNrY2hlY2suVGVzdC5ydW46IHRlc3QgZmFpbGVkXCIgKGlucHV0IDogTS50KSAoZXJyb3IgOiBFcnJvci50KV1cbjs7XG5cbmxldCB3aXRoX3NhbXBsZV9leG4gfmYgP2NvbmZpZyA/ZXhhbXBsZXMgZ2VuZXJhdG9yID1cbiAgbGV0IGYgeCA9IE9yX2Vycm9yLnRyeV93aXRoIChmdW4gKCkgLT4gZiB4KSBpblxuICB3aXRoX3NhbXBsZSB+ZiA/Y29uZmlnID9leGFtcGxlcyBnZW5lcmF0b3IgfD4gT3JfZXJyb3Iub2tfZXhuXG47O1xuXG5sZXQgcnVuX2V4biB+ZiA/Y29uZmlnID9leGFtcGxlcyB0ZXN0YWJsZSA9XG4gIGxldCBmIHggPVxuICAgIE9yX2Vycm9yLnRyeV93aXRoIH5iYWNrdHJhY2U6KEJhY2t0cmFjZS5FeG4uYW1fcmVjb3JkaW5nICgpKSAoZnVuICgpIC0+IGYgeClcbiAgaW5cbiAgcnVuIH5mID9jb25maWcgP2V4YW1wbGVzIHRlc3RhYmxlIHw+IE9yX2Vycm9yLm9rX2V4blxuOztcbiIsIm9wZW4hIEJhc2VcbmluY2x1ZGUgT2JzZXJ2ZXIwXG5cbmxldCB1bm1hcCB0IH5mID0gY3JlYXRlIChmdW4geCB+c2l6ZSB+aGFzaCAtPiBvYnNlcnZlIHQgKGYgeCkgfnNpemUgfmhhc2gpXG5sZXQgb2ZfaGFzaF9mb2xkIGYgPSBjcmVhdGUgKGZ1biB4IH5zaXplOl8gfmhhc2ggLT4gZiBoYXNoIHgpXG5sZXQgb2ZfbGF6eSBsYXp5X3QgPSBjcmVhdGUgKGZ1biB4IH5zaXplIH5oYXNoIC0+IG9ic2VydmUgKGZvcmNlIGxhenlfdCkgeCB+c2l6ZSB+aGFzaClcblxubGV0IGZpeGVkX3BvaW50IHdyYXAgPVxuICBsZXQgcmVjIGxhenlfdCA9IGxhenkgKHdyYXAgKG9mX2xhenkgbGF6eV90KSkgaW5cbiAgb2ZfbGF6eSBsYXp5X3Rcbjs7XG5cbmxldCB1bml0ID0gb3BhcXVlXG5sZXQgYm9vbCA9IG9mX2hhc2hfZm9sZCBCb29sLmhhc2hfZm9sZF90XG5sZXQgY2hhciA9IG9mX2hhc2hfZm9sZCBDaGFyLmhhc2hfZm9sZF90XG5sZXQgaW50ID0gb2ZfaGFzaF9mb2xkIEludC5oYXNoX2ZvbGRfdFxubGV0IGludDMyID0gb2ZfaGFzaF9mb2xkIEludDMyLmhhc2hfZm9sZF90XG5sZXQgaW50NjMgPSBvZl9oYXNoX2ZvbGQgSW50NjMuaGFzaF9mb2xkX3RcbmxldCBpbnQ2NCA9IG9mX2hhc2hfZm9sZCBJbnQ2NC5oYXNoX2ZvbGRfdFxubGV0IG5hdGl2ZWludCA9IG9mX2hhc2hfZm9sZCBOYXRpdmVpbnQuaGFzaF9mb2xkX3RcbmxldCBmbG9hdCA9IG9mX2hhc2hfZm9sZCBGbG9hdC5oYXNoX2ZvbGRfdFxubGV0IHN0cmluZyA9IG9mX2hhc2hfZm9sZCBTdHJpbmcuaGFzaF9mb2xkX3RcbmxldCBzZXhwID0gb2ZfaGFzaF9mb2xkIFNleHAuaGFzaF9mb2xkX3RcbmxldCBiaWdzdHJpbmcgPSBvZl9oYXNoX2ZvbGQgKEJpZ2FycmF5X2hlbHBlcnMuQXJyYXkxLmhhc2hfZm9sZCBoYXNoX2ZvbGRfY2hhcilcbmxldCBmbG9hdDMyX3ZlYyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDY0X3ZlYyA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTEuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDMyX21hdCA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBmbG9hdDY0X21hdCA9IG9mX2hhc2hfZm9sZCAoQmlnYXJyYXlfaGVscGVycy5BcnJheTIuaGFzaF9mb2xkIGhhc2hfZm9sZF9mbG9hdClcbmxldCBieXRlcyA9IHVubWFwIHN0cmluZyB+ZjpCeXRlcy50b19zdHJpbmdcblxubGV0IGVpdGhlciBmc3RfdCBzbmRfdCA9XG4gIGNyZWF0ZSAoZnVuIGVpdGhlciB+c2l6ZSB+aGFzaCAtPlxuICAgIG1hdGNoIChlaXRoZXIgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgfCBGaXJzdCBmc3QgLT4gb2JzZXJ2ZSBmc3RfdCBmc3QgfnNpemUgfmhhc2g6KGhhc2hfZm9sZF9pbnQgaGFzaCAxKVxuICAgIHwgU2Vjb25kIHNuZCAtPiBvYnNlcnZlIHNuZF90IHNuZCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDIpKVxuOztcblxubGV0IHJlc3VsdCBva190IGVycl90ID1cbiAgdW5tYXAgKGVpdGhlciBva190IGVycl90KSB+ZjooZnVuY3Rpb25cbiAgICB8IE9rIG9rIC0+IEZpcnN0IG9rXG4gICAgfCBFcnJvciBlcnIgLT4gU2Vjb25kIGVycilcbjs7XG5cbmxldCBib3RoIGZzdF90IHNuZF90ID1cbiAgY3JlYXRlIChmdW4gKGZzdCwgc25kKSB+c2l6ZSB+aGFzaCAtPlxuICAgIGxldCBoYXNoID0gb2JzZXJ2ZSBmc3RfdCBmc3QgfnNpemUgfmhhc2ggaW5cbiAgICBsZXQgaGFzaCA9IG9ic2VydmUgc25kX3Qgc25kIH5zaXplIH5oYXNoIGluXG4gICAgaGFzaClcbjs7XG5cbmxldCBvcHRpb24gdmFsdWVfdCA9XG4gIHVubWFwIChlaXRoZXIgb3BhcXVlIHZhbHVlX3QpIH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBGaXJzdCAoKVxuICAgIHwgU29tZSB2YWx1ZSAtPiBTZWNvbmQgdmFsdWUpXG47O1xuXG5sZXQgbGlzdCBlbHRfdCA9XG4gIGNyZWF0ZSAoZnVuIGxpc3QgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUub2ZfaW50IChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpIGluXG4gICAgbGV0IGxlbmd0aCA9IExpc3QubGVuZ3RoIGxpc3QgaW5cbiAgICBsZXQgc2l6ZXMgPVxuICAgICAgR2VuZXJhdG9yLnNpemVzIH5taW5fbGVuZ3RoOmxlbmd0aCB+bWF4X2xlbmd0aDpsZW5ndGggKClcbiAgICAgIHw+IEdlbmVyYXRvci5nZW5lcmF0ZSB+c2l6ZSB+cmFuZG9tXG4gICAgaW5cbiAgICBMaXN0LmZvbGQyX2V4biBsaXN0IHNpemVzIH5pbml0OihoYXNoX2ZvbGRfaW50IGhhc2ggMCkgfmY6KGZ1biBoYXNoIGVsdCBzaXplIC0+XG4gICAgICBvYnNlcnZlIGVsdF90IGVsdCB+c2l6ZSB+aGFzaDooaGFzaF9mb2xkX2ludCBoYXNoIDEpKSlcbjs7XG5cbmxldCBhcnJheSB0ID0gdW5tYXAgKGxpc3QgdCkgfmY6QXJyYXkudG9fbGlzdFxubGV0IHJlZiB0ID0gdW5tYXAgdCB+ZjpSZWYuKCAhIClcbmxldCBsYXp5X3QgdCA9IHVubWFwIHQgfmY6TGF6eS5mb3JjZVxuXG5sZXQgZm4gZG9tIHJuZyA9XG4gIGNyZWF0ZSAoZnVuIGYgfnNpemUgfmhhc2ggLT5cbiAgICBsZXQgcmFuZG9tID0gU3BsaXR0YWJsZV9yYW5kb20uU3RhdGUub2ZfaW50IChIYXNoLmdldF9oYXNoX3ZhbHVlIGhhc2gpIGluXG4gICAgbGV0IHNpemVzID1cbiAgICAgICgqIEVtcGlyaWNhbGx5LCBkb3VibGluZyB0aGUgc2l6ZSB3aGVuIGdlbmVyYXRpbmcgdGhlIGxpc3Qgb2YgaW5wdXRzIGdpdmVzIHVzIG11Y2hcbiAgICAgICAgIGJldHRlciBjb3ZlcmFnZSBvZiB0aGUgc3BhY2Ugb2YgZnVuY3Rpb25zLiAqKVxuICAgICAgR2VuZXJhdG9yLmdlbmVyYXRlIChHZW5lcmF0b3Iuc2l6ZXMgKCkpIH5zaXplOihzaXplICogMikgfnJhbmRvbVxuICAgIGluXG4gICAgTGlzdC5mb2xkIHNpemVzIH5pbml0Omhhc2ggfmY6KGZ1biBoYXNoIHNpemUgLT5cbiAgICAgIGxldCB4ID0gR2VuZXJhdG9yLmdlbmVyYXRlIGRvbSB+c2l6ZSB+cmFuZG9tIGluXG4gICAgICBvYnNlcnZlIHJuZyAoZiB4KSB+c2l6ZSB+aGFzaCkpXG47O1xuXG5sZXQgbWFwX3RyZWUga2V5X29icyBkYXRhX29icyA9XG4gIHVubWFwIChsaXN0IChib3RoIGtleV9vYnMgZGF0YV9vYnMpKSB+ZjpNYXAuVXNpbmdfY29tcGFyYXRvci5UcmVlLnRvX2FsaXN0XG47O1xuXG5sZXQgc2V0X3RyZWUgZWx0X29icyA9IHVubWFwIChsaXN0IGVsdF9vYnMpIH5mOlNldC5Vc2luZ19jb21wYXJhdG9yLlRyZWUudG9fbGlzdFxuXG5sZXQgbWFwX3Qga2V5X29icyBkYXRhX29icyA9XG4gIHVubWFwIChtYXBfdHJlZSBrZXlfb2JzIGRhdGFfb2JzKSB+ZjpNYXAuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG47O1xuXG5sZXQgc2V0X3QgZWx0X29icyA9IHVubWFwIChzZXRfdHJlZSBlbHRfb2JzKSB+ZjpTZXQuVXNpbmdfY29tcGFyYXRvci50b190cmVlXG4iLCJtb2R1bGUgR2VuZXJhdG9yID0gR2VuZXJhdG9yXG5tb2R1bGUgT2JzZXJ2ZXIgPSBPYnNlcnZlclxubW9kdWxlIFNocmlua2VyID0gU2hyaW5rZXJcbm1vZHVsZSBUZXN0ID0gVGVzdFxubW9kdWxlIEV4cG9ydCA9IEV4cG9ydFxuaW5jbHVkZSBFeHBvcnRcblxuKCoqLyoqKVxuXG4oKl8gVGhpcyBtb2R1bGUgaXMgZXhwb3NlZCBvbmx5IHRvIG1ha2Ugb2NhbWxkb2Mgb3V0cHV0IG1vcmUgcmVhZGFibGUuICopXG5tb2R1bGUgV2l0aF9iYXNpY190eXBlcyA9IFdpdGhfYmFzaWNfdHlwZXNcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIEJpZ2FycmF5X2hlbHBlcnMgPSBCaWdhcnJheV9oZWxwZXJzXG5lbmRcbiJdfQ==
