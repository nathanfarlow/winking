// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.1.1

//# unitInfo: Provides: Base__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base = [0];
   runtime.caml_register_global(0, Base, "Base__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Poly0
//# unitInfo: Requires: Caml
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_compare = runtime.caml_compare,
    global_data = runtime.caml_get_global_data(),
    Caml = global_data.Caml;
   function descending(x, y){return caml_compare(y, x);}
   var
    max = Caml[17],
    min = Caml[16],
    Base_Poly0 = [0, caml_compare, descending, min, max];
   runtime.caml_register_global(1, Base_Poly0, "Base__Poly0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import0
//# unitInfo: Requires: Base__Poly0, Caml, Shadow_stdlib, Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_equal = runtime.caml_bytes_equal,
    caml_bytes_greaterequal = runtime.caml_bytes_greaterequal,
    caml_bytes_lessequal = runtime.caml_bytes_lessequal,
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int_compare = runtime.caml_int_compare,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_notequal = runtime.caml_notequal,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_greaterequal = runtime.caml_string_greaterequal,
    caml_string_lessequal = runtime.caml_string_lessequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Poly0 = global_data.Base__Poly0,
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Caml = global_data.Caml,
    do_at_exit = Shadow_stdlib[91],
    unsafe_really_input = Shadow_stdlib[90],
    valid_float_lexem = Shadow_stdlib[89],
    at_exit = Shadow_stdlib[88],
    exit = Shadow_stdlib[87],
    symbol = Shadow_stdlib[86],
    string_of_format = Shadow_stdlib[85],
    set_binary_mode_in = Shadow_stdlib[84],
    close_in_noerr = Shadow_stdlib[83],
    close_in = Shadow_stdlib[82],
    in_channel_length = Shadow_stdlib[81],
    pos_in = Shadow_stdlib[80],
    seek_in = Shadow_stdlib[79],
    input_value = Shadow_stdlib[78],
    input_binary_int = Shadow_stdlib[77],
    input_byte = Shadow_stdlib[76],
    really_input_string = Shadow_stdlib[75],
    really_input = Shadow_stdlib[74],
    input = Shadow_stdlib[73],
    input_line = Shadow_stdlib[72],
    input_char = Shadow_stdlib[71],
    open_in_gen = Shadow_stdlib[70],
    open_in_bin = Shadow_stdlib[69],
    open_in = Shadow_stdlib[68],
    set_binary_mode_out = Shadow_stdlib[67],
    close_out_noerr = Shadow_stdlib[66],
    close_out = Shadow_stdlib[65],
    out_channel_length = Shadow_stdlib[64],
    pos_out = Shadow_stdlib[63],
    seek_out = Shadow_stdlib[62],
    output_value = Shadow_stdlib[61],
    output_binary_int = Shadow_stdlib[60],
    output_byte = Shadow_stdlib[59],
    output_substring = Shadow_stdlib[58],
    output = Shadow_stdlib[57],
    output_bytes = Shadow_stdlib[56],
    output_string = Shadow_stdlib[55],
    output_char = Shadow_stdlib[54],
    flush_all = Shadow_stdlib[53],
    flush = Shadow_stdlib[52],
    open_out_gen = Shadow_stdlib[51],
    open_out_bin = Shadow_stdlib[50],
    open_out = Shadow_stdlib[49],
    read_float = Shadow_stdlib[48],
    read_float_opt = Shadow_stdlib[47],
    read_int = Shadow_stdlib[46],
    read_int_opt = Shadow_stdlib[45],
    read_line = Shadow_stdlib[44],
    prerr_newline = Shadow_stdlib[43],
    prerr_endline = Shadow_stdlib[42],
    prerr_float = Shadow_stdlib[41],
    prerr_int = Shadow_stdlib[40],
    prerr_bytes = Shadow_stdlib[39],
    prerr_string = Shadow_stdlib[38],
    prerr_char = Shadow_stdlib[37],
    print_newline = Shadow_stdlib[36],
    print_endline = Shadow_stdlib[35],
    print_float = Shadow_stdlib[34],
    print_int = Shadow_stdlib[33],
    print_bytes = Shadow_stdlib[32],
    print_string = Shadow_stdlib[31],
    print_char = Shadow_stdlib[30],
    stderr = Shadow_stdlib[29],
    stdout = Shadow_stdlib[28],
    stdin = Shadow_stdlib[27],
    float_of_string_opt = Shadow_stdlib[25],
    string_of_float = Shadow_stdlib[24],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_int = Shadow_stdlib[22],
    bool_of_string = Shadow_stdlib[21],
    bool_of_string_opt = Shadow_stdlib[20],
    string_of_bool = Shadow_stdlib[19],
    char_of_int = Shadow_stdlib[18],
    epsilon_float = Shadow_stdlib[16],
    min_float = Shadow_stdlib[15],
    max_float = Shadow_stdlib[14],
    nan = Shadow_stdlib[13],
    neg_infinity = Shadow_stdlib[12],
    infinity = Shadow_stdlib[11],
    min_int = Shadow_stdlib[9],
    max_int = Shadow_stdlib[8],
    Not_found = Shadow_stdlib[4],
    Exit = Shadow_stdlib[3],
    invalid_arg = Caml[1],
    failwith = Caml[2],
    Exit$0 = Caml[3],
    Match_failure = Caml[4],
    Assert_failure = Caml[5],
    Invalid_argument = Caml[6],
    Failure = Caml[7],
    Out_of_memory = Caml[9],
    Stack_overflow = Caml[10],
    Sys_error = Caml[11],
    End_of_file = Caml[12],
    Division_by_zero = Caml[13],
    Sys_blocked_io = Caml[14],
    Undefined_recursive_module = Caml[15],
    min = Caml[16],
    max = Caml[17],
    abs = Caml[18],
    max_int$0 = Caml[19],
    min_int$0 = Caml[20],
    lnot = Caml[21],
    infinity$0 = Caml[22],
    neg_infinity$0 = Caml[23],
    nan$0 = Caml[24],
    max_float$0 = Caml[25],
    min_float$0 = Caml[26],
    epsilon_float$0 = Caml[27],
    symbol$0 = Caml[28],
    char_of_int$0 = Caml[29],
    string_of_bool$0 = Caml[30],
    bool_of_string_opt$0 = Caml[31],
    bool_of_string$0 = Caml[32],
    string_of_int$0 = Caml[33],
    int_of_string_opt$0 = Caml[34],
    string_of_float$0 = Caml[35],
    float_of_string_opt$0 = Caml[36],
    symbol$1 = Caml[37],
    stdin$0 = Caml[38],
    stdout$0 = Caml[39],
    stderr$0 = Caml[40],
    print_char$0 = Caml[41],
    print_string$0 = Caml[42],
    print_bytes$0 = Caml[43],
    print_int$0 = Caml[44],
    print_float$0 = Caml[45],
    print_endline$0 = Caml[46],
    print_newline$0 = Caml[47],
    prerr_char$0 = Caml[48],
    prerr_string$0 = Caml[49],
    prerr_bytes$0 = Caml[50],
    prerr_int$0 = Caml[51],
    prerr_float$0 = Caml[52],
    prerr_endline$0 = Caml[53],
    prerr_newline$0 = Caml[54],
    read_line$0 = Caml[55],
    read_int_opt$0 = Caml[56],
    read_int$0 = Caml[57],
    read_float_opt$0 = Caml[58],
    read_float$0 = Caml[59],
    open_out$0 = Caml[60],
    open_out_bin$0 = Caml[61],
    open_out_gen$0 = Caml[62],
    flush$0 = Caml[63],
    flush_all$0 = Caml[64],
    output_char$0 = Caml[65],
    output_string$0 = Caml[66],
    output_bytes$0 = Caml[67],
    output$0 = Caml[68],
    output_substring$0 = Caml[69],
    output_byte$0 = Caml[70],
    output_binary_int$0 = Caml[71],
    output_value$0 = Caml[72],
    seek_out$0 = Caml[73],
    pos_out$0 = Caml[74],
    out_channel_length$0 = Caml[75],
    close_out$0 = Caml[76],
    close_out_noerr$0 = Caml[77],
    set_binary_mode_out$0 = Caml[78],
    open_in$0 = Caml[79],
    open_in_bin$0 = Caml[80],
    open_in_gen$0 = Caml[81],
    input_char$0 = Caml[82],
    input_line$0 = Caml[83],
    input$0 = Caml[84],
    really_input$0 = Caml[85],
    really_input_string$0 = Caml[86],
    input_byte$0 = Caml[87],
    input_binary_int$0 = Caml[88],
    input_value$0 = Caml[89],
    seek_in$0 = Caml[90],
    pos_in$0 = Caml[91],
    in_channel_length$0 = Caml[92],
    close_in$0 = Caml[93],
    close_in_noerr$0 = Caml[94],
    set_binary_mode_in$0 = Caml[95],
    LargeFile = Caml[96],
    string_of_format$0 = Caml[97],
    symbol$2 = Caml[98],
    exit$0 = Caml[99],
    at_exit$0 = Caml[100],
    valid_float_lexem$0 = Caml[101],
    unsafe_really_input$0 = Caml[102],
    do_at_exit$0 = Caml[103],
    In_channel = Caml[104],
    Out_channel = Caml[105],
    Not_found$0 = Caml[8],
    Caml$0 =
      [0,
       invalid_arg,
       failwith,
       Exit$0,
       Match_failure,
       Assert_failure,
       Invalid_argument,
       Failure,
       Out_of_memory,
       Stack_overflow,
       Sys_error,
       End_of_file,
       Division_by_zero,
       Sys_blocked_io,
       Undefined_recursive_module,
       min,
       max,
       abs,
       max_int$0,
       min_int$0,
       lnot,
       infinity$0,
       neg_infinity$0,
       nan$0,
       max_float$0,
       min_float$0,
       epsilon_float$0,
       symbol$0,
       char_of_int$0,
       string_of_bool$0,
       bool_of_string_opt$0,
       bool_of_string$0,
       string_of_int$0,
       int_of_string_opt$0,
       string_of_float$0,
       float_of_string_opt$0,
       symbol$1,
       stdin$0,
       stdout$0,
       stderr$0,
       print_char$0,
       print_string$0,
       print_bytes$0,
       print_int$0,
       print_float$0,
       print_endline$0,
       print_newline$0,
       prerr_char$0,
       prerr_string$0,
       prerr_bytes$0,
       prerr_int$0,
       prerr_float$0,
       prerr_endline$0,
       prerr_newline$0,
       read_line$0,
       read_int_opt$0,
       read_int$0,
       read_float_opt$0,
       read_float$0,
       open_out$0,
       open_out_bin$0,
       open_out_gen$0,
       flush$0,
       flush_all$0,
       output_char$0,
       output_string$0,
       output_bytes$0,
       output$0,
       output_substring$0,
       output_byte$0,
       output_binary_int$0,
       output_value$0,
       seek_out$0,
       pos_out$0,
       out_channel_length$0,
       close_out$0,
       close_out_noerr$0,
       set_binary_mode_out$0,
       open_in$0,
       open_in_bin$0,
       open_in_gen$0,
       input_char$0,
       input_line$0,
       input$0,
       really_input$0,
       really_input_string$0,
       input_byte$0,
       input_binary_int$0,
       input_value$0,
       seek_in$0,
       pos_in$0,
       in_channel_length$0,
       close_in$0,
       close_in_noerr$0,
       set_binary_mode_in$0,
       LargeFile,
       string_of_format$0,
       symbol$2,
       exit$0,
       at_exit$0,
       valid_float_lexem$0,
       unsafe_really_input$0,
       do_at_exit$0,
       In_channel,
       Out_channel,
       Not_found$0];
   function bool_to_int(x){return x;}
   function symbol$3(_V_, _U_){return _V_ !== _U_ ? 1 : 0;}
   var symbol$4 = runtime.caml_mul;
   function symbol$5(_T_, _S_){return Math.pow(_T_, _S_);}
   function symbol$6(_R_, _Q_){return _R_ * _Q_;}
   function symbol$7(_P_, _O_){return _P_ + _O_ | 0;}
   function symbol$8(_N_, _M_){return _N_ + _M_;}
   function symbol$9(_L_, _K_){return _L_ - _K_ | 0;}
   function symbol$10(_J_, _I_){return _J_ - _I_;}
   var symbol$11 = runtime.caml_div;
   function symbol$12(_H_, _G_){return _H_ / _G_;}
   var ascending = caml_int_compare;
   function descending(x, y){return caml_int_compare(y, x);}
   function max$0(x, y){return y <= x ? x : y;}
   function min$0(x, y){return x <= y ? x : y;}
   var
    Int_replace_polymorphic_compar = [0, ascending, descending, max$0, min$0],
    ascending$0 = Int_replace_polymorphic_compar[1],
    descending$0 = Int_replace_polymorphic_compar[2],
    max$1 = Int_replace_polymorphic_compar[3],
    min$1 = Int_replace_polymorphic_compar[4],
    symbol$13 = caml_lessthan,
    symbol$14 = caml_lessequal,
    symbol$15 = caml_notequal,
    symbol$16 = caml_equal,
    symbol$17 = caml_greaterthan,
    symbol$18 = caml_greaterequal;
   function ascending$1(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$1(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare = caml_int_compare, equal = caml_equal;
   function max$2(x, y){return caml_greaterequal(x, y) ? x : y;}
   function min$2(x, y){return caml_lessequal(x, y) ? x : y;}
   var
    Int32_replace_polymorphic_comp =
      [0,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       ascending$1,
       descending$1,
       compare,
       equal,
       max$2,
       min$2];
   function ascending$2(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$2(x, y){return caml_call2(Base_Poly0[2], x, y);}
   function max$3(x, y){return caml_greaterequal(x, y) ? x : y;}
   function min$3(x, y){return caml_lessequal(x, y) ? x : y;}
   var
    Int64_replace_polymorphic_comp =
      [0, ascending$2, descending$2, max$3, min$3],
    symbol$19 = caml_lessthan,
    symbol$20 = caml_lessequal,
    symbol$21 = caml_notequal,
    symbol$22 = caml_equal,
    symbol$23 = caml_greaterthan,
    symbol$24 = caml_greaterequal;
   function ascending$3(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$3(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare, equal$0 = caml_equal;
   function max$4(x, y){return caml_greaterequal(x, y) ? x : y;}
   function min$4(x, y){return caml_lessequal(x, y) ? x : y;}
   var
    Nativeint_replace_polymorphic_ =
      [0,
       symbol$19,
       symbol$20,
       symbol$21,
       symbol$22,
       symbol$23,
       symbol$24,
       ascending$3,
       descending$3,
       compare$0,
       equal$0,
       max$4,
       min$4];
   function symbol$25(x, y){return x < y ? 1 : 0;}
   function symbol$26(x, y){return x <= y ? 1 : 0;}
   function symbol$27(x, y){return x !== y ? 1 : 0;}
   function symbol$28(x, y){return x === y ? 1 : 0;}
   function symbol$29(x, y){return y < x ? 1 : 0;}
   function symbol$30(x, y){return y <= x ? 1 : 0;}
   function ascending$4(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$4(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$1 = caml_int_compare;
   function equal$1(x, y){return x === y ? 1 : 0;}
   function max$5(x, y){return y <= x ? x : y;}
   function min$5(x, y){return x <= y ? x : y;}
   var
    Bool_replace_polymorphic_compa =
      [0,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       symbol$30,
       ascending$4,
       descending$4,
       compare$1,
       equal$1,
       max$5,
       min$5];
   function symbol$31(x, y){return x < y ? 1 : 0;}
   function symbol$32(x, y){return x <= y ? 1 : 0;}
   function symbol$33(x, y){return x !== y ? 1 : 0;}
   function symbol$34(x, y){return x === y ? 1 : 0;}
   function symbol$35(x, y){return y < x ? 1 : 0;}
   function symbol$36(x, y){return y <= x ? 1 : 0;}
   function ascending$5(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$5(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$2 = caml_int_compare;
   function equal$2(x, y){return x === y ? 1 : 0;}
   function max$6(x, y){return y <= x ? x : y;}
   function min$6(x, y){return x <= y ? x : y;}
   var
    Char_replace_polymorphic_compa =
      [0,
       symbol$31,
       symbol$32,
       symbol$33,
       symbol$34,
       symbol$35,
       symbol$36,
       ascending$5,
       descending$5,
       compare$2,
       equal$2,
       max$6,
       min$6];
   function i(x){return caml_call1(Stdlib_Uchar[10], x);}
   function symbol$37(x, y){var _F_ = i(y); return i(x) < _F_ ? 1 : 0;}
   function symbol$38(x, y){var _E_ = i(y); return i(x) <= _E_ ? 1 : 0;}
   function symbol$39(x, y){var _D_ = i(y); return i(x) !== _D_ ? 1 : 0;}
   function symbol$40(x, y){var _C_ = i(y); return i(x) === _C_ ? 1 : 0;}
   function symbol$41(x, y){var _B_ = i(y); return _B_ < i(x) ? 1 : 0;}
   function symbol$42(x, y){var _A_ = i(y); return _A_ <= i(x) ? 1 : 0;}
   function ascending$6(x, y){
    var _y_ = i(y), _z_ = i(x);
    return caml_call2(Int_replace_polymorphic_compar[1], _z_, _y_);
   }
   function descending$6(x, y){
    var _w_ = i(y), _x_ = i(x);
    return caml_call2(Int_replace_polymorphic_compar[2], _x_, _w_);
   }
   function compare$3(x, y){
    var _v_ = i(y);
    return caml_int_compare(i(x), _v_);
   }
   function equal$3(x, y){var _u_ = i(y); return i(x) === _u_ ? 1 : 0;}
   function max$7(x, y){return symbol$42(x, y) ? x : y;}
   function min$7(x, y){return symbol$38(x, y) ? x : y;}
   var
    Uchar_replace_polymorphic_comp =
      [0,
       i,
       symbol$37,
       symbol$38,
       symbol$39,
       symbol$40,
       symbol$41,
       symbol$42,
       ascending$6,
       descending$6,
       compare$3,
       equal$3,
       max$7,
       min$7];
   function symbol$43(x, y){return x < y ? 1 : 0;}
   function symbol$44(x, y){return x <= y ? 1 : 0;}
   function symbol$45(x, y){return x != y ? 1 : 0;}
   function symbol$46(x, y){return x == y ? 1 : 0;}
   function symbol$47(x, y){return y < x ? 1 : 0;}
   function symbol$48(x, y){return y <= x ? 1 : 0;}
   function ascending$7(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$7(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$4 = runtime.caml_float_compare;
   function equal$4(x, y){return x == y ? 1 : 0;}
   function max$8(x, y){return y <= x ? x : y;}
   function min$8(x, y){return x <= y ? x : y;}
   var
    Float_replace_polymorphic_comp =
      [0,
       symbol$43,
       symbol$44,
       symbol$45,
       symbol$46,
       symbol$47,
       symbol$48,
       ascending$7,
       descending$7,
       compare$4,
       equal$4,
       max$8,
       min$8],
    symbol$49 = runtime.caml_string_lessthan,
    symbol$50 = caml_string_lessequal,
    symbol$51 = runtime.caml_string_notequal,
    symbol$52 = caml_string_equal,
    symbol$53 = runtime.caml_string_greaterthan,
    symbol$54 = caml_string_greaterequal;
   function ascending$8(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$8(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$5 = runtime.caml_string_compare, equal$5 = caml_string_equal;
   function max$9(x, y){return caml_string_greaterequal(x, y) ? x : y;}
   function min$9(x, y){return caml_string_lessequal(x, y) ? x : y;}
   var
    String_replace_polymorphic_com =
      [0,
       symbol$49,
       symbol$50,
       symbol$51,
       symbol$52,
       symbol$53,
       symbol$54,
       ascending$8,
       descending$8,
       compare$5,
       equal$5,
       max$9,
       min$9],
    symbol$55 = runtime.caml_bytes_lessthan,
    symbol$56 = caml_bytes_lessequal,
    symbol$57 = runtime.caml_bytes_notequal,
    symbol$58 = caml_bytes_equal,
    symbol$59 = runtime.caml_bytes_greaterthan,
    symbol$60 = caml_bytes_greaterequal;
   function ascending$9(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending$9(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$6 = runtime.caml_bytes_compare, equal$6 = caml_bytes_equal;
   function max$10(x, y){return caml_bytes_greaterequal(x, y) ? x : y;}
   function min$10(x, y){return caml_bytes_lessequal(x, y) ? x : y;}
   var
    Bytes_replace_polymorphic_comp =
      [0,
       symbol$55,
       symbol$56,
       symbol$57,
       symbol$58,
       symbol$59,
       symbol$60,
       ascending$9,
       descending$9,
       compare$6,
       equal$6,
       max$10,
       min$10],
    symbol$61 = Caml$0[36],
    symbol$62 = Caml$0[27];
   function symbol$63(_t_){return - _t_ | 0;}
   function symbol$64(_s_){return - _s_;}
   function asr(_r_, _q_){return _r_ >> _q_;}
   function land(_p_, _o_){return _p_ & _o_;}
   var lnot$0 = Caml$0[20];
   function lor(_n_, _m_){return _n_ | _m_;}
   function lsl(_l_, _k_){return _l_ << _k_;}
   function lsr(_j_, _i_){return _j_ >>> _i_ | 0;}
   function lxor(_h_, _g_){return _h_ ^ _g_;}
   var mod = runtime.caml_mod, abs$0 = Caml$0[17], failwith$0 = Caml$0[2];
   function fst(_f_){return _f_[1];}
   var invalid_arg$0 = Caml$0[1];
   function snd(_e_){return _e_[2];}
   function phys_equal(_d_, _c_){return _d_ === _c_ ? 1 : 0;}
   function decr(_b_){_b_[1] += -1; return 0;}
   function incr(_a_){_a_[1]++; return 0;}
   var
    float_of_string = runtime.caml_float_of_string,
    am_testing = runtime.Base_am_testing(0),
    Base_Import0 =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Caml$0,
       bool_to_int,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       Int_replace_polymorphic_compar,
       ascending$0,
       descending$0,
       max$1,
       min$1,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$61,
       symbol$62,
       symbol$63,
       symbol$64,
       asr,
       land,
       lnot$0,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs$0,
       failwith$0,
       fst,
       invalid_arg$0,
       snd,
       phys_equal,
       decr,
       incr,
       float_of_string,
       am_testing];
   runtime.caml_register_global(4, Base_Import0, "Base__Import0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Printf
//# unitInfo: Requires: Base__Import0, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Stdlib_Printf = global_data.Stdlib__Printf,
    sprintf = Stdlib_Printf[4],
    bprintf = Stdlib_Printf[5],
    ifprintf = Stdlib_Printf[6],
    ksprintf = Stdlib_Printf[10],
    kbprintf = Stdlib_Printf[11];
   function failwithf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[123], s);},
             fmt);
   }
   function invalid_argf(fmt){
    return caml_call2
            (ksprintf,
             function(s, param){return caml_call1(Base_Import0[125], s);},
             fmt);
   }
   var
    Base_Printf =
      [0,
       ifprintf,
       sprintf,
       bprintf,
       ksprintf,
       kbprintf,
       failwithf,
       invalid_argf];
   runtime.caml_register_global(2, Base_Printf, "Base__Printf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys0
//# unitInfo: Requires: Base__Import0, Base__Printf, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_sys_argv = runtime.caml_sys_argv,
    caml_sys_getenv = runtime.caml_sys_getenv,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Sys = global_data.Stdlib__Sys,
    backend_type = Stdlib_Sys[5],
    interactive = Stdlib_Sys[3],
    os_type = Stdlib_Sys[4],
    unix = Stdlib_Sys[6],
    win32 = Stdlib_Sys[7],
    cygwin = Stdlib_Sys[8],
    word_size_in_bits = Stdlib_Sys[9],
    int_size_in_bits = Stdlib_Sys[10],
    big_endian = Stdlib_Sys[11],
    max_string_length = Stdlib_Sys[12],
    max_array_length = Stdlib_Sys[13],
    runtime_variant = runtime.caml_runtime_variant,
    runtime_parameters = runtime.caml_runtime_parameters,
    argv = caml_sys_argv(0),
    _a_ =
      [0,
       [11,
        "Sys.getenv_exn: environment variable ",
        [2, 0, [11, " is not set", 0]]],
       "Sys.getenv_exn: environment variable %s is not set"];
   function get_argv(param){return caml_sys_argv(0);}
   var
    ocaml_version = Stdlib_Sys[46],
    enable_runtime_warnings = Stdlib_Sys[47],
    runtime_warnings_enabled = Stdlib_Sys[48];
   function getenv_exn(var$0){
    try{var _e_ = caml_sys_getenv(var$0); return _e_;}
    catch(_f_){
     var _d_ = caml_wrap_exception(_f_);
     if(_d_ === Base_Import0[84][105])
      return caml_call3(Base_Printf[6], _a_, var$0, 0);
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function getenv(var$0){
    try{var x = caml_sys_getenv(var$0);}
    catch(_c_){
     var _b_ = caml_wrap_exception(_c_);
     if(_b_ === Base_Import0[84][105]) return 0;
     throw caml_maybe_attach_backtrace(_b_, 0);
    }
    return [0, x];
   }
   var
    Break = Stdlib_Sys[44],
    Base_Sys0 =
      [0,
       backend_type,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       argv,
       get_argv,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv_exn,
       getenv,
       Break];
   runtime.caml_register_global(4, Base_Sys0, "Base__Sys0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array0
//# unitInfo: Requires: Base__Printf, Base__Sys0, Stdlib, Stdlib__ArrayLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_ArrayLabels = global_data.Stdlib__ArrayLabels;
   global_data.Stdlib;
   var
    Base_Printf = global_data.Base__Printf,
    Base_Sys0 = global_data.Base__Sys0,
    invalid_argf = Base_Printf[7],
    Array = [0],
    max_length = Base_Sys0[11];
   function create(len, x){return runtime.caml_make_vect(len, x);}
   function create_float_uninitialized(len){
    return runtime.caml_make_float_vect(len);
   }
   var
    append = Stdlib_ArrayLabels[5],
    blit = Stdlib_ArrayLabels[10],
    concat = Stdlib_ArrayLabels[6],
    copy = Stdlib_ArrayLabels[8],
    fill = Stdlib_ArrayLabels[9],
    init = Stdlib_ArrayLabels[2],
    make_matrix = Stdlib_ArrayLabels[3],
    of_list = Stdlib_ArrayLabels[12],
    sub = Stdlib_ArrayLabels[7],
    to_list = Stdlib_ArrayLabels[11];
   function fold(t, init, f){
    return caml_call3(Stdlib_ArrayLabels[17], f, init, t);
   }
   function fold_right(t, f, init){
    return caml_call3(Stdlib_ArrayLabels[19], f, t, init);
   }
   function iter(t, f){return caml_call2(Stdlib_ArrayLabels[13], f, t);}
   function iteri(t, f){return caml_call2(Stdlib_ArrayLabels[14], f, t);}
   function map(t, f){return caml_call2(Stdlib_ArrayLabels[15], f, t);}
   function mapi(t, f){return caml_call2(Stdlib_ArrayLabels[16], f, t);}
   function stable_sort(t, compare){
    return caml_call2(Stdlib_ArrayLabels[33], compare, t);
   }
   function swap(t, i, j){
    var
     elt_i = caml_check_bound(t, i)[1 + i],
     elt_j = caml_check_bound(t, j)[1 + j];
    t[1 + i] = elt_j;
    t[1 + j] = elt_i;
    return 0;
   }
   var
    Base_Array0 =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap];
   runtime.caml_register_global(6, Base_Array0, "Base__Array0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char0
//# unitInfo: Requires: Base__Printf, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Printf = global_data.Base__Printf,
    Stdlib_Char = global_data.Stdlib__Char,
    failwithf = Base_Printf[6],
    escaped = Stdlib_Char[2],
    lowercase = Stdlib_Char[5],
    _a_ =
      [0,
       [11, "Char.of_int_exn got integer out of range: ", [4, 0, 0, 0, 0]],
       "Char.of_int_exn got integer out of range: %d"];
   function to_int(_e_){return _e_;}
   function unsafe_of_int(_d_){return _d_;}
   var uppercase = Stdlib_Char[6];
   function int_is_ok(i){
    var _b_ = 0 <= i ? 1 : 0, _c_ = _b_ ? i <= 255 ? 1 : 0 : _b_;
    return _c_;
   }
   var min_value = 0, max_value = 255;
   function of_int(i){return int_is_ok(i) ? [0, i] : 0;}
   function of_int_exn(i){
    return int_is_ok(i) ? i : caml_call3(failwithf, _a_, i, 0);
   }
   function equal(t1, t2){return t1 === t2 ? 1 : 0;}
   var
    Base_Char0 =
      [0,
       failwithf,
       escaped,
       lowercase,
       to_int,
       unsafe_of_int,
       uppercase,
       int_is_ok,
       min_value,
       max_value,
       of_int,
       of_int_exn,
       equal];
   runtime.caml_register_global(3, Base_Char0, "Base__Char0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_intf = [0];
   runtime.caml_register_global(0, Base_Hash_intf, "Base__Hash_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int0
//# unitInfo: Requires: Caml
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Caml = global_data.Caml,
    to_string = Caml[33],
    of_string = runtime.caml_int_of_string;
   function to_float(_c_){return _c_;}
   function of_float(_b_){return _b_ | 0;}
   var max_value = Caml[19], min_value = Caml[20];
   function succ(_a_){return _a_ + 1 | 0;}
   var
    Base_Int0 =
      [0,
       to_string,
       of_string,
       to_float,
       of_float,
       max_value,
       min_value,
       succ];
   runtime.caml_register_global(1, Base_Int0, "Base__Int0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List0
//# unitInfo: Requires: Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    hd_exn = Stdlib_ListLabels[5],
    length = Stdlib_ListLabels[1],
    rev_append = Stdlib_ListLabels[12],
    tl_exn = Stdlib_ListLabels[6],
    unzip = Stdlib_ListLabels[54];
   function exists(t, f){return caml_call2(Stdlib_ListLabels[33], f, t);}
   function exists2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[35], f, l1, l2);
   }
   function fold(t, init, f){
    return caml_call3(Stdlib_ListLabels[25], f, init, t);
   }
   function fold2_ok(l1, l2, init, f){
    return caml_call4(Stdlib_ListLabels[30], f, init, l1, l2);
   }
   function for_all(t, f){return caml_call2(Stdlib_ListLabels[32], f, t);}
   function for_all2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[34], f, l1, l2);
   }
   function iter(t, f){return caml_call2(Stdlib_ListLabels[17], f, t);}
   function iter2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[27], f, l1, l2);
   }
   function nontail_map(t, f){return caml_call2(Stdlib_ListLabels[19], f, t);}
   function nontail_mapi(t, f){
    return caml_call2(Stdlib_ListLabels[20], f, t);
   }
   function partition(t, f){return caml_call2(Stdlib_ListLabels[44], f, t);}
   function rev_map(t, f){return caml_call2(Stdlib_ListLabels[21], f, t);}
   function rev_map2_ok(l1, l2, f){
    return caml_call3(Stdlib_ListLabels[29], f, l1, l2);
   }
   function sort(l, compare){
    return caml_call2(Stdlib_ListLabels[56], compare, l);
   }
   function stable_sort(l, compare){
    return caml_call2(Stdlib_ListLabels[57], compare, l);
   }
   function rev(res){
    if(res){
     var match = res[2];
     if(match){
      var rest = match[2], y = match[1], x = res[1];
      return caml_call2(rev_append, rest, [0, y, [0, x, 0]]);
     }
    }
    return res;
   }
   function fold_right(l, f, init){
    if(! l) return init;
    function _a_(a, b){return caml_call2(f, b, a);}
    return fold(rev(l), init, _a_);
   }
   var
    Base_List0 =
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort,
       rev,
       fold_right];
   runtime.caml_register_global(1, Base_List0, "Base__List0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash
//# unitInfo: Requires: Base__Char0, Base__Hash_intf, Base__Import0, Base__Int0, Base__List0, Base_internalhash_types, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    description = "internalhash",
    Base_Import0 = global_data.Base__Import0,
    Base_Int0 = global_data.Base__Int0,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_List0 = global_data.Base__List0,
    Base_Char0 = global_data.Base__Char0;
   function Folding(Hash){
    function hash_fold_unit(s, param){return s;}
    var
     hash_fold_int = Hash[2],
     hash_fold_int64 = Hash[3],
     hash_fold_float = Hash[4],
     hash_fold_string = Hash[5];
    function as_int(f, s, x){
     return caml_call2(hash_fold_int, s, caml_call1(f, x));
    }
    function _Q_(_ar_){return _ar_;}
    function hash_fold_int32(_ap_, _aq_){return as_int(_Q_, _ap_, _aq_);}
    var _R_ = Base_Char0[4];
    function hash_fold_char(_an_, _ao_){return as_int(_R_, _an_, _ao_);}
    function _S_(param){return param ? 1 : 0;}
    function hash_fold_bool(_al_, _am_){return as_int(_S_, _al_, _am_);}
    function hash_fold_nativeint(s, x){
     return caml_call2(hash_fold_int64, s, runtime.caml_int64_of_int32(x));
    }
    function hash_fold_option(hash_fold_elem, s, param){
     if(! param) return caml_call2(hash_fold_int, s, 0);
     var x = param[1];
     return caml_call2(hash_fold_elem, caml_call2(hash_fold_int, s, 1), x);
    }
    function hash_fold_list(hash_fold_elem, s$1, list$1){
     var
      s$2 = caml_call2(hash_fold_int, s$1, caml_call1(Base_List0[2], list$1)),
      s = s$2,
      list = list$1;
     for(;;){
      if(! list) return s;
      var
       list$0 = list[2],
       x = list[1],
       s$0 = caml_call2(hash_fold_elem, s, x),
       s = s$0,
       list = list$0;
     }
    }
    function hash_fold_lazy_t(hash_fold_elem, s, x){
     var
      _aj_ = runtime.caml_obj_tag(x),
      _ak_ =
        250 === _aj_
         ? x[1]
         : 246 === _aj_ ? caml_call1(CamlinternalLazy[2], x) : x;
     return caml_call2(hash_fold_elem, s, _ak_);
    }
    function hash_fold_ref_frozen(hash_fold_elem, s, x){return caml_call2(hash_fold_elem, s, x[1]);
    }
    function hash_fold_array_frozen(hash_fold_elem, s$1, array){
     var
      s$2 = caml_call2(hash_fold_int, s$1, array.length - 1),
      s = s$2,
      i = 0;
     for(;;){
      if(i === array.length - 1) return s;
      var
       e = array[1 + i],
       i$0 = caml_call2(Base_Import0[90], i, 1),
       s$0 = caml_call2(hash_fold_elem, s, e),
       s = s$0,
       i = i$0;
     }
    }
    function hash_nativeint(x){
     var
      _ah_ = caml_call1(Hash[6], 0),
      _ai_ = hash_fold_nativeint(caml_call2(Hash[7], 0, _ah_), x);
     return caml_call1(Hash[8], _ai_);
    }
    function hash_int64(x){
     var
      _af_ = caml_call1(Hash[6], 0),
      _ag_ = caml_call2(hash_fold_int64, caml_call2(Hash[7], 0, _af_), x);
     return caml_call1(Hash[8], _ag_);
    }
    function hash_int32(x){
     var
      _ad_ = caml_call1(Hash[6], 0),
      _ae_ = hash_fold_int32(caml_call2(Hash[7], 0, _ad_), x);
     return caml_call1(Hash[8], _ae_);
    }
    function hash_char(x){
     var
      _ab_ = caml_call1(Hash[6], 0),
      _ac_ = hash_fold_char(caml_call2(Hash[7], 0, _ab_), x);
     return caml_call1(Hash[8], _ac_);
    }
    function hash_int(x){
     var
      _$_ = caml_call1(Hash[6], 0),
      _aa_ = caml_call2(hash_fold_int, caml_call2(Hash[7], 0, _$_), x);
     return caml_call1(Hash[8], _aa_);
    }
    function hash_bool(x){
     var
      _Z_ = caml_call1(Hash[6], 0),
      ___ = hash_fold_bool(caml_call2(Hash[7], 0, _Z_), x);
     return caml_call1(Hash[8], ___);
    }
    function hash_string(x){
     var
      _X_ = caml_call1(Hash[6], 0),
      _Y_ = caml_call2(hash_fold_string, caml_call2(Hash[7], 0, _X_), x);
     return caml_call1(Hash[8], _Y_);
    }
    function hash_float(x){
     var
      _V_ = caml_call1(Hash[6], 0),
      _W_ = caml_call2(hash_fold_float, caml_call2(Hash[7], 0, _V_), x);
     return caml_call1(Hash[8], _W_);
    }
    function hash_unit(x){
     var _T_ = caml_call1(Hash[6], 0), _U_ = caml_call2(Hash[7], 0, _T_);
     return caml_call1(Hash[8], _U_);
    }
    return [0,
            hash_fold_nativeint,
            hash_fold_int64,
            hash_fold_int32,
            hash_fold_char,
            hash_fold_int,
            hash_fold_bool,
            hash_fold_string,
            hash_fold_float,
            hash_fold_unit,
            hash_fold_option,
            hash_fold_list,
            hash_fold_lazy_t,
            hash_fold_ref_frozen,
            hash_fold_array_frozen,
            hash_nativeint,
            hash_int64,
            hash_int32,
            hash_char,
            hash_int,
            hash_bool,
            hash_string,
            hash_float,
            hash_unit];
   }
   function F(Hash){
    var
     description = Hash[1],
     fold_int = Hash[2],
     fold_int64 = Hash[3],
     fold_float = Hash[4],
     fold_string = Hash[5],
     alloc = Hash[6],
     reset = Hash[7],
     get_hash_value = Hash[8],
     For_tests = Hash[9];
    function create(seed, param){
     return caml_call2(reset, seed, caml_call1(alloc, 0));
    }
    function of_fold(hash_fold_t, t){
     return caml_call1
             (get_hash_value, caml_call2(hash_fold_t, create(0, 0), t));
    }
    var Builtin = Folding(Hash);
    function run(seed, folder, x){
     var
      _O_ = caml_call1(Hash[6], 0),
      _P_ = caml_call2(folder, caml_call2(Hash[7], seed, _O_), x);
     return caml_call1(Hash[8], _P_);
    }
    return [0,
            description,
            fold_int,
            fold_int64,
            fold_float,
            fold_string,
            alloc,
            reset,
            get_hash_value,
            For_tests,
            create,
            of_fold,
            Builtin,
            run];
   }
   function alloc(param){return 0;}
   function reset(opt, t){
    if(opt) var sth = opt[1], seed = sth; else var seed = 0;
    return seed;
   }
   var compare_state = runtime.caml_int_compare;
   function state_to_string(state){return caml_call1(Base_Int0[1], state);}
   var For_tests = [0, compare_state, state_to_string];
   function create(seed, param){return reset(seed, 0);}
   function run(seed, folder, x){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(folder, reset(seed, 0), x));
   }
   function of_fold(hash_fold_t, t){
    return runtime.Base_internalhash_get_hash_value
            (caml_call2(hash_fold_t, create(0, 0), t));
   }
   function _a_(_N_){return runtime.Base_internalhash_get_hash_value(_N_);}
   function _b_(_M_, _L_){
    return runtime.Base_internalhash_fold_string(_M_, _L_);
   }
   function _c_(_K_, _J_){
    return runtime.Base_internalhash_fold_float(_K_, _J_);
   }
   function _d_(_I_, _H_){
    return runtime.Base_internalhash_fold_int64(_I_, _H_);
   }
   var
    Folding$0 =
      Folding
       ([0,
         description,
         function(_G_, _F_){
          return runtime.Base_internalhash_fold_int(_G_, _F_);
         },
         _d_,
         _c_,
         _b_,
         alloc,
         reset,
         _a_,
         For_tests]),
    hash_fold_nativeint = Folding$0[1],
    hash_fold_int64 = Folding$0[2],
    hash_fold_int32 = Folding$0[3],
    hash_fold_char = Folding$0[4],
    hash_fold_int = Folding$0[5],
    hash_fold_bool = Folding$0[6],
    hash_fold_string = Folding$0[7],
    hash_fold_float = Folding$0[8],
    hash_fold_unit = Folding$0[9],
    hash_fold_option = Folding$0[10],
    hash_fold_list = Folding$0[11],
    hash_fold_lazy_t = Folding$0[12],
    hash_fold_ref_frozen = Folding$0[13],
    hash_fold_array_frozen = Folding$0[14],
    hash_nativeint = Folding$0[15],
    hash_int64 = Folding$0[16],
    hash_int32 = Folding$0[17],
    hash_string = Folding$0[21],
    hash_char = Base_Char0[4];
   function hash_int(t){
    var
     _t_ = caml_call2(Base_Import0[118], t, 21),
     _u_ = caml_call1(Base_Import0[116], t),
     t$0 = caml_call2(Base_Import0[90], _u_, _t_),
     _v_ = caml_call2(Base_Import0[119], t$0, 24),
     t$1 = caml_call2(Base_Import0[120], t$0, _v_),
     _w_ = caml_call2(Base_Import0[118], t$1, 8),
     _x_ = caml_call2(Base_Import0[118], t$1, 3),
     _y_ = caml_call2(Base_Import0[90], t$1, _x_),
     t$2 = caml_call2(Base_Import0[90], _y_, _w_),
     _z_ = caml_call2(Base_Import0[119], t$2, 14),
     t$3 = caml_call2(Base_Import0[120], t$2, _z_),
     _A_ = caml_call2(Base_Import0[118], t$3, 4),
     _B_ = caml_call2(Base_Import0[118], t$3, 2),
     _C_ = caml_call2(Base_Import0[90], t$3, _B_),
     t$4 = caml_call2(Base_Import0[90], _C_, _A_),
     _D_ = caml_call2(Base_Import0[119], t$4, 28),
     t$5 = caml_call2(Base_Import0[120], t$4, _D_),
     _E_ = caml_call2(Base_Import0[118], t$5, 31);
    return caml_call2(Base_Import0[90], t$5, _E_);
   }
   function hash_bool(x){return x ? 1 : 0;}
   function hash_unit(param){return 0;}
   var
    _e_ =
      [0,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       hash_char,
       hash_int,
       hash_bool,
       hash_string,
       function(_s_){return runtime.Base_hash_double(_s_);},
       hash_unit];
   function _f_(_r_){return runtime.Base_internalhash_get_hash_value(_r_);}
   function _g_(_q_, _p_){
    return runtime.Base_internalhash_fold_string(_q_, _p_);
   }
   function _h_(_o_, _n_){
    return runtime.Base_internalhash_fold_float(_o_, _n_);
   }
   function _i_(_m_, _l_){
    return runtime.Base_internalhash_fold_int64(_m_, _l_);
   }
   var
    Base_Hash =
      [0,
       F,
       description,
       function(_k_, _j_){
        return runtime.Base_internalhash_fold_int(_k_, _j_);
       },
       _i_,
       _h_,
       _g_,
       alloc,
       reset,
       _f_,
       For_tests,
       create,
       of_fold,
       _e_,
       run];
   runtime.caml_register_global(6, Base_Hash, "Base__Hash");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_compare_lib
//# unitInfo: Requires: Base__Import0, Base__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_which_is_abstract_in_an_im =
      ", which is abstract in an implementation.",
    caml_equal = runtime.caml_equal,
    caml_float_compare = runtime.caml_float_compare,
    caml_int_compare = runtime.caml_int_compare;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Base_Printf = global_data.Base__Printf,
    phys_equal = Base_Import0[127],
    _b_ =
      [0,
       [11,
        "Equal called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Equal called on the type %s, which is abstract in an implementation."],
    _a_ =
      [0,
       [11,
        "Compare called on the type ",
        [2, 0, [11, cst_which_is_abstract_in_an_im, 0]]],
       "Compare called on the type %s, which is abstract in an implementation."];
   function compare_abstract(type_name, param, _u_){
    return caml_call3(Base_Printf[4], Base_Import0[123], _a_, type_name);
   }
   function equal_abstract(type_name, param, _t_){
    return caml_call3(Base_Printf[4], Base_Import0[123], _b_, type_name);
   }
   var
    Comparable = [0],
    Equal = [0],
    compare_bool = caml_int_compare,
    compare_char = caml_int_compare,
    compare_float = caml_float_compare,
    compare_int = caml_int_compare,
    compare_int32 = caml_int_compare;
   function compare_int64(_s_, _r_){
    return runtime.caml_int64_compare(_s_, _r_);
   }
   var
    compare_nativeint = caml_int_compare,
    compare_string = runtime.caml_string_compare,
    compare_unit = caml_int_compare;
   function compare_array(compare_elt, a, b){
    if(caml_call2(phys_equal, a, b)) return 0;
    var
     len_a = a.length - 1,
     len_b = b.length - 1,
     ret = caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var l = a[1 + i], r = b[1 + i], res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import0[90], i, 1), i = i$0;
    }
   }
   function compare_list(compare_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      res = caml_call2(compare_elt, x, y);
     if(0 !== res) return res;
     var a$0 = xs, b$0 = ys;
    }
   }
   function compare_option(compare_elt, a, b){
    if(! a) return b ? -1 : 0;
    var a$0 = a[1];
    if(! b) return 1;
    var b$0 = b[1];
    return caml_call2(compare_elt, a$0, b$0);
   }
   function compare_ref(compare_elt, a, b){
    return caml_call2(compare_elt, a[1], b[1]);
   }
   function equal_bool(_q_, _p_){return _q_ === _p_ ? 1 : 0;}
   function equal_char(_o_, _n_){return _o_ === _n_ ? 1 : 0;}
   function equal_int(_m_, _l_){return _m_ === _l_ ? 1 : 0;}
   var
    equal_int32 = caml_equal,
    equal_int64 = caml_equal,
    equal_nativeint = caml_equal,
    equal_string = runtime.caml_string_equal;
   function equal_unit(_k_, _j_){return _k_ === _j_ ? 1 : 0;}
   function equal_float(x, y){return caml_float_compare(x, y) === 0 ? 1 : 0;}
   function equal_array(equal_elt, a, b){
    var _d_ = caml_call2(phys_equal, a, b);
    if(_d_)
     var _e_ = _d_;
    else{
     var
      len_a = a.length - 1,
      len_b = b.length - 1,
      _f_ = len_a === len_b ? 1 : 0;
     if(_f_){
      var i = 0;
      for(;;){
       var _g_ = i === len_a ? 1 : 0;
       if(_g_)
        var _h_ = _g_;
       else{
        var l = a[1 + i], r = b[1 + i], _i_ = caml_call2(equal_elt, l, r);
        if(_i_){
         var i$0 = caml_call2(Base_Import0[90], i, 1), i = i$0;
         continue;
        }
        var _h_ = _i_;
       }
       return _h_;
      }
     }
     var _e_ = _f_;
    }
    return _e_;
   }
   function equal_list(equal_elt, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(a$0){
      if(b$0){
       var
        ys = b$0[2],
        y = b$0[1],
        xs = a$0[2],
        x = a$0[1],
        _c_ = caml_call2(equal_elt, x, y);
       if(! _c_) return _c_;
       var a$0 = xs, b$0 = ys;
       continue;
      }
     }
     else if(! b$0) return 1;
     return 0;
    }
   }
   function equal_option(equal_elt, a, b){
    if(a){
     if(b){
      var b$0 = b[1], a$0 = a[1];
      return caml_call2(equal_elt, a$0, b$0);
     }
    }
    else if(! b) return 1;
    return 0;
   }
   function equal_ref(equal_elt, a, b){
    return caml_call2(equal_elt, a[1], b[1]);
   }
   var
    Base_Ppx_compare_lib =
      [0,
       phys_equal,
       compare_abstract,
       equal_abstract,
       Comparable,
       Equal,
       [0,
        compare_bool,
        compare_char,
        compare_float,
        compare_int,
        compare_int32,
        compare_int64,
        compare_nativeint,
        compare_string,
        compare_unit,
        compare_array,
        compare_list,
        compare_option,
        compare_ref,
        equal_bool,
        equal_char,
        equal_float,
        equal_int,
        equal_int32,
        equal_int64,
        equal_nativeint,
        equal_string,
        equal_unit,
        equal_array,
        equal_list,
        equal_option,
        equal_ref]];
   runtime.caml_register_global
    (4, Base_Ppx_compare_lib, "Base__Ppx_compare_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_hash_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Std = [0],
    Hashable = [0],
    Base_Ppx_hash_lib = [0, Std, Hashable];
   runtime.caml_register_global(0, Base_Ppx_hash_lib, "Base__Ppx_hash_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp
//# unitInfo: Requires: Base__Hash, Base__Ppx_compare_lib, Sexplib0__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_update_dummy = runtime.caml_update_dummy;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    t_of_sexp = Sexplib0_Sexp[1],
    sexp_of_t = Sexplib0_Sexp[2],
    equal = Sexplib0_Sexp[3],
    Not_found_s = Sexplib0_Sexp[5],
    Of_sexp_error = Sexplib0_Sexp[6],
    message = Sexplib0_Sexp[7],
    default_indent = Sexplib0_Sexp[8],
    pp_hum = Sexplib0_Sexp[9],
    pp_hum_indent = Sexplib0_Sexp[10],
    pp_mach = Sexplib0_Sexp[11],
    pp = Sexplib0_Sexp[12],
    to_string_hum = Sexplib0_Sexp[13],
    to_string_mach = Sexplib0_Sexp[14],
    to_string = Sexplib0_Sexp[15],
    of_float_style = Sexplib0_Sexp[16],
    of_int_style = Sexplib0_Sexp[17],
    Private = Sexplib0_Sexp[18];
   function compare(a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(Base_Ppx_compare_lib[6][8], a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call3(Base_Ppx_compare_lib[6][11], compare, a_005, b_006);
   }
   var
    hash_fold_t = function _f_(_d_, _e_){return _f_.fun(_d_, _e_);},
    hash = function _c_(_b_){return _c_.fun(_b_);};
   caml_update_dummy
    (hash_fold_t,
     function(hsv, arg){
      if(0 === arg[0]){
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(Base_Hash[13][7], hsv$0, a0);
      }
      var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
      return caml_call3(Base_Hash[13][11], hash_fold_t, hsv$1, a0$0);
     });
   caml_update_dummy
    (hash,
     function(arg){
      var
       hsv = caml_call2(Base_Hash[11], 0, 0),
       _a_ = caml_call2(hash_fold_t, hsv, arg);
      return caml_call1(Base_Hash[9], _a_);
     });
   var t_sexp_grammar = Sexplib0_Sexp_conv[59], of_string = 0;
   function invariant(param){return 0;}
   var
    Base_Sexp =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       Private,
       t_sexp_grammar,
       invariant,
       of_string];
   runtime.caml_register_global(4, Base_Sexp, "Base__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Import
//# unitInfo: Requires: Base__Hash, Base__Import0, Base__Ppx_compare_lib, Base__Sexp, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Import0 = global_data.Base__Import0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Sexp = global_data.Base__Sexp,
    Exit = Base_Import0[1],
    Not_found = Base_Import0[2],
    max_int = Base_Import0[3],
    min_int = Base_Import0[4],
    infinity = Base_Import0[5],
    neg_infinity = Base_Import0[6],
    nan = Base_Import0[7],
    max_float = Base_Import0[8],
    min_float = Base_Import0[9],
    epsilon_float = Base_Import0[10],
    char_of_int = Base_Import0[11],
    string_of_bool = Base_Import0[12],
    bool_of_string_opt = Base_Import0[13],
    bool_of_string = Base_Import0[14],
    string_of_int = Base_Import0[15],
    int_of_string_opt = Base_Import0[16],
    string_of_float = Base_Import0[17],
    float_of_string_opt = Base_Import0[18],
    stdin = Base_Import0[19],
    stdout = Base_Import0[20],
    stderr = Base_Import0[21],
    print_char = Base_Import0[22],
    print_string = Base_Import0[23],
    print_bytes = Base_Import0[24],
    print_int = Base_Import0[25],
    print_float = Base_Import0[26],
    print_endline = Base_Import0[27],
    print_newline = Base_Import0[28],
    prerr_char = Base_Import0[29],
    prerr_string = Base_Import0[30],
    prerr_bytes = Base_Import0[31],
    prerr_int = Base_Import0[32],
    prerr_float = Base_Import0[33],
    prerr_endline = Base_Import0[34],
    prerr_newline = Base_Import0[35],
    read_line = Base_Import0[36],
    read_int_opt = Base_Import0[37],
    read_int = Base_Import0[38],
    read_float_opt = Base_Import0[39],
    read_float = Base_Import0[40],
    open_out = Base_Import0[41],
    open_out_bin = Base_Import0[42],
    open_out_gen = Base_Import0[43],
    flush = Base_Import0[44],
    flush_all = Base_Import0[45],
    output_char = Base_Import0[46],
    output_string = Base_Import0[47],
    output_bytes = Base_Import0[48],
    output = Base_Import0[49],
    output_substring = Base_Import0[50],
    output_byte = Base_Import0[51],
    output_binary_int = Base_Import0[52],
    output_value = Base_Import0[53],
    seek_out = Base_Import0[54],
    pos_out = Base_Import0[55],
    out_channel_length = Base_Import0[56],
    close_out = Base_Import0[57],
    close_out_noerr = Base_Import0[58],
    set_binary_mode_out = Base_Import0[59],
    open_in = Base_Import0[60],
    open_in_bin = Base_Import0[61],
    open_in_gen = Base_Import0[62],
    input_char = Base_Import0[63],
    input_line = Base_Import0[64],
    input = Base_Import0[65],
    really_input = Base_Import0[66],
    really_input_string = Base_Import0[67],
    input_byte = Base_Import0[68],
    input_binary_int = Base_Import0[69],
    input_value = Base_Import0[70],
    seek_in = Base_Import0[71],
    pos_in = Base_Import0[72],
    in_channel_length = Base_Import0[73],
    close_in = Base_Import0[74],
    close_in_noerr = Base_Import0[75],
    set_binary_mode_in = Base_Import0[76],
    string_of_format = Base_Import0[77],
    symbol = Base_Import0[78],
    exit = Base_Import0[79],
    at_exit = Base_Import0[80],
    valid_float_lexem = Base_Import0[81],
    unsafe_really_input = Base_Import0[82],
    do_at_exit = Base_Import0[83],
    Caml = Base_Import0[84],
    bool_to_int = Base_Import0[85],
    symbol$0 = Base_Import0[86],
    symbol$1 = Base_Import0[87],
    symbol$2 = Base_Import0[88],
    symbol$3 = Base_Import0[89],
    symbol$4 = Base_Import0[90],
    symbol$5 = Base_Import0[91],
    symbol$6 = Base_Import0[92],
    symbol$7 = Base_Import0[93],
    symbol$8 = Base_Import0[94],
    symbol$9 = Base_Import0[95],
    Int_replace_polymorphic_compar = Base_Import0[96],
    ascending = Base_Import0[97],
    descending = Base_Import0[98],
    max = Base_Import0[99],
    min = Base_Import0[100],
    Int32_replace_polymorphic_comp = Base_Import0[101],
    Int64_replace_polymorphic_comp = Base_Import0[102],
    Nativeint_replace_polymorphic_ = Base_Import0[103],
    Bool_replace_polymorphic_compa = Base_Import0[104],
    Char_replace_polymorphic_compa = Base_Import0[105],
    Uchar_replace_polymorphic_comp = Base_Import0[106],
    Float_replace_polymorphic_comp = Base_Import0[107],
    String_replace_polymorphic_com = Base_Import0[108],
    Bytes_replace_polymorphic_comp = Base_Import0[109],
    symbol$10 = Base_Import0[110],
    symbol$11 = Base_Import0[111],
    symbol$12 = Base_Import0[112],
    symbol$13 = Base_Import0[113],
    asr = Base_Import0[114],
    land = Base_Import0[115],
    lnot = Base_Import0[116],
    lor = Base_Import0[117],
    lsl = Base_Import0[118],
    lsr = Base_Import0[119],
    lxor = Base_Import0[120],
    mod = Base_Import0[121],
    abs = Base_Import0[122],
    failwith = Base_Import0[123],
    fst = Base_Import0[124],
    invalid_arg = Base_Import0[125],
    snd = Base_Import0[126],
    phys_equal = Base_Import0[127],
    decr = Base_Import0[128],
    incr = Base_Import0[129],
    float_of_string = Base_Import0[130],
    am_testing = Base_Import0[131],
    default_string_of_float = Sexplib0_Sexp_conv[1],
    write_old_option_format = Sexplib0_Sexp_conv[2],
    read_old_option_format = Sexplib0_Sexp_conv[3],
    list_map = Sexplib0_Sexp_conv[4],
    sexp_of_unit = Sexplib0_Sexp_conv[5],
    sexp_of_bool = Sexplib0_Sexp_conv[6],
    sexp_of_string = Sexplib0_Sexp_conv[7],
    sexp_of_bytes = Sexplib0_Sexp_conv[8],
    sexp_of_char = Sexplib0_Sexp_conv[9],
    sexp_of_int = Sexplib0_Sexp_conv[10],
    sexp_of_float = Sexplib0_Sexp_conv[11],
    sexp_of_int32 = Sexplib0_Sexp_conv[12],
    sexp_of_int64 = Sexplib0_Sexp_conv[13],
    sexp_of_nativeint = Sexplib0_Sexp_conv[14],
    sexp_of_ref = Sexplib0_Sexp_conv[15],
    sexp_of_lazy_t = Sexplib0_Sexp_conv[16],
    sexp_of_option = Sexplib0_Sexp_conv[17],
    sexp_of_pair = Sexplib0_Sexp_conv[18],
    sexp_of_triple = Sexplib0_Sexp_conv[19],
    sexp_of_list = Sexplib0_Sexp_conv[20],
    sexp_of_array = Sexplib0_Sexp_conv[21],
    sexp_of_hashtbl = Sexplib0_Sexp_conv[22],
    sexp_of_opaque = Sexplib0_Sexp_conv[23],
    sexp_of_fun = Sexplib0_Sexp_conv[24],
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    record_check_extra_fields = Sexplib0_Sexp_conv[26],
    of_sexp_error = Sexplib0_Sexp_conv[27],
    of_sexp_error_exn = Sexplib0_Sexp_conv[28],
    unit_of_sexp = Sexplib0_Sexp_conv[29],
    bool_of_sexp = Sexplib0_Sexp_conv[30],
    string_of_sexp = Sexplib0_Sexp_conv[31],
    bytes_of_sexp = Sexplib0_Sexp_conv[32],
    char_of_sexp = Sexplib0_Sexp_conv[33],
    int_of_sexp = Sexplib0_Sexp_conv[34],
    float_of_sexp = Sexplib0_Sexp_conv[35],
    int32_of_sexp = Sexplib0_Sexp_conv[36],
    int64_of_sexp = Sexplib0_Sexp_conv[37],
    nativeint_of_sexp = Sexplib0_Sexp_conv[38],
    ref_of_sexp = Sexplib0_Sexp_conv[39],
    lazy_t_of_sexp = Sexplib0_Sexp_conv[40],
    option_of_sexp = Sexplib0_Sexp_conv[41],
    pair_of_sexp = Sexplib0_Sexp_conv[42],
    triple_of_sexp = Sexplib0_Sexp_conv[43],
    list_of_sexp = Sexplib0_Sexp_conv[44],
    array_of_sexp = Sexplib0_Sexp_conv[45],
    hashtbl_of_sexp = Sexplib0_Sexp_conv[46],
    opaque_of_sexp = Sexplib0_Sexp_conv[47],
    fun_of_sexp = Sexplib0_Sexp_conv[48],
    unit_sexp_grammar = Sexplib0_Sexp_conv[49],
    bool_sexp_grammar = Sexplib0_Sexp_conv[50],
    string_sexp_grammar = Sexplib0_Sexp_conv[51],
    bytes_sexp_grammar = Sexplib0_Sexp_conv[52],
    char_sexp_grammar = Sexplib0_Sexp_conv[53],
    int_sexp_grammar = Sexplib0_Sexp_conv[54],
    float_sexp_grammar = Sexplib0_Sexp_conv[55],
    int32_sexp_grammar = Sexplib0_Sexp_conv[56],
    int64_sexp_grammar = Sexplib0_Sexp_conv[57],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv[58],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv[59],
    ref_sexp_grammar = Sexplib0_Sexp_conv[60],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv[61],
    option_sexp_grammar = Sexplib0_Sexp_conv[62],
    list_sexp_grammar = Sexplib0_Sexp_conv[63],
    array_sexp_grammar = Sexplib0_Sexp_conv[64],
    opaque_sexp_grammar = Sexplib0_Sexp_conv[65],
    fun_sexp_grammar = Sexplib0_Sexp_conv[66],
    sexp_of_exn = Sexplib0_Sexp_conv[67],
    printexc_prefer_sexp = Sexplib0_Sexp_conv[68],
    sexp_of_exn_opt = Sexplib0_Sexp_conv[69],
    Exn_converter = Sexplib0_Sexp_conv[70],
    _a_ = Base_Hash[13],
    hash_fold_nativeint = _a_[1],
    hash_fold_int64 = _a_[2],
    hash_fold_int32 = _a_[3],
    hash_fold_char = _a_[4],
    hash_fold_int = _a_[5],
    hash_fold_bool = _a_[6],
    hash_fold_string = _a_[7],
    hash_fold_float = _a_[8],
    hash_fold_unit = _a_[9],
    hash_fold_option = _a_[10],
    hash_fold_list = _a_[11],
    hash_fold_lazy_t = _a_[12],
    hash_fold_ref_frozen = _a_[13],
    hash_fold_array_frozen = _a_[14],
    hash_nativeint = _a_[15],
    hash_int64 = _a_[16],
    hash_int32 = _a_[17],
    hash_char = _a_[18],
    hash_int = _a_[19],
    hash_bool = _a_[20],
    hash_string = _a_[21],
    hash_float = _a_[22],
    hash_unit = _a_[23],
    include = Base_Ppx_compare_lib[6],
    compare_bool = include[1],
    compare_char = include[2],
    compare_float = include[3],
    compare_int = include[4],
    compare_int32 = include[5],
    compare_int64 = include[6],
    compare_nativeint = include[7],
    compare_string = include[8],
    compare_unit = include[9],
    compare_array = include[10],
    compare_list = include[11],
    compare_option = include[12],
    compare_ref = include[13],
    equal_bool = include[14],
    equal_char = include[15],
    equal_float = include[16],
    equal_int = include[17],
    equal_int32 = include[18],
    equal_int64 = include[19],
    equal_nativeint = include[20],
    equal_string = include[21],
    equal_unit = include[22],
    equal_array = include[23],
    equal_list = include[24],
    equal_option = include[25],
    equal_ref = include[26],
    Not_found_s = Base_Sexp[7],
    Base_Import =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Caml,
       bool_to_int,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       symbol$9,
       Int_replace_polymorphic_compar,
       ascending,
       descending,
       max,
       min,
       Int32_replace_polymorphic_comp,
       Int64_replace_polymorphic_comp,
       Nativeint_replace_polymorphic_,
       Bool_replace_polymorphic_compa,
       Char_replace_polymorphic_compa,
       Uchar_replace_polymorphic_comp,
       Float_replace_polymorphic_comp,
       String_replace_polymorphic_com,
       Bytes_replace_polymorphic_comp,
       symbol$10,
       symbol$11,
       symbol$12,
       symbol$13,
       asr,
       land,
       lnot,
       lor,
       lsl,
       lsr,
       lxor,
       mod,
       abs,
       failwith,
       fst,
       invalid_arg,
       snd,
       phys_equal,
       decr,
       incr,
       float_of_string,
       am_testing,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       Exn_converter,
       hash_fold_nativeint,
       hash_fold_int64,
       hash_fold_int32,
       hash_fold_char,
       hash_fold_int,
       hash_fold_bool,
       hash_fold_string,
       hash_fold_float,
       hash_fold_unit,
       hash_fold_option,
       hash_fold_list,
       hash_fold_lazy_t,
       hash_fold_ref_frozen,
       hash_fold_array_frozen,
       hash_nativeint,
       hash_int64,
       hash_int32,
       hash_char,
       hash_int,
       hash_bool,
       hash_string,
       hash_float,
       hash_unit,
       compare_bool,
       compare_char,
       compare_float,
       compare_int,
       compare_int32,
       compare_int64,
       compare_nativeint,
       compare_string,
       compare_unit,
       compare_array,
       compare_list,
       compare_option,
       compare_ref,
       equal_bool,
       equal_char,
       equal_float,
       equal_int,
       equal_int32,
       equal_int64,
       equal_nativeint,
       equal_string,
       equal_unit,
       equal_array,
       equal_list,
       equal_option,
       equal_ref,
       Not_found_s];
   runtime.caml_register_global(5, Base_Import, "Base__Import");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Word_size
//# unitInfo: Requires: Base__Import, Base__Sys0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    Base_Import = global_data.Base__Import,
    _a_ = [0, "W64"],
    _b_ = [0, "W32"],
    cst_unknown_word_size = "unknown word size";
   function sexp_of_t(param){return param ? _a_ : _b_;}
   function num_bits(param){return param ? 64 : 32;}
   var
    _c_ = Base_Sys0[7],
    word_size =
      32 === _c_
       ? 0
       : 64 === _c_ ? 1 : caml_call1(Base_Import[123], cst_unknown_word_size),
    Base_Word_size = [0, sexp_of_t, num_bits, word_size];
   runtime.caml_register_global(5, Base_Word_size, "Base__Word_size");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Formatter
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Formatter = [0];
   runtime.caml_register_global(0, Base_Formatter, "Base__Formatter");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pretty_printer
//# unitInfo: Requires: Base__Import, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Import = global_data.Base__Import,
    r = [0, [0, "Base.Sexp.pp_hum", 0]],
    cst_pp = ".pp";
   function all(param){return r[1];}
   function register(p){r[1] = [0, p, r[1]]; return 0;}
   function Register_pp(M){
    var pp = M[1], module_name = M[2];
    register(caml_call2(Base_Import[111], M[2], cst_pp));
    return [0, pp, module_name];
   }
   function _a_(_c_){return [0, Register_pp(_c_)[1]];}
   var
    Base_Pretty_printer =
      [0,
       all,
       function(M){
        var module_name = M[1];
        function pp(formatter, t){
         var _b_ = caml_call1(M[2], t);
         return caml_call2(Stdlib_Format[13], formatter, _b_);
        }
        return [0, Register_pp([0, pp, module_name])[1]];
       },
       _a_,
       register];
   runtime.caml_register_global
    (4, Base_Pretty_printer, "Base__Pretty_printer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Exn
//# unitInfo: Requires: Assert_failure, Base__Import, Base__Pretty_printer, Base__Printf, Base__Sexp, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_2 = "<2>",
    cst_src_exn_ml = "src/exn.ml",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Exn",
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Import = global_data.Base__Import,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Sexp = global_data.Base__Sexp,
    Base_Printf = global_data.Base__Printf,
    Assert_failure = global_data.Assert_failure,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    sexp_of_t = Base_Import[198],
    exit = Base_Import[84][98],
    Finally = [248, "Base__Exn.Finally", caml_fresh_oo_id(0)],
    _k_ =
      [0,
       [11, "Exn.handle_uncaught could not print; exiting anyway\n", [10, 0]],
       "Exn.handle_uncaught could not print; exiting anyway\n%!"],
    _j_ =
      [0,
       [18,
        [1, [0, [11, cst_2, 0], cst_2]],
        [11,
         "Uncaught exception:",
         [17,
          3,
          [17,
           3,
           [18, [1, [0, 0, ""]], [15, [17, 0, [17, 0, [17, 3, [17, 4, 0]]]]]]]]]],
       "@[<2>Uncaught exception:@\n@\n@[%a@]@]@\n@."],
    _i_ = [0, 2],
    _h_ = [0, cst_src_exn_ml, 54, 6],
    _e_ = [0, "exn.ml.Reraised"],
    _f_ = [0, cst_src_exn_ml, 33, 11],
    _b_ = [0, "exn.ml.Finally"],
    _c_ = [0, cst_src_exn_ml, 19, 11],
    cst_Base_Exn_Reraised = "Base__Exn.Reraised",
    cst_Base_Exn_Sexp = "Base__Exn.Sexp";
   function _a_(param){
    if(param[1] !== Finally)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var
     arg1_002 = param[3],
     arg0_001 = param[2],
     res0_003 = caml_call1(sexp_of_t, arg0_001),
     res1_004 = caml_call1(sexp_of_t, arg1_002);
    return [1, [0, _b_, [0, res0_003, [0, res1_004, 0]]]];
   }
   caml_call4(Sexplib0_Sexp_conv[70][1], 0, 0, Finally, _a_);
   var Reraised = [248, cst_Base_Exn_Reraised, caml_fresh_oo_id(0)];
   function _d_(param){
    if(param[1] !== Reraised)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    var
     arg1_006 = param[3],
     arg0_005 = param[2],
     res0_007 = caml_call1(Base_Import[138], arg0_005),
     res1_008 = caml_call1(sexp_of_t, arg1_006);
    return [1, [0, _e_, [0, res0_007, [0, res1_008, 0]]]];
   }
   caml_call4(Sexplib0_Sexp_conv[70][1], 0, 0, Reraised, _d_);
   var Sexp = [248, cst_Base_Exn_Sexp, caml_fresh_oo_id(0)];
   function _g_(param){
    if(param[1] !== Sexp)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var t = param[2];
    return t;
   }
   caml_call4(Sexplib0_Sexp_conv[70][1], 0, 0, Sexp, _g_);
   function create_s(sexp){return [0, Sexp, sexp];}
   function raise_with_original_backtrace(t, backtrace){
    runtime.caml_restore_raw_backtrace(t, backtrace);
    throw caml_maybe_attach_backtrace(t, 0);
   }
   function reraise(exn, str){
    var exn$0 = [0, Reraised, str, exn];
    if(! runtime.Base_caml_exn_is_most_recent_exn(exn))
     throw caml_maybe_attach_backtrace(exn$0, 1);
    var bt = caml_call1(Stdlib_Printexc[12], 0);
    return raise_with_original_backtrace(exn$0, bt);
   }
   function reraisef(exc, format){
    function _y_(str, param){return reraise(exc, str);}
    return caml_call2(Base_Printf[4], _y_, format);
   }
   function to_string(exc){
    var _x_ = caml_call1(Base_Import[198], exc);
    return caml_call2(Base_Sexp[15], _i_, _x_);
   }
   function to_string_mach(exc){
    var _w_ = caml_call1(Base_Import[198], exc);
    return caml_call1(Base_Sexp[16], _w_);
   }
   var sexp_of_t$0 = Base_Import[198];
   function protectx(f, x, finally$0){
    try{var res = caml_call1(f, x);}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     try{caml_call1(finally$0, x);}
     catch(final_exn$0){
      var final_exn = caml_wrap_exception(final_exn$0);
      return raise_with_original_backtrace([0, Finally, exn, final_exn], bt);
     }
     return raise_with_original_backtrace(exn, bt);
    }
    caml_call1(finally$0, x);
    return res;
   }
   function protect(f, finally$0){return protectx(f, 0, finally$0);}
   function does_raise(f){
    try{caml_call1(f, 0); var _u_ = 0; return _u_;}catch(_v_){return 1;}
   }
   function pp(ppf, t){
    var match = caml_call1(Base_Import[200], t);
    if(match){
     var sexp = match[1];
     return caml_call2(Base_Sexp[11], ppf, sexp);
    }
    var _t_ = caml_call1(Stdlib_Printexc[1], t);
    return caml_call2(Stdlib_Format[13], ppf, _t_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1];
   function print_with_backtrace(exc, raw_backtrace){
    caml_call3(Stdlib_Format[131], _j_, pp$0, exc);
    if(caml_call1(Stdlib_Printexc[8], 0))
     caml_call2(Stdlib_Printexc[13], Base_Import[84][39], raw_backtrace);
    return caml_call1(Base_Import[84][62], Base_Import[84][39]);
   }
   function handle_uncaught_aux(do_at_exit, exit, f){
    try{var _p_ = caml_call1(f, 0); return _p_;}
    catch(exc$0){
     var
      exc = caml_wrap_exception(exc$0),
      raw_backtrace = caml_call1(Stdlib_Printexc[12], 0);
     if(do_at_exit) try{caml_call1(Base_Import[84][102], 0);}catch(_s_){}
     try{print_with_backtrace(exc, raw_backtrace);}
     catch(_q_){try{caml_call1(Stdlib_Printf[3], _k_);}catch(_r_){}}
     return caml_call1(exit, 1);
    }
   }
   function handle_uncaught_and_exit(f){
    return handle_uncaught_aux(1, exit, f);
   }
   function handle_uncaught(must_exit, f){
    var exit$0 = must_exit ? exit : function(_o_){return 0;};
    return handle_uncaught_aux(must_exit, exit$0, f);
   }
   function reraise_uncaught(str, func){
    try{var _n_ = caml_call1(func, 0); return _n_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      bt = caml_call1(Stdlib_Printexc[12], 0);
     return raise_with_original_backtrace([0, Reraised, str, exn], bt);
    }
   }
   function raise_without_backtrace(e){
    runtime.Base_clear_caml_backtrace_pos(0);
    throw e;
   }
   function initialize_module(param){
    return caml_call1(Stdlib_Printexc[16], print_with_backtrace);
   }
   function clear_backtrace(_m_){
    return runtime.Base_clear_caml_backtrace_pos(_m_);
   }
   var
    Private = [0, clear_backtrace],
    Base_Exn =
      [0,
       sexp_of_t$0,
       pp$0,
       Finally,
       Reraised,
       create_s,
       raise_without_backtrace,
       raise_with_original_backtrace,
       reraise,
       reraisef,
       to_string,
       to_string_mach,
       protectx,
       protect,
       handle_uncaught,
       handle_uncaught_and_exit,
       reraise_uncaught,
       does_raise,
       function(_l_){return runtime.Base_caml_exn_is_most_recent_exn(_l_);},
       initialize_module,
       Private];
   runtime.caml_register_global(21, Base_Exn, "Base__Exn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__With_return
//# unitInfo: Requires: Base__Exn, Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Exn = global_data.Base__Exn,
    cst_use_of_return_from_a_with_ =
      "use of [return] from a [with_return] that already returned",
    cst_Return = "Return";
   function with_return(f){
    var
     Return = [248, cst_Return, runtime.caml_fresh_oo_id(0)],
     is_alive = [0, 1];
    function return$0(a){
     if(1 - is_alive[1])
      caml_call1(Base_Import[123], cst_use_of_return_from_a_with_);
     return caml_call1(Base_Exn[6], [0, Return, a]);
    }
    try{var a$0 = caml_call1(f, return$0); is_alive[1] = 0; return a$0;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     is_alive[1] = 0;
     if(exn[1] !== Return) throw caml_maybe_attach_backtrace(exn, 0);
     var a = exn[2];
     return a;
    }
   }
   function with_return_option(f){
    return with_return
            (function(return$0){
              caml_call1(f, function(a){return caml_call1(return$0, [0, a]);});
              return 0;
             });
   }
   function prepend(param, f){
    return function(x){return caml_call1(param, caml_call1(f, x));};
   }
   var Base_With_return = [0, with_return, with_return_option, prepend];
   runtime.caml_register_global(4, Base_With_return, "Base__With_return");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variant
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variant = [0];
   runtime.caml_register_global(0, Base_Variant, "Base__Variant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Variantslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Variantslib = [0];
   runtime.caml_register_global(0, Base_Variantslib, "Base__Variantslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function S_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S3(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_to_S_indexed(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Monad_infix = X[3],
     bind = X[4],
     return$0 = X[5],
     map = X[6],
     join = X[7],
     ignore_m = X[8],
     all = X[9],
     all_unit = X[10],
     Let_syntax = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S2_to_S(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit,
            Let_syntax];
   }
   function S3_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function S_indexed_to_S2(X){
    var
     symbol_bind = X[1],
     symbol_map = X[2],
     Let_syntax = X[3],
     Monad_infix = X[4],
     bind = X[5],
     return$0 = X[6],
     map = X[7],
     join = X[8],
     ignore_m = X[9],
     all = X[10],
     all_unit = X[11];
    return [0,
            symbol_bind,
            symbol_map,
            Let_syntax,
            Monad_infix,
            bind,
            return$0,
            map,
            join,
            ignore_m,
            all,
            all_unit];
   }
   var
    Base_Monad_intf =
      [0,
       S_to_S2,
       S2_to_S3,
       S_to_S_indexed,
       S2_to_S,
       S3_to_S2,
       S_indexed_to_S2];
   runtime.caml_register_global(0, Base_Monad_intf, "Base__Monad_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Monad
//# unitInfo: Requires: Base__List0, Base__Monad_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0;
   function Make_general(_s_){
    var bind = _s_[1], return$0 = _s_[3];
    function map_via_bind(ma, f){
     function _t_(a){
      var _u_ = caml_call1(f, a);
      return caml_call1(_s_[3], _u_);
     }
     return caml_call2(_s_[1], ma, _t_);
    }
    var match = _s_[2];
    if(typeof match === "number")
     var map = map_via_bind;
    else
     var x = match[2], map = x;
    function symbol_bind(t, f){return caml_call2(bind, t, f);}
    function symbol_map(t, f){return caml_call2(map, t, f);}
    var
     Monad_infix = [0, symbol_bind, symbol_map],
     symbol_bind$0 = Monad_infix[1],
     symbol_map$0 = Monad_infix[2],
     symbol_bind$1 = Monad_infix[1],
     symbol_map$1 = Monad_infix[2];
    function both(a, b){
     return caml_call2
             (symbol_bind$1,
              a,
              function(a){
               return caml_call2
                       (symbol_map$1, b, function(b){return [0, a, b];});
              });
    }
    var
     Open_on_rhs = [0],
     Let_syntax = [0, return$0, bind, map, both, Open_on_rhs],
     Let_syntax$0 = [0, return$0, symbol_bind$1, symbol_map$1, Let_syntax];
    function join(t){
     return caml_call2(symbol_bind$0, t, function(t){return t;});
    }
    function ignore_m(t){
     return caml_call2(map, t, function(param){return 0;});
    }
    function loop(vs, param){
     if(! param) return caml_call1(return$0, caml_call1(Base_List0[21], vs));
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(v){return loop([0, v, vs], ts);});
    }
    function all(ts){return loop(0, ts);}
    function all_unit(param){
     if(! param) return caml_call1(return$0, 0);
     var ts = param[2], t = param[1];
     return caml_call2
             (symbol_bind$0, t, function(param){return all_unit(ts);});
    }
    return [0,
            bind,
            return$0,
            map_via_bind,
            map,
            Monad_infix,
            symbol_bind$0,
            symbol_map$0,
            Let_syntax$0,
            join,
            ignore_m,
            all,
            all_unit];
   }
   function Make_indexed(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _r_ = Make_general([0, bind, map, return$0]);
    return [0,
            _r_[6],
            _r_[7],
            _r_[8],
            _r_[5],
            _r_[1],
            _r_[2],
            _r_[4],
            _r_[9],
            _r_[10],
            _r_[11],
            _r_[12]];
   }
   function Make3(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _q_ = Make_general([0, bind, map, return$0]);
    return [0,
            _q_[6],
            _q_[7],
            _q_[8],
            _q_[5],
            _q_[1],
            _q_[2],
            _q_[4],
            _q_[9],
            _q_[10],
            _q_[11],
            _q_[12]];
   }
   function Make2(M){
    var
     bind = M[1],
     map = M[2],
     return$0 = M[3],
     _p_ = Make_general([0, bind, map, return$0]);
    return [0,
            _p_[6],
            _p_[7],
            _p_[8],
            _p_[5],
            _p_[1],
            _p_[2],
            _p_[4],
            _p_[9],
            _p_[10],
            _p_[11],
            _p_[12]];
   }
   function Make(M){
    var
     bind = M[1],
     return$0 = M[2],
     map = M[3],
     _o_ = Make_general([0, bind, map, return$0]);
    return [0,
            _o_[6],
            _o_[7],
            _o_[5],
            _o_[1],
            _o_[2],
            _o_[4],
            _o_[9],
            _o_[10],
            _o_[11],
            _o_[12],
            _o_[8]];
   }
   function Of_monad_general(Monad, M){
    function return$0(a){
     var _n_ = caml_call1(Monad[3], a);
     return caml_call1(M[2], _n_);
    }
    function bind(t, f){
     function _j_(a){
      var _m_ = caml_call1(f, a);
      return caml_call1(M[1], _m_);
     }
     var _k_ = caml_call1(M[1], t), _l_ = caml_call2(Monad[1], _k_, _j_);
     return caml_call1(M[2], _l_);
    }
    var
     map =
       [0,
        -198771759,
        function(t, f){
         var _h_ = caml_call1(M[1], t), _i_ = caml_call2(Monad[2], _h_, f);
         return caml_call1(M[2], _i_);
        }];
    return Make_general([0, bind, map, return$0]);
   }
   function bind(a, f){return caml_call1(f, a);}
   function return$0(a){return a;}
   var
    map = [0, -198771759, function(a, f){return caml_call1(f, a);}],
    include = Make([0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11],
    Ident =
      [0,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax];
   function _a_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[5],
     return$0 = Monad[6],
     map = Monad[7],
     _g_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _g_[6],
            _g_[7],
            _g_[8],
            _g_[5],
            _g_[1],
            _g_[2],
            _g_[4],
            _g_[9],
            _g_[10],
            _g_[11],
            _g_[12]];
   }
   function _b_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[5],
     return$0 = Monad[6],
     map = Monad[7],
     _f_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _f_[6],
            _f_[7],
            _f_[8],
            _f_[5],
            _f_[1],
            _f_[2],
            _f_[4],
            _f_[9],
            _f_[10],
            _f_[11],
            _f_[12]];
   }
   function _c_(Monad, M){
    var
     to_monad = M[1],
     of_monad = M[2],
     bind = Monad[5],
     return$0 = Monad[6],
     map = Monad[7],
     _e_ = Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
    return [0,
            _e_[6],
            _e_[7],
            _e_[8],
            _e_[5],
            _e_[1],
            _e_[2],
            _e_[4],
            _e_[9],
            _e_[10],
            _e_[11],
            _e_[12]];
   }
   var
    Base_Monad =
      [0,
       Make,
       Make2,
       Make3,
       Make_indexed,
       function(Monad, M){
        var
         to_monad = M[1],
         of_monad = M[2],
         bind = Monad[4],
         return$0 = Monad[5],
         map = Monad[6],
         _d_ =
           Of_monad_general([0, bind, map, return$0], [0, to_monad, of_monad]);
        return [0,
                _d_[6],
                _d_[7],
                _d_[5],
                _d_[1],
                _d_[2],
                _d_[4],
                _d_[9],
                _d_[10],
                _d_[11],
                _d_[12],
                _d_[8]];
       },
       _c_,
       _b_,
       _a_,
       Ident];
   runtime.caml_register_global(1, Base_Monad, "Base__Monad");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Applicative_intf = [0];
   runtime.caml_register_global
    (0, Base_Applicative_intf, "Base__Applicative_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Applicative
//# unitInfo: Requires: Base__Applicative_intf, Base__Import, Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_List0 = global_data.Base__List0;
   function S_to_S2(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S2_to_S3(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function S3_to_S2(X){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     apply = X[8],
     map2 = X[9],
     map3 = X[10],
     all = X[11],
     all_unit = X[12],
     Applicative_infix = X[13];
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Make3(_M_){
    var return$0 = _M_[1], symbol = _M_[2];
    function derived_map(t, f){
     return caml_call2(symbol, caml_call1(return$0, f), t);
    }
    var match = _M_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function map2(ta, tb, f){
     return caml_call2(symbol, caml_call2(map, ta, f), tb);
    }
    function map3(ta, tb, tc, f){
     return caml_call2
             (symbol, caml_call2(symbol, caml_call2(map, ta, f), tb), tc);
    }
    function all(ts){
     var _O_ = caml_call1(return$0, 0);
     function _P_(x, xs){return [0, x, xs];}
     function _Q_(_R_){return function(_S_){return map2(_R_, _S_, _P_);};}
     return caml_call3(Base_List0[22], ts, _Q_, _O_);
    }
    function both(ta, tb){
     return map2(ta, tb, function(a, b){return [0, a, b];});
    }
    function symbol$0(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(param, y){return y;}),
                u),
              v);
    }
    function symbol$1(u, v){
     return caml_call2
             (symbol,
              caml_call2
               (symbol,
                caml_call1(return$0, function(x, param){return x;}),
                u),
              v);
    }
    function all_unit(ts){
     var _N_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _N_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make3([0, return$0, apply, map]);
   }
   function Make(X){
    var return$0 = X[1], apply = X[2], map = X[3];
    return Make2([0, return$0, apply, map]);
   }
   function Make_let_syntax3(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7],
     return$1 = X[1],
     map$0 = X[2],
     both$0 = X[3],
     symbol$2 = X[4],
     symbol$3 = X[5],
     symbol$4 = X[6],
     symbol_map$0 = X[7],
     Let_syntax =
       [0,
        return$1,
        map$0,
        both$0,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol_map$0,
        Impl],
     Let_syntax$0 =
       [0,
        return$0,
        map,
        both,
        symbol,
        symbol$0,
        symbol$1,
        symbol_map,
        Let_syntax];
    return [0, Let_syntax$0];
   }
   function Make_let_syntax2(X, Intf, Impl){
    var
     return$0 = X[1],
     map = X[2],
     both = X[3],
     symbol = X[4],
     symbol$0 = X[5],
     symbol$1 = X[6],
     symbol_map = X[7];
    return Make_let_syntax3
            ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
             Intf,
             Impl);
   }
   function Make3_using_map2(_D_){
    var return$0 = _D_[1], map2 = _D_[2];
    function symbol(tf, ta){
     return caml_call3(map2, tf, ta, function(f, a){return caml_call1(f, a);});
    }
    function derived_map(t, f){return symbol(caml_call1(return$0, f), t);}
    var match = _D_[3];
    if(typeof match === "number")
     var map = derived_map;
    else
     var x = match[2], map = x;
    function symbol_map(t, f){return caml_call2(map, t, f);}
    function both(ta, tb){
     return caml_call3(map2, ta, tb, function(a, b){return [0, a, b];});
    }
    function map3(ta, tb, tc, f){
     function _L_(fab, c){return caml_call1(fab, c);}
     return caml_call3(map2, caml_call3(map2, ta, tb, f), tc, _L_);
    }
    function all(ts){
     var _F_ = caml_call1(return$0, 0);
     function _G_(x, xs){return [0, x, xs];}
     function _H_(_I_){
      var _J_ = caml_call1(map2, _I_);
      return function(_K_){return caml_call2(_J_, _K_, _G_);};
     }
     return caml_call3(Base_List0[22], ts, _H_, _F_);
    }
    function symbol$0(u, v){
     return caml_call3(map2, u, v, function(param, y){return y;});
    }
    function symbol$1(u, v){
     return caml_call3(map2, u, v, function(x, param){return x;});
    }
    function all_unit(ts){
     var _E_ = caml_call1(return$0, 0);
     return caml_call3(Base_List0[8], ts, _E_, symbol$0);
    }
    return [0,
            return$0,
            map,
            both,
            symbol,
            symbol$1,
            symbol$0,
            symbol_map,
            symbol,
            map2,
            map3,
            all,
            all_unit,
            [0, symbol, symbol$1, symbol$0, symbol_map]];
   }
   function Make2_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make3_using_map2([0, return$0, map2, map]);
   }
   function Make_using_map2(X){
    var return$0 = X[1], map2 = X[2], map = X[3];
    return Make2_using_map2([0, return$0, map2, map]);
   }
   function Of_monad2(M){
    var return$0 = M[6];
    function apply(mf, mx){
     function _C_(f){return caml_call2(M[7], mx, f);}
     return caml_call2(M[5], mf, _C_);
    }
    var map = [0, -198771759, M[7]];
    return Make2([0, return$0, apply, map]);
   }
   function Of_monad(M){
    var
     symbol_bind = M[1],
     symbol_map = M[2],
     Monad_infix = M[3],
     bind = M[4],
     return$0 = M[5],
     map = M[6],
     join = M[7],
     ignore_m = M[8],
     all = M[9],
     all_unit = M[10],
     Let_syntax = M[11];
    return Of_monad2
            ([0,
              symbol_bind,
              symbol_map,
              Let_syntax,
              Monad_infix,
              bind,
              return$0,
              map,
              join,
              ignore_m,
              all,
              all_unit]);
   }
   function Compose(F, G){
    function return$0(a){
     var _B_ = caml_call1(F[1], a);
     return caml_call1(G[1], _B_);
    }
    function apply(tf, tx){
     var _A_ = caml_call2(G[2], tf, F[8]);
     return caml_call2(G[8], _A_, tx);
    }
    function custom_map(t, f){
     var _x_ = F[2];
     function _y_(_z_){return caml_call2(_x_, _z_, f);}
     return caml_call2(G[2], t, _y_);
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function Pair(F, G){
    function return$0(a){
     var _w_ = caml_call1(G[1], a);
     return [0, caml_call1(F[1], a), _w_];
    }
    function apply(tf, tx){
     var
      _r_ = caml_call1(Base_Import[126], tx),
      _s_ = caml_call1(Base_Import[126], tf),
      _t_ = caml_call2(G[8], _s_, _r_),
      _u_ = caml_call1(Base_Import[124], tx),
      _v_ = caml_call1(Base_Import[124], tf);
     return [0, caml_call2(F[8], _v_, _u_), _t_];
    }
    function custom_map(t, f){
     var
      _o_ = caml_call1(Base_Import[126], t),
      _p_ = caml_call2(G[2], _o_, f),
      _q_ = caml_call1(Base_Import[124], t);
     return [0, caml_call2(F[2], _q_, f), _p_];
    }
    var
     map = [0, -198771759, custom_map],
     include = Make([0, return$0, apply, map]),
     return$1 = include[1],
     map$0 = include[2],
     both = include[3],
     symbol = include[4],
     symbol$0 = include[5],
     symbol$1 = include[6],
     symbol_map = include[7],
     apply$0 = include[8],
     map2 = include[9],
     map3 = include[10],
     all = include[11],
     all_unit = include[12],
     Applicative_infix = include[13];
    return [0,
            return$1,
            map$0,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix];
   }
   function _a_(_l_, _k_, _j_){
    var _m_ = Make_let_syntax3(_l_, _k_, _j_)[1], _n_ = _m_[8];
    return [0,
            [0,
             _m_[1],
             _m_[4],
             _m_[5],
             _m_[6],
             _m_[7],
             [0, _n_[1], _n_[2], _n_[3], _n_[8]]]];
   }
   function _b_(_g_, _f_, _e_){
    var _h_ = Make_let_syntax2(_g_, _f_, _e_)[1], _i_ = _h_[8];
    return [0,
            [0,
             _h_[1],
             _h_[4],
             _h_[5],
             _h_[6],
             _h_[7],
             [0, _i_[1], _i_[2], _i_[3], _i_[8]]]];
   }
   var
    Base_Applicative =
      [0,
       S2_to_S,
       S_to_S2,
       S3_to_S2,
       S2_to_S3,
       Make,
       Make2,
       Make3,
       function(X, Intf, Impl){
        var
         return$0 = X[1],
         map = X[2],
         both = X[3],
         symbol = X[4],
         symbol$0 = X[5],
         symbol$1 = X[6],
         symbol_map = X[7],
         _c_ =
           Make_let_syntax2
             ([0, return$0, map, both, symbol, symbol$0, symbol$1, symbol_map],
              Intf,
              Impl)
            [1],
         _d_ = _c_[8];
        return [0,
                [0,
                 _c_[1],
                 _c_[4],
                 _c_[5],
                 _c_[6],
                 _c_[7],
                 [0, _d_[1], _d_[2], _d_[3], _d_[8]]]];
       },
       _b_,
       _a_,
       Make_using_map2,
       Make2_using_map2,
       Make3_using_map2,
       Of_monad,
       Of_monad2,
       Compose,
       Pair];
   runtime.caml_register_global(2, Base_Applicative, "Base__Applicative");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes0
//# unitInfo: Requires: Base__Sys0, Stdlib__BytesLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Base_Sys0 = global_data.Base__Sys0,
    Primitives = [0],
    max_length = Base_Sys0[10],
    blit = Stdlib_BytesLabels[11],
    blit_string = Stdlib_BytesLabels[12],
    compare = Stdlib_BytesLabels[44],
    copy = Stdlib_BytesLabels[4],
    create = runtime.caml_create_bytes,
    fill = Stdlib_BytesLabels[10],
    make = Stdlib_BytesLabels[1],
    map = Stdlib_BytesLabels[17],
    mapi = Stdlib_BytesLabels[18],
    sub = Stdlib_BytesLabels[7],
    unsafe_blit = runtime.caml_blit_bytes,
    to_string = Stdlib_BytesLabels[6],
    of_string = Stdlib_BytesLabels[5];
   function unsafe_to_string(s){return caml_call1(Stdlib_BytesLabels[48], s);}
   var
    unsafe_of_string_promise_no_mu = Stdlib_BytesLabels[49],
    Base_Bytes0 =
      [0,
       Primitives,
       max_length,
       blit,
       blit_string,
       compare,
       copy,
       create,
       fill,
       make,
       map,
       mapi,
       sub,
       unsafe_blit,
       to_string,
       of_string,
       unsafe_to_string,
       unsafe_of_string_promise_no_mu];
   runtime.caml_register_global(2, Base_Bytes0, "Base__Bytes0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparator
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var Module = [0], _a_ = [0, "_"];
   function make(compare, sexp_of_t){
    var comparator = [0, compare, sexp_of_t];
    return [0, comparator];
   }
   function S_to_S1(S){var comparator = S[1]; return [0, comparator];}
   function Make1(M){
    var comparator = [0, M[1], M[2]];
    return [0, comparator];
   }
   var compare = runtime.caml_compare;
   function sexp_of_t(param){return _a_;}
   var
    include = Make1([0, compare, sexp_of_t]),
    comparator = include[1],
    Poly = [0, comparator];
   function Derived(M){
    function comparator(a){
     var _d_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _d_];
    }
    return [0, comparator];
   }
   function Derived2(M){
    function comparator(a, b){
     var _c_ = caml_call2(M[2], a[2], b[2]);
     return [0, caml_call2(M[1], a[1], b[1]), _c_];
    }
    return [0, comparator];
   }
   function Derived_phantom(M){
    function comparator(a){
     var _b_ = caml_call1(M[2], a[2]);
     return [0, caml_call1(M[1], a[1]), _b_];
    }
    return [0, comparator];
   }
   var
    Base_Comparator =
      [0,
       make,
       Poly,
       Module,
       S_to_S1,
       function(M){var comparator = [0, M[1], M[2]]; return [0, comparator];},
       Make1,
       Derived,
       Derived2,
       Derived_phantom];
   runtime.caml_register_global(1, Base_Comparator, "Base__Comparator");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparisons
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparisons = [0];
   runtime.caml_register_global(0, Base_Comparisons, "Base__Comparisons");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either0
//# unitInfo: Requires: Base__Hash, Base__Ppx_compare_lib, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_First$0 = "First",
    cst_Second$0 = "Second",
    cst_first = "first",
    cst_second = "second",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_011 = "either0.ml.t",
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    cst_Second = cst_Second$0,
    cst_First = cst_First$0,
    _a_ = [0, cst_First$0],
    _b_ = [0, cst_Second$0];
   function compare(cmp_f, cmp_s, a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(0 === a_001[0]){
     var a_003 = a_001[1];
     if(0 !== b_002[0]) return -1;
     var b_004 = b_002[1];
     return caml_call2(cmp_f, a_003, b_004);
    }
    var a_005 = a_001[1];
    if(0 === b_002[0]) return 1;
    var b_006 = b_002[1];
    return caml_call2(cmp_s, a_005, b_006);
   }
   function hash_fold_t(hash_fold_f, hash_fold_s, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_f, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_s, hsv$1, a0$0);
   }
   function t_of_sexp(of_f_007, of_s_008, sexp_013){
    if(0 === sexp_013[0]){
     var _c_ = sexp_013[1], switch$0 = 0;
     if(caml_string_notequal(_c_, cst_First$0)){
      var switch$1 = 0;
      if(caml_string_notequal(_c_, cst_Second$0)){
       if(caml_string_notequal(_c_, cst_first))
        if(caml_string_notequal(_c_, cst_second))
         switch$0 = 1;
        else
         switch$1 = 1;
      }
      else
       switch$1 = 1;
      if(switch$1)
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_011, sexp_013);
     }
     if(! switch$0)
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_011, sexp_013);
    }
    else{
     var _d_ = sexp_013[1];
     if(! _d_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_011, sexp_013);
     var _e_ = _d_[1];
     if(0 !== _e_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_011, sexp_013);
     var tag_014 = _e_[1], switch$2 = 0;
     if(caml_string_notequal(tag_014, cst_First$0)){
      var switch$3 = 0;
      if(caml_string_notequal(tag_014, cst_Second$0)){
       if(caml_string_notequal(tag_014, cst_first))
        if(caml_string_notequal(tag_014, cst_second))
         switch$2 = 1;
        else
         switch$3 = 1;
      }
      else
       switch$3 = 1;
      if(switch$3){
       var sexp_args_020 = _d_[2];
       if(sexp_args_020 && ! sexp_args_020[2]){
        var
         arg0_021 = sexp_args_020[1],
         res0_022 = caml_call1(of_s_008, arg0_021);
        return [1, res0_022];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[4],
                error_source_011,
                tag_014,
                sexp_013);
      }
     }
     if(! switch$2){
      var sexp_args_015 = _d_[2];
      if(sexp_args_015 && ! sexp_args_015[2]){
       var
        arg0_016 = sexp_args_015[1],
        res0_017 = caml_call1(of_f_007, arg0_016);
       return [0, res0_017];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_011,
               tag_014,
               sexp_013);
     }
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_011, sexp_013);
   }
   function sexp_of_t(of_f_025, of_s_026, param){
    if(0 === param[0]){
     var arg0_027 = param[1], res0_028 = caml_call1(of_f_025, arg0_027);
     return [1, [0, _a_, [0, res0_028, 0]]];
    }
    var arg0_029 = param[1], res0_030 = caml_call1(of_s_026, arg0_029);
    return [1, [0, _b_, [0, res0_030, 0]]];
   }
   function t_sexp_grammar(f_sexp_grammar, s_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_First, [0, [0, f_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Second, [0, [0, s_sexp_grammar, 0]]]], 0]]]];
   }
   var
    Base_Either0 =
      [0, compare, hash_fold_t, t_of_sexp, sexp_of_t, t_sexp_grammar];
   runtime.caml_register_global(16, Base_Either0, "Base__Either0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Field
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function opaque_identity(_b_){return _b_;}
   var For_generated_code = [0, opaque_identity];
   function name(param){return param[2];}
   function get(param, r){return caml_call1(param[4], r);}
   function fset(param, r, v){return caml_call2(param[5], r, v);}
   function setter(param){return param[3];}
   function map(param, r, f){
    var _a_ = caml_call1(f, caml_call1(param[4], r));
    return caml_call2(param[5], r, _a_);
   }
   function updater(field){
    var match = field[3];
    if(! match) return 0;
    var setter = match[1];
    return [0,
            function(r, f){
             return caml_call2
                     (setter, r, caml_call1(f, caml_call1(field[4], r)));
            }];
   }
   var
    Base_Field =
      [0, For_generated_code, name, get, fset, setter, map, updater];
   runtime.caml_register_global(0, Base_Field, "Base__Field");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String0
//# unitInfo: Requires: Base__Bytes0, Base__Import0, Base__Sys0, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Import0 = global_data.Base__Import0,
    String = [0],
    max_length = Base_Sys0[10],
    symbol = Base_Import0[111],
    capitalize = Stdlib_StringLabels[27],
    compare = Stdlib_StringLabels[9];
   function copy(x){
    var _a_ = caml_call1(Base_Bytes0[15], x);
    return caml_call1(Base_Bytes0[16], _a_);
   }
   var
    escaped = Stdlib_StringLabels[24],
    lowercase = Stdlib_StringLabels[26],
    make = Stdlib_StringLabels[1],
    sub = Stdlib_StringLabels[15],
    uncapitalize = Stdlib_StringLabels[28],
    unsafe_blit = runtime.caml_blit_string,
    uppercase = Stdlib_StringLabels[25];
   function concat(opt, l){
    if(opt) var sth = opt[1], sep = sth; else var sep = cst$0;
    if(! l) return cst;
    if(l[2]) return caml_call2(Stdlib_StringLabels[6], sep, l);
    var x = l[1];
    return x;
   }
   function iter(t, f){return caml_call2(Stdlib_StringLabels[29], f, t);}
   var
    Base_String0 =
      [0,
       String,
       max_length,
       symbol,
       capitalize,
       compare,
       copy,
       escaped,
       lowercase,
       make,
       sub,
       uncapitalize,
       unsafe_blit,
       uppercase,
       concat,
       iter];
   runtime.caml_register_global(6, Base_String0, "Base__String0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position0
//# unitInfo: Requires: Base__Comparator, Base__Hash, Base__Import, Base__Int0, Base__Ppx_compare_lib, Base__String0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$1 = ":";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Import = global_data.Base__Import,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Comparator = global_data.Base__Comparator,
    _a_ = [0, "pos_cnum"],
    _b_ = [0, "pos_bol"],
    _c_ = [0, "pos_lnum"],
    _d_ = [0, "pos_fname"];
   function compare(a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    var n = caml_call2(Base_Import[232], a_001[1], b_002[1]);
    if(0 !== n) return n;
    var n$0 = caml_call2(Base_Import[228], a_001[2], b_002[2]);
    if(0 !== n$0) return n$0;
    var n$1 = caml_call2(Base_Import[228], a_001[3], b_002[3]);
    return 0 === n$1 ? caml_call2(Base_Import[228], a_001[4], b_002[4]) : n$1;
   }
   function hash_fold_t(hsv, arg){
    var
     hsv$0 = caml_call2(Base_Import[208], hsv, arg[1]),
     hsv$1 = caml_call2(Base_Import[206], hsv$0, arg[2]),
     hsv$2 = caml_call2(Base_Import[206], hsv$1, arg[3]);
    return caml_call2(Base_Import[206], hsv$2, arg[4]);
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function sexp_of_t(param){
    var
     pos_cnum_010 = param[4],
     pos_bol_008 = param[3],
     pos_lnum_006 = param[2],
     pos_fname_004 = param[1],
     arg_011 = caml_call1(Base_Import[141], pos_cnum_010),
     bnds_003 = [0, [1, [0, _a_, [0, arg_011, 0]]], 0],
     arg_009 = caml_call1(Base_Import[141], pos_bol_008),
     bnds_003$0 = [0, [1, [0, _b_, [0, arg_009, 0]]], bnds_003],
     arg_007 = caml_call1(Base_Import[141], pos_lnum_006),
     bnds_003$1 = [0, [1, [0, _c_, [0, arg_007, 0]]], bnds_003$0],
     arg_005 = caml_call1(Base_Import[138], pos_fname_004),
     bnds_003$2 = [0, [1, [0, _d_, [0, arg_005, 0]]], bnds_003$1];
    return [1, bnds_003$2];
   }
   var
    T = [0, compare, hash_fold_t, hash, sexp_of_t],
    compare$0 = T[1],
    hash_fold_t$0 = T[2],
    hash$0 = T[3],
    include = caml_call1(Base_Comparator[5], [0, T[1], T[4]]),
    comparator = include[1];
   function make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol){
    var
     _e_ = caml_call2(Base_Import[92], pos_cnum, pos_bol),
     _f_ = [0, cst, [0, caml_call1(Base_Int0[1], _e_), 0]],
     _g_ =
       [0,
        pos_fname,
        [0, cst$0, [0, caml_call1(Base_Int0[1], pos_lnum), _f_]]];
    return caml_call2(Base_String0[14], 0, _g_);
   }
   function to_string(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1];
    return make_location_string(pos_fname, pos_lnum, pos_cnum, pos_bol);
   }
   function sexp_of_t$0(t){return [0, to_string(t)];}
   var
    Base_Source_code_position0 =
      [0,
       T,
       compare$0,
       hash_fold_t$0,
       hash$0,
       comparator,
       make_location_string,
       to_string,
       sexp_of_t$0];
   runtime.caml_register_global
    (12, Base_Source_code_position0, "Base__Source_code_position0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Invariant_intf = [0];
   runtime.caml_register_global
    (0, Base_Invariant_intf, "Base__Invariant_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List1
//# unitInfo: Requires: Base__List0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List0 = global_data.Base__List0,
    hd_exn = Base_List0[1],
    length = Base_List0[2],
    rev_append = Base_List0[3],
    tl_exn = Base_List0[4],
    unzip = Base_List0[5],
    exists = Base_List0[6],
    exists2_ok = Base_List0[7],
    fold = Base_List0[8],
    fold2_ok = Base_List0[9],
    for_all = Base_List0[10],
    for_all2_ok = Base_List0[11],
    iter = Base_List0[12],
    iter2_ok = Base_List0[13],
    nontail_map = Base_List0[14],
    nontail_mapi = Base_List0[15],
    partition = Base_List0[16],
    rev_map = Base_List0[17],
    rev_map2_ok = Base_List0[18],
    sort = Base_List0[19],
    stable_sort = Base_List0[20],
    rev = Base_List0[21],
    fold_right = Base_List0[22];
   function is_empty(param){return param ? 0 : 1;}
   function partition_map(t, f){
    var t$0 = t, fst = 0, snd = 0;
    for(;;){
     if(! t$0){
      var _a_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _a_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x);
     if(0 === match[0]){
      var y = match[1], fst$0 = [0, y, fst], t$0 = t$1, fst = fst$0;
      continue;
     }
     var y$0 = match[1], snd$0 = [0, y$0, snd], t$0 = t$1, snd = snd$0;
    }
   }
   var
    Base_List1 =
      [0,
       hd_exn,
       length,
       rev_append,
       tl_exn,
       unzip,
       exists,
       exists2_ok,
       fold,
       fold2_ok,
       for_all,
       for_all2_ok,
       iter,
       iter2_ok,
       nontail_map,
       nontail_mapi,
       partition,
       rev_map,
       rev_map2_ok,
       sort,
       stable_sort,
       rev,
       fold_right,
       is_empty,
       partition_map];
   runtime.caml_register_global(1, Base_List1, "Base__List1");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Result
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Ppx_compare_lib, Base__Printf, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Error$0 = "Error",
    cst_Ok$0 = "Ok",
    cst_error = "error",
    cst_ok = "ok",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_005 = "result.ml.t",
    Base_List1 = global_data.Base__List1,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Monad = global_data.Base__Monad,
    _c_ = [0, 0],
    cst_Error = cst_Error$0,
    cst_Ok = cst_Ok$0,
    _a_ = [0, cst_Ok$0],
    _b_ = [0, cst_Error$0];
   function t_of_sexp(of_a_001, of_b_002, sexp_007){
    if(0 === sexp_007[0]){
     var _f_ = sexp_007[1], switch$0 = 0;
     if(caml_string_notequal(_f_, cst_Error$0)){
      var switch$1 = 0;
      if(caml_string_notequal(_f_, cst_Ok$0)){
       if(caml_string_notequal(_f_, cst_error))
        if(caml_string_notequal(_f_, cst_ok)) switch$0 = 1; else switch$1 = 1;
      }
      else
       switch$1 = 1;
      if(switch$1)
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_005, sexp_007);
     }
     if(! switch$0)
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_005, sexp_007);
    }
    else{
     var _g_ = sexp_007[1];
     if(! _g_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_007);
     var _h_ = _g_[1];
     if(0 !== _h_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_005, sexp_007);
     var tag_008 = _h_[1], switch$2 = 0;
     if(caml_string_notequal(tag_008, cst_Error$0)){
      var switch$3 = 0;
      if(caml_string_notequal(tag_008, cst_Ok$0)){
       if(caml_string_notequal(tag_008, cst_error))
        if(caml_string_notequal(tag_008, cst_ok))
         switch$2 = 1;
        else
         switch$3 = 1;
      }
      else
       switch$3 = 1;
      if(switch$3){
       var sexp_args_009 = _g_[2];
       if(sexp_args_009 && ! sexp_args_009[2]){
        var
         arg0_010 = sexp_args_009[1],
         res0_011 = caml_call1(of_a_001, arg0_010);
        return [0, res0_011];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[4],
                error_source_005,
                tag_008,
                sexp_007);
      }
     }
     if(! switch$2){
      var sexp_args_014 = _g_[2];
      if(sexp_args_014 && ! sexp_args_014[2]){
       var
        arg0_015 = sexp_args_014[1],
        res0_016 = caml_call1(of_b_002, arg0_015);
       return [1, res0_016];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_005,
               tag_008,
               sexp_007);
     }
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_005, sexp_007);
   }
   function sexp_of_t(of_a_019, of_b_020, param){
    if(0 === param[0]){
     var arg0_021 = param[1], res0_022 = caml_call1(of_a_019, arg0_021);
     return [1, [0, _a_, [0, res0_022, 0]]];
    }
    var arg0_023 = param[1], res0_024 = caml_call1(of_b_020, arg0_023);
    return [1, [0, _b_, [0, res0_024, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Ok, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Error, [0, [0, b_sexp_grammar, 0]]]], 0]]]];
   }
   function compare(cmp_a, cmp_b, a_027, b_028){
    if(caml_call2(Base_Ppx_compare_lib[1], a_027, b_028)) return 0;
    if(0 === a_027[0]){
     var a_029 = a_027[1];
     if(0 !== b_028[0]) return -1;
     var b_030 = b_028[1];
     return caml_call2(cmp_a, a_029, b_030);
    }
    var a_031 = a_027[1];
    if(0 === b_028[0]) return 1;
    var b_032 = b_028[1];
    return caml_call2(cmp_b, a_031, b_032);
   }
   function equal(cmp_a, cmp_b, a_033, b_034){
    if(caml_call2(Base_Ppx_compare_lib[1], a_033, b_034)) return 1;
    if(0 === a_033[0]){
     var a_035 = a_033[1];
     if(0 !== b_034[0]) return 0;
     var b_036 = b_034[1];
     return caml_call2(cmp_a, a_035, b_036);
    }
    var a_037 = a_033[1];
    if(0 === b_034[0]) return 0;
    var b_038 = b_034[1];
    return caml_call2(cmp_b, a_037, b_038);
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    if(0 === arg[0]){
     var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
     return caml_call2(hash_fold_a, hsv$0, a0);
    }
    var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
    return caml_call2(hash_fold_b, hsv$1, a0$0);
   }
   function bind(x, f){
    if(0 !== x[0]) return x;
    var x$0 = x[1];
    return caml_call1(f, x$0);
   }
   var
    map =
      [0,
       -198771759,
       function(x, f){
        if(0 !== x[0]) return x;
        var x$0 = x[1];
        return [0, caml_call1(f, x$0)];
       }];
   function return$0(x){return [0, x];}
   var
    include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Let_syntax = include[3],
    Monad_infix = include[4],
    bind$0 = include[5],
    return$1 = include[6],
    map$0 = include[7],
    join = include[8],
    ignore_m = include[9],
    all = include[10],
    all_unit = include[11];
   function invariant(check_ok, check_error, t){
    if(0 === t[0]){var ok = t[1]; return caml_call1(check_ok, ok);}
    var error = t[1];
    return caml_call1(check_error, error);
   }
   function fail(x){return [1, x];}
   function failf(format){return caml_call2(Base_Printf[4], fail, format);}
   function map_error(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return [1, caml_call1(f, x)];
   }
   function bind$1(x, f){
    if(0 === x[0]) return x;
    var e = x[1];
    return caml_call1(f, e);
   }
   var map$1 = [0, -198771759, map_error];
   function return$2(e){return [1, e];}
   var Error = caml_call1(Base_Monad[2], [0, bind$1, map$1, return$2]);
   function is_ok(param){return 0 === param[0] ? 1 : 0;}
   function is_error(param){return 0 === param[0] ? 0 : 1;}
   function ok(param){
    if(0 !== param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function error(param){
    if(0 === param[0]) return 0;
    var x = param[1];
    return [0, x];
   }
   function of_option(opt, error){
    if(! opt) return [1, error];
    var x = opt[1];
    return [0, x];
   }
   function iter(v, f){
    if(0 !== v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function iter_error(v, f){
    if(0 === v[0]) return 0;
    var x = v[1];
    return caml_call1(f, x);
   }
   function to_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function of_either(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var x$0 = param[1];
    return [1, x$0];
   }
   function ok_if_true(bool, error){return bool ? _c_ : [1, error];}
   function try_with(f){
    try{var _e_ = [0, caml_call1(f, 0)]; return _e_;}
    catch(exn$0){var exn = caml_wrap_exception(exn$0); return [1, exn];}
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var exn = param[1];
    throw caml_maybe_attach_backtrace(exn, 1);
   }
   function ok_or_failwith(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var str = param[1];
    return caml_call1(Base_Import[123], str);
   }
   function combine(t1, t2, ok, err){
    if(0 === t1[0]){
     var ok1 = t1[1];
     if(0 === t2[0]){var ok2 = t2[1]; return [0, caml_call2(ok, ok1, ok2)];}
     var e = t2[1];
    }
    else{
     var err1 = t1[1];
     if(0 !== t2[0]){
      var err2 = t2[1];
      return [1, caml_call2(err, err1, err2)];
     }
     var e = err1;
    }
    return [1, e];
   }
   function combine_errors(l){
    var
     match = caml_call2(Base_List1[24], l, to_either),
     errs = match[2],
     ok = match[1];
    return errs ? [1, errs] : [0, ok];
   }
   function combine_errors_unit(l){
    function _d_(param){return 0;}
    return caml_call2(map$0, combine_errors(l), _d_);
   }
   var
    Base_Result =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       equal,
       hash_fold_t,
       symbol_bind,
       symbol_map,
       Let_syntax,
       Monad_infix,
       bind$0,
       return$1,
       join,
       ignore_m,
       all,
       all_unit,
       Error,
       invariant,
       fail,
       failf,
       is_ok,
       is_error,
       ok,
       ok_exn,
       ok_or_failwith,
       error,
       of_option,
       iter,
       iter_error,
       map$0,
       map_error,
       combine,
       combine_errors,
       combine_errors_unit,
       to_either,
       of_either,
       to_either,
       ok_if_true,
       try_with,
       [0, is_ok, is_error]];
   runtime.caml_register_global(21, Base_Result, "Base__Result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Continue_or_stop = [0],
    Export = [0, Continue_or_stop],
    Continue_or_stop$0 = Export[1],
    Base_Container_intf = [0, Export, Continue_or_stop$0];
   runtime.caml_register_global
    (0, Base_Container_intf, "Base__Container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Container
//# unitInfo: Requires: Base__Array0, Base__Container_intf, Base__Import, Base__List0, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array0 = global_data.Base__Array0,
    Base_Import = global_data.Base__Import,
    Base_List0 = global_data.Base__List0,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iter(fold, t, f){
    return caml_call3
            (fold, t, 0, function(param, a){return caml_call1(f, a);});
   }
   function count(fold, t, f){
    return caml_call3
            (fold,
             t,
             0,
             function(n, a){
              return caml_call1(f, a) ? caml_call2(Base_Import[90], n, 1) : n;
             });
   }
   function sum(fold, M){
    return function(t, f){
     function _h_(n, a){
      var _i_ = caml_call1(f, a);
      return caml_call2(M[2], n, _i_);
     }
     return caml_call3(fold, t, M[1], _h_);};
   }
   function fold_result(fold, init, f, t){
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      caml_call3
                       (fold,
                        t,
                        init,
                        function(acc, item){
                         var e = caml_call2(f, acc, item);
                         if(0 !== e[0]) return caml_call1(param, e);
                         var x = e[1];
                         return x;
                        })];
             });
   }
   function fold_until(fold, init, f, finish, t){
    return caml_call1
            (with_return,
             function(param){
              return caml_call1
                      (finish,
                       caml_call3
                        (fold,
                         t,
                         init,
                         function(acc, item){
                          var match = caml_call2(f, acc, item);
                          if(0 === match[0]){var x = match[1]; return x;}
                          var x$0 = match[1];
                          return caml_call1(param, x$0);
                         }));
             });
   }
   function min_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var min = acc[1];
              return 0 < caml_call2(compare, min, elt) ? [0, elt] : acc;
             });
   }
   function max_elt(fold, t, compare){
    return caml_call3
            (fold,
             t,
             0,
             function(acc, elt){
              if(! acc) return [0, elt];
              var max = acc[1];
              return 0 <= caml_call2(compare, max, elt) ? acc : [0, elt];
             });
   }
   function length(fold, c){
    return caml_call3
            (fold,
             c,
             0,
             function(acc, param){return caml_call2(Base_Import[90], acc, 1);});
   }
   function is_empty(iter, c){
    return caml_call1
            (with_return,
             function(r){
              caml_call2(iter, c, function(param){return caml_call1(r, 0);});
              return 1;
             });
   }
   function exists(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _g_ = caml_call1(f, x);
                 return _g_ ? caml_call1(r, 1) : _g_;
                });
              return 0;
             });
   }
   function for_all(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _f_ = 1 - caml_call1(f, x);
                 return _f_ ? caml_call1(r, 0) : _f_;
                });
              return 1;
             });
   }
   function find_map(iter, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                t,
                function(x){
                 var res = caml_call1(f, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function find(iter, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iter,
                c,
                function(x){
                 var _e_ = caml_call1(f, x);
                 return _e_ ? caml_call1(r, [0, x]) : _e_;
                });
              return 0;
             });
   }
   function to_list(fold, c){
    var _d_ = caml_call3(fold, c, 0, function(acc, x){return [0, x, acc];});
    return caml_call1(Base_List0[21], _d_);
   }
   function to_array(length, iter, c){
    var array = [0, [0]], i = [0, 0];
    caml_call2
     (iter,
      c,
      function(x){
       if(0 === i[1]){
        var _b_ = caml_call1(length, c);
        array[1] = caml_call2(Base_Array0[4], _b_, x);
       }
       var _c_ = i[1];
       runtime.caml_check_bound(array[1], _c_)[1 + _c_] = x;
       return caml_call1(Base_Import[129], i);
      });
    return array[1];
   }
   function Make_gen(T){
    var fold = T[1], match = T[2];
    if(typeof match === "number")
     var iter$0 = function(t, f){return iter(fold, t, f);};
    else
     var iter$1 = match[2], iter$0 = iter$1;
    var match$0 = T[3];
    if(typeof match$0 === "number")
     var length$0 = function(t){return length(fold, t);};
    else
     var length$1 = match$0[2], length$0 = length$1;
    function is_empty$0(t){return is_empty(iter$0, t);}
    function sum$0(m, t){return caml_call1(sum(fold, m), t);}
    function count$0(t, f){return count(fold, t, f);}
    function exists$0(t, f){return exists(iter$0, t, f);}
    function for_all$0(t, f){return for_all(iter$0, t, f);}
    function find_map$0(t, f){return find_map(iter$0, t, f);}
    function find$0(t, f){return find(iter$0, t, f);}
    function to_list$0(t){return to_list(fold, t);}
    function to_array$0(t){return to_array(length$0, iter$0, t);}
    function min_elt$0(t, compare){return min_elt(fold, t, compare);}
    function max_elt$0(t, compare){return max_elt(fold, t, compare);}
    function fold_result$0(t, init, f){return fold_result(fold, init, f, t);}
    function fold_until$0(t, init, f, finish){
     return fold_until(fold, init, f, finish, t);
    }
    return [0,
            length$0,
            is_empty$0,
            iter$0,
            fold,
            fold_result$0,
            fold_until$0,
            exists$0,
            for_all$0,
            count$0,
            sum$0,
            find$0,
            find_map$0,
            to_list$0,
            to_array$0,
            min_elt$0,
            max_elt$0];
   }
   function _a_(T){
    var
     fold = T[2],
     iter = T[3],
     length = T[4],
     include = Make_gen([0, fold, iter, length]),
     length$0 = include[1],
     is_empty = include[2],
     iter$0 = include[3],
     fold$0 = include[4],
     fold_result = include[5],
     fold_until = include[6],
     exists = include[7],
     for_all = include[8],
     count = include[9],
     sum = include[10],
     find = include[11],
     find_map = include[12],
     to_list = include[13],
     to_array = include[14],
     min_elt = include[15],
     max_elt = include[16];
    function mem(t, elt){
     return caml_call2(exists, t, caml_call1(T[1][1], elt));
    }
    return [0,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt];
   }
   var
    Base_Container =
      [0,
       iter,
       count,
       min_elt,
       max_elt,
       length,
       to_list,
       sum,
       fold_result,
       fold_until,
       is_empty,
       exists,
       for_all,
       find,
       find_map,
       to_array,
       function(T){
        var
         fold = T[1],
         iter = T[2],
         length = T[3],
         include = Make_gen([0, fold, iter, length]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[3],
         fold$0 = include[4],
         fold_result = include[5],
         fold_until = include[6],
         exists = include[7],
         for_all = include[8],
         count = include[9],
         sum = include[10],
         find = include[11],
         find_map = include[12],
         to_list = include[13],
         to_array = include[14],
         min_elt = include[15],
         max_elt = include[16];
        function mem(t, a, equal){
         return caml_call2(exists, t, caml_call1(equal, a));
        }
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt];
       },
       _a_,
       Make_gen];
   runtime.caml_register_global(4, Base_Container, "Base__Container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Lazy
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Monad, CamlinternalLazy, Stdlib__Lazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Import = global_data.Base__Import,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Base_Hash = global_data.Base__Hash,
    Base_Monad = global_data.Base__Monad,
    Undefined = Stdlib_Lazy[1],
    is_val = Stdlib_Lazy[3],
    from_val = Stdlib_Lazy[4],
    from_fun = Stdlib_Lazy[6],
    force_val = Stdlib_Lazy[7],
    t_of_sexp = Base_Import[171],
    sexp_of_t = Base_Import[147],
    cst_unforced_lazy = "<unforced lazy>";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[192], a_sexp_grammar);
   }
   function _a_(t, f){
    return [246,
            function(_q_){
             var
              _r_ = caml_obj_tag(t),
              _s_ =
                250 === _r_
                 ? t[1]
                 : 246 === _r_ ? caml_call1(CamlinternalLazy[2], t) : t;
             return caml_call1(f, _s_);
            }];
   }
   function compare(compare_a, t1, t2){
    if(caml_call2(Base_Import[127], t1, t2)) return 0;
    var
     _m_ = caml_obj_tag(t2),
     _n_ =
       250 === _m_
        ? t2[1]
        : 246 === _m_ ? caml_call1(CamlinternalLazy[2], t2) : t2,
     _o_ = caml_obj_tag(t1),
     _p_ =
       250 === _o_
        ? t1[1]
        : 246 === _o_ ? caml_call1(CamlinternalLazy[2], t1) : t1;
    return caml_call2(compare_a, _p_, _n_);
   }
   function equal(equal_a, t1, t2){
    if(caml_call2(Base_Import[127], t1, t2)) return 1;
    var
     _i_ = caml_obj_tag(t2),
     _j_ =
       250 === _i_
        ? t2[1]
        : 246 === _i_ ? caml_call1(CamlinternalLazy[2], t2) : t2,
     _k_ = caml_obj_tag(t1),
     _l_ =
       250 === _k_
        ? t1[1]
        : 246 === _k_ ? caml_call1(CamlinternalLazy[2], t1) : t1;
    return caml_call2(equal_a, _l_, _j_);
   }
   var hash_fold_t = Base_Hash[13][12];
   function return$0(x){return caml_call1(from_val, x);}
   function bind(t, f){
    return [246,
            function(_d_){
             var
              _e_ = caml_obj_tag(t),
              _f_ =
                250 === _e_
                 ? t[1]
                 : 246 === _e_ ? caml_call1(CamlinternalLazy[2], t) : t,
              _g_ = caml_call1(f, _f_),
              _h_ = caml_obj_tag(_g_);
             return 250 === _h_
                     ? _g_[1]
                     : 246 === _h_ ? caml_call1(CamlinternalLazy[2], _g_) : _g_;
            }];
   }
   var
    map = [0, -198771759, _a_],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function sexp_of_t$0(sexp_of_a, t){
    if(! caml_call1(is_val, t))
     return caml_call1(Base_Import[138], cst_unforced_lazy);
    var
     _b_ = caml_obj_tag(t),
     _c_ =
       250 === _b_
        ? t[1]
        : 246 === _b_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call1(sexp_of_a, _c_);
   }
   var
    T_unforcing = [0, sexp_of_t$0],
    Base_Lazy =
      [0,
       compare,
       equal,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       Undefined,
       force_val,
       from_fun,
       from_val,
       is_val,
       T_unforcing];
   runtime.caml_register_global(6, Base_Lazy, "Base__Lazy");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Info_intf = [0];
   runtime.caml_register_global(0, Base_Info_intf, "Base__Info_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common0
//# unitInfo: Requires: Base__Import, Base__Printf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    invalid_argf = Base_Printf[7],
    _a_ =
      [0,
       [11, "Negative position: ", [4, 0, 0, 0, 0]],
       "Negative position: %d"],
    _b_ =
      [0, [11, "Negative length: ", [4, 0, 0, 0, 0]], "Negative length: %d"],
    _c_ =
      [0,
       [11,
        "pos + len past end: ",
        [4, 0, 0, 0, [11, " + ", [4, 0, 0, 0, [11, " > ", [4, 0, 0, 0, 0]]]]]],
       "pos + len past end: %d + %d > %d"];
   function slow_check_pos_len_exn(pos, len, total_length){
    if(pos < 0) caml_call3(invalid_argf, _a_, pos, 0);
    if(len < 0) caml_call3(invalid_argf, _b_, len, 0);
    var _h_ = caml_call2(Base_Import[92], total_length, len) < pos ? 1 : 0;
    return _h_
            ? caml_call5(invalid_argf, _c_, pos, len, total_length, 0)
            : _h_;
   }
   function check_pos_len_exn(pos, len, total_length){
    var
     stop = caml_call2(Base_Import[90], pos, len),
     _d_ = caml_call2(Base_Import[92], total_length, stop),
     _e_ = caml_call2(Base_Import[117], pos, len),
     _f_ = caml_call2(Base_Import[117], _e_, stop),
     _g_ = caml_call2(Base_Import[117], _f_, _d_) < 0 ? 1 : 0;
    return _g_ ? slow_check_pos_len_exn(pos, len, total_length) : _g_;
   }
   function get_pos_len_exn(opt, len, param, total_length){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(len)
     var i = len[1], len$0 = i;
    else
     var len$0 = caml_call2(Base_Import[92], total_length, pos);
    check_pos_len_exn(pos, len$0, total_length);
    return [0, pos, len$0];
   }
   var
    Private = [0, slow_check_pos_len_exn],
    Base_Ordered_collection_common =
      [0, get_pos_len_exn, check_pos_len_exn, Private];
   runtime.caml_register_global
    (5, Base_Ordered_collection_common, "Base__Ordered_collection_common0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random_repr
//# unitInfo: Requires: Base__Array0, CamlinternalLazy
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Array0 = global_data.Base__Array0;
   function of_state(_e_){return _e_;}
   var Repr = [0, of_state];
   function assign(t1, t2){
    var
     _a_ = caml_obj_tag(t1),
     _b_ =
       250 === _a_
        ? t1[1]
        : 246 === _a_ ? caml_call1(CamlinternalLazy[2], t1) : t1,
     t1$0 = caml_call1(Repr[1], _b_),
     _c_ = caml_obj_tag(t2),
     _d_ =
       250 === _c_
        ? t2[1]
        : 246 === _c_ ? caml_call1(CamlinternalLazy[2], t2) : t2,
     t2$0 = caml_call1(Repr[1], _d_);
    caml_call5(Base_Array0[7], t2$0[1], 0, t1$0[1], 0, t1$0[1].length - 1);
    t1$0[2] = t2$0[2];
    return 0;
   }
   function make_default(default$0){return default$0;}
   function get_state(state){return state;}
   var Base_Random_repr = [0, Repr, assign, make_default, get_state];
   runtime.caml_register_global(2, Base_Random_repr, "Base__Random_repr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Random
//# unitInfo: Requires: Base__Char0, Base__Import, Base__Int0, Base__Lazy, Base__Printf, Base__Random_repr, Base__Word_size, CamlinternalLazy, Stdlib__Int32, Stdlib__Int64, Stdlib__Nativeint, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_left = runtime.caml_int64_shift_left,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_int64_xor = runtime.caml_int64_xor,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Random_repr = global_data.Base__Random_repr,
    Base_Import = global_data.Base__Import,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Int0 = global_data.Base__Int0,
    Base_Printf = global_data.Base__Printf,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Base_Lazy = global_data.Base__Lazy,
    Base_Char0 = global_data.Base__Char0,
    Base_Word_size = global_data.Base__Word_size,
    cst_float = "float",
    cst_int64 = "int64",
    _b_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_nativeint = "nativeint",
    cst_int32 = "int32",
    cst_int = "int",
    _a_ =
      [0,
       [11,
        "Random.",
        [2,
         0,
         [11, ": crossed bounds [", [2, 0, [11, " > ", [2, 0, [12, 93, 0]]]]]]],
       "Random.%s: crossed bounds [%s > %s]"],
    cst_initializing_Random_with_a =
      "initializing Random with a nondeterministic seed is forbidden in inline tests";
   function forbid_nondeterminism_in_tests(allow_in_tests){
    var _M_ = Base_Import[131];
    if(! _M_) return _M_;
    if(allow_in_tests && allow_in_tests[1]) return 0;
    return caml_call1(Base_Import[123], cst_initializing_Random_with_a);
   }
   function bits(t){
    var
     _K_ = caml_obj_tag(t),
     _L_ =
       250 === _K_
        ? t[1]
        : 246 === _K_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call1(Stdlib_Random[12][4], _L_);
   }
   function bool(t){
    var
     _I_ = caml_obj_tag(t),
     _J_ =
       250 === _I_
        ? t[1]
        : 246 === _I_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call1(Stdlib_Random[12][11], _J_);
   }
   function int$0(t, x){
    var
     _G_ = caml_obj_tag(t),
     _H_ =
       250 === _G_
        ? t[1]
        : 246 === _G_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call2(Stdlib_Random[12][5], _H_, x);
   }
   function int32(t, x){
    var
     _E_ = caml_obj_tag(t),
     _F_ =
       250 === _E_
        ? t[1]
        : 246 === _E_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call2(Stdlib_Random[12][7], _F_, x);
   }
   function int64(t, x){
    var
     _C_ = caml_obj_tag(t),
     _D_ =
       250 === _C_
        ? t[1]
        : 246 === _C_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call2(Stdlib_Random[12][9], _D_, x);
   }
   function nativeint(t, x){
    var
     _A_ = caml_obj_tag(t),
     _B_ =
       250 === _A_
        ? t[1]
        : 246 === _A_ ? caml_call1(CamlinternalLazy[2], t) : t;
    return caml_call2(Stdlib_Random[12][8], _B_, x);
   }
   function make(seed){
    var _z_ = caml_call1(Stdlib_Random[12][1], seed);
    return caml_call1(Base_Lazy[21], _z_);
   }
   function copy(t){
    var
     _w_ = caml_obj_tag(t),
     _x_ =
       250 === _w_
        ? t[1]
        : 246 === _w_ ? caml_call1(CamlinternalLazy[2], t) : t,
     _y_ = caml_call1(Stdlib_Random[12][3], _x_);
    return caml_call1(Base_Lazy[21], _y_);
   }
   function char$0(t){
    var _v_ = int$0(t, 256);
    return caml_call1(Base_Char0[5], _v_);
   }
   function ascii(t){
    var _u_ = int$0(t, 128);
    return caml_call1(Base_Char0[5], _u_);
   }
   function make_self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    var _t_ = caml_call1(Stdlib_Random[12][2], 0);
    return caml_call1(Base_Lazy[21], _t_);
   }
   var assign = Base_Random_repr[2];
   if(Base_Import[131]){
    var t = caml_call1(Stdlib_Random[13], 0);
    caml_call1(Stdlib_Random[1], 137);
    var default$0 = caml_call1(Base_Lazy[21], t);
   }
   else
    var
     default$0 =
       [246,
        function(param){
         var _r_ = make_self_init(0, 0), _s_ = caml_obj_tag(_r_);
         return 250 === _s_
                 ? _r_[1]
                 : 246 === _s_ ? caml_call1(CamlinternalLazy[2], _r_) : _r_;
        }];
   function int_on_64bits(t, bound){
    return 1073741823 < bound
            ? caml_int64_to_int32(int64(t, caml_int64_of_int32(bound)))
            : int$0(t, bound);
   }
   function int_on_32bits(t, bound){
    return 1073741823 < bound ? int32(t, bound) : int$0(t, bound);
   }
   var int$1 = Base_Word_size[3] ? int_on_64bits : int_on_32bits;
   function bits$0(state){return caml_int64_of_int32(bits(state));}
   function full_range_int64(state){
    var
     _p_ = caml_int64_shift_left(bits$0(state), 60),
     _q_ = caml_int64_xor(caml_int64_shift_left(bits$0(state), 30), _p_);
    return caml_int64_xor(bits$0(state), _q_);
   }
   function bits$1(state){return bits(state);}
   function full_range_int32(state){
    var _o_ = bits$1(state) << 30;
    return bits$1(state) ^ _o_;
   }
   function full_range_int_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_int_on_32bits(state){return full_range_int32(state);}
   var
    full_range_int_on_64bits$0 =
      Base_Word_size[3] ? full_range_int_on_64bits : full_range_int_on_32bits;
   function full_range_nativeint_on_64bits(state){
    return caml_int64_to_int32(full_range_int64(state));
   }
   function full_range_nativeint_on_32bits(state){return full_range_int32(state);
   }
   var
    full_range_nativeint =
      Base_Word_size[3]
       ? full_range_nativeint_on_64bits
       : full_range_nativeint_on_32bits;
   function raise_crossed_bounds
   (name, lower_bound, upper_bound, string_of_bound){
    var
     _m_ = caml_call1(string_of_bound, upper_bound),
     _n_ = caml_call1(string_of_bound, lower_bound);
    return caml_call5(Base_Printf[6], _a_, name, _n_, _m_, 0);
   }
   function int_incl(state, lo, hi){
    if(hi < lo) raise_crossed_bounds(cst_int, lo, hi, Base_Int0[1]);
    var diff = caml_call2(Base_Import[92], hi, lo);
    if(diff === Base_Int0[5]){
     var
      _i_ = Base_Int0[5],
      _j_ = full_range_int_on_64bits$0(state),
      _k_ = caml_call2(Base_Import[115], _j_, _i_);
     return caml_call2(Base_Import[90], lo, _k_);
    }
    if(0 <= diff){
     var _l_ = int$1(state, caml_call1(Base_Int0[7], diff));
     return caml_call2(Base_Import[90], lo, _l_);
    }
    for(;;){
     var int$0 = full_range_int_on_64bits$0(state);
     if(lo <= int$0 && int$0 <= hi) return int$0;
    }
   }
   function int32_incl(state, lo, hi){
    if(caml_call2(Base_Import[101][5], lo, hi))
     raise_crossed_bounds(cst_int32, lo, hi, Stdlib_Int32[14]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[101][4], diff, Stdlib_Int32[9])){
     var _h_ = Stdlib_Int32[9];
     return lo + (full_range_int32(state) & _h_) | 0;
    }
    if(caml_call2(Base_Import[101][6], diff, 0))
     return lo + int32(state, caml_call1(Stdlib_Int32[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_int32(state);
     if
      (caml_call2(Base_Import[101][6], int$0, lo)
       && caml_call2(Base_Import[101][2], int$0, hi))
      return int$0;
    }
   }
   function nativeint_incl(state, lo, hi){
    if(caml_call2(Base_Import[103][5], lo, hi))
     raise_crossed_bounds(cst_nativeint, lo, hi, Stdlib_Nativeint[15]);
    var diff = hi - lo | 0;
    if(caml_call2(Base_Import[103][4], diff, Stdlib_Nativeint[10])){
     var _g_ = Stdlib_Nativeint[10];
     return lo + (full_range_nativeint(state) & _g_) | 0;
    }
    if(caml_call2(Base_Import[103][6], diff, 0))
     return lo + nativeint(state, caml_call1(Stdlib_Nativeint[6], diff)) | 0;
    for(;;){
     var int$0 = full_range_nativeint(state);
     if
      (caml_call2(Base_Import[103][6], int$0, lo)
       && caml_call2(Base_Import[103][2], int$0, hi))
      return int$0;
    }
   }
   function int64_incl(state, lo, hi){
    if(runtime.caml_greaterthan(lo, hi))
     raise_crossed_bounds(cst_int64, lo, hi, Stdlib_Int64[14]);
    var diff = runtime.caml_int64_sub(hi, lo);
    if(runtime.caml_equal(diff, Stdlib_Int64[9])){
     var _f_ = Stdlib_Int64[9];
     return caml_int64_add
             (lo, runtime.caml_int64_and(full_range_int64(state), _f_));
    }
    if(caml_greaterequal(diff, _b_))
     return caml_int64_add
             (lo, int64(state, caml_call1(Stdlib_Int64[6], diff)));
    for(;;){
     var int$0 = full_range_int64(state);
     if(caml_greaterequal(int$0, lo) && runtime.caml_lessequal(int$0, hi))
      return int$0;
    }
   }
   function float$0(state, hi){
    for(;;){
     var
      r1 = bits(state),
      r2 = bits(state),
      _d_ = caml_call2(Base_Import[89], r1, 9.313225746154785e-10),
      _e_ = caml_call2(Base_Import[91], _d_, r2),
      result = caml_call2(Base_Import[89], _e_, 9.313225746154785e-10);
     if(caml_call2(Base_Import[107][1], result, 1.))
      return caml_call2(Base_Import[89], result, hi);
    }
   }
   function float_range(state, lo, hi){
    if(caml_call2(Base_Import[107][5], lo, hi))
     raise_crossed_bounds(cst_float, lo, hi, Base_Import[84][34]);
    var _c_ = float$0(state, caml_call2(Base_Import[93], hi, lo));
    return caml_call2(Base_Import[91], lo, _c_);
   }
   var default$1 = caml_call1(Base_Random_repr[3], default$0);
   function bits$2(param){
    return bits(caml_call1(Base_Random_repr[4], default$1));
   }
   function int$2(x){
    return int$1(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int32$0(x){
    return int32(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function nativeint$0(x){
    return nativeint(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int64$0(x){
    return int64(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function float$1(x){
    return float$0(caml_call1(Base_Random_repr[4], default$1), x);
   }
   function int_incl$0(x, y){
    return int_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function int32_incl$0(x, y){
    return int32_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function nativeint_incl$0(x, y){
    return nativeint_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function int64_incl$0(x, y){
    return int64_incl(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function float_range$0(x, y){
    return float_range(caml_call1(Base_Random_repr[4], default$1), x, y);
   }
   function bool$0(param){
    return bool(caml_call1(Base_Random_repr[4], default$1));
   }
   function char$1(param){
    return char$0(caml_call1(Base_Random_repr[4], default$1));
   }
   function ascii$0(param){
    return ascii(caml_call1(Base_Random_repr[4], default$1));
   }
   function full_init(seed){
    var t = caml_call1(Base_Random_repr[4], default$1);
    return caml_call2(assign, t, make(seed));
   }
   function init(seed){return full_init([0, seed]);}
   function self_init(allow_in_tests, param){
    forbid_nondeterminism_in_tests(allow_in_tests);
    return full_init(runtime.caml_sys_random_seed(0));
   }
   function set_state(s){
    return caml_call2(assign, caml_call1(Base_Random_repr[4], default$1), s);
   }
   var
    Base_Random =
      [0,
       init,
       full_init,
       self_init,
       bits$2,
       int$2,
       int32$0,
       nativeint$0,
       int64$0,
       float$1,
       int_incl$0,
       int32_incl$0,
       nativeint_incl$0,
       int64_incl$0,
       float_range$0,
       bool$0,
       char$1,
       ascii$0,
       [0,
        default$0,
        make,
        make_self_init,
        copy,
        bits,
        int$1,
        int32,
        nativeint,
        int64,
        float$0,
        int_incl,
        int32_incl,
        nativeint_incl,
        int64_incl,
        float_range,
        bool,
        char$0,
        ascii],
       set_state];
   runtime.caml_register_global(24, Base_Random, "Base__Random");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array_permute
//# unitInfo: Requires: Base__Array0, Base__Import, Base__Ordered_collection_common0, Base__Random
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    Base_Array0 = global_data.Base__Array0,
    invalid_argf = Base_Array0[1],
    Array = Base_Array0[2],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_float_uninitialized = Base_Array0[5],
    append = Base_Array0[6],
    blit = Base_Array0[7],
    concat = Base_Array0[8],
    copy = Base_Array0[9],
    fill = Base_Array0[10],
    init = Base_Array0[11],
    make_matrix = Base_Array0[12],
    of_list = Base_Array0[13],
    sub = Base_Array0[14],
    to_list = Base_Array0[15],
    fold = Base_Array0[16],
    fold_right = Base_Array0[17],
    iter = Base_Array0[18],
    iteri = Base_Array0[19],
    map = Base_Array0[20],
    mapi = Base_Array0[21],
    stable_sort = Base_Array0[22],
    swap = Base_Array0[23];
   function permute(opt, _a_, len, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(_a_) var sth$0 = _a_[1], pos = sth$0; else var pos = 0;
    var total_length = t.length - 1;
    if(len)
     var l = len[1], len$0 = l;
    else
     var len$0 = caml_call2(Base_Import[92], total_length, pos);
    caml_call3(Base_Ordered_collection_common[2], pos, len$0, total_length);
    var num_swaps = caml_call2(Base_Import[92], len$0, 1);
    if(num_swaps >= 1){
     var i = num_swaps;
     for(;;){
      var
       this_i = caml_call2(Base_Import[90], pos, i),
       _b_ = caml_call2(Base_Import[90], i, 1),
       _c_ = caml_call2(Base_Random[18][6], random_state, _b_),
       random_i = caml_call2(Base_Import[90], pos, _c_);
      caml_call3(swap, t, this_i, random_i);
      var _d_ = i - 1 | 0;
      if(1 !== i){var i = _d_; continue;}
      break;
     }
    }
    return 0;
   }
   var
    Base_Array_permute =
      [0,
       invalid_argf,
       Array,
       max_length,
       create,
       create_float_uninitialized,
       append,
       blit,
       concat,
       copy,
       fill,
       init,
       make_matrix,
       of_list,
       sub,
       to_list,
       fold,
       fold_right,
       iter,
       iteri,
       map,
       mapi,
       stable_sort,
       swap,
       permute];
   runtime.caml_register_global(4, Base_Array_permute, "Base__Array_permute");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Equal
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Equal = [0];
   runtime.caml_register_global(0, Base_Equal, "Base__Equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fn
//# unitInfo: Requires: Base__Import
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import;
   function const$0(c, param){return c;}
   function non(f, x){return 1 - caml_call1(f, x);}
   function forever(f){
    try{for(;;) caml_call1(f, 0);}
    catch(e$0){var e = caml_wrap_exception(e$0); return e;}
   }
   function compose(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function flip(f, x, y){return caml_call2(f, y, x);}
   function apply_n_times(n, f, x){
    var n$0 = n, x$0 = x;
    for(;;){
     if(0 >= n$0) return x$0;
     var
      x$1 = caml_call1(f, x$0),
      n$1 = caml_call2(Base_Import[92], n$0, 1),
      n$0 = n$1,
      x$0 = x$1;
    }
   }
   var Base_Fn = [0, const$0, non, forever, apply_n_times, compose, flip];
   runtime.caml_register_global(1, Base_Fn, "Base__Fn");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordering
//# unitInfo: Requires: Base__Hash, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Equal = "Equal",
    cst_Greater = "Greater",
    cst_Less = "Less",
    cst_equal = "equal",
    cst_greater = "greater",
    cst_less = "less",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, [0, 2, 0]]],
    error_source_005 = "ordering.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Less, 0]],
         [0, [1, [0, cst_Equal, 0]], [0, [1, [0, cst_Greater, 0]], 0]]]]],
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    compare = caml_int_compare,
    _a_ = [0, cst_Less],
    _b_ = [0, cst_Equal],
    _c_ = [0, cst_Greater];
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _h_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _h_);
   }
   function t_of_sexp(sexp_006){
    if(0 === sexp_006[0]){
     var _d_ = sexp_006[1], switch$0 = 0;
     if(caml_string_notequal(_d_, cst_Equal)){
      var switch$1 = 0;
      if(caml_string_notequal(_d_, cst_Greater)){
       var switch$2 = 0;
       if(caml_string_notequal(_d_, cst_Less)){
        if(caml_string_notequal(_d_, cst_equal))
         if(caml_string_notequal(_d_, cst_greater))
          if(caml_string_notequal(_d_, cst_less))
           switch$0 = 1;
          else
           switch$2 = 1;
         else
          switch$1 = 1;
       }
       else
        switch$2 = 1;
       if(switch$2) return 0;
      }
      else
       switch$1 = 1;
      if(switch$1) return 2;
     }
     if(! switch$0) return 1;
    }
    else{
     var _e_ = sexp_006[1];
     if(! _e_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_005, sexp_006);
     var _f_ = _e_[1];
     if(0 !== _f_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_005, sexp_006);
     var _g_ = _f_[1], switch$3 = 0;
     if(caml_string_notequal(_g_, cst_Equal)){
      var switch$4 = 0;
      if(caml_string_notequal(_g_, cst_Greater)){
       var switch$5 = 0;
       if(caml_string_notequal(_g_, cst_Less)){
        if(caml_string_notequal(_g_, cst_equal))
         if(caml_string_notequal(_g_, cst_greater))
          if(caml_string_notequal(_g_, cst_less))
           switch$3 = 1;
          else
           switch$5 = 1;
         else
          switch$4 = 1;
       }
       else
        switch$5 = 1;
       if(switch$5)
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
      }
      else
       switch$4 = 1;
      if(switch$4)
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
     }
     if(! switch$3)
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_005, sexp_006);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_005, sexp_006);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   function equal(a, b){return 0 === caml_int_compare(a, b) ? 1 : 0;}
   var Export = [0];
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   var
    Base_Ordering =
      [0,
       compare,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       all,
       equal,
       of_int,
       to_int,
       Export];
   runtime.caml_register_global(20, Base_Ordering, "Base__Ordering");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sys
//# unitInfo: Requires: Base__Sys0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Sys0 = global_data.Base__Sys0,
    backend_type = Base_Sys0[1],
    interactive = Base_Sys0[2],
    os_type = Base_Sys0[3],
    unix = Base_Sys0[4],
    win32 = Base_Sys0[5],
    cygwin = Base_Sys0[6],
    word_size_in_bits = Base_Sys0[7],
    int_size_in_bits = Base_Sys0[8],
    big_endian = Base_Sys0[9],
    max_string_length = Base_Sys0[10],
    max_array_length = Base_Sys0[11],
    runtime_variant = Base_Sys0[12],
    runtime_parameters = Base_Sys0[13],
    argv = Base_Sys0[14],
    get_argv = Base_Sys0[15],
    ocaml_version = Base_Sys0[16],
    enable_runtime_warnings = Base_Sys0[17],
    runtime_warnings_enabled = Base_Sys0[18],
    getenv_exn = Base_Sys0[19],
    getenv = Base_Sys0[20],
    Base_Sys =
      [0,
       get_argv,
       argv,
       interactive,
       os_type,
       unix,
       win32,
       cygwin,
       backend_type,
       word_size_in_bits,
       int_size_in_bits,
       big_endian,
       max_string_length,
       max_array_length,
       runtime_variant,
       runtime_parameters,
       ocaml_version,
       enable_runtime_warnings,
       runtime_warnings_enabled,
       getenv,
       getenv_exn];
   runtime.caml_register_global(1, Base_Sys, "Base__Sys");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__List
//# unitInfo: Requires: Assert_failure, Base__Applicative, Base__Array0, Base__Array_permute, Base__Container, Base__Import, Base__List1, Base__Monad, Base__Ordering, Base__Ppx_compare_lib, Base__Printf, Base__Random, Base__Result, Base__Sys, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = " <> ",
    cst$0 = ": ",
    cst_length_mismatch_in = "length mismatch in ",
    cst_src_list_ml = "src/list.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_022 = "list.ml.Assoc.t",
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Random = global_data.Base__Random,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Result = global_data.Base__Result,
    Base_Ordering = global_data.Base__Ordering,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_List1 = global_data.Base__List1,
    Base_Printf = global_data.Base__Printf,
    Base_Sys = global_data.Base__Sys,
    Base_Applicative = global_data.Base__Applicative,
    Base_Monad = global_data.Base__Monad,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    hd_exn = Base_List1[1],
    length = Base_List1[2],
    rev_append = Base_List1[3],
    tl_exn = Base_List1[4],
    exists = Base_List1[6],
    exists2_ok = Base_List1[7],
    fold_left = Base_List1[8],
    fold2_ok = Base_List1[9],
    for_all = Base_List1[10],
    for_all2_ok = Base_List1[11],
    iter = Base_List1[12],
    iter2_ok = Base_List1[13],
    nontail_map = Base_List1[14],
    rev_map = Base_List1[17],
    rev_map2_ok = Base_List1[18],
    sort = Base_List1[19],
    stable_sort = Base_List1[20],
    rev = Base_List1[21],
    fold_right = Base_List1[22],
    is_empty = Base_List1[23],
    partition_map = Base_List1[24],
    invalid_argf = Base_Printf[7],
    t_of_sexp = Base_Import[175],
    sexp_of_t = Base_Import[151],
    cst_List_last = "List.last",
    _s_ = [0, "list.ml.Transpose_got_lists_of_different_lengths"],
    _t_ = [0, cst_src_list_ml, 1301, 13],
    cst_List_random_element_exn_em = "List.random_element_exn: empty list",
    cst_List_drop_last_exn_empty_l = "List.drop_last_exn: empty list",
    _q_ =
      [0,
       [11, "List.chunks_of: Expected length > 0, got ", [4, 0, 0, 0, 0]],
       "List.chunks_of: Expected length > 0, got %d"],
    cst_List_sub = "List.sub",
    _o_ = [0, cst_src_list_ml, 1045, 12],
    _n_ = [0, cst_src_list_ml, 933, 4],
    _m_ = [0, [11, "List.init ", [4, 0, 0, 0, 0]], "List.init %d"],
    cst_List_reduce_balanced_exn = "List.reduce_balanced_exn",
    _l_ = [0, cst_src_list_ml, 661, 14],
    cst_List_reduce_exn = "List.reduce_exn",
    _k_ =
      [0,
       [11,
        "length mismatch in zip_exn: ",
        [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]],
       "length mismatch in zip_exn: %d <> %d"],
    cst_map3_exn = "map3_exn",
    cst_rev_map3_exn = "rev_map3_exn",
    _j_ = [0, cst_src_list_ml, 528, 11],
    cst_map2_exn = "map2_exn",
    cst_exists2_exn = "exists2_exn",
    cst_for_all2_exn = "for_all2_exn",
    cst_fold2_exn = "fold2_exn",
    cst_rev_map2_exn = "rev_map2_exn",
    cst_iter2_exn = "iter2_exn",
    _e_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2,
         0,
         [11,
          cst$0,
          [4,
           0,
           0,
           0,
           [11,
            cst,
            [4,
             0,
             0,
             0,
             [11, " || ", [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]]]]]],
       "length mismatch in %s: %d <> %d || %d <> %d"],
    _d_ =
      [0,
       [11,
        cst_length_mismatch_in,
        [2, 0, [11, cst$0, [4, 0, 0, 0, [11, cst, [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    _c_ =
      [0,
       [11,
        "List.nth_exn ",
        [4, 0, 0, 0, [11, " called on list of length ", [4, 0, 0, 0, 0]]]],
       "List.nth_exn %d called on list of length %d"],
    cst_List_range_stride_must_be_ = "List.range: stride must be non-zero",
    cst_List_range_stride_function$0 =
      "List.range': stride function cannot change direction",
    cst_List_range_stride_function =
      "List.range': stride function cannot return the same value",
    _a_ = [0, "Ok"],
    _b_ = [0, "Unequal_lengths"],
    _f_ = [0, "List.find_map_exn: not found"],
    _g_ = [0, "List.find_exn: not found"],
    _h_ = [0, "List.findi_exn: not found"],
    _i_ = [0, "List.find_mapi_exn: not found"],
    _p_ = [0, "List.Assoc.find_exn: not found"],
    cst_Base_List_Transpose_got_li =
      "Base__List.Transpose_got_lists_of_different_lengths";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[194], a_sexp_grammar);
   }
   function compare(cmp_a, a_006, b_007){
    if(caml_call2(Base_Ppx_compare_lib[1], a_006, b_007)) return 0;
    if(! a_006) return b_007 ? 1 : 0;
    var a_008 = a_006[1];
    if(! b_007) return -1;
    var b_009 = b_007[1];
    return caml_call2(cmp_a, a_008, b_009);
   }
   function sexp_of_t$0(of_a_010, param){
    if(! param) return _b_;
    var arg0_011 = param[1], res0_012 = caml_call1(of_a_010, arg0_011);
    return [1, [0, _a_, [0, res0_012, 0]]];
   }
   var Or_unequal_lengths = [0, compare, sexp_of_t$0];
   function invariant(f, t){return caml_call2(iter, t, f);}
   function of_list(t){return t;}
   function range(compare, stride, opt, _a0_, start_i, stop_i){
    if(opt) var sth = opt[1], start = sth; else var start = 104758188;
    if(_a0_) var sth$0 = _a0_[1], stop = sth$0; else var stop = -160346914;
    var next_i = caml_call1(stride, start_i);
    function order(x, y){
     var _a2_ = caml_call2(compare, x, y);
     return caml_call1(Base_Ordering[9], _a2_);
    }
    function raise_stride_cannot_return_sam(param){
     return caml_call1(Base_Import[125], cst_List_range_stride_function);
    }
    switch(order(start_i, next_i)){
      case 0:
       var initial_stride_order = 847855481; break;
      case 1:
       var initial_stride_order = raise_stride_cannot_return_sam(0); break;
      default: var initial_stride_order = 85047514;
    }
    var
     start_i$0 = 104758188 <= start ? start_i : next_i,
     i = start_i$0,
     accum = 0;
    for(;;){
     var i_to_stop_order = order(i, stop_i), switch$0 = 0;
     switch(i_to_stop_order){
       case 0:
        switch$0 = 847855481 <= initial_stride_order ? 1 : 2; break;
       case 1:
        var _a1_ = 104758188 <= stop ? [0, i, accum] : accum; break;
       default: switch$0 = 847855481 <= initial_stride_order ? 2 : 1;
     }
     switch(switch$0){
       case 1:
        var next_i$0 = caml_call1(stride, i), switch$1 = 0;
        switch(order(i, next_i$0)){
          case 0:
           switch$1 = 847855481 <= initial_stride_order ? 2 : 1; break;
          case 1:
           var _a1_ = raise_stride_cannot_return_sam(0); break;
          default: switch$1 = 847855481 <= initial_stride_order ? 1 : 2;
        }
        switch(switch$1){
          case 1:
           var
            _a1_ =
              caml_call1(Base_Import[125], cst_List_range_stride_function$0);
           break;
          case 2:
           var accum$0 = [0, i, accum], i = next_i$0, accum = accum$0;
           continue;
        }
        break;
       case 2:
        var _a1_ = accum; break;
     }
     return caml_call1(rev, _a1_);
    }
   }
   function range$0(opt, _aX_, _aW_, start_i, stop_i){
    if(opt) var sth = opt[1], stride = sth; else var stride = 1;
    if(_aX_) var sth$0 = _aX_[1], start = sth$0; else var start = 104758188;
    if(_aW_) var sth$1 = _aW_[1], stop = sth$1; else var stop = -160346914;
    if(0 === stride)
     caml_call1(Base_Import[125], cst_List_range_stride_must_be_);
    var _aY_ = [0, stop], _aZ_ = [0, start];
    return range
            (runtime.caml_int_compare,
             function(x){return caml_call2(Base_Import[90], x, stride);},
             _aZ_,
             _aY_,
             start_i,
             stop_i);
   }
   function hd(t){if(! t) return 0; var x = t[1]; return [0, x];}
   function tl(t){if(! t) return 0; var t$0 = t[2]; return [0, t$0];}
   function nth(t, n){
    if(0 > n) return 0;
    var t$0 = t, n$0 = n;
    for(;;){
     if(! t$0) return 0;
     var t$1 = t$0[2], a = t$0[1];
     if(0 === n$0) return [0, a];
     var n$1 = caml_call2(Base_Import[92], n$0, 1), t$0 = t$1, n$0 = n$1;
    }
   }
   function nth_exn(t, n){
    var match = nth(t, n);
    if(! match)
     return caml_call4(invalid_argf, _c_, n, caml_call1(length, t), 0);
    var a = match[1];
    return a;
   }
   function unordered_append(l1, l2){
    if(l1){
     if(l2) return caml_call2(rev_append, l1, l2);
     var l = l1;
    }
    else
     var l = l2;
    return l;
   }
   function of_lists(l1, l2){
    var a = l1, b = l2, shared_length = 0;
    for(;;){
     if(a){
      if(b){
       var
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[90], shared_length, 1),
        a = a$0,
        b = b$0,
        shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b) return [0, shared_length];
     return [1, shared_length, a, b];
    }
   }
   function check_length2_exn(name, l1, l2){
    var match = of_lists(l1, l2);
    if(0 === match[0]) return 0;
    var
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _aT_ = caml_call1(length, tail_of_b),
     _aU_ = caml_call2(Base_Import[90], shared_length, _aT_),
     _aV_ = caml_call1(length, tail_of_a);
    return caml_call5
            (invalid_argf,
             _d_,
             name,
             caml_call2(Base_Import[90], shared_length, _aV_),
             _aU_,
             0);
   }
   function check_length2(l1, l2, f){
    return 0 === of_lists(l1, l2)[0] ? [0, caml_call2(f, l1, l2)] : 0;
   }
   function of_lists$0(l1, l2, l3){
    var a = l1, b = l2, c = l3, shared_length = 0;
    for(;;){
     if(a){
      if(b && c){
       var
        c$0 = c[2],
        b$0 = b[2],
        a$0 = a[2],
        shared_length$0 = caml_call2(Base_Import[90], shared_length, 1),
        a = a$0,
        b = b$0,
        c = c$0,
        shared_length = shared_length$0;
       continue;
      }
     }
     else if(! b && ! c) return [0, shared_length];
     return [1, shared_length, a, b, c];
    }
   }
   function check_length3_exn(name, l1, l2, l3){
    var match = of_lists$0(l1, l2, l3);
    if(0 === match[0]) return 0;
    var
     tail_of_c = match[4],
     tail_of_b = match[3],
     tail_of_a = match[2],
     shared_length = match[1],
     _aQ_ = caml_call1(length, tail_of_a),
     n1 = caml_call2(Base_Import[90], shared_length, _aQ_),
     _aR_ = caml_call1(length, tail_of_b),
     n2 = caml_call2(Base_Import[90], shared_length, _aR_),
     _aS_ = caml_call1(length, tail_of_c),
     n3 = caml_call2(Base_Import[90], shared_length, _aS_);
    return caml_call7(invalid_argf, _e_, name, n1, n2, n2, n3, 0);
   }
   function check_length3(l1, l2, l3, f){
    return 0 === of_lists$0(l1, l2, l3)[0]
            ? [0, caml_call3(f, l1, l2, l3)]
            : 0;
   }
   function iter2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aN_){
              var _aO_ = caml_call1(iter2_ok, _aN_);
              return function(_aP_){return caml_call2(_aO_, _aP_, f);};
             });
   }
   function iter2_exn(l1, l2, f){
    check_length2_exn(cst_iter2_exn, l1, l2);
    return caml_call3(iter2_ok, l1, l2, f);
   }
   function rev_map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aK_){
              var _aL_ = caml_call1(rev_map2_ok, _aK_);
              return function(_aM_){return caml_call2(_aL_, _aM_, f);};
             });
   }
   function rev_map2_exn(l1, l2, f){
    check_length2_exn(cst_rev_map2_exn, l1, l2);
    return caml_call3(rev_map2_ok, l1, l2, f);
   }
   function fold2(l1, l2, init, f){
    return check_length2
            (l1,
             l2,
             function(_aH_){
              var _aI_ = caml_call1(fold2_ok, _aH_);
              return function(_aJ_){return caml_call3(_aI_, _aJ_, init, f);};
             });
   }
   function fold2_exn(l1, l2, init, f){
    check_length2_exn(cst_fold2_exn, l1, l2);
    return caml_call4(fold2_ok, l1, l2, init, f);
   }
   function for_all2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aE_){
              var _aF_ = caml_call1(for_all2_ok, _aE_);
              return function(_aG_){return caml_call2(_aF_, _aG_, f);};
             });
   }
   function for_all2_exn(l1, l2, f){
    check_length2_exn(cst_for_all2_exn, l1, l2);
    return caml_call3(for_all2_ok, l1, l2, f);
   }
   function exists2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_aB_){
              var _aC_ = caml_call1(exists2_ok, _aB_);
              return function(_aD_){return caml_call2(_aC_, _aD_, f);};
             });
   }
   function exists2_exn(l1, l2, f){
    check_length2_exn(cst_exists2_exn, l1, l2);
    return caml_call3(exists2_ok, l1, l2, f);
   }
   function mem(t, a, equal){
    var param = t;
    for(;;){
     if(! param) return 0;
     var bs = param[2], b = param[1], _aA_ = caml_call2(equal, a, b);
     if(_aA_) return _aA_;
     var param = bs;
    }
   }
   function rev_filter(t, f){
    var accu = 0, param = t;
    for(;;){
     if(! param) return accu;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)){
      var accu$0 = [0, x, accu], accu = accu$0, param = l;
      continue;
     }
     var param = l;
    }
   }
   function filter(t, f){return caml_call1(rev, rev_filter(t, f));}
   function find_map(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1], r = caml_call1(f, x);
     if(r) return r;
     var param = l;
    }
   }
   var not_found = [0, Base_Import[251], _f_];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find(t, f){
    var param = t;
    for(;;){
     if(! param) return 0;
     var l = param[2], x = param[1];
     if(caml_call1(f, x)) return [0, x];
     var param = l;
    }
   }
   var not_found$0 = [0, Base_Import[251], _g_];
   function find_exn(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) throw caml_maybe_attach_backtrace(not_found$0, 1);
     var t$1 = t$0[2], x = t$0[1];
     if(caml_call1(f, x)) return x;
     var t$0 = t$1;
    }
   }
   function findi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1];
     if(caml_call2(f, i, x)) return [0, [0, i, x]];
     var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0, t$0 = l;
    }
   }
   var not_found$1 = [0, Base_Import[251], _h_];
   function findi_exn(t, f){
    var match = findi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$1, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var l = t$0[2], x = t$0[1], result = caml_call2(f, i, x);
     if(result) return result;
     var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0, t$0 = l;
    }
   }
   var not_found$2 = [0, Base_Import[251], _i_];
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$2, 1);
    var x = match[1];
    return x;
   }
   function for_alli(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 1;
     var tl = t$0[2], hd = t$0[1], _az_ = caml_call2(f, i, hd);
     if(! _az_) return _az_;
     var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0, t$0 = tl;
    }
   }
   function existsi(t, f){
    var i = 0, t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var tl = t$0[2], hd = t$0[1], _ay_ = caml_call2(f, i, hd);
     if(_ay_) return _ay_;
     var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0, t$0 = tl;
    }
   }
   var to_array = Base_Array0[13];
   function to_list(t){return t;}
   var max_non_tailcall = typeof Base_Sys[8] === "number" ? 1000 : 50;
   function count_append(l1, l2, count){
    if(! l2) return l1;
    if(! l1) return l2;
    var _au_ = l1[2], x1 = l1[1];
    if(! _au_) return [0, x1, l2];
    var _av_ = _au_[2], x2 = _au_[1];
    if(! _av_) return [0, x1, [0, x2, l2]];
    var _aw_ = _av_[2], x3 = _av_[1];
    if(! _aw_) return [0, x1, [0, x2, [0, x3, l2]]];
    var match = _aw_[2], x4 = _aw_[1];
    if(! match) return [0, x1, [0, x2, [0, x3, [0, x4, l2]]]];
    var
     tl = match[2],
     x5 = match[1],
     _ax_ =
       max_non_tailcall < count
        ? caml_call2(rev_append, caml_call1(rev, tl), l2)
        : count_append(tl, l2, caml_call2(Base_Import[90], count, 1));
    return [0, x1, [0, x2, [0, x3, [0, x4, [0, x5, _ax_]]]]];
   }
   function append(l1, l2){return count_append(l1, l2, 0);}
   function count_map(f, l, ctr){
    if(! l) return 0;
    var _aq_ = l[2], x1$0 = l[1];
    if(! _aq_){var f1$3 = caml_call1(f, x1$0); return [0, f1$3, 0];}
    var _ar_ = _aq_[2], x2$0 = _aq_[1];
    if(! _ar_){
     var f1$2 = caml_call1(f, x1$0), f2$2 = caml_call1(f, x2$0);
     return [0, f1$2, [0, f2$2, 0]];
    }
    var _as_ = _ar_[2], x3$0 = _ar_[1];
    if(! _as_){
     var
      f1$1 = caml_call1(f, x1$0),
      f2$1 = caml_call1(f, x2$0),
      f3$1 = caml_call1(f, x3$0);
     return [0, f1$1, [0, f2$1, [0, f3$1, 0]]];
    }
    var match$1 = _as_[2], x4$0 = _as_[1];
    if(! match$1){
     var
      f1$0 = caml_call1(f, x1$0),
      f2$0 = caml_call1(f, x2$0),
      f3$0 = caml_call1(f, x3$0),
      f4$0 = caml_call1(f, x4$0);
     return [0, f1$0, [0, f2$0, [0, f3$0, [0, f4$0, 0]]]];
    }
    var
     tl = match$1[2],
     x5$0 = match$1[1],
     f1 = caml_call1(f, x1$0),
     f2 = caml_call1(f, x2$0),
     f3 = caml_call1(f, x3$0),
     f4 = caml_call1(f, x4$0),
     f5 = caml_call1(f, x5$0);
    if(max_non_tailcall < ctr){
     var bs$0 = 0, xs = tl;
     for(;;){
      if(xs){
       var _aj_ = xs[2];
       if(_aj_){
        var _ak_ = _aj_[2];
        if(_ak_){
         var _al_ = _ak_[2];
         if(_al_){
          var _am_ = _al_[2];
          if(_am_){
           var _an_ = _am_[2];
           if(_an_){
            var _ao_ = _an_[2];
            if(_ao_){
             var _ap_ = _ao_[2];
             if(_ap_){
              var match$0 = _ap_[2];
              if(match$0){
               var
                xs$0 = match$0[2],
                x8 = match$0[1],
                x7 = _ap_[1],
                x6 = _ao_[1],
                x5 = _an_[1],
                x4 = _am_[1],
                x3 = _al_[1],
                x2 = _ak_[1],
                x1 = _aj_[1],
                x0 = xs[1],
                y0$0 = caml_call1(f, x0),
                y1$0 = caml_call1(f, x1),
                y2$0 = caml_call1(f, x2),
                y3$0 = caml_call1(f, x3),
                y4$0 = caml_call1(f, x4),
                y5$0 = caml_call1(f, x5),
                y6$0 = caml_call1(f, x6),
                y7$0 = caml_call1(f, x7),
                y8$0 = caml_call1(f, x8),
                bs$1 =
                  [0,
                   [0, y0$0, y1$0, y2$0, y3$0, y4$0, y5$0, y6$0, y7$0, y8$0],
                   bs$0],
                bs$0 = bs$1,
                xs = xs$0;
               continue;
              }
             }
            }
           }
          }
         }
        }
       }
      }
      var ys$1 = caml_call2(nontail_map, xs, f), ys = ys$1, param = bs$0;
      for(;;){
       if(param){
        var
         bs = param[2],
         match = param[1],
         y8 = match[9],
         y7 = match[8],
         y6 = match[7],
         y5 = match[6],
         y4 = match[5],
         y3 = match[4],
         y2 = match[3],
         y1 = match[2],
         y0 = match[1],
         ys$0 =
           [0,
            y0,
            [0,
             y1,
             [0, y2, [0, y3, [0, y4, [0, y5, [0, y6, [0, y7, [0, y8, ys]]]]]]]]],
         ys = ys$0,
         param = bs;
        continue;
       }
       var _at_ = ys;
       break;
      }
      break;
     }
    }
    else
     var _at_ = count_map(f, tl, caml_call2(Base_Import[90], ctr, 1));
    return [0, f1, [0, f2, [0, f3, [0, f4, [0, f5, _at_]]]]];
   }
   function map(l, f){return count_map(f, l, 0);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return map
            (t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       map
        (t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function symbol_map(l, f){return map(l, f);}
   function map2_ok(l1, l2, f){
    return caml_call1(rev, caml_call3(rev_map2_ok, l1, l2, f));
   }
   function map2(l1, l2, f){
    return check_length2
            (l1,
             l2,
             function(_ah_){
              return function(_ai_){return map2_ok(_ah_, _ai_, f);};
             });
   }
   function map2_exn(l1, l2, f){
    check_length2_exn(cst_map2_exn, l1, l2);
    return map2_ok(l1, l2, f);
   }
   function rev_map3_ok(l1, l2, l3, f){
    var l1$0 = l1, l2$0 = l2, l3$0 = l3, ac = 0;
    for(;;){
     if(l1$0){
      if(l2$0 && l3$0){
       var
        l3$1 = l3$0[2],
        x3 = l3$0[1],
        l2$1 = l2$0[2],
        x2 = l2$0[1],
        l1$1 = l1$0[2],
        x1 = l1$0[1],
        ac$0 = [0, caml_call3(f, x1, x2, x3), ac],
        l1$0 = l1$1,
        l2$0 = l2$1,
        l3$0 = l3$1,
        ac = ac$0;
       continue;
      }
     }
     else if(! l2$0 && ! l3$0) return ac;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    }
   }
   function rev_map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_ae_){
              return function(_af_){
               return function(_ag_){
                return rev_map3_ok(_ae_, _af_, _ag_, f);};};
             });
   }
   function rev_map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_rev_map3_exn, l1, l2, l3);
    return rev_map3_ok(l1, l2, l3, f);
   }
   function map3_ok(l1, l2, l3, f){
    return caml_call1(rev, rev_map3_ok(l1, l2, l3, f));
   }
   function map3(l1, l2, l3, f){
    return check_length3
            (l1,
             l2,
             l3,
             function(_ab_){
              return function(_ac_){
               return function(_ad_){return map3_ok(_ab_, _ac_, _ad_, f);};};
             });
   }
   function map3_exn(l1, l2, l3, f){
    check_length3_exn(cst_map3_exn, l1, l2, l3);
    return map3_ok(l1, l2, l3, f);
   }
   function rev_map_append(l1, l2, f){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return l2$0;
     var
      l1$1 = l1$0[2],
      h = l1$0[1],
      l2$1 = [0, caml_call1(f, h), l2$0],
      l1$0 = l1$1,
      l2$0 = l2$1;
    }
   }
   function unzip(list){
    var list$2 = caml_call1(rev, list), list$0 = list$2, l1 = 0, l2 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2];
     var
      list$1 = list$0[2],
      match = list$0[1],
      y = match[2],
      x = match[1],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1],
      list$0 = list$1,
      l1 = l1$0,
      l2 = l2$0;
    }
   }
   function unzip3(list){
    var
     list$2 = caml_call1(rev, list),
     list$0 = list$2,
     l1 = 0,
     l2 = 0,
     l3 = 0;
    for(;;){
     if(! list$0) return [0, l1, l2, l3];
     var
      list$1 = list$0[2],
      match = list$0[1],
      z = match[3],
      y = match[2],
      x = match[1],
      l3$0 = [0, z, l3],
      l2$0 = [0, y, l2],
      l1$0 = [0, x, l1],
      list$0 = list$1,
      l1 = l1$0,
      l2 = l2$0,
      l3 = l3$0;
    }
   }
   function zip_exn(l1, l2){
    try{
     var _$_ = map2_ok(l1, l2, function(a, b){return [0, a, b];});
     return _$_;
    }
    catch(_aa_){
     var ___ = caml_call1(length, l2);
     return caml_call4(invalid_argf, _k_, caml_call1(length, l1), ___, 0);
    }
   }
   function zip(l1, l2){
    return map2(l1, l2, function(a, b){return [0, a, b];});
   }
   function rev_mapi(l, f){
    var i = 0, acc = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      t = param[2],
      h = param[1],
      acc$0 = [0, caml_call2(f, i, h), acc],
      i$0 = caml_call2(Base_Import[90], i, 1),
      i = i$0,
      acc = acc$0,
      param = t;
    }
   }
   function mapi(l, f){return caml_call1(rev, rev_mapi(l, f));}
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return mapi
            (t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       mapi
        (t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function iteri(l, f){
    caml_call3
     (fold_left,
      l,
      0,
      function(i, x){
       caml_call2(f, i, x);
       return caml_call2(Base_Import[90], i, 1);
      });
    return 0;
   }
   function foldi(t, init, f){
    var
     _Y_ =
       caml_call3
        (fold_left,
         t,
         [0, 0, init],
         function(param, v){
          var acc = param[2], i = param[1], _Z_ = caml_call3(f, i, acc, v);
          return [0, caml_call2(Base_Import[90], i, 1), _Z_];
         });
    return caml_call1(Base_Import[126], _Y_);
   }
   function filteri(l, f){
    return caml_call1
            (rev,
             foldi
              (l,
               0,
               function(pos, acc, x){
                return caml_call2(f, pos, x) ? [0, x, acc] : acc;
               }));
   }
   function reduce(l, f){
    if(! l) return 0;
    var tl = l[2], hd = l[1];
    return [0, caml_call3(fold_left, tl, hd, f)];
   }
   function reduce_exn(l, f){
    var match = reduce(l, f);
    if(! match) return caml_call1(Base_Import[125], cst_List_reduce_exn);
    var v = match[1];
    return v;
   }
   function reduce_balanced(l, f){
    function step_accum(num, acc, x){
     var num$0 = num, acc$0 = acc, x$0 = x;
     for(;;){
      if(0 === caml_call2(Base_Import[115], num$0, 1)) return [0, x$0, acc$0];
      if(! acc$0)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
      var
       acc$1 = acc$0[2],
       y = acc$0[1],
       x$1 = caml_call2(f, y, x$0),
       num$1 = caml_call2(Base_Import[114], num$0, 1),
       num$0 = num$1,
       acc$0 = acc$1,
       x$0 = x$1;
     }
    }
    var match = foldi(l, 0, step_accum);
    if(! match) return 0;
    var xs = match[2], x = match[1];
    return [0,
            caml_call3
             (fold_left, xs, x, function(x, y){return caml_call2(f, y, x);})];
   }
   function reduce_balanced_exn(l, f){
    var match = reduce_balanced(l, f);
    if(! match)
     return caml_call1(Base_Import[125], cst_List_reduce_balanced_exn);
    var v = match[1];
    return v;
   }
   function groupi(l, break$0){
    var
     groups =
       foldi
        (l,
         0,
         function(i, acc, x){
          if(! acc) return [0, [0, x, 0], 0];
          var tl = acc[2], current_group = acc[1];
          return caml_call3(break$0, i, caml_call1(hd_exn, current_group), x)
                  ? [0, [0, x, 0], [0, current_group, tl]]
                  : [0, [0, x, current_group], tl];
         });
    return groups ? caml_call2(rev_map, groups, rev) : 0;
   }
   function group(l, break$0){
    return groupi(l, function(param, x, y){return caml_call2(break$0, x, y);});
   }
   function sort_and_group(l, compare){
    var _X_ = caml_call2(stable_sort, l, compare);
    return group
            (_X_,
             function(x, y){return 0 !== caml_call2(compare, x, y) ? 1 : 0;});
   }
   function concat_map(l, f){
    var acc = 0, param = l;
    for(;;){
     if(! param) return caml_call1(rev, acc);
     var
      tl = param[2],
      hd = param[1],
      acc$0 = caml_call2(rev_append, caml_call1(f, hd), acc),
      acc = acc$0,
      param = tl;
    }
   }
   function concat_mapi(l, f){
    var cont = 0, acc = 0, param = l;
    for(;;){
     if(! param) return caml_call1(rev, acc);
     var
      tl = param[2],
      hd = param[1],
      acc$0 = caml_call2(rev_append, caml_call2(f, cont, hd), acc),
      cont$0 = caml_call2(Base_Import[90], cont, 1),
      cont = cont$0,
      acc = acc$0,
      param = tl;
    }
   }
   function merge(l1, l2, compare){
    var acc = 0, l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return caml_call2(rev_append, acc, l2$0);
     if(! l2$0) return caml_call2(rev_append, acc, l1$0);
     var t2 = l2$0[2], h2 = l2$0[1], t1 = l1$0[2], h1 = l1$0[1];
     if(0 < caml_call2(compare, h1, h2)){
      var acc$0 = [0, h2, acc], acc = acc$0, l2$0 = t2;
      continue;
     }
     var acc$1 = [0, h1, acc], acc = acc$1, l1$0 = t1;
    }
   }
   function map2$0(a, b, f){
    return concat_map
            (a,
             function(x){
              return map(b, function(y){return caml_call2(f, x, y);});
             });
   }
   function return$0(x){return [0, x, 0];}
   function symbol_bind(t, f){return concat_map(t, f);}
   var
    map$0 = [0, -198771759, map],
    Applicative =
      caml_call1(Base_Applicative[11], [0, return$0, map2$0, map$0]),
    map$1 = [0, -198771759, map],
    Monad = caml_call1(Base_Monad[1], [0, concat_map, return$0, map$1]),
    all = Monad[9],
    all_unit = Monad[10],
    ignore_m = Monad[8],
    join = Monad[7],
    apply = Applicative[8],
    both = Applicative[3],
    map3$0 = Applicative[10],
    symbol = Applicative[4],
    symbol$0 = Applicative[6],
    symbol$1 = Applicative[5],
    symbol$2 = Applicative[4],
    symbol$3 = Applicative[6],
    symbol$4 = Applicative[5],
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, concat_map, map, both, Open_on_rhs],
    Let_syntax$0 = [0, return$0, symbol_bind, symbol_map, Let_syntax],
    Monad_infix = [0, symbol_bind, symbol_map];
   function last_exn(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return caml_call1(Base_Import[125], cst_List_last);
     var x = list$0[1];
     if(! list$0[2]) return x;
     var list$1 = list$0[2], list$0 = list$1;
    }
   }
   function last(list){
    var list$0 = list;
    for(;;){
     if(! list$0) return 0;
     var x = list$0[1];
     if(! list$0[2]) return [0, x];
     var list$1 = list$0[2], list$0 = list$1;
    }
   }
   function is_prefix(list, prefix, equal){
    var list$0 = list, prefix$0 = prefix;
    for(;;){
     if(! prefix$0) return 1;
     var prefix$1 = prefix$0[2], hd = prefix$0[1];
     if(! list$0) return 0;
     var
      list$1 = list$0[2],
      hd$0 = list$0[1],
      _W_ = caml_call2(equal, hd, hd$0);
     if(! _W_) return _W_;
     var list$0 = list$1, prefix$0 = prefix$1;
    }
   }
   function find_consecutive_duplicate(t, equal){
    if(! t) return 0;
    var t$0 = t[2], a1 = t[1], a1$0 = a1, t$1 = t$0;
    for(;;){
     if(! t$1) return 0;
     var t$2 = t$1[2], a2 = t$1[1];
     if(caml_call2(equal, a1$0, a2)) return [0, [0, a1$0, a2]];
     var a1$0 = a2, t$1 = t$2;
    }
   }
   function remove_consecutive_duplicates(opt, list, equal){
    if(opt)
     var sth = opt[1], which_to_keep = sth;
    else
     var which_to_keep = 847656566;
    if(! list) return 0;
    var
     tl$0 = list[2],
     to_keep$2 = list[1],
     to_keep = to_keep$2,
     accum = 0,
     param = tl$0;
    for(;;){
     if(! param) return caml_call1(rev, [0, to_keep, accum]);
     var tl = param[2], to_keep$0 = param[1];
     if(caml_call2(equal, to_keep$0, to_keep)){
      var
       to_keep$1 = 847656566 <= which_to_keep ? to_keep$0 : to_keep,
       to_keep = to_keep$1,
       param = tl;
      continue;
     }
     var
      accum$0 = [0, to_keep, accum],
      to_keep = to_keep$0,
      accum = accum$0,
      param = tl;
    }
   }
   function dedup_and_sort(list, compare){
    if(list && list[2]){
     var
      equal =
        function(x$0, x){return 0 === caml_call2(compare, x$0, x) ? 1 : 0;},
      sorted = caml_call2(sort, list, compare);
     return remove_consecutive_duplicates(0, sorted, equal);
    }
    return list;
   }
   function find_a_dup(l, compare){
    var sorted = caml_call2(sort, l, compare), l$0 = sorted;
    for(;;){
     if(l$0){
      var tl = l$0[2];
      if(tl){
       var hd2 = tl[1], hd1 = l$0[1];
       if(0 === caml_call2(compare, hd1, hd2)) return [0, hd1];
       var l$0 = tl;
       continue;
      }
     }
     return 0;
    }
   }
   function contains_dup(lst, compare){
    return find_a_dup(lst, compare) ? 1 : 0;
   }
   function find_all_dups(l, compare){
    function compare$0(a, b){
     var _V_ = caml_call2(compare, a, b);
     return caml_call2(Base_Import[87], -1, _V_);
    }
    var sorted = caml_call2(sort, l, compare$0);
    if(! sorted) return 0;
    var
     sorted$2 = sorted[2],
     prev$1 = sorted[1],
     sorted$0 = sorted$2,
     prev = prev$1,
     already_recorded = 0,
     acc = 0;
    for(;;){
     if(! sorted$0) return acc;
     var sorted$1 = sorted$0[2], prev$0 = sorted$0[1];
     if(0 !== compare$0(prev, prev$0)){
      var sorted$0 = sorted$1, prev = prev$0, already_recorded = 0;
      continue;
     }
     if(already_recorded){
      var sorted$0 = sorted$1, prev = prev$0, already_recorded = 1;
      continue;
     }
     var
      acc$0 = [0, prev$0, acc],
      sorted$0 = sorted$1,
      prev = prev$0,
      already_recorded = 1,
      acc = acc$0;
    }
   }
   function all_equal(t$0, equal){
    if(! t$0) return 0;
    var xs$0 = t$0[2], x$0 = t$0[1], t = xs$0;
    for(;;){
     if(t){
      var xs = t[2], x = t[1], _T_ = caml_call2(equal, x, x$0);
      if(_T_){var t = xs; continue;}
      var _U_ = _T_;
     }
     else
      var _U_ = 1;
     return _U_ ? [0, x$0] : 0;
    }
   }
   function count(t, f){
    return caml_call3(Base_Container[2], fold_left, t, f);
   }
   function sum(m, t, f){
    return caml_call4(Base_Container[7], fold_left, m, t, f);
   }
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold_left, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold_left, t, compare);
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? caml_call2(Base_Import[90], count, 1)
                      : count;
             });
   }
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _m_, n, 0);
    var i = n, accum = 0;
    for(;;){
     if(0 > i) throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
     if(0 === i) return accum;
     var
      accum$0 = [0, caml_call1(f, caml_call2(Base_Import[92], i, 1)), accum],
      i$0 = caml_call2(Base_Import[92], i, 1),
      i = i$0,
      accum = accum$0;
    }
   }
   function rev_filter_map(l, f){
    var l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call1(f, hd);
     if(match){
      var x = match[1], accum$0 = [0, x, accum], l$0 = tl, accum = accum$0;
      continue;
     }
     var l$0 = tl;
    }
   }
   function filter_map(l, f){return caml_call1(rev, rev_filter_map(l, f));}
   function rev_filter_mapi(l, f){
    var i = 0, l$0 = l, accum = 0;
    for(;;){
     if(! l$0) return accum;
     var tl = l$0[2], hd = l$0[1], match = caml_call2(f, i, hd);
     if(match){
      var
       x = match[1],
       accum$0 = [0, x, accum],
       i$0 = caml_call2(Base_Import[90], i, 1),
       i = i$0,
       l$0 = tl,
       accum = accum$0;
      continue;
     }
     var i$1 = caml_call2(Base_Import[90], i, 1), i = i$1, l$0 = tl;
    }
   }
   function filter_mapi(l, f){return caml_call1(rev, rev_filter_mapi(l, f));}
   function filter_opt(l){return filter_map(l, function(_S_){return _S_;});}
   function partition3_map(t, f){
    var t$0 = t, fst = 0, snd = 0, trd = 0;
    for(;;){
     if(! t$0){
      var _Q_ = caml_call1(rev, trd), _R_ = caml_call1(rev, snd);
      return [0, caml_call1(rev, fst), _R_, _Q_];
     }
     var t$1 = t$0[2], x = t$0[1], match = caml_call1(f, x), _P_ = match[1];
     if(4152137 === _P_){
      var y = match[2], snd$0 = [0, y, snd], t$0 = t$1, snd = snd$0;
      continue;
     }
     if(4202758 <= _P_){
      var y$0 = match[2], trd$0 = [0, y$0, trd], t$0 = t$1, trd = trd$0;
      continue;
     }
     var y$1 = match[2], fst$0 = [0, y$1, fst], t$0 = t$1, fst = fst$0;
    }
   }
   function partition_tf(t, f){
    function f$0(x){return caml_call1(f, x) ? [0, x] : [1, x];}
    return caml_call2(partition_map, t, f$0);
   }
   function partition_result(t){
    return caml_call2(partition_map, t, Base_Result[35]);
   }
   function t_of_sexp$0(of_a_014, of_b_015, x_023){
    function _M_(sexp_021){
     if(1 === sexp_021[0]){
      var _N_ = sexp_021[1];
      if(_N_){
       var _O_ = _N_[2];
       if(_O_ && ! _O_[2]){
        var
         arg1_018 = _O_[1],
         arg0_017 = _N_[1],
         res0_019 = caml_call1(of_a_014, arg0_017),
         res1_020 = caml_call1(of_b_015, arg1_018);
        return [0, res0_019, res1_020];
       }
      }
     }
     return caml_call3
             (Sexplib0_Sexp_conv_error[2], error_source_022, 2, sexp_021);
    }
    return caml_call2(Base_Import[175], _M_, x_023);
   }
   function sexp_of_t$1(of_a_024, of_b_025, x_030){
    function _L_(param){
     var
      arg1_027 = param[2],
      arg0_026 = param[1],
      res0_028 = caml_call1(of_a_024, arg0_026),
      res1_029 = caml_call1(of_b_025, arg1_027);
     return [1, [0, res0_028, [0, res1_029, 0]]];
    }
    return caml_call2(Base_Import[151], _L_, x_030);
   }
   function t_sexp_grammar$0(a_sexp_grammar, b_sexp_grammar){
    return caml_call1
            (Base_Import[194],
             [2, [0, a_sexp_grammar, [0, b_sexp_grammar, 0]]]);
   }
   function pair_of_group(list){
    if(! list) throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
    var k = list[1][1];
    return [0, k, map(list, Base_Import[126])];
   }
   function group$0(alist, equal){
    return map
            (group
              (alist,
               function(param, _K_){
                var y = _K_[1], x = param[1];
                return 1 - caml_call2(equal, x, y);
               }),
             pair_of_group);
   }
   function sort_and_group$0(alist, compare){
    return map
            (sort_and_group
              (alist,
               function(param, _J_){
                var y = _J_[1], x = param[1];
                return caml_call2(compare, x, y);
               }),
             pair_of_group);
   }
   function find$0(t, equal, key){
    var
     match =
       find
        (t,
         function(param){
          var key$0 = param[1];
          return caml_call2(equal, key, key$0);
         });
    if(! match) return 0;
    var x = match[1];
    return [0, caml_call1(Base_Import[126], x)];
   }
   var not_found$3 = [0, Base_Import[251], _p_];
   function find_exn$0(t, equal, key){
    var match = find$0(t, equal, key);
    if(! match) throw caml_maybe_attach_backtrace(not_found$3, 1);
    var value = match[1];
    return value;
   }
   function mem$0(t, equal, key){return find$0(t, equal, key) ? 1 : 0;}
   function remove(t, equal, key){
    return filter
            (t,
             function(param){
              var key$0 = param[1];
              return 1 - caml_call2(equal, key, key$0);
             });
   }
   function add(t, equal, key, value){
    return [0, [0, key, value], remove(t, equal, key)];
   }
   function inverse(t){
    return map
            (t,
             function(param){
              var y = param[2], x = param[1];
              return [0, y, x];
             });
   }
   function map$2(t, f){
    return map
            (t,
             function(param){
              var value = param[2], key = param[1];
              return [0, key, caml_call1(f, value)];
             });
   }
   function sub(l, pos, len){
    var _F_ = pos < 0 ? 1 : 0;
    if(_F_)
     var _G_ = _F_;
    else{
     var _H_ = len < 0 ? 1 : 0;
     if(_H_)
      var _G_ = _H_;
     else
      var
       _I_ = caml_call1(length, l),
       _G_ = caml_call2(Base_Import[92], _I_, len) < pos ? 1 : 0;
    }
    if(_G_) caml_call1(Base_Import[125], cst_List_sub);
    return caml_call1
            (rev,
             foldi
              (l,
               0,
               function(i, acc, el){
                if(pos <= i && i < caml_call2(Base_Import[90], pos, len))
                 return [0, el, acc];
                return acc;
               }));
   }
   function split_n(t_orig, n){
    if(0 >= n) return [0, 0, t_orig];
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(0 === n$0) return [0, caml_call1(rev, accum), t];
     if(! t) return [0, t_orig, 0];
     var
      tl = t[2],
      hd = t[1],
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[92], n$0, 1),
      n$0 = n$1,
      t = tl,
      accum = accum$0;
    }
   }
   function take(t_orig, n){
    if(0 >= n) return 0;
    var n$0 = n, t = t_orig, accum = 0;
    for(;;){
     if(0 === n$0) return caml_call1(rev, accum);
     if(! t) return t_orig;
     var
      tl = t[2],
      hd = t[1],
      accum$0 = [0, hd, accum],
      n$1 = caml_call2(Base_Import[92], n$0, 1),
      n$0 = n$1,
      t = tl,
      accum = accum$0;
    }
   }
   function drop(t, n){
    var t$0 = t, n$0 = n;
    for(;;){
     if(t$0){
      var tl = t$0[2];
      if(0 < n$0){
       var n$1 = caml_call2(Base_Import[92], n$0, 1), t$0 = tl, n$0 = n$1;
       continue;
      }
     }
     return t$0;
    }
   }
   function chunks_of(l, length){
    if(length <= 0) caml_call3(invalid_argf, _q_, length, 0);
    var acc = 0, l$0 = l;
    for(;;){
     if(! l$0) return caml_call1(rev, acc);
     var
      match = split_n(l$0, length),
      l$1 = match[2],
      sublist = match[1],
      acc$0 = [0, sublist, acc],
      acc = acc$0,
      l$0 = l$1;
    }
   }
   function split_while(xs, f){
    var acc = 0, t = xs;
    for(;;){
     if(t){
      var tl = t[2], hd = t[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc], acc = acc$0, t = tl;
       continue;
      }
     }
     return [0, caml_call1(rev, acc), t];
    }
   }
   function take_while(xs, f){
    var acc = 0, param = xs;
    for(;;){
     if(param){
      var tl = param[2], hd = param[1];
      if(caml_call1(f, hd)){
       var acc$0 = [0, hd, acc], acc = acc$0, param = tl;
       continue;
      }
     }
     return caml_call1(rev, acc);
    }
   }
   function drop_while(t, f){
    var t$0 = t;
    for(;;){
     if(t$0){
      var tl = t$0[2], hd = t$0[1];
      if(caml_call1(f, hd)){var t$0 = tl; continue;}
     }
     return t$0;
    }
   }
   function drop_last(t){
    var match = caml_call1(rev, t);
    if(! match) return 0;
    var lst = match[2];
    return [0, caml_call1(rev, lst)];
   }
   function drop_last_exn(t){
    var match = drop_last(t);
    if(! match)
     return caml_call1(Base_Import[123], cst_List_drop_last_exn_empty_l);
    var lst = match[1];
    return lst;
   }
   function cartesian_product(list1, list2){
    if(caml_call1(is_empty, list2)) return 0;
    var l1 = list1, accum = 0;
    for(;;){
     if(! l1) return caml_call1(rev, accum);
     var
      tl = l1[2],
      hd = l1[1],
      accum$0 =
        caml_call2
         (rev_append,
          map
           (list2, function(hd){return function(x){return [0, hd, x];};}(hd)),
          accum),
      l1 = tl,
      accum = accum$0;
    }
   }
   function concat(l){return caml_call3(fold_right, l, append, 0);}
   function concat_no_order(l){
    return caml_call3
            (fold_left,
             l,
             0,
             function(acc, l){return caml_call2(rev_append, l, acc);});
   }
   function cons(x, l){return [0, x, l];}
   function is_sorted(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _E_ = caml_call2(compare, x1, x2) <= 0 ? 1 : 0;
       if(! _E_) return _E_;
       var l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   function is_sorted_strictly(l, compare){
    var l$0 = l;
    for(;;){
     if(l$0){
      var rest = l$0[2];
      if(rest){
       var
        x2 = rest[1],
        x1 = l$0[1],
        _D_ = caml_call2(compare, x1, x2) < 0 ? 1 : 0;
       if(! _D_) return _D_;
       var l$0 = rest;
       continue;
      }
     }
     return 1;
    }
   }
   var Infix = [0, append];
   function permute(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(list){
     var _C_ = list[2];
     if(_C_){
      if(_C_[2]){
       var arr = caml_call1(Base_Array0[13], list);
       caml_call4(Base_Array_permute[24], [0, random_state], 0, 0, arr);
       return caml_call1(Base_Array0[15], arr);
      }
      var y = _C_[1], x = list[1];
      return caml_call1(Base_Random[18][16], random_state)
              ? [0, y, [0, x, 0]]
              : list;
     }
    }
    return list;
   }
   function random_element_exn(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(caml_call1(is_empty, list))
     return caml_call1(Base_Import[123], cst_List_random_element_exn_em);
    var _B_ = caml_call1(length, list);
    return nth_exn(list, caml_call2(Base_Random[18][6], random_state, _B_));
   }
   function random_element(opt, list){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    try{
     var _z_ = [0, random_element_exn([0, random_state], list)];
     return _z_;
    }
    catch(_A_){return 0;}
   }
   function compare$0(cmp, a, b){
    var a$0 = a, b$0 = b;
    for(;;){
     if(! a$0) return b$0 ? -1 : 0;
     if(! b$0) return 1;
     var
      ys = b$0[2],
      y = b$0[1],
      xs = a$0[2],
      x = a$0[1],
      n = caml_call2(cmp, x, y);
     if(0 !== n) return n;
     var a$0 = xs, b$0 = ys;
    }
   }
   var hash_fold_t = Base_Import[212];
   function equal(equal, t1, t2){
    var t1$0 = t1, t2$0 = t2;
    for(;;){
     if(t1$0){
      if(t2$0){
       var
        t2$1 = t2$0[2],
        x2 = t2$0[1],
        t1$1 = t1$0[2],
        x1 = t1$0[1],
        _y_ = caml_call2(equal, x1, x2);
       if(! _y_) return _y_;
       var t1$0 = t1$1, t2$0 = t2$1;
       continue;
      }
     }
     else if(! t2$0) return 1;
     return 0;
    }
   }
   function transpose(rows$0){
    var rows = rows$0, columns = 0, do_rev = 1;
    a:
    for(;;){
     var t = rows, column_acc = 0, trimmed_rows = 0, found_empty = 0;
     for(;;){
      if(! t){
       if(! column_acc && ! trimmed_rows)
        return [0, caml_call1(rev, columns)];
       if(found_empty) return 0;
       var
        column = do_rev ? caml_call1(rev, column_acc) : column_acc,
        do_rev$0 = 1 - do_rev,
        columns$0 = [0, column, columns],
        rows = trimmed_rows,
        columns = columns$0,
        do_rev = do_rev$0;
       continue a;
      }
      var match = t[1];
      if(match){
       var
        tl = t[2],
        xs = match[2],
        x = match[1],
        trimmed = [0, xs, trimmed_rows],
        column_acc$0 = [0, x, column_acc],
        t = tl,
        column_acc = column_acc$0,
        trimmed_rows = trimmed;
       continue;
      }
      var tl$0 = t[2], t = tl$0, found_empty = 1;
     }
    }
   }
   var
    Transpose_got_lists_of_differe =
      [248, cst_Base_List_Transpose_got_li, runtime.caml_fresh_oo_id(0)];
   function _r_(param){
    if(param[1] !== Transpose_got_lists_of_differe)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _t_], 1);
    var
     arg0_031 = param[2],
     res0_032 = caml_call2(Base_Import[151], Base_Import[141], arg0_031);
    return [1, [0, _s_, [0, res0_032, 0]]];
   }
   caml_call4
    (Sexplib0_Sexp_conv[70][1], 0, 0, Transpose_got_lists_of_differe, _r_);
   function transpose_exn(l){
    var match = transpose(l);
    if(! match)
     throw caml_maybe_attach_backtrace
            ([0, Transpose_got_lists_of_differe, map(l, length)], 1);
    var l$0 = match[1];
    return l$0;
   }
   function intersperse(t, sep){
    if(! t) return 0;
    var xs = t[2], x = t[1], _x_ = 0;
    return [0,
            x,
            caml_call3
             (fold_right,
              xs,
              function(y, acc){return [0, sep, [0, y, acc]];},
              _x_)];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold_left, init, f, t);
   }
   function fold_until(t, init, f){
    var _v_ = caml_call3(Base_Container[9], fold_left, init, f);
    return function(_w_){return caml_call2(_v_, _w_, t);};
   }
   function is_suffix(list, suffix, equal_elt){
    var
     list_len = caml_call1(length, list),
     suffix_len = caml_call1(length, suffix),
     _u_ = suffix_len <= list_len ? 1 : 0;
    return _u_
            ? equal
              (equal_elt,
               drop(list, caml_call2(Base_Import[92], list_len, suffix_len)),
               suffix)
            : _u_;
   }
   var
    Base_List =
      [0,
       compare$0,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold_left,
       fold_result,
       fold_until,
       exists,
       for_all,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       invariant,
       [0,
        both,
        symbol,
        symbol$1,
        symbol$0,
        apply,
        map2$0,
        map3$0,
        [0, symbol$2, symbol$4, symbol$3, symbol_map],
        symbol_bind,
        symbol_map,
        [0, symbol_bind, symbol_map],
        concat_map,
        return$0,
        map,
        join,
        ignore_m,
        all,
        all_unit,
        [0, return$0, symbol_bind, symbol_map, Let_syntax]],
       symbol_bind,
       symbol_map,
       Monad_infix,
       concat_map,
       return$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax$0,
       Or_unequal_lengths,
       of_list,
       nth,
       nth_exn,
       rev,
       rev_append,
       unordered_append,
       rev_map,
       iter2_exn,
       iter2,
       rev_map2_exn,
       rev_map2,
       fold2_exn,
       fold2,
       for_alli,
       for_all2_exn,
       for_all2,
       existsi,
       exists2_exn,
       exists2,
       filter,
       rev_filter,
       filteri,
       partition_map,
       partition3_map,
       partition_tf,
       partition_result,
       split_n,
       sort,
       stable_sort,
       merge,
       hd,
       tl,
       hd_exn,
       tl_exn,
       findi,
       findi_exn,
       find_exn,
       find_map_exn,
       find_mapi,
       find_mapi_exn,
       append,
       map,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       concat_map,
       concat_mapi,
       map2_exn,
       map2,
       rev_map3_exn,
       rev_map3,
       map3_exn,
       map3,
       rev_map_append,
       fold_right,
       fold_left,
       unzip,
       unzip3,
       zip,
       zip_exn,
       mapi,
       rev_mapi,
       iteri,
       foldi,
       reduce_exn,
       reduce,
       reduce_balanced,
       reduce_balanced_exn,
       group,
       groupi,
       sort_and_group,
       chunks_of,
       last,
       last_exn,
       is_prefix,
       is_suffix,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       dedup_and_sort,
       find_a_dup,
       contains_dup,
       find_all_dups,
       all_equal,
       count,
       counti,
       range$0,
       range,
       init,
       rev_filter_map,
       rev_filter_mapi,
       filter_map,
       filter_mapi,
       filter_opt,
       [0,
        t_of_sexp$0,
        sexp_of_t$1,
        t_sexp_grammar$0,
        add,
        find$0,
        find_exn$0,
        mem$0,
        remove,
        map$2,
        inverse,
        group$0,
        sort_and_group$0],
       sub,
       take,
       drop,
       take_while,
       drop_while,
       split_while,
       drop_last,
       drop_last_exn,
       concat,
       concat_no_order,
       cons,
       cartesian_product,
       permute,
       random_element,
       random_element_exn,
       is_sorted,
       is_sorted_strictly,
       equal,
       Infix,
       transpose,
       transpose_exn,
       intersperse];
   runtime.caml_register_global(54, Base_List, "Base__List");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Info
//# unitInfo: Requires: Assert_failure, Base__Exn, Base__Hash, Base__Import, Base__Info_intf, Base__Lazy, Base__List, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Source_code_position0, Base__String0, CamlinternalLazy, Sexplib0__Sexp_conv, Stdlib__Format, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = ": ",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$4 = "",
    cst$3 = "; ",
    cst = cst$5,
    cst$0 = cst$5,
    cst$1 = cst$5,
    cst$2 = cst$5,
    t_sexp_grammar = [0, "Info.t"],
    module_name = "Base.Info",
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Exn = global_data.Base__Exn,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Lazy = global_data.Base__Lazy,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Assert_failure = global_data.Assert_failure,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_String0 = global_data.Base__String0,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    _l_ = [0, "src/info.ml", 204, 6],
    _a_ = [0, "Could_not_construct"],
    _b_ = [0, "String"],
    _c_ = [0, "Exn"],
    _d_ = [0, "Sexp"],
    _e_ = [0, "Tag_sexp"],
    _f_ = [0, "Tag_t"],
    _g_ = [0, "Tag_arg"],
    _h_ = [0, "Of_list"],
    _i_ = [0, "With_backtrace"],
    cst_could_not_construct_info = "could not construct info: ",
    _j_ =
      [0,
       [11, "and ", [4, 0, 0, 0, [11, " more info", 0]]],
       "and %d more info"],
    cst_Backtrace = "\nBacktrace:\n",
    cst_Base_Info_Exn = "Base__Info.Exn";
   function sexp_of_t(param){
    switch(param[0]){
      case 0:
       var arg0_001 = param[1], res0_002 = caml_call1(Base_Sexp[4], arg0_001);
       return [1, [0, _a_, [0, res0_002, 0]]];
      case 1:
       var
        arg0_003 = param[1],
        res0_004 = caml_call1(Base_Import[138], arg0_003);
       return [1, [0, _b_, [0, res0_004, 0]]];
      case 2:
       var
        arg0_005 = param[1],
        res0_006 = caml_call1(Base_Import[198], arg0_005);
       return [1, [0, _c_, [0, res0_006, 0]]];
      case 3:
       var arg0_007 = param[1], res0_008 = caml_call1(Base_Sexp[4], arg0_007);
       return [1, [0, _d_, [0, res0_008, 0]]];
      case 4:
       var
        arg2_011 = param[3],
        arg1_010 = param[2],
        arg0_009 = param[1],
        res0_012 = caml_call1(Base_Import[138], arg0_009),
        res1_013 = caml_call1(Base_Sexp[4], arg1_010),
        res2_014 =
          caml_call2
           (Base_Import[148], Base_Source_code_position0[8], arg2_011);
       return [1, [0, _e_, [0, res0_012, [0, res1_013, [0, res2_014, 0]]]]];
      case 5:
       var
        arg1_016 = param[2],
        arg0_015 = param[1],
        res0_017 = caml_call1(Base_Import[138], arg0_015),
        res1_018 = sexp_of_t(arg1_016);
       return [1, [0, _f_, [0, res0_017, [0, res1_018, 0]]]];
      case 6:
       var
        arg2_021 = param[3],
        arg1_020 = param[2],
        arg0_019 = param[1],
        res0_022 = caml_call1(Base_Import[138], arg0_019),
        res1_023 = caml_call1(Base_Sexp[4], arg1_020),
        res2_024 = sexp_of_t(arg2_021);
       return [1, [0, _g_, [0, res0_022, [0, res1_023, [0, res2_024, 0]]]]];
      case 7:
       var
        arg1_026 = param[2],
        arg0_025 = param[1],
        res0_027 = caml_call2(Base_Import[148], Base_Import[141], arg0_025),
        res1_028 = caml_call2(Base_Import[151], sexp_of_t, arg1_026);
       return [1, [0, _h_, [0, res0_027, [0, res1_028, 0]]]];
      default:
       var
        arg1_030 = param[2],
        arg0_029 = param[1],
        res0_031 = sexp_of_t(arg0_029),
        res1_032 = caml_call1(Base_Import[138], arg1_030);
       return [1, [0, _i_, [0, res0_031, [0, res1_032, 0]]]];
    }
   }
   function to_strings_hum(t, ac){
    var t$0 = t, ac$0 = ac;
    for(;;)
     switch(t$0[0]){
       case 0:
        var sexp = t$0[1];
        return [0,
                cst_could_not_construct_info,
                [0, caml_call1(Base_Sexp[16], sexp), ac$0]];
       case 1:
        var string = t$0[1]; return [0, string, ac$0];
       case 2:
        var exn = t$0[1], _R_ = caml_call1(Base_Exn[1], exn);
        return [0, caml_call1(Base_Sexp[16], _R_), ac$0];
       case 3:
        var sexp$0 = t$0[1];
        return [0, caml_call1(Base_Sexp[16], sexp$0), ac$0];
       case 4:
        var sexp$1 = t$0[2], tag = t$0[1];
        return [0,
                tag,
                [0, cst, [0, caml_call1(Base_Sexp[16], sexp$1), ac$0]]];
       case 5:
        var t$1 = t$0[2], tag$0 = t$0[1];
        return [0, tag$0, [0, cst$0, to_strings_hum(t$1, ac$0)]];
       case 6:
        var
         t$2 = t$0[3],
         sexp$2 = t$0[2],
         tag$1 = t$0[1],
         _S_ = [0, cst$1, to_strings_hum(t$2, ac$0)],
         body = [0, caml_call1(Base_Sexp[16], sexp$2), _S_];
        return 0 === caml_ml_string_length(tag$1)
                ? body
                : [0, tag$1, [0, cst$2, body]];
       case 7:
        var ts = t$0[2], trunc_after = t$0[1];
        if(trunc_after){
         var max = trunc_after[1], n = caml_call1(Base_List[7], ts);
         if(n <= max)
          var ts$0 = ts;
         else
          var
           _V_ = caml_call2(Base_Import[92], n, max),
           _W_ = [0, [1, caml_call2(Base_Printf[2], _j_, _V_)], 0],
           _X_ = caml_call2(Base_List[131], ts, max),
           ts$0 = caml_call2(Base_Import[110], _X_, _W_);
         var ts$1 = ts$0;
        }
        else
         var ts$1 = ts;
        var
         _T_ =
           function(ac, t){
            var ac$0 = caml_call1(Base_List[8], ac) ? ac : [0, cst$3, ac];
            return to_strings_hum(t, ac$0);
           },
         _U_ = caml_call1(Base_List[38], ts$1);
        return caml_call3(Base_List[10], _U_, ac$0, _T_);
       default:
        var
         backtrace = t$0[2],
         t$3 = t$0[1],
         ac$1 = [0, cst_Backtrace, [0, backtrace, ac$0]],
         t$0 = t$3,
         ac$0 = ac$1;
        continue;
     }
   }
   function to_sexps_hum(t, ac){
    switch(t[0]){
      case 0:
       return [0, sexp_of_t(t), ac];
      case 1:
       var string = t[1]; return [0, [0, string], ac];
      case 2:
       var exn = t[1]; return [0, caml_call1(Base_Exn[1], exn), ac];
      case 3:
       var sexp = t[1]; return [0, sexp, ac];
      case 4:
       var here = t[3], sexp$0 = t[2], tag = t[1];
       if(here)
        var
         here$0 = here[1],
         _O_ = [0, caml_call1(Base_Source_code_position0[8], here$0), 0];
       else
        var _O_ = 0;
       return [0, [1, [0, [0, tag], [0, sexp$0, _O_]]], ac];
      case 5:
       var t$0 = t[2], tag$0 = t[1];
       return [0, [1, [0, [0, tag$0], to_sexps_hum(t$0, 0)]], ac];
      case 6:
       var
        t$1 = t[3],
        sexp$1 = t[2],
        tag$1 = t[1],
        body = [0, sexp$1, to_sexps_hum(t$1, 0)];
       return 0 === caml_ml_string_length(tag$1)
               ? [0, [1, body], ac]
               : [0, [1, [0, [0, tag$1], body]], ac];
      case 7:
       var
        ts = t[2],
        _P_ = function(ac, t){return to_sexps_hum(t, ac);},
        _Q_ = caml_call1(Base_List[38], ts);
       return caml_call3(Base_List[10], _Q_, ac, _P_);
      default:
       var backtrace = t[2], t$2 = t[1];
       return [0, [1, [0, to_sexp_hum(t$2), [0, [0, backtrace], 0]]], ac];
    }
   }
   function to_sexp_hum(t){
    var sexps = to_sexps_hum(t, 0);
    if(sexps && ! sexps[2]){var sexp = sexps[1]; return sexp;}
    return [1, sexps];
   }
   function protect(f){
    try{var _N_ = caml_call1(f, 0); return _N_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     return [0, caml_call1(Base_Exn[1], exn)];
    }
   }
   function to_message(info){
    return protect
            (function(param){
              var _M_ = caml_obj_tag(info);
              return 250 === _M_
                      ? info[1]
                      : 246 === _M_ ? caml_call1(CamlinternalLazy[2], info) : info;
             });
   }
   function of_message(t){return [250, t];}
   function invariant(param){return 0;}
   function sexp_of_t$0(t){return to_sexp_hum(to_message(t));}
   function t_of_sexp(sexp){return [246, function(_L_){return [3, sexp];}];}
   function compare(t1, t2){
    var _J_ = sexp_of_t$0(t2), _K_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[6], _K_, _J_);
   }
   function equal(t1, t2){
    var _H_ = sexp_of_t$0(t2), _I_ = sexp_of_t$0(t1);
    return caml_call2(Base_Sexp[5], _I_, _H_);
   }
   function hash_fold_t(state, t){
    var _G_ = sexp_of_t$0(t);
    return caml_call2(Base_Sexp[1], state, _G_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string_hum(t){
    var message = to_message(t);
    if(1 === message[0]){var s = message[1]; return s;}
    var _F_ = to_sexp_hum(message);
    return caml_call2(Base_Sexp[15], 0, _F_);
   }
   function to_string_hum_deprecated(t){
    var t$0 = to_message(t), _E_ = to_strings_hum(t$0, 0);
    return caml_call2(Base_String0[14], 0, _E_);
   }
   function to_string_mach(t){
    var _D_ = sexp_of_t$0(t);
    return caml_call1(Base_Sexp[16], _D_);
   }
   function of_lazy(l){
    return [246,
            function(_A_){
             return protect
                     (function(param){
                       var
                        _B_ = caml_obj_tag(l),
                        _C_ =
                          250 === _B_
                           ? l[1]
                           : 246 === _B_ ? caml_call1(CamlinternalLazy[2], l) : l;
                       return [1, _C_];
                      });
            }];
   }
   function of_lazy_sexp(l){
    return [246,
            function(_x_){
             return protect
                     (function(param){
                       var
                        _y_ = caml_obj_tag(l),
                        _z_ =
                          250 === _y_
                           ? l[1]
                           : 246 === _y_ ? caml_call1(CamlinternalLazy[2], l) : l;
                       return [3, _z_];
                      });
            }];
   }
   function of_lazy_t(lazy_t){return caml_call1(Base_Lazy[13], lazy_t);}
   function of_string(message){
    return caml_call1(Base_Lazy[21], [1, message]);
   }
   function createf(format){
    return caml_call2(Base_Printf[4], of_string, format);
   }
   function of_thunk(f){
    return [246,
            function(_w_){
             return protect(function(param){return [1, caml_call1(f, 0)];});
            }];
   }
   function create(here, strict, tag, x, sexp_of_x){
    return strict
            ? [250, [4, tag, caml_call1(sexp_of_x, x), here]]
            : [246,
              function(_v_){
               return protect
                       (function(param){
                         return [4, tag, caml_call1(sexp_of_x, x), here];
                        });
              }];
   }
   function create_s(sexp){return caml_call1(Base_Lazy[21], [3, sexp]);}
   function tag(t, tag){
    return [246, function(param){return [5, tag, to_message(t)];}];
   }
   function tag_s_lazy(t, tag){
    return [246,
            function(_r_){
             return protect
                     (function(param){
                       var
                        _s_ = to_message(t),
                        _t_ = caml_obj_tag(tag),
                        _u_ =
                          250 === _t_
                           ? tag[1]
                           : 246 === _t_ ? caml_call1(CamlinternalLazy[2], tag) : tag;
                       return [6, cst$4, _u_, _s_];
                      });
            }];
   }
   function tag_s(t, tag){
    return tag_s_lazy(t, caml_call1(Base_Lazy[21], tag));
   }
   function tag_arg(t, tag, x, sexp_of_x){
    return [246,
            function(_p_){
             return protect
                     (function(param){
                       var _q_ = to_message(t);
                       return [6, tag, caml_call1(sexp_of_x, x), _q_];
                      });
            }];
   }
   function of_list(trunc_after, ts){
    return [246,
            function(param){
             return [7,
                     trunc_after,
                     caml_call2(Base_List[76], ts, to_message)];
            }];
   }
   var Exn = [248, cst_Base_Info_Exn, runtime.caml_fresh_oo_id(0)];
   function _k_(param){
    if(param[1] !== Exn)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    var t = param[2];
    return sexp_of_t$0(t);
   }
   caml_call4(Sexplib0_Sexp_conv[70][1], 0, 0, Exn, _k_);
   function to_exn(t){
    if(! caml_call1(Base_Lazy[22], t)) return [0, Exn, t];
    var
     _o_ = caml_obj_tag(t),
     match =
       250 === _o_
        ? t[1]
        : 246 === _o_ ? caml_call1(CamlinternalLazy[2], t) : t;
    if(2 !== match[0]) return [0, Exn, t];
    var exn = match[1];
    return exn;
   }
   function of_exn(backtrace, exn){
    if(backtrace){
     var match = backtrace[1];
     if(typeof match === "number")
      var _n_ = [0, caml_call1(Stdlib_Printexc[6], 0)];
     else
      var s = match[2], _n_ = [0, s];
     var backtrace$0 = _n_;
    }
    else
     var backtrace$0 = 0;
    if(exn[1] === Exn){
     var t = exn[2];
     if(! backtrace$0) return t;
     var backtrace$1 = backtrace$0[1];
     return [246, function(param){return [8, to_message(t), backtrace$1];}];
    }
    if(! backtrace$0) return caml_call1(Base_Lazy[21], [2, exn]);
    var backtrace$2 = backtrace$0[1];
    return [246,
            function(param){
             return [8, [3, caml_call1(Base_Exn[1], exn)], backtrace$2];
            }];
   }
   function pp(ppf, t){
    var _m_ = to_string_hum(t);
    return caml_call2(Stdlib_Format[13], ppf, _m_);
   }
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Info =
      [0,
       compare,
       equal,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       to_string_hum_deprecated,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       [0, sexp_of_t, to_message, of_message]];
   runtime.caml_register_global(37, Base_Info, "Base__Info");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Error
//# unitInfo: Requires: Base__Info, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [0, "Error.t"],
    module_name = "Base.Error",
    Base_Info = global_data.Base__Info,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Info[1],
    equal = Base_Info[2],
    hash_fold_t = Base_Info[3],
    hash = Base_Info[4],
    t_of_sexp = Base_Info[5],
    sexp_of_t = Base_Info[6],
    invariant = Base_Info[8],
    to_string_hum = Base_Info[9],
    to_string_mach = Base_Info[10],
    to_string_hum_deprecated = Base_Info[11],
    of_string = Base_Info[12],
    of_lazy = Base_Info[13],
    of_lazy_sexp = Base_Info[14],
    of_thunk = Base_Info[15],
    of_lazy_t = Base_Info[16],
    create = Base_Info[17],
    create_s = Base_Info[18],
    createf = Base_Info[19],
    tag = Base_Info[20],
    tag_s = Base_Info[21],
    tag_s_lazy = Base_Info[22],
    tag_arg = Base_Info[23],
    of_list = Base_Info[24],
    of_exn = Base_Info[25],
    to_exn = Base_Info[26],
    pp = Base_Info[27],
    Internal_repr = Base_Info[28];
   function raise(t){
    throw caml_maybe_attach_backtrace(caml_call1(to_exn, t), 1);
   }
   function raise_s(sexp){return raise(caml_call1(create_s, sexp));}
   function to_info(t){return t;}
   function of_info(t){return t;}
   var
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    Base_Error =
      [0,
       compare,
       equal,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       to_string_hum,
       to_string_mach,
       to_string_hum_deprecated,
       of_string,
       of_lazy,
       of_lazy_sexp,
       of_thunk,
       of_lazy_t,
       create,
       create_s,
       createf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       of_list,
       of_exn,
       to_exn,
       pp$0,
       Internal_repr,
       raise,
       raise_s,
       to_info,
       of_info];
   runtime.caml_register_global(4, Base_Error, "Base__Error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Invariant
//# unitInfo: Requires: Base__Error, Base__Field, Base__Import, Base__Invariant_intf, Base__Sexp, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_exn$1 = "exn",
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$1,
    cst$0 = cst$1,
    Base_Field = global_data.Base__Field,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[30],
    cst_exn$0 = cst_exn$1,
    cst_field = "field",
    cst_problem_with_field = "problem with field",
    cst_exn = cst_exn$1,
    cst_invariant_failed = "invariant failed";
   function invariant(here, t, sexp_of_t, f){
    try{var _h_ = caml_call1(f, 0); return _h_;}
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _e_ = [0, [0, cst, caml_call1(sexp_of_t, t)], 0],
      _f_ = [0, [0, cst_exn, caml_call1(Base_Import[198], exn)], _e_],
      _g_ =
        [0, [0, cst$0, caml_call1(Base_Source_code_position0[8], here)], _f_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[9], cst_invariant_failed, _g_));
    }
   }
   function check_field(t, f, field){
    try{
     var _d_ = caml_call1(f, caml_call2(Base_Field[3], field, t));
     return _d_;
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      _a_ = [0, [0, cst_exn$0, caml_call1(Base_Import[198], exn)], 0],
      _b_ = caml_call1(Base_Field[2], field),
      _c_ = [0, [0, cst_field, caml_call1(Base_Import[138], _b_)], _a_];
     return caml_call1
             (raise_s, caml_call2(Base_Sexp[9], cst_problem_with_field, _c_));
    }
   }
   var Base_Invariant = [0, invariant, check_field];
   runtime.caml_register_global(12, Base_Invariant, "Base__Invariant");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Or_error
//# unitInfo: Requires: Assert_failure, Base__Applicative, Base__Error, Base__Import, Base__List, Base__Printf, Base__Result, Base__With_return
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Base_Error = global_data.Base__Error,
    Base_With_return = global_data.Base__With_return,
    Assert_failure = global_data.Assert_failure,
    Base_Result = global_data.Base__Result,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Applicative = global_data.Base__Applicative,
    ignore_m = Base_Result[14],
    join = Base_Result[13],
    return$0 = Base_Result[12],
    bind = Base_Result[11],
    symbol_bind = Base_Result[7],
    _c_ = [0, "src/or_error.ml", 135, 22],
    cst_unimplemented = "unimplemented",
    _b_ = [0, 3553398],
    _a_ = Base_Result[30];
   function compare(cmp_a, a_001, b_002){
    return caml_call4(Base_Result[4], cmp_a, Base_Error[1], a_001, b_002);
   }
   function equal(cmp_a, a_007, b_008){
    return caml_call4(Base_Result[5], cmp_a, Base_Error[2], a_007, b_008);
   }
   function hash_fold_t(hash_fold_a, hsv, arg){
    return caml_call4(Base_Result[6], hash_fold_a, Base_Error[3], hsv, arg);
   }
   function t_of_sexp(of_a_013, x_015){
    return caml_call3(Base_Result[1], of_a_013, Base_Error[5], x_015);
   }
   function sexp_of_t(of_a_016, x_017){
    return caml_call3(Base_Result[2], of_a_016, Base_Error[6], x_017);
   }
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call2(Base_Result[3], a_sexp_grammar, Base_Error[7]);
   }
   function invariant(invariant_a, t){
    if(0 === t[0]){var a = t[1]; return caml_call1(invariant_a, a);}
    var error = t[1];
    return caml_call1(Base_Error[8], error);
   }
   function apply(f, x){
    function _y_(e1, e2){
     return caml_call2(Base_Error[24], 0, [0, e1, [0, e2, 0]]);
    }
    function _z_(f, x){return caml_call1(f, x);}
    return caml_call4(Base_Result[32], f, x, _z_, _y_);
   }
   var
    map = [0, -198771759, _a_],
    include = caml_call1(Base_Applicative[5], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13],
    include$0 = Base_Result[10],
    symbol_bind$0 = include$0[1],
    symbol_map$0 = include$0[2],
    Open_on_rhs = [0],
    ok = Base_Result[23],
    is_ok = Base_Result[21],
    is_error = Base_Result[22];
   function try_with(opt, f){
    if(opt) var sth = opt[1], backtrace = sth; else var backtrace = 0;
    try{var _x_ = [0, caml_call1(f, 0)]; return _x_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0), _w_ = backtrace ? _b_ : 0;
     return [1, caml_call2(Base_Error[25], _w_, exn)];
    }
   }
   function try_with_join(backtrace, f){
    return caml_call1(join, try_with(backtrace, f));
   }
   function ok_exn(param){
    if(0 === param[0]){var x = param[1]; return x;}
    var err = param[1];
    return caml_call1(Base_Error[29], err);
   }
   function of_exn(backtrace, exn){
    return [1, caml_call2(Base_Error[25], backtrace, exn)];
   }
   function of_exn_result(backtrace, z){
    if(0 === z[0]) return z;
    var exn = z[1];
    return of_exn(backtrace, exn);
   }
   function error(here, strict, message, a, sexp_of_a){
    return [1,
            caml_call5(Base_Error[17], here, strict, message, a, sexp_of_a)];
   }
   function error_s(sexp){return [1, caml_call1(Base_Error[18], sexp)];}
   function error_string(message){
    return [1, caml_call1(Base_Error[12], message)];
   }
   function errorf(format){
    return caml_call2(Base_Printf[4], error_string, format);
   }
   function tag(t, tag){
    var _t_ = Base_Error[20];
    function _u_(_v_){return caml_call2(_t_, _v_, tag);}
    return caml_call2(Base_Result[31], t, _u_);
   }
   function tag_s(t, tag){
    var _q_ = Base_Error[21];
    function _r_(_s_){return caml_call2(_q_, _s_, tag);}
    return caml_call2(Base_Result[31], t, _r_);
   }
   function tag_s_lazy(t, tag){
    var _n_ = Base_Error[22];
    function _o_(_p_){return caml_call2(_n_, _p_, tag);}
    return caml_call2(Base_Result[31], t, _o_);
   }
   function tag_arg(t, message, a, sexp_of_a){
    function _m_(e){
     return caml_call4(Base_Error[23], e, message, a, sexp_of_a);
    }
    return caml_call2(Base_Result[31], t, _m_);
   }
   function unimplemented(s){
    return error(0, 0, cst_unimplemented, s, Base_Import[138]);
   }
   function combine_errors(l){
    var arg = Base_Error[24];
    function _k_(eta){return caml_call2(arg, 0, eta);}
    var _l_ = caml_call1(Base_Result[33], l);
    return caml_call2(Base_Result[31], _l_, _k_);
   }
   function combine_errors_unit(l){
    function _i_(param){return 0;}
    var _j_ = combine_errors(l);
    return caml_call2(Base_Result[30], _j_, _i_);
   }
   function filter_ok_at_least_one(l){
    var
     match = caml_call2(Base_List[57], l, Base_Result[35]),
     errs = match[2],
     ok = match[1];
    return ok ? [0, ok] : [1, caml_call2(Base_Error[24], 0, errs)];
   }
   function find_ok(l){
    var match = caml_call2(Base_List[17], l, Base_Result[23]);
    if(match){var x = match[1]; return [0, x];}
    function _g_(param){
     if(0 === param[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     var err = param[1];
     return err;
    }
    var _h_ = caml_call2(Base_List[76], l, _g_);
    return [1, caml_call2(Base_Error[24], 0, _h_)];
   }
   function find_map_ok(l, f){
    function _d_(param){
     function _e_(elt){
      var x = caml_call1(f, elt);
      if(0 === x[0]) return caml_call1(param, x);
      var err = x[1];
      return err;
     }
     var _f_ = caml_call2(Base_List[76], l, _e_);
     return [1, caml_call2(Base_Error[24], 0, _f_)];
    }
    return caml_call1(Base_With_return[1], _d_);
   }
   var
    map$1 = Base_Result[30],
    iter = Base_Result[28],
    iter_error = Base_Result[29],
    Base_Or_error =
      [0,
       compare,
       equal,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       invariant,
       symbol_bind,
       symbol_map,
       Base_Result[10],
       bind,
       return$1,
       join,
       ignore_m,
       all,
       all_unit,
       [0,
        return$1,
        symbol_bind$0,
        symbol_map$0,
        [0, return$1, bind, map$0, both, Open_on_rhs]],
       is_ok,
       is_error,
       try_with,
       try_with_join,
       ok,
       ok_exn,
       of_exn,
       of_exn_result,
       error,
       error_s,
       error_string,
       errorf,
       tag,
       tag_s,
       tag_s_lazy,
       tag_arg,
       unimplemented,
       map$1,
       iter,
       iter_error,
       combine_errors,
       combine_errors_unit,
       filter_ok_at_least_one,
       find_ok,
       find_map_ok];
   runtime.caml_register_global(11, Base_Or_error, "Base__Or_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign0
//# unitInfo: Requires: Base__Hash, Base__Import, Base__Poly0, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero = "zero",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign0.ml.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0, [1, [0, cst_Zero, 0]], [0, [1, [0, cst_Pos, 0]], 0]]]]],
    all = [0, 0, [0, 1, [0, 2, 0]]],
    module_name = "Base.Sign",
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos];
   function t_of_sexp(sexp_004){
    if(0 === sexp_004[0]){
     var _e_ = sexp_004[1], switch$0 = 0;
     if(caml_string_notequal(_e_, cst_Neg)){
      var switch$1 = 0;
      if(caml_string_notequal(_e_, cst_Pos)){
       var switch$2 = 0;
       if(caml_string_notequal(_e_, cst_Zero)){
        if(caml_string_notequal(_e_, cst_neg))
         if(caml_string_notequal(_e_, cst_pos))
          if(caml_string_notequal(_e_, cst_zero))
           switch$0 = 1;
          else
           switch$2 = 1;
         else
          switch$1 = 1;
       }
       else
        switch$2 = 1;
       if(switch$2) return 1;
      }
      else
       switch$1 = 1;
      if(switch$1) return 2;
     }
     if(! switch$0) return 0;
    }
    else{
     var _f_ = sexp_004[1];
     if(! _f_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     var _g_ = _f_[1];
     if(0 !== _g_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_003, sexp_004);
     var _h_ = _g_[1], switch$3 = 0;
     if(caml_string_notequal(_h_, cst_Neg)){
      var switch$4 = 0;
      if(caml_string_notequal(_h_, cst_Pos)){
       var switch$5 = 0;
       if(caml_string_notequal(_h_, cst_Zero)){
        if(caml_string_notequal(_h_, cst_neg))
         if(caml_string_notequal(_h_, cst_pos))
          if(caml_string_notequal(_h_, cst_zero))
           switch$3 = 1;
          else
           switch$5 = 1;
         else
          switch$4 = 1;
       }
       else
        switch$5 = 1;
       if(switch$5)
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
      }
      else
       switch$4 = 1;
      if(switch$4)
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
     }
     if(! switch$3)
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){case 0: return _a_;case 1: return _b_;default: return _c_;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    Replace_polymorphic_compare =
      [0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       ascending,
       descending,
       compare$0,
       equal,
       max,
       min];
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[138], s));}
   function to_string(t){
    var _d_ = sexp_of_t(t);
    return caml_call1(Base_Import[162], _d_);
   }
   function to_int(param){
    switch(param){case 0: return -1;case 1: return 0;default: return 1;
    }
   }
   function of_int(n){return 0 <= n ? 0 === n ? 1 : 2 : 0;}
   var
    Base_Sign0 =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       hash_fold_t,
       all,
       Replace_polymorphic_compare,
       of_string,
       to_string,
       to_int,
       to_int,
       module_name,
       of_int];
   runtime.caml_register_global(23, Base_Sign0, "Base__Sign0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Comparable_intf = [0];
   runtime.caml_register_global
    (0, Base_Comparable_intf, "Base__Comparable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Comparable
//# unitInfo: Requires: Assert_failure, Base__Comparable_intf, Base__Comparator, Base__Or_error, Base__Poly0, Base__Sexp, Base__Sign0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_clamp_requires_min_max$1 = "clamp requires [min <= max]",
    cst_max$1 = "max",
    cst_min$1 = "min",
    cst_src_comparable_ml = "src/comparable.ml",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparator = global_data.Base__Comparator,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Sign0 = global_data.Base__Sign0,
    cst_max$0 = cst_max$1,
    cst_min$0 = cst_min$1,
    cst_clamp_requires_min_max$0 = cst_clamp_requires_min_max$1,
    _b_ = [0, cst_src_comparable_ml, 133, 4],
    cst_max = cst_max$1,
    cst_min = cst_min$1,
    cst_clamp_requires_min_max = cst_clamp_requires_min_max$1,
    _a_ = [0, cst_src_comparable_ml, 47, 4];
   function geq(cmp, a, b){return 0 <= caml_call2(cmp, a, b) ? 1 : 0;}
   function leq(cmp, a, b){return caml_call2(cmp, a, b) <= 0 ? 1 : 0;}
   function equal(cmp, a, b){return 0 === caml_call2(cmp, a, b) ? 1 : 0;}
   function min(cmp, t$0, t){return leq(cmp, t$0, t) ? t$0 : t;}
   function max(cmp, t$0, t){return geq(cmp, t$0, t) ? t$0 : t;}
   function Infix(T){
    function symbol(a, b){
     var cmp = T[1];
     return 0 < caml_call2(cmp, a, b) ? 1 : 0;
    }
    function symbol$0(a, b){
     var cmp = T[1];
     return caml_call2(cmp, a, b) < 0 ? 1 : 0;
    }
    function symbol$1(a, b){return geq(T[1], a, b);}
    function symbol$2(a, b){return leq(T[1], a, b);}
    function symbol$3(a, b){return equal(T[1], a, b);}
    function symbol$4(a, b){
     var cmp = T[1];
     return 0 !== caml_call2(cmp, a, b) ? 1 : 0;
    }
    return [0, symbol$1, symbol$2, symbol$3, symbol, symbol$0, symbol$4];
   }
   function Polymorphic_compare(T){
    var
     include = Infix(T),
     symbol = include[1],
     symbol$0 = include[2],
     symbol$1 = include[3],
     symbol$2 = include[4],
     symbol$3 = include[5],
     symbol$4 = include[6],
     compare = T[1];
    function min$0(t$0, t){return min(compare, t$0, t);}
    function max$0(t$0, t){return max(compare, t$0, t);}
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            symbol$1,
            compare,
            min$0,
            max$0];
   }
   function Make_using_comparator(T){
    var
     sexp_of_t = T[1],
     comparator = T[2],
     compare = comparator[1],
     Replace_polymorphic_compare = Polymorphic_compare([0, compare]),
     symbol = Replace_polymorphic_compare[1],
     symbol$0 = Replace_polymorphic_compare[2],
     symbol$1 = Replace_polymorphic_compare[3],
     symbol$2 = Replace_polymorphic_compare[4],
     symbol$3 = Replace_polymorphic_compare[5],
     symbol$4 = Replace_polymorphic_compare[6],
     equal = Replace_polymorphic_compare[7],
     compare$0 = Replace_polymorphic_compare[8],
     min = Replace_polymorphic_compare[9],
     max = Replace_polymorphic_compare[10];
    function descending(t$0, t){return caml_call2(compare$0, t, t$0);}
    function between(t, low, high){
     var _s_ = caml_call2(symbol$0, low, t);
     return _s_ ? caml_call2(symbol$0, t, high) : _s_;
    }
    function clamp_unchecked(t, min, max){
     return caml_call2(symbol$3, t, min)
             ? min
             : caml_call2(symbol$0, t, max) ? t : max;
    }
    function clamp_exn(t, min, max){
     if(caml_call2(symbol$0, min, max)) return clamp_unchecked(t, min, max);
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    }
    function clamp(t, min, max){
     if(! caml_call2(symbol$2, min, max))
      return [0, clamp_unchecked(t, min, max)];
     var
      _p_ = [0, [0, cst_max$0, caml_call1(sexp_of_t, max)], 0],
      _q_ = [0, [0, cst_min$0, caml_call1(sexp_of_t, min)], _p_],
      _r_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max$0, _q_);
     return caml_call1(Base_Or_error[35], _r_);
    }
    return [0,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare$0,
            min,
            max,
            compare$0,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator];
   }
   function Make(T){
    var
     sexp_of_t = T[2],
     include = caml_call1(Base_Comparator[5], T),
     comparator = include[1];
    return Make_using_comparator([0, sexp_of_t, comparator]);
   }
   function Inherit(C, T){
    var sexp_of_t = T[1];
    function compare(t$0, t){
     var _n_ = caml_call1(T[2], t), _o_ = caml_call1(T[2], t$0);
     return caml_call2(C[1], _o_, _n_);
    }
    return Make([0, compare, sexp_of_t]);
   }
   function lexicographic(cmps, x, y){
    var param = cmps;
    for(;;){
     if(! param) return 0;
     var cmps$0 = param[2], cmp = param[1], res = caml_call2(cmp, x, y);
     if(0 !== res) return res;
     var param = cmps$0;
    }
   }
   function lift(cmp, f, x, y){
    var _m_ = caml_call1(f, y);
    return caml_call2(cmp, caml_call1(f, x), _m_);
   }
   function reverse(cmp, x, y){return caml_call2(cmp, y, x);}
   function _c_(_i_){
    var _j_ = _i_[3], _k_ = _i_[1];
    function is_positive(t){return 0 < caml_call2(_k_, t, _j_) ? 1 : 0;}
    function is_non_negative(t){return 0 <= caml_call2(_k_, t, _j_) ? 1 : 0;}
    function is_negative(t){return caml_call2(_k_, t, _j_) < 0 ? 1 : 0;}
    function is_non_positive(t){return caml_call2(_k_, t, _j_) <= 0 ? 1 : 0;}
    function sign(t){
     var _l_ = caml_call2(_k_, t, _j_);
     return caml_call1(Base_Sign0[13], _l_);
    }
    return [0,
            is_positive,
            is_non_negative,
            is_negative,
            is_non_positive,
            sign];
   }
   var
    Base_Comparable =
      [0,
       lexicographic,
       lift,
       reverse,
       equal,
       max,
       min,
       Infix,
       Polymorphic_compare,
       Inherit,
       Make,
       Make_using_comparator,
       function(T){
        var
         sexp_of_t = T[1],
         ascending = Base_Poly0[1],
         descending = Base_Poly0[2],
         min = Base_Poly0[3],
         max = Base_Poly0[4];
        function between(t, low, high){
         var
          _g_ = caml_lessequal(low, t),
          _h_ = _g_ ? caml_lessequal(t, high) : _g_;
         return _h_;
        }
        function clamp_unchecked(t, min, max){
         return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
        }
        function clamp_exn(t, min, max){
         if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
         throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
        }
        function clamp(t, min, max){
         if(! caml_greaterthan(min, max))
          return [0, clamp_unchecked(t, min, max)];
         var
          _d_ = [0, [0, cst_max, caml_call1(T[1], max)], 0],
          _e_ = [0, [0, cst_min, caml_call1(T[1], min)], _d_],
          _f_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _e_);
         return caml_call1(Base_Or_error[35], _f_);
        }
        var
         include =
           caml_call1(Base_Comparator[5], [0, caml_compare, sexp_of_t]),
         comparator = include[1];
        return [0,
                runtime.caml_greaterequal,
                caml_lessequal,
                caml_equal,
                caml_greaterthan,
                caml_lessthan,
                runtime.caml_notequal,
                caml_equal,
                caml_compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator];
       },
       _c_];
   runtime.caml_register_global(14, Base_Comparable, "Base__Comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable_intf
//# unitInfo: Requires: Base__Import, Stdlib__MoreLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    _a_ = [0, "_"];
   function equal(a, b){
    var _b_ = caml_call2(Base_Import[127], a, b);
    if(_b_)
     var _c_ = _b_;
    else{
     var _d_ = caml_call2(Base_Import[127], a[1], b[1]);
     if(_d_){
      var _e_ = caml_call2(Base_Import[127], a[2], b[2]);
      if(_e_) return caml_call2(Base_Import[127], a[3], b[3]);
      var _c_ = _e_;
     }
     else
      var _c_ = _d_;
    }
    return _c_;
   }
   var
    hash_param = Stdlib_MoreLabels[1][30],
    hash = Stdlib_MoreLabels[1][28],
    poly = [0, hash, runtime.caml_compare, function(param){return _a_;}];
   function of_key(Key){return [0, Key[3], Key[1], Key[2]];}
   function to_key(param){
    var sexp_of_t = param[3], compare = param[2], hash = param[1];
    return [0, compare, sexp_of_t, hash];
   }
   var
    Hashable = [0, equal, hash_param, hash, poly, of_key, to_key],
    equal$0 = Hashable[1],
    hash_param$0 = Hashable[2],
    hash$0 = Hashable[3],
    poly$0 = Hashable[4],
    of_key$0 = Hashable[5],
    to_key$0 = Hashable[6],
    Base_Hashable_intf =
      [0, Hashable, equal$0, hash_param$0, hash$0, poly$0, of_key$0, to_key$0];
   runtime.caml_register_global(3, Base_Hashable_intf, "Base__Hashable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashable
//# unitInfo: Requires: Base__Hashable_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Base_Hashable_intf = global_data.Base__Hashable_intf,
    equal = Base_Hashable_intf[2],
    hash_param = Base_Hashable_intf[3],
    hash = Base_Hashable_intf[4],
    poly = Base_Hashable_intf[5],
    of_key = Base_Hashable_intf[6],
    to_key = Base_Hashable_intf[7],
    Base_Hashable = [0, equal, poly, of_key, to_key, hash_param, hash];
   runtime.caml_register_global(1, Base_Hashable, "Base__Hashable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stringable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stringable = [0];
   runtime.caml_register_global(0, Base_Stringable, "Base__Stringable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Identifiable_intf = [0];
   runtime.caml_register_global
    (0, Base_Identifiable_intf, "Base__Identifiable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Identifiable
//# unitInfo: Requires: Base__Comparable, Base__Identifiable_intf, Base__Pretty_printer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer;
   function _a_(T){
    var
     hash_fold_t = T[2],
     hash = T[3],
     t_of_sexp = T[4],
     sexp_of_t = T[5],
     of_string = T[6],
     to_string = T[7],
     _c_ = caml_call1(Base_Comparable[11], [0, T[5], T[9]]),
     symbol = _c_[1],
     symbol$0 = _c_[2],
     symbol$1 = _c_[3],
     symbol$2 = _c_[4],
     symbol$3 = _c_[5],
     symbol$4 = _c_[6],
     equal = _c_[7],
     compare = _c_[8],
     min = _c_[9],
     max = _c_[10],
     ascending = _c_[11],
     descending = _c_[12],
     between = _c_[13],
     clamp_exn = _c_[14],
     clamp = _c_[15],
     comparator = _c_[16],
     include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
     pp = include[1],
     hashable = [0, hash, compare, sexp_of_t];
    return [0,
            hash_fold_t,
            hash,
            t_of_sexp,
            sexp_of_t,
            of_string,
            to_string,
            symbol,
            symbol$0,
            symbol$1,
            symbol$2,
            symbol$3,
            symbol$4,
            equal,
            compare,
            min,
            max,
            ascending,
            descending,
            between,
            clamp_exn,
            clamp,
            comparator,
            pp,
            hashable];
   }
   var
    Base_Identifiable =
      [0,
       function(T){
        var
         hash_fold_t = T[2],
         hash = T[3],
         t_of_sexp = T[4],
         sexp_of_t = T[5],
         of_string = T[6],
         to_string = T[7],
         _b_ = caml_call1(Base_Comparable[10], [0, T[1], T[5]]),
         symbol = _b_[1],
         symbol$0 = _b_[2],
         symbol$1 = _b_[3],
         symbol$2 = _b_[4],
         symbol$3 = _b_[5],
         symbol$4 = _b_[6],
         equal = _b_[7],
         compare = _b_[8],
         min = _b_[9],
         max = _b_[10],
         ascending = _b_[11],
         descending = _b_[12],
         between = _b_[13],
         clamp_exn = _b_[14],
         clamp = _b_[15],
         comparator = _b_[16],
         include = caml_call1(Base_Pretty_printer[2], [0, T[8], T[7]]),
         pp = include[1],
         hashable = [0, hash, compare, sexp_of_t];
        return [0,
                hash_fold_t,
                hash,
                t_of_sexp,
                sexp_of_t,
                of_string,
                to_string,
                symbol,
                symbol$0,
                symbol$1,
                symbol$2,
                symbol$3,
                symbol$4,
                equal,
                compare,
                min,
                max,
                ascending,
                descending,
                between,
                clamp_exn,
                clamp,
                comparator,
                pp,
                hashable];
       },
       _a_];
   runtime.caml_register_global(2, Base_Identifiable, "Base__Identifiable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Unit
//# unitInfo: Requires: Base__Identifiable, Base__Import
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst$0 = "()";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = cst$0,
    all = [0, 0, 0],
    module_name = "Base.Unit",
    Base_Import = global_data.Base__Import,
    Base_Identifiable = global_data.Base__Identifiable,
    hash_fold_t = Base_Import[210],
    func = Base_Import[224],
    cst_Base_Unit_of_string_expect = "Base.Unit.of_string: () expected";
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[160],
    sexp_of_t = Base_Import[136],
    t_sexp_grammar = Base_Import[180];
   function compare(param, _a_){return 0;}
   function of_string(param){
    return runtime.caml_string_notequal(param, cst$0)
            ? caml_call1(Base_Import[123], cst_Base_Unit_of_string_expect)
            : 0;
   }
   function to_string(param){return cst;}
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24];
   function invariant(param){return 0;}
   var
    Base_Unit =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       invariant];
   runtime.caml_register_global(7, Base_Unit, "Base__Unit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ordered_collection_common
//# unitInfo: Requires: Base__Or_error, Base__Ordered_collection_common0, Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Base_Or_error = global_data.Base__Or_error,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common0,
    get_pos_len_exn = Base_Ordered_collection_common[1],
    check_pos_len_exn = Base_Ordered_collection_common[2],
    Private = Base_Ordered_collection_common[3];
   function get_pos_len(pos, len, param, total_length){
    try{
     var _a_ = [0, caml_call4(get_pos_len_exn, pos, len, 0, total_length)];
     return _a_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var s = exn[2];
     return caml_call1(Base_Or_error[36], s);
    }
   }
   var
    Base_Ordered_collection_common$0 =
      [0, get_pos_len_exn, check_pos_len_exn, Private, get_pos_len];
   runtime.caml_register_global
    (3, Base_Ordered_collection_common$0, "Base__Ordered_collection_common");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_search
//# unitInfo: Requires: Base__Fn, Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Fn = global_data.Base__Fn;
   function find_first_satisfying(pos, len, t, get, length, pred){
    var
     _e_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _e_),
     len$0 = match[2],
     pos$0 = match[1],
     _f_ = caml_call2(Base_Import[90], pos$0, len$0),
     hi$0 = caml_call2(Base_Import[92], _f_, 1),
     lo$1 = pos$0,
     hi = hi$0;
    for(;;){
     if(8 < caml_call2(Base_Import[92], hi, lo$1)){
      var
       _c_ = caml_call2(Base_Import[92], hi, lo$1),
       _d_ = caml_call2(Base_Import[94], _c_, 2),
       mid = caml_call2(Base_Import[90], lo$1, _d_);
      if(caml_call1(pred, caml_call2(get, t, mid))){var hi = mid; continue;}
      var lo$2 = caml_call2(Base_Import[90], mid, 1), lo$1 = lo$2;
      continue;
     }
     var lo = lo$1;
     for(;;){
      if(hi < lo) return 0;
      if(caml_call1(pred, caml_call2(get, t, lo))) return [0, lo];
      var lo$0 = caml_call2(Base_Import[90], lo, 1), lo = lo$0;
     }
    }
   }
   function find_last_satisfying(pos, len, t, pred, get, length){
    var
     _a_ = caml_call1(length, t),
     match = caml_call4(Base_Ordered_collection_common[1], pos, len, 0, _a_),
     len$0 = match[2],
     pos$0 = match[1];
    if(0 === len$0) return 0;
    var
     match$0 =
       find_first_satisfying
        ([0, pos$0], [0, len$0], t, get, length, caml_call1(Base_Fn[2], pred));
    if(match$0){
     var i = match$0[1];
     return i === pos$0 ? 0 : [0, caml_call2(Base_Import[92], i, 1)];
    }
    var _b_ = caml_call2(Base_Import[90], pos$0, len$0);
    return [0, caml_call2(Base_Import[92], _b_, 1)];
   }
   function binary_search(pos, len, t, length, get, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;},
                  get,
                  length)
             : -253007807
               <= how
               ? find_last_satisfying
                 (pos,
                  len,
                  t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
                  get,
                  length)
               : find_first_satisfying
                 (pos,
                  len,
                  t,
                  get,
                  length,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      match =
        find_last_satisfying
         (pos,
          len,
          t,
          function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;},
          get,
          length);
     if(match){
      var x = match[1];
      if(0 === caml_call2(compare, caml_call2(get, t, x), v)) return [0, x];
     }
     return 0;
    }
    var
     match$0 =
       find_first_satisfying
        (pos,
         len,
         t,
         get,
         length,
         function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(match$0){
     var x$0 = match$0[1];
     if(0 === caml_call2(compare, caml_call2(get, t, x$0), v))
      return [0, x$0];
    }
    return 0;
   }
   function binary_search_segmented(pos, len, t, length, get, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(pos, len, t, is_left, get, length)
            : find_first_satisfying(pos, len, t, get, length, is_right);
   }
   var Base_Binary_search = [0, binary_search, binary_search_segmented];
   runtime.caml_register_global(3, Base_Binary_search, "Base__Binary_search");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    all =
      [0,
       200870407,
       [0,
        -253007807,
        [0, -1055410545, [0, -1056898635, [0, 926943384, [0, -839473056, 0]]]]]],
    all$0 = [0, 125585502, [0, -63348021, 0]],
    Which_target_by_key = [0, all],
    Which_target_by_segment = [0, all$0],
    Base_Binary_searchable_intf =
      [0, Which_target_by_key, Which_target_by_segment];
   runtime.caml_register_global
    (2, Base_Binary_searchable_intf, "Base__Binary_searchable_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Binary_searchable
//# unitInfo: Requires: Base__Binary_search, Base__Binary_searchable_intf
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   function caml_call8(f, a0, a1, a2, a3, a4, a5, a6, a7){
    return (f.l >= 0 ? f.l : f.l = f.length) == 8
            ? f(a0, a1, a2, a3, a4, a5, a6, a7)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6, a7]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Binary_search = global_data.Base__Binary_search;
   function Make_gen(T){
    var get = T[1], length = T[2];
    function binary_search(pos, len, t, compare, how, v){
     return caml_call8
             (Base_Binary_search[1],
              pos,
              len,
              t,
              length,
              get,
              compare,
              how,
              v);
    }
    function binary_search_segmented(pos, len, t, segment_of, how){
     return caml_call7
             (Base_Binary_search[2],
              pos,
              len,
              t,
              length,
              get,
              segment_of,
              how);
    }
    return [0, get, length, binary_search, binary_search_segmented];
   }
   function _a_(T){
    var get = T[1], length = T[2], _c_ = Make_gen([0, get, length]);
    return [0, _c_[3], _c_[4]];
   }
   var
    Base_Binary_searchable =
      [0,
       function(T){
        var get = T[1], length = T[2], _b_ = Make_gen([0, get, length]);
        return [0, _b_[3], _b_[4]];
       },
       _a_];
   runtime.caml_register_global
    (1, Base_Binary_searchable, "Base__Binary_searchable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Blit_intf = [0];
   runtime.caml_register_global(0, Base_Blit_intf, "Base__Blit_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Blit
//# unitInfo: Requires: Base__Blit_intf, Base__Bytes0, Base__Import, Base__Ordered_collection_common
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common;
   function Make_gen(Src, Dst){
    var unsafe_blit = Dst[3];
    function blit(src, src_pos, dst, dst_pos, len){
     var _q_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], src_pos, len, _q_);
     var _r_ = caml_call1(Dst[1], dst);
     caml_call3(Base_Ordered_collection_common[2], dst_pos, len, _r_);
     var _s_ = 0 < len ? 1 : 0;
     return _s_
             ? caml_call5(unsafe_blit, src, src_pos, dst, dst_pos, len)
             : _s_;
    }
    function blito(src, opt, _o_, dst, _n_, param){
     if(opt) var sth = opt[1], src_pos = sth; else var src_pos = 0;
     if(_o_)
      var sth$0 = _o_[1], src_len = sth$0;
     else
      var
       _p_ = caml_call1(Src[1], src),
       src_len = caml_call2(Base_Import[92], _p_, src_pos);
     if(_n_) var sth$1 = _n_[1], dst_pos = sth$1; else var dst_pos = 0;
     return blit(src, src_pos, dst, dst_pos, src_len);
    }
    function sub(src, pos, len){
     var _m_ = caml_call1(Src[1], src);
     caml_call3(Base_Ordered_collection_common[2], pos, len, _m_);
     var dst = caml_call2(Dst[2], len, src);
     if(0 < len) caml_call5(unsafe_blit, src, pos, dst, 0, len);
     return dst;
    }
    function subo(opt, len, src){
     if(opt) var sth = opt[1], pos = sth; else var pos = 0;
     if(len)
      var i = len[1], i$0 = i;
     else
      var
       _l_ = caml_call1(Src[1], src),
       i$0 = caml_call2(Base_Import[92], _l_, pos);
     return sub(src, pos, i$0);
    }
    return [0, unsafe_blit, blit, blito, sub, subo];
   }
   function Make_to_string(T, To_bytes){
    function sub(src, pos, len){
     var _k_ = caml_call3(To_bytes[4], src, pos, len);
     return caml_call1(Base_Bytes0[16], _k_);
    }
    function subo(pos, len, src){
     var _j_ = caml_call3(To_bytes[5], pos, len, src);
     return caml_call1(Base_Bytes0[16], _j_);
    }
    return [0, sub, subo];
   }
   function _a_(_h_){
    var _i_ = Make_gen([0, _h_[2]], [0, _h_[2], _h_[1], _h_[3]]);
    return [0, _i_[2], _i_[3], _i_[1], _i_[4], _i_[5]];
   }
   function _b_(_e_){
    var _f_ = [0, _e_[2], _e_[1], _e_[3]], _g_ = Make_gen([0, _f_[1]], _f_);
    return [0, _g_[2], _g_[3], _g_[1], _g_[4], _g_[5]];
   }
   function _c_(Src, Dst){
    var length = Dst[1];
    function create_like(len, param){return caml_call1(Dst[2], len);}
    var
     unsafe_blit = Dst[3],
     length$0 = Src[1],
     _d_ = Make_gen([0, length$0], [0, length, create_like, unsafe_blit]);
    return [0, _d_[2], _d_[3], _d_[1], _d_[4], _d_[5]];
   }
   var
    Base_Blit =
      [0,
       function(Sequence){
        function create_like(len, param){return caml_call1(Sequence[2], len);}
        var
         length = Sequence[1],
         unsafe_blit = Sequence[3],
         include =
           Make_gen([0, length], [0, length, create_like, unsafe_blit]),
         unsafe_blit$0 = include[1],
         blit = include[2],
         blito = include[3],
         sub = include[4],
         subo = include[5];
        return [0, blit, blito, unsafe_blit$0, sub, subo];
       },
       _c_,
       Make_to_string,
       _b_,
       _a_];
   runtime.caml_register_global(3, Base_Blit, "Base__Blit");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Either_intf = [0];
   runtime.caml_register_global(0, Base_Either_intf, "Base__Either_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option
//# unitInfo: Requires: Base__Applicative, Base__Container, Base__Error, Base__Import, Base__Monad, Base__Source_code_position0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Container = global_data.Base__Container,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Error = global_data.Base__Error,
    Base_Import = global_data.Base__Import,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    compare = Base_Import[236],
    hash_fold_t = Base_Import[211],
    t_of_sexp = Base_Import[172],
    sexp_of_t = Base_Import[148],
    cst_Option_value_exn = "Option.value_exn",
    cst_Option_value_exn_None = "Option.value_exn None";
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[193], a_sexp_grammar);
   }
   function is_none(param){return param ? 0 : 1;}
   function is_some(param){return param ? 1 : 0;}
   function value_map(o, default$0, f){
    if(! o) return default$0;
    var x = o[1];
    return caml_call1(f, x);
   }
   function iter(o, f){
    if(! o) return 0;
    var a = o[1];
    return caml_call1(f, a);
   }
   function invariant(f, t){return iter(t, f);}
   function call(x, f){
    if(! f) return 0;
    var f$0 = f[1];
    return caml_call1(f$0, x);
   }
   function value(t, default$0){
    if(! t) return default$0;
    var x = t[1];
    return x;
   }
   function value_exn(here, error, message, t){
    if(t){var x = t[1]; return x;}
    if(here){
     var p = here[1];
     if(error)
      var
       e = error[1],
       _g_ =
         caml_call2
          (Base_Import[149], Base_Error[6], Base_Source_code_position0[8]),
       _h_ = value(message, cst),
       _i_ = caml_call5(Base_Error[17], 0, 0, _h_, [0, e, p], _g_);
     else if(message)
      var
       m = message[1],
       _i_ =
         caml_call5(Base_Error[17], 0, 0, m, p, Base_Source_code_position0[8]);
     else
      var
       _i_ =
         caml_call5
          (Base_Error[17],
           0,
           0,
           cst_Option_value_exn,
           p,
           Base_Source_code_position0[8]);
     var error$0 = _i_;
    }
    else if(error){
     var e$0 = error[1];
     if(message)
      var m$0 = message[1], _j_ = caml_call2(Base_Error[20], e$0, m$0);
     else
      var _j_ = e$0;
     var error$0 = _j_;
    }
    else if(message)
     var m$1 = message[1], error$0 = caml_call1(Base_Error[12], m$1);
    else
     var error$0 = caml_call1(Base_Error[12], cst_Option_value_exn_None);
    return caml_call1(Base_Error[29], error$0);
   }
   function value_or_thunk(o, default$0){
    if(! o) return caml_call1(default$0, 0);
    var x = o[1];
    return x;
   }
   function to_array(t){if(! t) return [0]; var x = t[1]; return [0, x];}
   function to_list(t){if(! t) return 0; var x = t[1]; return [0, x, 0];}
   function min_elt(t, param){return t;}
   function max_elt(t, param){return t;}
   function sum(M){return function(t, f){return value_map(t, M[1], f);};}
   function for_all(t, f){
    if(! t) return 1;
    var x = t[1];
    return caml_call1(f, x);
   }
   function exists(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x);
   }
   function mem(t, a, equal){
    if(! t) return 0;
    var a$0 = t[1];
    return caml_call2(equal, a, a$0);
   }
   function length(t){return t ? 1 : 0;}
   function fold(t, init, f){
    if(! t) return init;
    var x = t[1];
    return caml_call2(f, init, x);
   }
   function count(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a) ? 1 : 0;
   }
   function find(t, f){
    if(! t) return 0;
    var x = t[1];
    return caml_call1(f, x) ? t : 0;
   }
   function find_map(t, f){
    if(! t) return 0;
    var a = t[1];
    return caml_call1(f, a);
   }
   function equal(f, t$0, t){
    if(t$0){
     if(t){var x = t[1], x$0 = t$0[1]; return caml_call2(f, x$0, x);}
    }
    else if(! t) return 1;
    return 0;
   }
   function some(x){return [0, x];}
   function first_some(x, y){return x ? x : y;}
   function some_if(cond, x){return cond ? [0, x] : 0;}
   function merge(a, b, f){
    if(a){
     if(b){var b$0 = b[1], a$0 = a[1]; return [0, caml_call2(f, a$0, b$0)];}
     var x = a;
    }
    else
     var x = b;
    return x;
   }
   function filter(t, f){
    if(t){var v = t[1]; if(caml_call1(f, v)) return t;}
    return 0;
   }
   function try_with(f){
    try{var x = caml_call1(f, 0);}catch(_f_){return 0;}
    return [0, x];
   }
   function try_with_join(f){
    try{var x = caml_call1(f, 0); return x;}catch(_e_){return 0;}
   }
   function _a_(t, f){
    if(! t) return 0;
    var a = t[1];
    return [0, caml_call1(f, a)];
   }
   function apply(f, x){if(! f) return 0; var f$0 = f[1]; return _a_(x, f$0);}
   function return$0(x){return [0, x];}
   var map = [0, -198771759, _a_];
   function bind(o, f){
    if(! o) return 0;
    var x = o[1];
    return caml_call1(f, x);
   }
   var
    _b_ = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = _b_[1],
    Monad_infix = _b_[3],
    bind$0 = _b_[4],
    join = _b_[7],
    ignore_m = _b_[8],
    Let_syntax = _b_[11],
    include = caml_call1(Base_Applicative[5], [0, return$0, apply, map]),
    return$1 = include[1],
    map$0 = include[2],
    both = include[3],
    symbol = include[4],
    symbol$0 = include[5],
    symbol$1 = include[6],
    symbol_map = include[7],
    apply$0 = include[8],
    map2 = include[9],
    map3 = include[10],
    all = include[11],
    all_unit = include[12],
    Applicative_infix = include[13];
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _c_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_d_){return caml_call2(_c_, _d_, t);};
   }
   var
    Base_Option =
      [0,
       compare,
       hash_fold_t,
       t_sexp_grammar,
       equal,
       invariant,
       t_of_sexp,
       sexp_of_t,
       both,
       symbol,
       symbol$0,
       symbol$1,
       apply$0,
       map2,
       map3,
       Applicative_infix,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       value,
       value_exn,
       value_map,
       value_or_thunk,
       fold,
       mem,
       length,
       iter,
       exists,
       for_all,
       find,
       find_map,
       to_list,
       to_array,
       call,
       merge,
       filter,
       try_with,
       try_with_join,
       some,
       first_some,
       some_if,
       is_none,
       is_some,
       is_none,
       fold_result,
       fold_until,
       min_elt,
       max_elt,
       count,
       sum];
   runtime.caml_register_global(9, Base_Option, "Base__Option");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexpable
//# unitInfo: Requires: Base__Import, Sexplib0__Sexpable
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    cst_Sexpable_Of_stringable_t_o =
      "Sexpable.Of_stringable.t_of_sexp expected an atom, but got a list";
   function Of_sexpable(Sexpable, M){
    function t_of_sexp(sexp){
     var s = caml_call1(Sexpable[1], sexp);
     try{var _i_ = caml_call1(M[2], s); return _i_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(t){
     var _h_ = caml_call1(M[1], t);
     return caml_call1(Sexpable[2], _h_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable1(Sexpable, M){
    function t_of_sexp(a_of_sexp, sexp){
     var s = caml_call2(Sexpable[1], a_of_sexp, sexp);
     try{var _g_ = caml_call1(M[2], s); return _g_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, t){
     var _f_ = caml_call1(M[1], t);
     return caml_call2(Sexpable[2], sexp_of_a, _f_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable2(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, sexp){
     var s = caml_call3(Sexpable[1], a_of_sexp, b_of_sexp, sexp);
     try{var _e_ = caml_call1(M[2], s); return _e_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, t){
     var _d_ = caml_call1(M[1], t);
     return caml_call3(Sexpable[2], sexp_of_a, sexp_of_b, _d_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_sexpable3(Sexpable, M){
    function t_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
     var s = caml_call4(Sexpable[1], a_of_sexp, b_of_sexp, c_of_sexp, sexp);
     try{var _c_ = caml_call1(M[2], s); return _c_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(sexp_of_a, sexp_of_b, sexp_of_c, t){
     var _b_ = caml_call1(M[1], t);
     return caml_call4(Sexpable[2], sexp_of_a, sexp_of_b, sexp_of_c, _b_);
    }
    return [0, t_of_sexp, sexp_of_t];
   }
   function Of_stringable(M){
    function t_of_sexp(sexp){
     if(0 !== sexp[0])
      return caml_call2
              (Base_Import[158], cst_Sexpable_Of_stringable_t_o, sexp);
     var s = sexp[1];
     try{var _a_ = caml_call1(M[1], s); return _a_;}
     catch(exn$0){
      var exn = caml_wrap_exception(exn$0);
      return caml_call2(Base_Import[159], exn, sexp);
     }
    }
    function sexp_of_t(t){return [0, caml_call1(M[2], t)];}
    return [0, t_of_sexp, sexp_of_t];
   }
   var
    Base_Sexpable =
      [0,
       Of_sexpable,
       Of_sexpable1,
       Of_sexpable2,
       Of_sexpable3,
       Of_stringable];
   runtime.caml_register_global(2, Base_Sexpable, "Base__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Either
//# unitInfo: Requires: Base__Applicative, Base__Either0, Base__Either_intf, Base__List0, Base__Monad, Base__Option, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_With_return = global_data.Base__With_return,
    Base_Option = global_data.Base__Option,
    Base_List0 = global_data.Base__List0,
    Base_Monad = global_data.Base__Monad,
    Base_Applicative = global_data.Base__Applicative,
    Base_Either0 = global_data.Base__Either0,
    compare = Base_Either0[1],
    hash_fold_t = Base_Either0[2],
    t_of_sexp = Base_Either0[3],
    sexp_of_t = Base_Either0[4],
    t_sexp_grammar = Base_Either0[5];
   function swap(param){
    if(0 === param[0]){var x = param[1]; return [1, x];}
    var x$0 = param[1];
    return [0, x$0];
   }
   function is_first(param){return 0 === param[0] ? 1 : 0;}
   function is_second(param){return 0 === param[0] ? 0 : 1;}
   function value(param){var x = param[1]; return x;}
   function value_map(t, first, second){
    if(0 === t[0]){var x = t[1]; return caml_call1(first, x);}
    var x$0 = t[1];
    return caml_call1(second, x$0);
   }
   function map(t, first, second){
    if(0 === t[0]){var x = t[1]; return [0, caml_call1(first, x)];}
    var x$0 = t[1];
    return [1, caml_call1(second, x$0)];
   }
   function first(x){return [0, x];}
   function second(x){return [1, x];}
   function equal(eq1, eq2, t1, t2){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return caml_call2(eq1, x, y);}
    }
    else{
     var x$0 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return caml_call2(eq2, x$0, y$0);}
    }
    return 0;
   }
   function invariant(f, s, param){
    if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
    var y = param[1];
    return caml_call1(s, y);
   }
   function Make_focused(M){
    var
     return$0 = M[1],
     other = M[2],
     either = M[3],
     combine = M[4],
     bind = M[5],
     map =
       [0,
        -198771759,
        function(t, f){
         return caml_call2
                 (bind,
                  t,
                  function(x){return caml_call1(return$0, caml_call1(f, x));});
        }],
     include = caml_call1(Base_Monad[2], [0, bind, map, return$0]),
     symbol_bind = include[1],
     Let_syntax = include[3],
     Monad_infix = include[4],
     bind$0 = include[5],
     return$1 = include[6],
     join = include[8],
     ignore_m = include[9],
     _a_ = include[7];
    function apply(t1, t2){
     return caml_call2
             (bind$0,
              t1,
              function(f){
               return caml_call2
                       (bind$0,
                        t2,
                        function(x){return caml_call1(return$1, caml_call1(f, x));});
              });
    }
    var
     map$0 = [0, -198771759, _a_],
     App = caml_call1(Base_Applicative[6], [0, return$1, apply, map$0]),
     return$2 = App[1],
     map$1 = App[2],
     both = App[3],
     symbol = App[4],
     symbol$0 = App[5],
     symbol$1 = App[6],
     symbol_map = App[7],
     apply$0 = App[8],
     map2 = App[9],
     map3 = App[10],
     all = App[11],
     all_unit = App[12],
     Applicative_infix = App[13];
    function other_loop(f, acc, param){
     if(! param) return caml_call1(other, acc);
     var ts = param[2], t = param[1];
     function _i_(o){return other_loop(f, caml_call2(f, acc, o), ts);}
     return caml_call3
             (either, t, function(param){return other_loop(f, acc, ts);}, _i_);
    }
    function return_loop(f, acc, param){
     if(! param) return caml_call1(return$2, caml_call1(Base_List0[21], acc));
     var ts = param[2], t = param[1];
     function _h_(o){return other_loop(f, o, ts);}
     return caml_call3
             (either,
              t,
              function(x){return return_loop(f, [0, x, acc], ts);},
              _h_);
    }
    function combine_all(ts, f){return return_loop(f, 0, ts);}
    function other_loop$0(f, acc, param){
     if(! param) return caml_call1(other, acc);
     var ts = param[2], t = param[1];
     function _g_(o){return other_loop$0(f, caml_call2(f, acc, o), ts);}
     return caml_call3
             (either,
              t,
              function(param){return other_loop$0(f, acc, ts);},
              _g_);
    }
    function return_loop$0(f, param){
     if(! param) return caml_call1(return$2, 0);
     var ts = param[2], t = param[1];
     function _f_(o){return other_loop$0(f, o, ts);}
     return caml_call3
             (either, t, function(param){return return_loop$0(f, ts);}, _f_);
    }
    function combine_all_unit(ts, f){return return_loop$0(f, ts);}
    function to_option(t){
     function _e_(param){return 0;}
     return caml_call3(either, t, Base_Option[46], _e_);
    }
    function value(t, default$0){
     function _c_(param){return default$0;}
     return caml_call3(either, t, function(_d_){return _d_;}, _c_);
    }
    function with_return(f){
     function _b_(ret){
      return caml_call1
              (other,
               caml_call1(f, caml_call2(Base_With_return[3], ret, return$2)));
     }
     return caml_call1(Base_With_return[1], _b_);
    }
    return [0,
            other,
            either,
            combine,
            symbol_bind,
            Let_syntax,
            Monad_infix,
            bind$0,
            join,
            ignore_m,
            App,
            return$2,
            map$1,
            both,
            symbol,
            symbol$0,
            symbol$1,
            symbol_map,
            apply$0,
            map2,
            map3,
            all,
            all_unit,
            Applicative_infix,
            combine_all,
            combine_all_unit,
            to_option,
            value,
            with_return];
   }
   function either(t, return$0, other){
    if(0 === t[0]){var x = t[1]; return caml_call1(return$0, x);}
    var y = t[1];
    return caml_call1(other, y);
   }
   function combine(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(f, x, y)];}
     var x$0 = t2[1];
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){
      var y$0 = t2[1];
      return [1, caml_call2(other, x$1, y$0)];
     }
     var x$0 = x$1;
    }
    return [1, x$0];
   }
   function bind(t, f){
    if(0 !== t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var First = Make_focused([0, first, second, either, combine, bind]);
   function either$0(t, return$0, other){
    if(0 === t[0]){var x = t[1]; return caml_call1(other, x);}
    var y = t[1];
    return caml_call1(return$0, y);
   }
   function combine$0(t1, t2, f, other){
    if(0 === t1[0]){
     var x = t1[1];
     if(0 === t2[0]){var y = t2[1]; return [0, caml_call2(other, x, y)];}
     var x$0 = x;
    }
    else{
     var x$1 = t1[1];
     if(0 !== t2[0]){var y$0 = t2[1]; return [1, caml_call2(f, x$1, y$0)];}
     var x$0 = t2[1];
    }
    return [0, x$0];
   }
   function bind$0(t, f){
    if(0 === t[0]) return t;
    var x = t[1];
    return caml_call1(f, x);
   }
   var
    Second = Make_focused([0, second, first, either$0, combine$0, bind$0]),
    Export = [0],
    Base_Either =
      [0,
       compare,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       swap,
       value,
       value_map,
       value_map,
       map,
       equal,
       [0,
        First[4],
        First[5],
        First[6],
        First[7],
        First[8],
        First[9],
        First[11],
        First[12],
        First[13],
        First[14],
        First[15],
        First[16],
        First[17],
        First[18],
        First[19],
        First[20],
        First[21],
        First[22],
        First[23],
        First[27],
        First[26],
        First[28],
        First[3],
        First[24],
        First[25]],
       [0,
        Second[4],
        Second[5],
        Second[6],
        Second[7],
        Second[8],
        Second[9],
        Second[11],
        Second[12],
        Second[13],
        Second[14],
        Second[15],
        Second[16],
        Second[17],
        Second[18],
        Second[19],
        Second[20],
        Second[21],
        Second[22],
        Second[23],
        Second[27],
        Second[26],
        Second[28],
        Second[3],
        Second[24],
        Second[25]],
       is_first,
       is_second,
       first,
       second,
       Export];
   runtime.caml_register_global(6, Base_Either, "Base__Either");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Indexed_container_intf = [0];
   runtime.caml_register_global
    (0, Base_Indexed_container_intf, "Base__Indexed_container_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Indexed_container
//# unitInfo: Requires: Base__Container, Base__Indexed_container_intf, Base__With_return
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Container = global_data.Base__Container,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1];
   function iteri(fold, t, f){
    caml_call3
     (fold, t, 0, function(i, x){caml_call2(f, i, x); return i + 1 | 0;});
    return 0;
   }
   function foldi(fold, t, init, f){
    var i = [0, 0];
    return caml_call3
            (fold,
             t,
             init,
             function(acc, v){
              var acc$0 = caml_call3(f, i[1], acc, v);
              i[1] = i[1] + 1 | 0;
              return acc$0;
             });
   }
   function counti(foldi, t, f){
    return caml_call3
            (foldi,
             t,
             0,
             function(i, n, a){return caml_call2(f, i, a) ? n + 1 | 0 : n;});
   }
   function existsi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _d_ = caml_call2(f, i, x);
                 return _d_ ? caml_call1(r, 1) : _d_;
                });
              return 0;
             });
   }
   function for_alli(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _c_ = 1 - caml_call2(f, i, x);
                 return _c_ ? caml_call1(r, 0) : _c_;
                });
              return 1;
             });
   }
   function find_mapi(iteri, t, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                t,
                function(i, x){
                 var res = caml_call2(f, i, x);
                 return res ? caml_call1(r, res) : 0;
                });
              return 0;
             });
   }
   function findi(iteri, c, f){
    return caml_call1
            (with_return,
             function(r){
              caml_call2
               (iteri,
                c,
                function(i, x){
                 var _b_ = caml_call2(f, i, x);
                 return _b_ ? caml_call1(r, [0, [0, i, x]]) : _b_;
                });
              return 0;
             });
   }
   function Make_gen(T){
    var
     include = caml_call1(Base_Container[18], [0, T[1], T[2], T[3]]),
     length = include[1],
     is_empty = include[2],
     iter = include[3],
     fold = include[4],
     fold_result = include[5],
     fold_until = include[6],
     exists = include[7],
     for_all = include[8],
     count = include[9],
     sum = include[10],
     find = include[11],
     find_map = include[12],
     to_list = include[13],
     to_array = include[14],
     min_elt = include[15],
     max_elt = include[16],
     match = T[4];
    if(typeof match === "number")
     var iteri$0 = function(t, f){return iteri(fold, t, f);};
    else
     var iteri$1 = match[2], iteri$0 = iteri$1;
    var match$0 = T[5];
    if(typeof match$0 === "number")
     var foldi$0 = function(t, init, f){return foldi(fold, t, init, f);};
    else
     var foldi$1 = match$0[2], foldi$0 = foldi$1;
    function counti$0(t, f){return counti(foldi$0, t, f);}
    function existsi$0(t, f){return existsi(iteri$0, t, f);}
    function for_alli$0(t, f){return for_alli(iteri$0, t, f);}
    function find_mapi$0(t, f){return find_mapi(iteri$0, t, f);}
    function findi$0(t, f){return findi(iteri$0, t, f);}
    return [0,
            length,
            is_empty,
            iter,
            fold,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi$0,
            for_alli$0,
            counti$0,
            findi$0,
            find_mapi$0];
   }
   function _a_(T){
    var
     C = caml_call1(Base_Container[17], [0, T[1], T[2], T[3], T[4]]),
     mem = C[1],
     fold = T[2],
     iter = T[3],
     length = T[4],
     iteri = T[5],
     foldi = T[6],
     include = Make_gen([0, fold, iter, length, iteri, foldi]),
     length$0 = include[1],
     is_empty = include[2],
     iter$0 = include[3],
     fold$0 = include[4],
     fold_result = include[5],
     fold_until = include[6],
     exists = include[7],
     for_all = include[8],
     count = include[9],
     sum = include[10],
     find = include[11],
     find_map = include[12],
     to_list = include[13],
     to_array = include[14],
     min_elt = include[15],
     max_elt = include[16],
     foldi$0 = include[17],
     iteri$0 = include[18],
     existsi = include[19],
     for_alli = include[20],
     counti = include[21],
     findi = include[22],
     find_mapi = include[23];
    return [0,
            mem,
            length$0,
            is_empty,
            iter$0,
            fold$0,
            fold_result,
            fold_until,
            exists,
            for_all,
            count,
            sum,
            find,
            find_map,
            to_list,
            to_array,
            min_elt,
            max_elt,
            foldi$0,
            iteri$0,
            existsi,
            for_alli,
            counti,
            findi,
            find_mapi];
   }
   var
    Base_Indexed_container =
      [0,
       foldi,
       iteri,
       counti,
       existsi,
       for_alli,
       findi,
       find_mapi,
       function(T){
        var
         C = caml_call1(Base_Container[16], [0, T[1], T[2], T[3]]),
         mem = C[1],
         fold = T[1],
         iter = T[2],
         length = T[3],
         iteri = T[4],
         foldi = T[5],
         include = Make_gen([0, fold, iter, length, iteri, foldi]),
         length$0 = include[1],
         is_empty = include[2],
         iter$0 = include[3],
         fold$0 = include[4],
         fold_result = include[5],
         fold_until = include[6],
         exists = include[7],
         for_all = include[8],
         count = include[9],
         sum = include[10],
         find = include[11],
         find_map = include[12],
         to_list = include[13],
         to_array = include[14],
         min_elt = include[15],
         max_elt = include[16],
         foldi$0 = include[17],
         iteri$0 = include[18],
         existsi = include[19],
         for_alli = include[20],
         counti = include[21],
         findi = include[22],
         find_mapi = include[23];
        return [0,
                mem,
                length$0,
                is_empty,
                iter$0,
                fold$0,
                fold_result,
                fold_until,
                exists,
                for_all,
                count,
                sum,
                find,
                find_map,
                to_list,
                to_array,
                min_elt,
                max_elt,
                foldi$0,
                iteri$0,
                existsi,
                for_alli,
                counti,
                findi,
                find_mapi];
       },
       _a_,
       Make_gen];
   runtime.caml_register_global
    (2, Base_Indexed_container, "Base__Indexed_container");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sequence
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Container, Base__Hash, Base__Import, Base__List1, Base__Monad, Base__Ppx_compare_lib, Base__Result, Base__With_return, CamlinternalLazy, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Both$0 = "Both",
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Sequence_nth$1 = "Sequence.nth",
    cst_both = "both",
    cst_left = "left",
    cst_right = "right",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_025 = "sequence.ml.Merge_with_duplicates_element.t",
    Base_List1 = global_data.Base__List1,
    Base_With_return = global_data.Base__With_return,
    Base_Import = global_data.Base__Import,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Base_Result = global_data.Base__Result,
    Base_Container = global_data.Base__Container,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    Base_Monad = global_data.Base__Monad,
    _j_ = [0, 0],
    cst_Sequence_cycle_list_exn = "Sequence.cycle_list_exn",
    cst_Sequence_drop = "Sequence.drop",
    cst_Sequence_take = "Sequence.take",
    cst_Sequence_sub = "Sequence.sub",
    cst_Sequence_reduce_exn = "Sequence.reduce_exn",
    cst_Sequence_find_exn = "Sequence.find_exn",
    cst_Sequence_chunks_exn = "Sequence.chunks_exn",
    cst_Sequence_tl_exn = "Sequence.tl_exn",
    cst_hd_exn = "hd_exn",
    cst_Both = cst_Both$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0,
    _g_ = [0, cst_Left$0],
    _h_ = [0, cst_Right$0],
    _i_ = [0, cst_Both$0],
    cst_Sequence_nth$0 = cst_Sequence_nth$1,
    cst_Sequence_nth = cst_Sequence_nth$1,
    _f_ = [0, "src/sequence.ml", 259, 14],
    _e_ = [0, 0, 0],
    _a_ = [0, "Done"],
    _b_ = [0, "Skip"],
    _c_ = [0, "Yield"];
   function sexp_of_t(of_a_001, of_s_002, param){
    if(typeof param === "number") return _a_;
    if(0 === param[0]){
     var arg0_003 = param[1], res0_004 = caml_call1(of_s_002, arg0_003);
     return [1, [0, _b_, [0, res0_004, 0]]];
    }
    var
     arg1_006 = param[2],
     arg0_005 = param[1],
     res0_007 = caml_call1(of_a_001, arg0_005),
     res1_008 = caml_call1(of_s_002, arg1_006);
    return [1, [0, _c_, [0, res0_007, [0, res1_008, 0]]]];
   }
   var Step = [0, sexp_of_t];
   function next_step(param){
    var f = param[2], s = param[1], match = caml_call1(f, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, s$0, f]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, s$1, f]];
   }
   function delayed_fold_step(s, init, f, finish){
    function loop(s, next, finish, f, acc){
     var match = caml_call1(next, s);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){
      var s$0 = match[1];
      return caml_call3
              (f,
               acc,
               0,
               function(_Z_){return loop(s$0, next, finish, f, _Z_);});
     }
     var s$1 = match[2], a = match[1];
     return caml_call3
             (f,
              acc,
              [0, a],
              function(_Y_){return loop(s$1, next, finish, f, _Y_);});
    }
    var next = s[2], s$0 = s[1];
    return loop(s$0, next, finish, f, init);
   }
   var Expert = [0, next_step, delayed_fold_step];
   function unfold_step(init, f){return [0, init, f];}
   function unfold(init, f){
    return [0,
            init,
            function(s){
             var match = caml_call1(f, s);
             if(! match) return 0;
             var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
             return [1, a, s$0];
            }];
   }
   function unfold_with(s, init, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, init, s$0],
            function(param){
             var s = param[2], seed = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$0 = match[1];
              return [0, [0, seed, s$0]];
             }
             var
              s$1 = match[2],
              a = match[1],
              match$0 = caml_call2(f, seed, a);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var seed$0 = match$0[1];
              return [0, [0, seed$0, s$1]];
             }
             var seed$1 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, seed$1, s$1]];
            }];
   }
   function unfold_with_and_finish
   (s, init, running_step, inner_finished, finishing_step){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -172306698, [0, init, s$0]],
            function(state){
             if(301075099 <= state[1]){
              var
               state$0 = state[2],
               match = caml_call1(finishing_step, state$0);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var state$1 = match[1];
               return [0, [0, 301075099, state$1]];
              }
              var state$2 = match[2], y = match[1];
              return [1, y, [0, 301075099, state$2]];
             }
             var
              match$0 = state[2],
              inner_state = match$0[2],
              state$3 = match$0[1],
              match$1 = caml_call1(next, inner_state);
             if(typeof match$1 === "number")
              return [0, [0, 301075099, caml_call1(inner_finished, state$3)]];
             if(0 === match$1[0]){
              var inner_state$0 = match$1[1];
              return [0, [0, -172306698, [0, state$3, inner_state$0]]];
             }
             var
              inner_state$1 = match$1[2],
              x = match$1[1],
              match$2 = caml_call2(running_step, state$3, x);
             if(typeof match$2 === "number") return 0;
             if(0 === match$2[0]){
              var state$4 = match$2[1];
              return [0, [0, -172306698, [0, state$4, inner_state$1]]];
             }
             var state$5 = match$2[2], y$0 = match$2[1];
             return [1, y$0, [0, -172306698, [0, state$5, inner_state$1]]];
            }];
   }
   function of_list(l){
    return [0,
            l,
            function(param){
             if(! param) return 0;
             var l = param[2], x = param[1];
             return [1, x, l];
            }];
   }
   function fold(t, init, f){
    var next = t[2], seed$2 = t[1], seed = seed$2, v = init;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return v;
     if(0 === match[0]){var seed$0 = match[1], seed = seed$0; continue;}
     var
      seed$1 = match[2],
      a = match[1],
      v$0 = caml_call2(f, v, a),
      seed = seed$1,
      v = v$0;
    }
   }
   function to_list_rev(t){
    return fold(t, 0, function(l, x){return [0, x, l];});
   }
   function to_list(param){
    var next = param[2], s = param[1];
    function to_list(s, next, i){
     var s$0 = s;
     for(;;){
      if(0 === i){
       var t = [0, s$0, next], _X_ = to_list_rev(t);
       return caml_call1(Base_List1[21], _X_);
      }
      var match = caml_call1(next, s$0);
      if(typeof match === "number") return 0;
      if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
      var s$2 = match[2], a = match[1];
      return [0, a, to_list(s$2, next, caml_call2(Base_Import[92], i, 1))];
     }
    }
    return to_list(s, next, 500);
   }
   function sexp_of_t$0(sexp_of_a, t){
    var _W_ = to_list(t);
    return caml_call2(Base_Import[151], sexp_of_a, _W_);
   }
   function range(opt, _V_, _U_, start_v, stop_v){
    if(opt) var sth = opt[1], stride = sth; else var stride = 1;
    if(_V_) var sth$0 = _V_[1], start = sth$0; else var start = 104758188;
    if(_U_) var sth$1 = _U_[1], stop = sth$1; else var stop = -160346914;
    var
     step =
       104758188 <= stop
        ? 0
          <= stride
          ? function
           (i){
            return stop_v < i
                    ? 0
                    : [1, i, caml_call2(Base_Import[90], i, stride)];
           }
          : function
           (i){
            return i < stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[90], i, stride)];
           }
        : 0
          <= stride
          ? function
           (i){
            return stop_v <= i
                    ? 0
                    : [1, i, caml_call2(Base_Import[90], i, stride)];
           }
          : function
           (i){
            return i <= stop_v
                    ? 0
                    : [1, i, caml_call2(Base_Import[90], i, stride)];
           },
     init =
       104758188 <= start
        ? start_v
        : caml_call2(Base_Import[90], start_v, stride);
    return [0, init, step];
   }
   function of_lazy(t_lazy){
    return [0,
            t_lazy,
            function(t_lazy){
             var
              _T_ = caml_obj_tag(t_lazy),
              match =
                250 === _T_
                 ? t_lazy[1]
                 : 246
                   === _T_
                   ? caml_call1(CamlinternalLazy[2], t_lazy)
                   : t_lazy,
              next = match[2],
              s = match[1],
              match$0 = caml_call1(next, s);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s$0 = match$0[1], v = [0, s$0, next];
              return [0, v];
             }
             var s$1 = match$0[2], x = match$0[1], v$0 = [0, s$1, next];
             return [1, x, v$0];
            }];
   }
   function _d_(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var s$0 = match[2], a = match[1];
             return [1, caml_call1(f, a), s$0];
            }];
   }
   function mapi(t, f){
    var next = t[2], s = t[1];
    return [0,
            [0, 0, s],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var
              s$1 = match[2],
              a = match[1],
              _S_ = [0, caml_call2(Base_Import[90], i, 1), s$1];
             return [1, caml_call2(f, i, a), _S_];
            }];
   }
   function folding_map(t, init, f){
    return unfold_with
            (t,
             init,
             function(acc, x){
              var
               match = caml_call2(f, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, acc$0];
             });
   }
   function folding_mapi(t, init, f){
    return unfold_with
            (t,
             [0, 0, init],
             function(param, x){
              var
               acc = param[2],
               i = param[1],
               match = caml_call3(f, i, acc, x),
               x$0 = match[2],
               acc$0 = match[1];
              return [1, x$0, [0, caml_call2(Base_Import[90], i, 1), acc$0]];
             });
   }
   function filter(t, f){
    var next = t[2], seed = t[1];
    return [0,
            seed,
            function(seed){
             var match = caml_call1(next, seed);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s = match[1]; return [0, s];}
             var a = match[1], s$0 = match[2];
             if(caml_call1(f, a)) return [1, a, s$0];
             var s$1 = match[2];
             return [0, s$1];
            }];
   }
   function filteri(t, f){
    var _Q_ = Base_Import[126];
    function _R_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return _d_(filter(mapi(t, function(i, s){return [0, i, s];}), _R_), _Q_);
   }
   function length(t){
    var next = t[2], seed = t[1], i = 0, s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return i;
     if(0 === match[0]){var s$0 = match[1], s = s$0; continue;}
     var
      s$1 = match[2],
      i$0 = caml_call2(Base_Import[90], i, 1),
      i = i$0,
      s = s$1;
    }
   }
   function to_array(t){
    var
     match =
       fold
        (t,
         _e_,
         function(param, x){
          var i = param[2], l = param[1];
          return [0, [0, x, l], caml_call2(Base_Import[90], i, 1)];
         }),
     len = match[2],
     l = match[1];
    if(! l) return [0];
    var
     l$0 = l[2],
     x = l[1],
     a = caml_call2(Base_Array0[4], len, x),
     i$1 = caml_call2(Base_Import[92], len, 2),
     i = i$1,
     l$1 = l$0;
    for(;;){
     if(l$1){
      var l$2 = l$1[2], x$0 = l$1[1];
      runtime.caml_check_bound(a, i)[1 + i] = x$0;
      var i$0 = caml_call2(Base_Import[92], i, 1), i = i$0, l$1 = l$2;
      continue;
     }
     if(-1 === i) return a;
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    }
   }
   function find(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(caml_call1(f, a)) return [0, a];
      var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   function find_map(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){var s$0 = match[1], s = s$0; continue;}
     var s$1 = match[2], a = match[1], some_b = caml_call1(f, a);
     if(some_b) return some_b;
     var s = s$1;
    }
   }
   function find_mapi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){var s$0 = match[1], s = s$0; continue;}
     var s$1 = match[2], a = match[1], some_b = caml_call2(f, i, a);
     if(some_b) return some_b;
     var i$0 = caml_call2(Base_Import[90], i, 1), s = s$1, i = i$0;
    }
   }
   function for_all(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var a = match[1];
      if(! caml_call1(f, a)) return 0;
      var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   function for_alli(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 === match[0]){var s$0 = match[1], s = s$0; continue;}
     var a = match[1];
     if(! caml_call2(f, i, a)) return 0;
     var
      s$1 = match[2],
      i$0 = caml_call2(Base_Import[90], i, 1),
      s = s$1,
      i = i$0;
    }
   }
   function exists(t, f){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{var a = match[1]; if(caml_call1(f, a)) return 1; var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   function existsi(t, f){
    var next = t[2], seed = t[1], s = seed, i = 0;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0]){var s$0 = match[1], s = s$0; continue;}
     var a = match[1];
     if(caml_call2(f, i, a)) return 1;
     var
      s$1 = match[2],
      i$0 = caml_call2(Base_Import[90], i, 1),
      s = s$1,
      i = i$0;
    }
   }
   function iter(t, f){
    var next = t[2], seed$2 = t[1], seed = seed$2;
    for(;;){
     var match = caml_call1(next, seed);
     if(typeof match === "number") return 0;
     if(0 === match[0]){var seed$0 = match[1], seed = seed$0; continue;}
     var seed$1 = match[2], a = match[1];
     caml_call1(f, a);
     var seed = seed$1;
    }
   }
   function is_empty(t){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 1;
     if(0 !== match[0]) return 0;
     var s$0 = match[1], s = s$0;
    }
   }
   function mem(t, a, equal){
    var next = t[2], seed = t[1], s = seed;
    for(;;){
     var match = caml_call1(next, s);
     if(typeof match === "number") return 0;
     if(0 === match[0])
      var s$0 = match[1];
     else{
      var b = match[1];
      if(caml_call2(equal, a, b)) return 1;
      var s$0 = match[2];
     }
     var s = s$0;
    }
   }
   var empty = [0, 0, function(param){return 0;}];
   function bind(t, f){
    return [0,
            [0, empty, t],
            function(param){
             var
              rest = param[2],
              match = param[1],
              next = match[2],
              seed = match[1],
              match$0 = caml_call1(next, seed);
             if(typeof match$0 === "number"){
              var
               next$0 = rest[2],
               seed$0 = rest[1],
               match$1 = caml_call1(next$0, seed$0);
              if(typeof match$1 === "number") return 0;
              if(0 === match$1[0]){
               var s = match$1[1];
               return [0, [0, empty, [0, s, next$0]]];
              }
              var s$0 = match$1[2], a = match$1[1];
              return [0, [0, caml_call1(f, a), [0, s$0, next$0]]];
             }
             if(0 === match$0[0]){
              var s$1 = match$0[1];
              return [0, [0, [0, s$1, next], rest]];
             }
             var s$2 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, [0, s$2, next], rest]];
            }];
   }
   function return$0(x){
    return [0,
            [0, x],
            function(param){
             if(! param) return 0;
             var x = param[1];
             return [1, x, 0];
            }];
   }
   var
    map = [0, -198771759, _d_],
    include = caml_call1(Base_Monad[1], [0, bind, return$0, map]),
    symbol_bind = include[1],
    symbol_map = include[2],
    Monad_infix = include[3],
    bind$0 = include[4],
    return$1 = include[5],
    map$0 = include[6],
    join = include[7],
    ignore_m = include[8],
    all = include[9],
    all_unit = include[10],
    Let_syntax = include[11];
   function nth(s, n){
    if(0 > n) return 0;
    var next = s[2], s$3 = s[1], i = n, s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
     var s$2 = match[2], a = match[1];
     if(caml_call2(Base_Import[127], i, 0)) return [0, a];
     var i$0 = caml_call2(Base_Import[92], i, 1), i = i$0, s$0 = s$2;
    }
   }
   function nth_exn(s, n){
    if(0 > n) return caml_call1(Base_Import[125], cst_Sequence_nth$0);
    var match = nth(s, n);
    if(! match) return caml_call1(Base_Import[123], cst_Sequence_nth);
    var x = match[1];
    return x;
   }
   function compare(cmp_a, cmp_b, a_011, b_012){
    if(caml_call2(Base_Ppx_compare_lib[1], a_011, b_012)) return 0;
    switch(a_011[0]){
      case 0:
       var a_013 = a_011[1];
       if(0 !== b_012[0]) return -1;
       var b_014 = b_012[1];
       return caml_call2(cmp_a, a_013, b_014);
      case 1:
       var a_015 = a_011[1];
       switch(b_012[0]){
         case 0: break;
         case 1:
          var b_016 = b_012[1]; return caml_call2(cmp_b, a_015, b_016);
         default: return -1;
       }
       break;
      default:
       var a_019 = a_011[2], a_017 = a_011[1];
       switch(b_012[0]){
         case 0: break;
         case 1:
          return 1;
         default:
          var
           b_020 = b_012[2],
           b_018 = b_012[1],
           n = caml_call2(cmp_a, a_017, b_018);
          return 0 === n ? caml_call2(cmp_b, a_019, b_020) : n;
       }
    }
    return 1;
   }
   function hash_fold_t(hash_fold_a, hash_fold_b, hsv, arg){
    switch(arg[0]){
      case 0:
       var a0 = arg[1], hsv$0 = caml_call2(Base_Hash[3], hsv, 0);
       return caml_call2(hash_fold_a, hsv$0, a0);
      case 1:
       var a0$0 = arg[1], hsv$1 = caml_call2(Base_Hash[3], hsv, 1);
       return caml_call2(hash_fold_b, hsv$1, a0$0);
      default:
       var
        a1 = arg[2],
        a0$1 = arg[1],
        hsv$2 = caml_call2(Base_Hash[3], hsv, 2),
        hsv$3 = caml_call2(hash_fold_a, hsv$2, a0$1);
       return caml_call2(hash_fold_b, hsv$3, a1);
    }
   }
   function t_of_sexp(of_a_021, of_b_022, sexp_027){
    if(0 === sexp_027[0]){
     var _M_ = sexp_027[1], switch$0 = 0;
     if(caml_string_notequal(_M_, cst_Both$0)){
      var switch$1 = 0;
      if(caml_string_notequal(_M_, cst_Left$0)){
       var switch$2 = 0;
       if(caml_string_notequal(_M_, cst_Right$0)){
        if(caml_string_notequal(_M_, cst_both))
         if(caml_string_notequal(_M_, cst_left))
          if(caml_string_notequal(_M_, cst_right))
           switch$0 = 1;
          else
           switch$2 = 1;
         else
          switch$1 = 1;
       }
       else
        switch$2 = 1;
       if(switch$2)
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_025, sexp_027);
      }
      else
       switch$1 = 1;
      if(switch$1)
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_025, sexp_027);
     }
     if(! switch$0)
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_025, sexp_027);
    }
    else{
     var _N_ = sexp_027[1];
     if(! _N_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_025, sexp_027);
     var _O_ = _N_[1];
     if(0 !== _O_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_025, sexp_027);
     var tag_028 = _O_[1], switch$3 = 0;
     if(caml_string_notequal(tag_028, cst_Both$0)){
      var switch$4 = 0;
      if(caml_string_notequal(tag_028, cst_Left$0)){
       var switch$5 = 0;
       if(caml_string_notequal(tag_028, cst_Right$0)){
        if(caml_string_notequal(tag_028, cst_both))
         if(caml_string_notequal(tag_028, cst_left))
          if(caml_string_notequal(tag_028, cst_right))
           switch$3 = 1;
          else
           switch$5 = 1;
         else
          switch$4 = 1;
       }
       else
        switch$5 = 1;
       if(switch$5){
        var sexp_args_034 = _N_[2];
        if(sexp_args_034 && ! sexp_args_034[2]){
         var
          arg0_035 = sexp_args_034[1],
          res0_036 = caml_call1(of_b_022, arg0_035);
         return [1, res0_036];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_025,
                 tag_028,
                 sexp_027);
       }
      }
      else
       switch$4 = 1;
      if(switch$4){
       var sexp_args_029 = _N_[2];
       if(sexp_args_029 && ! sexp_args_029[2]){
        var
         arg0_030 = sexp_args_029[1],
         res0_031 = caml_call1(of_a_021, arg0_030);
        return [0, res0_031];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[4],
                error_source_025,
                tag_028,
                sexp_027);
      }
     }
     if(! switch$3){
      var sexp_args_039 = _N_[2];
      if(sexp_args_039){
       var _P_ = sexp_args_039[2];
       if(_P_ && ! _P_[2]){
        var
         arg1_041 = _P_[1],
         arg0_040 = sexp_args_039[1],
         res0_042 = caml_call1(of_a_021, arg0_040),
         res1_043 = caml_call1(of_b_022, arg1_041);
        return [2, res0_042, res1_043];
       }
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_025,
               tag_028,
               sexp_027);
     }
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_025, sexp_027);
   }
   function sexp_of_t$1(of_a_046, of_b_047, param){
    switch(param[0]){
      case 0:
       var arg0_048 = param[1], res0_049 = caml_call1(of_a_046, arg0_048);
       return [1, [0, _g_, [0, res0_049, 0]]];
      case 1:
       var arg0_050 = param[1], res0_051 = caml_call1(of_b_047, arg0_050);
       return [1, [0, _h_, [0, res0_051, 0]]];
      default:
       var
        arg1_053 = param[2],
        arg0_052 = param[1],
        res0_054 = caml_call1(of_a_046, arg0_052),
        res1_055 = caml_call1(of_b_047, arg1_053);
       return [1, [0, _i_, [0, res0_054, [0, res1_055, 0]]]];
    }
   }
   function t_sexp_grammar(a_sexp_grammar, b_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Left, [0, [0, a_sexp_grammar, 0]]]],
              [0,
               [1, [0, cst_Right, [0, [0, b_sexp_grammar, 0]]]],
               [0,
                [1,
                 [0,
                  cst_Both,
                  [0, [0, a_sexp_grammar, [0, b_sexp_grammar, 0]]]]],
                0]]]]];
   }
   var
    Merge_with_duplicates_element =
      [0, compare, hash_fold_t, t_of_sexp, sexp_of_t$1, t_sexp_grammar];
   function merge_with_duplicates(param, _L_, compare){
    var next2 = _L_[2], s2 = _L_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [1, b], [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, [0, a], [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 <= comparison
               ? 0
                 === comparison
                 ? [1, [2, a, b$0], [0, [0, s1$1], [0, s2$3]]]
                 : [1, [1, b$0], [0, s1, [0, s2$3]]]
               : [1, [0, a], [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function merge_deduped_and_sorted(s1, s2, compare){
    function _K_(param){var x = param[1]; return x;}
    return caml_call2(map$0, merge_with_duplicates(s1, s2, compare), _K_);
   }
   function merge_sorted(param, _J_, compare){
    var next2 = _J_[2], s2 = _J_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, b, [0, 0, [0, s2$0]]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var s2$2 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof s2$2 === "number") return [1, a, [0, [0, s1$1], 0]];
      if(0 !== s2$2[0]){
       var
        s2$3 = s2$2[2],
        b$0 = s2$2[1],
        comparison = caml_call2(compare, a, b$0);
       return 0 < comparison
               ? [1, b$0, [0, s1, [0, s2$3]]]
               : [1, a, [0, [0, s1$1], s2$2]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function hd(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
     var a = match[1];
     return [0, a];
    }
   }
   function hd_exn(s){
    var match = hd(s);
    if(! match) return caml_call1(Base_Import[123], cst_hd_exn);
    var a = match[1];
    return a;
   }
   function tl(s){
    var next = s[2], s$2 = s[1], s$0 = s$2;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      var match$0 = 0;
     else{
      if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
      var a = match[2], match$0 = [0, a];
     }
     if(! match$0) return 0;
     var s$3 = match$0[1];
     return [0, [0, s$3, next]];
    }
   }
   function tl_eagerly_exn(s){
    var match = tl(s);
    if(! match) return caml_call1(Base_Import[123], cst_Sequence_tl_exn);
    var s$0 = match[1];
    return s$0;
   }
   function lift_identity(next, s){
    var match = caml_call1(next, s);
    if(typeof match === "number") return 0;
    if(0 === match[0]){var s$0 = match[1]; return [0, [0, 316735838, s$0]];}
    var s$1 = match[2], a = match[1];
    return [1, a, [0, 316735838, s$1]];
   }
   function next(s){
    var next = s[2], s$3 = s[1], s$0 = s$3;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
     var s$2 = match[2], a = match[1];
     return [0, [0, a, [0, s$2, next]]];
    }
   }
   function filter_opt(s){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var match$0 = match[1];
             if(match$0){
              var s$1 = match[2], a = match$0[1];
              return [1, a, s$1];
             }
             var s$2 = match[2];
             return [0, s$2];
            }];
   }
   function filter_map(s, f){return filter_opt(caml_call2(map$0, s, f));}
   function filter_mapi(s, f){
    function _I_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return filter_map(mapi(s, function(i, s){return [0, i, s];}), _I_);
   }
   function split_n(s, n){
    var next = s[2], s$3 = s[1], s$0 = s$3, i = n, accum = 0;
    for(;;){
     if(0 >= i) return [0, caml_call1(Base_List1[21], accum), [0, s$0, next]];
     var match = caml_call1(next, s$0);
     if(typeof match === "number")
      return [0, caml_call1(Base_List1[21], accum), empty];
     if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
     var
      s$2 = match[2],
      a = match[1],
      accum$0 = [0, a, accum],
      i$0 = caml_call2(Base_Import[92], i, 1),
      s$0 = s$2,
      i = i$0,
      accum = accum$0;
    }
   }
   function chunks_exn(t, n){
    return 0 < n
            ? [0,
              t,
              function(t){
               var match = split_n(t, n), xs = match[1];
               if(! xs) return 0;
               var t$0 = match[2];
               return [1, xs, t$0];
              }]
            : caml_call1(Base_Import[125], cst_Sequence_chunks_exn);
   }
   function findi(s, f){
    function _H_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return find(mapi(s, function(i, s){return [0, i, s];}), _H_);
   }
   function find_exn(s, f){
    var match = find(s, f);
    if(! match) return caml_call1(Base_Import[123], cst_Sequence_find_exn);
    var x = match[1];
    return x;
   }
   function append(s1, s2){
    var next2 = s2[2], s2$0 = s2[1], next1 = s1[2], s1$0 = s1[1];
    return [0,
            [0, 472258093, s1$0],
            function(param){
             if(472258093 <= param[1]){
              var s1 = param[2], match = caml_call1(next1, s1);
              if(typeof match === "number") return [0, [0, -630817751, s2$0]];
              if(0 === match[0]){
               var s1$0 = match[1];
               return [0, [0, 472258093, s1$0]];
              }
              var s1$1 = match[2], a = match[1];
              return [1, a, [0, 472258093, s1$1]];
             }
             var s2 = param[2], match$0 = caml_call1(next2, s2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s2$1 = match$0[1];
              return [0, [0, -630817751, s2$1]];
             }
             var s2$2 = match$0[2], a$0 = match$0[1];
             return [1, a$0, [0, -630817751, s2$2]];
            }];
   }
   function concat_map(s, f){return caml_call2(bind$0, s, f);}
   function concat(s){return concat_map(s, function(_G_){return _G_;});}
   function concat_mapi(s, f){
    function _F_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return concat_map(mapi(s, function(i, s){return [0, i, s];}), _F_);
   }
   function zip(param, _D_){
    var next2 = _D_[2], s2 = _D_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var _E_ = param[1], switch$0 = 0;
     if(typeof _E_ === "number")
      switch$0 = 1;
     else if(1 === _E_[0]){
      var match = param[2], s1$0 = _E_[2], a = _E_[1];
      if(typeof match !== "number"){
       if(0 === match[0]){
        var s2$0 = param[2][1];
        return [0, [0, _E_, caml_call1(next2, s2$0)]];
       }
       var s2$1 = match[2], b = match[1];
       return [1, [0, a, b], [0, [0, s1$0], [0, s2$1]]];
      }
     }
     if(! switch$0 && typeof param[2] !== "number"){
      var s2 = param[2], s1 = _E_[1];
      return [0, [0, caml_call1(next1, s1), s2]];
     }
     return 0;
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function zip_full(param, _C_){
    var next2 = _C_[2], s2 = _C_[1], next1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[1];
     if(typeof s1 === "number"){
      var match = param[2];
      if(typeof match === "number") return 0;
      if(0 !== match[0]){
       var s2$0 = match[2], b = match[1];
       return [1, [0, -57574468, b], [0, 0, caml_call1(next2, s2$0)]];
      }
     }
     else{
      if(0 === s1[0]){
       var s2$1 = param[2], s1$0 = s1[1];
       return [0, [0, caml_call1(next1, s1$0), s2$1]];
      }
      var match$0 = param[2], s1$1 = s1[2], a = s1[1];
      if(typeof match$0 === "number")
       return [1, [0, 847852583, a], [0, caml_call1(next1, s1$1), 0]];
      if(0 !== match$0[0]){
       var s2$2 = match$0[2], b$0 = match$0[1];
       return [1, [0, 737457313, [0, a, b$0]], [0, [0, s1$1], [0, s2$2]]];
      }
     }
     var s2 = param[2][1];
     return [0, [0, s1, caml_call1(next2, s2)]];
    }
    return [0, [0, [0, s1], [0, s2]], next];
   }
   function bounded_length(param, at_most){
    var next = param[2], seed = param[1], i = 0, seed$0 = seed;
    for(;;){
     if(at_most < i) return 85047514;
     var match = caml_call1(next, seed$0);
     if(typeof match === "number") return [0, 16394, i];
     if(0 === match[0]){var seed$1 = match[1], seed$0 = seed$1; continue;}
     var
      seed$2 = match[2],
      i$0 = caml_call2(Base_Import[90], i, 1),
      i = i$0,
      seed$0 = seed$2;
    }
   }
   function length_is_bounded_by(opt, max, t){
    if(opt) var sth = opt[1], min = sth; else var min = -1;
    if(max){
     var max$0 = max[1], match$0 = bounded_length(t, max$0);
     if(typeof match$0 !== "number" && 16394 === match$0[1]){var len = match$0[2]; if(min <= len) return 1;}
     return 0;
    }
    var next = t[2], s = t[1], s$0 = s, acc = 0;
    for(;;){
     if(min <= acc) return 1;
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
     var
      s$2 = match[2],
      acc$0 = caml_call2(Base_Import[90], acc, 1),
      s$0 = s$2,
      acc = acc$0;
    }
   }
   function iteri(s, f){
    function _B_(param){
     var s = param[2], i = param[1];
     return caml_call2(f, i, s);
    }
    return iter(mapi(s, function(i, s){return [0, i, s];}), _B_);
   }
   function foldi(s, init, f){
    function _A_(acc, param){
     var s = param[2], i = param[1];
     return caml_call3(f, i, acc, s);
    }
    return fold(mapi(s, function(i, s){return [0, i, s];}), init, _A_);
   }
   function reduce(s, f){
    var match = next(s);
    if(! match) return 0;
    var match$0 = match[1], s$0 = match$0[2], a = match$0[1];
    return [0, fold(s$0, a, f)];
   }
   function reduce_exn(s, f){
    var match = reduce(s, f);
    if(! match) return caml_call1(Base_Import[123], cst_Sequence_reduce_exn);
    var res = match[1];
    return res;
   }
   function group(param, break$0){
    var next = param[2], s = param[1];
    return [0,
            [0, [0, 0, s]],
            function(param){
             if(! param) return 0;
             var
              match = param[1],
              s = match[2],
              acc = match[1],
              match$0 = caml_call1(next, s);
             if(typeof match$0 !== "number" && 0 === match$0[0]){
              var s$2 = match$0[1];
              return [0, [0, [0, acc, s$2]]];
             }
             if(acc){
              if(typeof match$0 === "number")
               return [1, caml_call1(Base_List1[21], acc), 0];
              var s$0 = match$0[2], cur = match$0[1], prev = acc[1];
              return caml_call2(break$0, prev, cur)
                      ? [1,
                        caml_call1(Base_List1[21], acc),
                        [0, [0, [0, cur, 0], s$0]]]
                      : [0, [0, [0, [0, cur, acc], s$0]]];
             }
             if(typeof match$0 === "number") return 0;
             var s$1 = match$0[2], cur$0 = match$0[1];
             return [0, [0, [0, [0, cur$0, 0], s$1]]];
            }];
   }
   function find_consecutive_duplicate(param, equal){
    var next = param[2], s = param[1], last_elt = 0, s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
     var s$2 = match[2], a = match[1];
     if(last_elt){
      var b = last_elt[1];
      if(caml_call2(equal, a, b)) return [0, [0, b, a]];
     }
     var last_elt$0 = [0, a], last_elt = last_elt$0, s$0 = s$2;
    }
   }
   function remove_consecutive_duplicates(s, equal){
    return unfold_with
            (s,
             0,
             function(prev, a){
              if(prev){
               var b = prev[1];
               if(caml_call2(equal, a, b)) return [0, [0, a]];
              }
              return [1, a, [0, a]];
             });
   }
   function count(s, f){return length(filter(s, f));}
   function counti(t, f){return length(filteri(t, f));}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function init(n, f){
    return [0,
            0,
            function(i){
             if(n <= i) return 0;
             var _z_ = caml_call2(Base_Import[90], i, 1);
             return [1, caml_call1(f, i), _z_];
            }];
   }
   function sub(s, pos, len){
    var _x_ = pos < 0 ? 1 : 0, _y_ = _x_ || (len < 0 ? 1 : 0);
    if(_y_) caml_call1(Base_Import[123], cst_Sequence_sub);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= caml_call2(Base_Import[92], i, pos)) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(pos <= i)
              return [1, a, [0, caml_call2(Base_Import[90], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[90], i, 1), s$2]];
            }];
   }
   function take(s, len){
    if(len < 0) caml_call1(Base_Import[123], cst_Sequence_take);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1];
             if(len <= i) return 0;
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var s$1 = match[2], a = match[1];
             return [1, a, [0, caml_call2(Base_Import[90], i, 1), s$1]];
            }];
   }
   function drop(s, len){
    if(len < 0) caml_call1(Base_Import[123], cst_Sequence_drop);
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 0, s$0],
            function(param){
             var s = param[2], i = param[1], match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, [0, i, s$0]];}
             var a = match[1], s$1 = match[2];
             if(len <= i)
              return [1, a, [0, caml_call2(Base_Import[90], i, 1), s$1]];
             var s$2 = match[2];
             return [0, [0, caml_call2(Base_Import[90], i, 1), s$2]];
            }];
   }
   function take_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            s$0,
            function(s){
             var match = caml_call1(next, s);
             if(typeof match === "number") return 0;
             if(0 === match[0]){var s$0 = match[1]; return [0, s$0];}
             var a = match[1], s$1 = match[2];
             return caml_call1(f, a) ? [1, a, s$1] : 0;
            }];
   }
   function drop_while(s, f){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, -557110719, s$0],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var s$0 = param[2], match = caml_call1(next, s$0);
             if(typeof match === "number") return 0;
             if(0 === match[0]){
              var s$1 = match[1];
              return [0, [0, -557110719, s$1]];
             }
             var a = match[1], s$2 = match[2];
             if(caml_call1(f, a)) return [0, [0, -557110719, s$2]];
             var s$3 = match[2];
             return [1, a, [0, 316735838, s$3]];
            }];
   }
   function shift_right(s, x){
    var next = s[2], seed = s[1];
    return [0,
            [0, -433944719, [0, seed, x]],
            function(param){
             if(316735838 <= param[1]){
              var s = param[2];
              return lift_identity(next, s);
             }
             var match = param[2], x = match[2], seed = match[1];
             return [1, x, [0, 316735838, seed]];
            }];
   }
   function shift_right_with_list(s, l){return append(of_list(l), s);}
   var Infix = [0, append];
   function intersperse(s, sep){
    var next = s[2], s$0 = s[1];
    return [0,
            [0, 815032112, s$0],
            function(param){
             var _w_ = param[1];
             if(815032112 === _w_){
              var s = param[2], match = caml_call1(next, s);
              if(typeof match === "number") return 0;
              if(0 === match[0]){
               var s$0 = match[1];
               return [0, [0, 815032112, s$0]];
              }
              var s$1 = match[2], a = match[1];
              return [1, a, [0, 951752159, s$1]];
             }
             if(951752159 > _w_){
              var match$1 = param[2], s$5 = match$1[2], a$1 = match$1[1];
              return [1, a$1, [0, 951752159, s$5]];
             }
             var s$2 = param[2], match$0 = caml_call1(next, s$2);
             if(typeof match$0 === "number") return 0;
             if(0 === match$0[0]){
              var s$3 = match$0[1];
              return [0, [0, 951752159, s$3]];
             }
             var s$4 = match$0[2], a$0 = match$0[1];
             return [1, sep, [0, -571577571, [0, a$0, s$4]]];
            }];
   }
   function repeat(x){return [0, x, function(x){return [1, x, x];}];}
   function cycle_list_exn(xs){
    if(caml_call1(Base_List1[23], xs))
     caml_call1(Base_Import[125], cst_Sequence_cycle_list_exn);
    var s = of_list(xs);
    function _v_(param){return s;}
    return concat_map(repeat(0), _v_);
   }
   function cartesian_product(sa, sb){
    return concat_map(sa, function(a){return zip(repeat(a), sb);});
   }
   function singleton(x){return caml_call1(return$1, x);}
   function delayed_fold(s, init, f, finish){
    function _u_(acc, option, k){
     if(! option) return caml_call1(k, acc);
     var a = option[1];
     return caml_call3(f, acc, a, k);
    }
    return caml_call4(Expert[2], s, init, _u_, finish);
   }
   function fold_m(bind, return$0, t, init, f){
    function _t_(acc, option, k){
     if(! option) return caml_call2(bind, caml_call1(return$0, acc), k);
     var a = option[1];
     return caml_call2(bind, caml_call2(f, acc, a), k);
    }
    return caml_call4(Expert[2], t, init, _t_, return$0);
   }
   function iter_m(bind, return$0, t, f){
    function _s_(param, option, k){
     if(! option) return caml_call2(bind, caml_call1(return$0, 0), k);
     var a = option[1];
     return caml_call2(bind, caml_call1(f, a), k);
    }
    return caml_call4(Expert[2], t, 0, _s_, return$0);
   }
   function fold_until(s, init, f, finish){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(finish, acc);
     if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
     var s$2 = match[2], a = match[1], match$0 = caml_call2(f, acc, a);
     if(0 === match$0[0]){
      var acc$0 = match$0[1], s$0 = s$2, acc = acc$0;
      continue;
     }
     var x = match$0[1];
     return x;
    }
   }
   function fold_result(s, init, f){
    var next = s[2], s$3 = s[1], s$0 = s$3, acc = init;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return caml_call1(Base_Result[12], acc);
     if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
     var s$2 = match[2], a = match[1], e = caml_call2(f, acc, a);
     if(0 !== e[0]) return e;
     var acc$0 = e[1], s$0 = s$2, acc = acc$0;
    }
   }
   function force_eagerly(t){return of_list(to_list(t));}
   function memoize(param){
    var next = param[2], s = param[1];
    function memoize(s){
     return [0,
             [246,
              function(_r_){
               var s$0 = s;
               for(;;){
                var match = caml_call1(next, s$0);
                if(typeof match === "number") return 0;
                if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
                var s$2 = match[2], a = match[1];
                return [1, a, memoize(s$2)];
               }
              }]];
    }
    function _p_(param){
     var l = param[1], _q_ = caml_obj_tag(l);
     return 250 === _q_
             ? l[1]
             : 246 === _q_ ? caml_call1(CamlinternalLazy[2], l) : l;
    }
    return [0, memoize(s), _p_];
   }
   function drop_eagerly(s, len){
    var next = s[2], s$3 = s[1], i = 0, s$0 = s$3;
    for(;;){
     if(len <= i) return [0, s$0, next];
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return empty;
     if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
     var
      s$2 = match[2],
      i$0 = caml_call2(Base_Import[90], i, 1),
      i = i$0,
      s$0 = s$2;
    }
   }
   function drop_while_option(param, f){
    var next = param[2], s = param[1], s$0 = s;
    for(;;){
     var match = caml_call1(next, s$0);
     if(typeof match === "number") return 0;
     if(0 === match[0]){var s$1 = match[1], s$0 = s$1; continue;}
     var s$2 = match[2], x = match[1];
     if(! caml_call1(f, x)) return [0, [0, x, [0, s$2, next]]];
     var s$0 = s$2;
    }
   }
   function compare$0(compare_a, t1, t2){
    function _l_(r){
     function _m_(param){
      var _n_ = param[1];
      if(737457313 !== _n_)
       return 847852583 <= _n_ ? caml_call1(r, 1) : caml_call1(r, -1);
      var
       match = param[2],
       v2 = match[2],
       v1 = match[1],
       c = caml_call2(compare_a, v1, v2),
       _o_ = 0 !== c ? 1 : 0;
      return _o_ ? caml_call1(r, c) : _o_;
     }
     iter(zip_full(t1, t2), _m_);
     return 0;
    }
    return caml_call1(Base_With_return[1], _l_);
   }
   function equal(equal_a, t1, t2){
    function _k_(param){
     if(737457313 !== param[1]) return 0;
     var match = param[2], a2 = match[2], a1 = match[1];
     return caml_call2(equal_a, a1, a2);
    }
    return for_all(zip_full(t1, t2), _k_);
   }
   function round_robin(list){
    function next(param){
     var done_stack = param[2], todo_stack = param[1];
     if(! todo_stack)
      return caml_call1(Base_List1[23], done_stack)
              ? 0
              : [0, [0, caml_call1(Base_List1[21], done_stack), 0]];
     var
      todo_stack$0 = todo_stack[2],
      match = todo_stack[1],
      f = match[2],
      s = match[1],
      match$0 = caml_call1(f, s);
     if(typeof match$0 === "number")
      return [0, [0, todo_stack$0, done_stack]];
     if(0 === match$0[0]){
      var s$0 = match$0[1];
      return [0, [0, [0, [0, s$0, f], todo_stack$0], done_stack]];
     }
     var s$1 = match$0[2], x = match$0[1];
     return [1, x, [0, todo_stack$0, [0, [0, s$1, f], done_stack]]];
    }
    var state = [0, list, 0];
    return [0, state, next];
   }
   function interleave(param){
    var f1 = param[2], s1 = param[1];
    function next(param){
     var s1 = param[3], done_stack = param[2], todo_stack = param[1];
     if(todo_stack){
      var
       todo_stack$0 = todo_stack[2],
       match = todo_stack[1],
       f2 = match[2],
       s2 = match[1],
       match$0 = caml_call1(f2, s2);
      if(typeof match$0 === "number")
       return [0, [0, todo_stack$0, done_stack, s1]];
      if(0 === match$0[0]){
       var s2$0 = match$0[1];
       return [0, [0, todo_stack$0, [0, [0, s2$0, f2], done_stack], s1]];
      }
      var s2$1 = match$0[2], x = match$0[1];
      return [1, x, [0, todo_stack$0, [0, [0, s2$1, f2], done_stack], s1]];
     }
     var match$1 = caml_call1(f1, s1);
     if(typeof match$1 === "number")
      return done_stack
              ? [0, [0, caml_call1(Base_List1[21], done_stack), 0, s1]]
              : 0;
     if(0 === match$1[0]){
      var s1$0 = match$1[1];
      return [0, [0, caml_call1(Base_List1[21], done_stack), 0, s1$0]];
     }
     var s1$1 = match$1[2], t = match$1[1];
     return [0, [0, caml_call1(Base_List1[21], [0, t, done_stack]), 0, s1$1]];
    }
    var state = [0, 0, 0, s1];
    return [0, state, next];
   }
   function interleaved_cartesian_product(s1, s2){
    return interleave
            (caml_call2
              (map$0,
               s1,
               function(x1){
                return caml_call2
                        (map$0, s2, function(x2){return [0, x1, x2];});
               }));
   }
   function of_seq(seq){
    return [0,
            seq,
            function(seq){
             var match = caml_call1(seq, 0);
             if(! match) return 0;
             var tl = match[2], hd = match[1];
             return [1, hd, tl];
            }];
   }
   function to_seq(param){
    var next = param[2], state = param[1];
    function loop(state){
     var state$0 = state;
     for(;;){
      var match = caml_call1(next, state$0);
      if(typeof match === "number") return 0;
      if(0 === match[0]){var state$1 = match[1], state$0 = state$1; continue;}
      var state$2 = match[2], hd = match[1];
      return [0, hd, function(param){return loop(state$2);}];
     }
    }
    return function(param){return loop(state);};
   }
   function return$2(x, k){return caml_call1(k, x);}
   function bind$1(m, f, k){
    return caml_call1
            (m,
             function(a){var m = caml_call1(f, a); return caml_call1(m, k);});
   }
   var
    map$1 =
      [0,
       -198771759,
       function(m, f, k){
        return caml_call1
                (m, function(a){return caml_call1(k, caml_call1(f, a));});
       }],
    include$0 = caml_call1(Base_Monad[2], [0, bind$1, map$1, return$2]),
    symbol_bind$0 = include$0[1],
    symbol_map$0 = include$0[2],
    Let_syntax$0 = include$0[3],
    Monad_infix$0 = include$0[4],
    bind$2 = include$0[5],
    return$3 = include$0[6],
    map$2 = include$0[7],
    join$0 = include$0[8],
    ignore_m$0 = include$0[9],
    all$0 = include$0[10],
    all_unit$0 = include$0[11];
   function yield$0(e, k){return [0, [1, e, k]];}
   function of_sequence(sequence){
    return delayed_fold
            (sequence,
             0,
             function(param, x, k, f){
              return [0, [1, x, function(param){return caml_call2(k, 0, f);}]];
             },
             return$3);
   }
   function run(t){
    function init(param){return caml_call1(t, function(param){return _j_;});}
    function f(thunk){return caml_call1(thunk, 0)[1];}
    return [0, init, f];
   }
   var
    Base_Sequence =
      [0,
       sexp_of_t$0,
       equal,
       compare$0,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       counti,
       findi,
       find_mapi,
       symbol_bind,
       symbol_map,
       Monad_infix,
       bind$0,
       return$1,
       map$0,
       join,
       ignore_m,
       all,
       all_unit,
       Let_syntax,
       empty,
       next,
       Step,
       unfold_step,
       unfold,
       unfold_with,
       unfold_with_and_finish,
       nth,
       nth_exn,
       folding_map,
       folding_mapi,
       mapi,
       filteri,
       filter,
       merge_deduped_and_sorted,
       merge_deduped_and_sorted,
       merge_sorted,
       Merge_with_duplicates_element,
       merge_with_duplicates,
       hd,
       hd_exn,
       tl,
       tl_eagerly_exn,
       find_exn,
       for_alli,
       append,
       concat,
       concat_map,
       concat_mapi,
       interleave,
       round_robin,
       zip,
       zip_full,
       reduce_exn,
       reduce,
       group,
       find_consecutive_duplicate,
       remove_consecutive_duplicates,
       range,
       init,
       filter_map,
       filter_mapi,
       filter_opt,
       sub,
       take,
       drop,
       drop_eagerly,
       take_while,
       drop_while,
       drop_while_option,
       split_n,
       chunks_exn,
       shift_right,
       shift_right_with_list,
       drop,
       Infix,
       cartesian_product,
       interleaved_cartesian_product,
       intersperse,
       cycle_list_exn,
       repeat,
       singleton,
       delayed_fold,
       fold_m,
       iter_m,
       to_list_rev,
       of_list,
       of_lazy,
       memoize,
       force_eagerly,
       bounded_length,
       length_is_bounded_by,
       of_seq,
       to_seq,
       [0,
        symbol_bind$0,
        symbol_map$0,
        Let_syntax$0,
        Monad_infix$0,
        bind$2,
        return$3,
        map$2,
        join$0,
        ignore_m$0,
        all$0,
        all_unit$0,
        yield$0,
        of_sequence,
        run],
       Expert];
   runtime.caml_register_global(48, Base_Sequence, "Base__Sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Array
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Array_permute, Base__Binary_searchable, Base__Blit, Base__Container, Base__Import, Base__List, Base__Option, Base__Ordered_collection_common, Base__Random, Base__Sequence
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_array_ml = "src/array.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Sequence = global_data.Base__Sequence,
    Base_Random = global_data.Base__Random,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Container = global_data.Base__Container,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Array0 = global_data.Base__Array0,
    Base_Array_permute = global_data.Base__Array_permute,
    Base_Binary_searchable = global_data.Base__Binary_searchable,
    Base_Blit = global_data.Base__Blit,
    invalid_argf = Base_Array0[1],
    max_length = Base_Array0[3],
    create = Base_Array0[4],
    create_float_uninitialized = Base_Array0[5],
    append = Base_Array0[6],
    concat = Base_Array0[8],
    copy = Base_Array0[9],
    fill = Base_Array0[10],
    init = Base_Array0[11],
    make_matrix = Base_Array0[12],
    of_list = Base_Array0[13],
    sub = Base_Array0[14],
    to_list = Base_Array0[15],
    fold = Base_Array0[16],
    fold_right = Base_Array0[17],
    iter = Base_Array0[18],
    iteri = Base_Array0[19],
    map = Base_Array0[20],
    mapi = Base_Array0[21],
    stable_sort = Base_Array0[22],
    swap = Base_Array0[23],
    compare = Base_Import[234],
    t_of_sexp = Base_Import[176],
    sexp_of_t = Base_Import[152],
    _g_ = [0, cst_src_array_ml, 858, 8],
    cst_Array_transpose_exn = "Array.transpose_exn",
    cst_Array_zip_exn = "Array.zip_exn",
    cst_Array_random_element_exn_e = "Array.random_element_exn: empty array",
    cst_Array_reduce_exn = "Array.reduce_exn",
    _d_ = [0, "Array.find_exn: not found"],
    _c_ = [0, "Array.findi_exn: not found"],
    cst_Array_for_all2_exn = "Array.for_all2_exn",
    cst_Array_exists2_exn = "Array.exists2_exn",
    cst_Array_fold2_exn = "Array.fold2_exn",
    cst_Array_map2_exn = "Array.map2_exn",
    cst_Array_iter2_exn = "Array.iter2_exn",
    _b_ =
      [0,
       [11,
        "length mismatch in ",
        [2, 0, [11, ": ", [4, 0, 0, 0, [11, " <> ", [4, 0, 0, 0, 0]]]]]],
       "length mismatch in %s: %d <> %d"],
    _a_ = [0, cst_src_array_ml, 435, 14],
    _e_ = [0, "Array.find_map_exn: not found"],
    _f_ = [0, "Array.find_mapi_exn: not found"];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[195], a_sexp_grammar);
   }
   function get(_aL_, _aK_){return caml_check_bound(_aL_, _aK_)[1 + _aK_];}
   function set(_aJ_, _aI_, _aH_){
    caml_check_bound(_aJ_, _aI_)[1 + _aI_] = _aH_;
    return 0;
   }
   function swap$0(arr, i, j){
    var tmp = get(arr, i);
    set(arr, i, get(arr, j));
    return set(arr, j, tmp);
   }
   function sort(arr, compare, left, right){
    var _aF_ = caml_call2(Base_Import[90], left, 1);
    if(right >= _aF_){
     var pos = _aF_;
     a:
     for(;;){
      var v = get(arr, pos), final_pos = pos;
      for(;;){
       var i_next = caml_call2(Base_Import[92], final_pos, 1);
       if(left <= i_next && 0 < caml_call2(compare, get(arr, i_next), v)){
        set(arr, final_pos, get(arr, i_next));
        var final_pos = i_next;
        continue;
       }
       set(arr, final_pos, v);
       var _aG_ = pos + 1 | 0;
       if(right !== pos){var pos = _aG_; continue a;}
       break;
      }
      break;
     }
    }
    return 0;
   }
   var Insertion_sort = [0, sort];
   function heapify(arr, compare, root, left, right){
    var root$0 = root;
    for(;;){
     var
      relative_root = caml_call2(Base_Import[92], root$0, left),
      _ay_ = caml_call2(Base_Import[87], 2, relative_root),
      _az_ = caml_call2(Base_Import[90], _ay_, left),
      left_child = caml_call2(Base_Import[90], _az_, 1),
      _aA_ = caml_call2(Base_Import[87], 2, relative_root),
      _aB_ = caml_call2(Base_Import[90], _aA_, left),
      right_child = caml_call2(Base_Import[90], _aB_, 2),
      switch$0 = 0;
     if(left_child <= right){
      var _aC_ = get(arr, root$0);
      if(0 < caml_call2(compare, get(arr, left_child), _aC_)){var largest = left_child; switch$0 = 1;}
     }
     if(! switch$0) var largest = root$0;
     var switch$1 = 0;
     if(right_child <= right){
      var _aD_ = get(arr, largest);
      if(0 < caml_call2(compare, get(arr, right_child), _aD_)){var largest$0 = right_child; switch$1 = 1;}
     }
     if(! switch$1) var largest$0 = largest;
     var _aE_ = largest$0 !== root$0 ? 1 : 0;
     if(! _aE_) return _aE_;
     swap$0(arr, root$0, largest$0);
     var root$0 = largest$0;
    }
   }
   function sort$0(arr, compare, left, right){
    var
     _at_ = caml_call2(Base_Import[90], left, right),
     _au_ = caml_call2(Base_Import[94], _at_, 2);
    if(_au_ >= left){
     var i = _au_;
     for(;;){
      heapify(arr, compare, i, left, right);
      var _av_ = i - 1 | 0;
      if(left !== i){var i = _av_; continue;}
      break;
     }
    }
    var _aw_ = caml_call2(Base_Import[90], left, 1);
    if(right >= _aw_){
     var i$0 = right;
     for(;;){
      swap$0(arr, left, i$0);
      heapify(arr, compare, left, left, caml_call2(Base_Import[92], i$0, 1));
      var _ax_ = i$0 - 1 | 0;
      if(_aw_ !== i$0){var i$0 = _ax_; continue;}
      break;
     }
    }
    return 0;
   }
   var Heap_sort = [0, sort$0];
   function five_element_sort(arr, compare, m1, m2, m3, m4, m5){
    function compare_and_swap(i, j){
     var
      _ar_ = get(arr, j),
      _as_ = 0 < caml_call2(compare, get(arr, i), _ar_) ? 1 : 0;
     return _as_ ? swap$0(arr, i, j) : _as_;
    }
    compare_and_swap(m1, m2);
    compare_and_swap(m4, m5);
    compare_and_swap(m1, m3);
    compare_and_swap(m2, m3);
    compare_and_swap(m1, m4);
    compare_and_swap(m3, m4);
    compare_and_swap(m2, m5);
    compare_and_swap(m2, m3);
    return compare_and_swap(m4, m5);
   }
   function intro_sort(arr, max_depth, compare, left, right){
    var max_depth$0 = max_depth, left$0 = left;
    a:
    for(;;){
     var
      _aq_ = caml_call2(Base_Import[92], right, left$0),
      len = caml_call2(Base_Import[90], _aq_, 1);
     if(32 >= len)
      return caml_call4(Insertion_sort[1], arr, compare, left$0, right);
     if(0 > max_depth$0)
      return caml_call4(Heap_sort[1], arr, compare, left$0, right);
     var
      max_depth$1 = caml_call2(Base_Import[92], max_depth$0, 1),
      _ap_ = caml_call2(Base_Import[92], right, left$0),
      sixth = caml_call2(Base_Import[94], _ap_, 6),
      m1 = caml_call2(Base_Import[90], left$0, sixth),
      m2 = caml_call2(Base_Import[90], m1, sixth),
      m3 = caml_call2(Base_Import[90], m2, sixth),
      m4 = caml_call2(Base_Import[90], m3, sixth),
      m5 = caml_call2(Base_Import[90], m4, sixth);
     five_element_sort(arr, compare, m1, m2, m3, m4, m5);
     var
      m2_val = get(arr, m2),
      m3_val = get(arr, m3),
      m4_val = get(arr, m4),
      match =
        0 === caml_call2(compare, m2_val, m3_val)
         ? [0, m2_val, m3_val, 1]
         : 0
           === caml_call2(compare, m3_val, m4_val)
           ? [0, m3_val, m4_val, 1]
           : [0, m2_val, m4_val, 0],
      middle_sorted = match[3],
      pivot2 = match[2],
      pivot1 = match[1],
      l$0 = left$0,
      p$1 = left$0,
      r$2 = right;
     b:
     for(;;){
      if(r$2 < p$1){
       intro_sort
        (arr,
         max_depth$1,
         compare,
         left$0,
         caml_call2(Base_Import[92], l$0, 1));
       if(1 - middle_sorted) intro_sort(arr, max_depth$1, compare, l$0, r$2);
       var
        left$1 = caml_call2(Base_Import[90], r$2, 1),
        max_depth$0 = max_depth$1,
        left$0 = left$1;
       continue a;
      }
      var pv = get(arr, p$1);
      if(0 > caml_call2(compare, pv, pivot1)){
       swap$0(arr, p$1, l$0);
       var
        p$0 = caml_call2(Base_Import[90], p$1, 1),
        l = caml_call2(Base_Import[90], l$0, 1),
        l$0 = l,
        p$1 = p$0;
       continue;
      }
      if(0 >= caml_call2(compare, pv, pivot2)){
       var p = caml_call2(Base_Import[90], p$1, 1), p$1 = p;
       continue;
      }
      var r = r$2;
      for(;;){
       if(p$1 < r && 0 < caml_call2(compare, get(arr, r), pivot2)){
        var r$0 = caml_call2(Base_Import[92], r, 1), r = r$0;
        continue;
       }
       swap$0(arr, r, p$1);
       var r$1 = caml_call2(Base_Import[92], r, 1), r$2 = r$1;
       continue b;
      }
     }
    }
   }
   function sort$1(arr, compare, left, right){
    return intro_sort(arr, 32, compare, left, right);
   }
   var Intro_sort = [0, sort$1, five_element_sort];
   function sort$2(pos, len, arr, compare){
    var
     match =
       caml_call4
        (Base_Ordered_collection_common[1], pos, len, 0, arr.length - 1),
     len$0 = match[2],
     pos$0 = match[1],
     _an_ = caml_call2(Base_Import[90], pos$0, len$0),
     _ao_ = caml_call2(Base_Import[92], _an_, 1);
    return caml_call4(Intro_sort[1], arr, compare, pos$0, _ao_);
   }
   function to_array(t){return t;}
   function is_empty(t){return 0 === t.length - 1 ? 1 : 0;}
   function is_sorted(t, compare){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[92], i[1], 1)];
      if(0 < caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function is_sorted_strictly(t, compare){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 < i[1] && result[1]){
      var
       elt_i = t[1 + i[1]],
       elt_i_minus_1 = t[1 + caml_call2(Base_Import[92], i[1], 1)];
      if(0 <= caml_call2(compare, elt_i_minus_1, elt_i)) result[1] = 0;
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function merge(a1, a2, compare){
    var l1 = a1.length - 1, l2 = a2.length - 1;
    if(0 === l1) return caml_call1(copy, a2);
    if(0 === l2) return caml_call1(copy, a1);
    var _ai_ = a1[1 + caml_call2(Base_Import[92], l1, 1)];
    if(0 <= caml_call2(compare, a2[1], _ai_))
     return caml_call2(append, a1, a2);
    var _aj_ = a2[1 + caml_call2(Base_Import[92], l2, 1)];
    if(0 < caml_call2(compare, a1[1], _aj_))
     return caml_call2(append, a2, a1);
    var
     len = caml_call2(Base_Import[90], l1, l2),
     merged = caml_call2(create, len, a1[1]),
     a1_index = [0, 0],
     a2_index = [0, 0],
     _al_ = caml_call2(Base_Import[92], len, 1),
     _ak_ = 0;
    if(_al_ >= 0){
     var i = _ak_;
     for(;;){
      var
       use_a1 =
         l1 === a1_index[1]
          ? 0
          : l2
            === a2_index[1]
            ? 1
            : caml_call2
               (compare, a1[1 + a1_index[1]], a2[1 + a2_index[1]])
              <= 0
              ? 1
              : 0;
      if(use_a1){
       merged[1 + i] = a1[1 + a1_index[1]];
       a1_index[1] = caml_call2(Base_Import[90], a1_index[1], 1);
      }
      else{
       merged[1 + i] = a2[1 + a2_index[1]];
       a2_index[1] = caml_call2(Base_Import[90], a2_index[1], 1);
      }
      var _am_ = i + 1 | 0;
      if(_al_ !== i){var i = _am_; continue;}
      break;
     }
    }
    return merged;
   }
   function copy_matrix(_ah_){return caml_call2(map, _ah_, copy);}
   function folding_map(t, init, f){
    var acc = [0, init];
    return caml_call2
            (map,
             t,
             function(x){
              var
               match = caml_call2(f, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_map(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (map,
         t,
         function(x){
          var
           match = caml_call2(f, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _af_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_ag_){return caml_call2(_af_, _ag_, t);};
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function foldi(t, init, f){
    var
     acc = [0, init],
     _ad_ = caml_call2(Base_Import[92], t.length - 1, 1),
     _ac_ = 0;
    if(_ad_ >= 0){
     var i = _ac_;
     for(;;){
      acc[1] = caml_call3(f, i, acc[1], t[1 + i]);
      var _ae_ = i + 1 | 0;
      if(_ad_ !== i){var i = _ae_; continue;}
      break;
     }
    }
    return acc[1];
   }
   function folding_mapi(t, init, f){
    var acc = [0, init];
    return caml_call2
            (mapi,
             t,
             function(i, x){
              var
               match = caml_call3(f, i, acc[1], x),
               y = match[2],
               new_acc = match[1];
              acc[1] = new_acc;
              return y;
             });
   }
   function fold_mapi(t, init, f){
    var
     acc = [0, init],
     result =
       caml_call2
        (mapi,
         t,
         function(i, x){
          var
           match = caml_call3(f, i, acc[1], x),
           y = match[2],
           new_acc = match[1];
          acc[1] = new_acc;
          return y;
         });
    return [0, acc[1], result];
   }
   function counti(t, f){
    return foldi
            (t,
             0,
             function(idx, count, a){
              return caml_call2(f, idx, a)
                      ? caml_call2(Base_Import[90], count, 1)
                      : count;
             });
   }
   function concat_map(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(map, t, f)));
   }
   function concat_mapi(t, f){
    return caml_call1(concat, caml_call1(to_list, caml_call2(mapi, t, f)));
   }
   function rev_inplace(t){
    var i = [0, 0], j = [0, caml_call2(Base_Import[92], t.length - 1, 1)];
    for(;;){
     if(i[1] >= j[1]) return 0;
     caml_call3(swap, t, i[1], j[1]);
     caml_call1(Base_Import[129], i);
     caml_call1(Base_Import[128], j);
    }
   }
   function rev(t){
    var t$0 = caml_call1(copy, t);
    rev_inplace(t$0);
    return t$0;
   }
   function of_list_rev(l){
    if(! l) return [0];
    var
     l$0 = l[2],
     a = l[1],
     _$_ = caml_call1(Base_List[7], l$0),
     len = caml_call2(Base_Import[90], 1, _$_),
     t = caml_call2(create, len, a),
     r = [0, l$0],
     _aa_ = caml_call2(Base_Import[92], len, 2);
    if(_aa_ >= 0){
     var i = _aa_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      var l$1 = match[2], a$0 = match[1];
      caml_check_bound(t, i)[1 + i] = a$0;
      r[1] = l$1;
      var _ab_ = i - 1 | 0;
      if(0 !== i){var i = _ab_; continue;}
      break;
     }
    }
    return t;
   }
   function of_list_map(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _Z_ = caml_call1(f, hd),
     ___ = caml_call1(Base_List[7], tl),
     a = caml_call2(create, caml_call2(Base_Import[90], 1, ___), _Z_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call1(f, hd$0);
     var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0, param = tl$0;
    }
   }
   function of_list_mapi(xs, f){
    if(! xs) return [0];
    var
     tl = xs[2],
     hd = xs[1],
     _X_ = caml_call2(f, 0, hd),
     _Y_ = caml_call1(Base_List[7], tl),
     a = caml_call2(create, caml_call2(Base_Import[90], 1, _Y_), _X_),
     i = 1,
     param = tl;
    for(;;){
     if(! param) return a;
     var tl$0 = param[2], hd$0 = param[1];
     a[1 + i] = caml_call2(f, i, hd$0);
     var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0, param = tl$0;
    }
   }
   function of_list_rev_map(xs, f){
    var t = of_list_map(xs, f);
    rev_inplace(t);
    return t;
   }
   function of_list_rev_mapi(xs, f){
    var t = of_list_mapi(xs, f);
    rev_inplace(t);
    return t;
   }
   function filter_mapi(t, f){
    var
     r = [0, [0]],
     k = [0, 0],
     _V_ = caml_call2(Base_Import[92], t.length - 1, 1),
     _U_ = 0;
    if(_V_ >= 0){
     var i = _U_;
     for(;;){
      var match = caml_call2(f, i, t[1 + i]);
      if(match){
       var a = match[1];
       if(0 === k[1]) r[1] = caml_call2(create, t.length - 1, a);
       r[1][1 + k[1]] = a;
       caml_call1(Base_Import[129], k);
      }
      var _W_ = i + 1 | 0;
      if(_V_ !== i){var i = _W_; continue;}
      break;
     }
    }
    return k[1] === t.length - 1
            ? r[1]
            : 0 < k[1] ? caml_call3(sub, r[1], 0, k[1]) : [0];
   }
   function filter_map(t, f){
    return filter_mapi(t, function(i, a){return caml_call1(f, a);});
   }
   function filter_opt(t){return filter_map(t, function(_T_){return _T_;});}
   function check_length2_exn(name, t1, t2){
    var n1 = t1.length - 1, n2 = t2.length - 1, _S_ = n1 !== n2 ? 1 : 0;
    return _S_ ? caml_call5(invalid_argf, _b_, name, n1, n2, 0) : _S_;
   }
   function iter2_exn(t1, t2, f){
    check_length2_exn(cst_Array_iter2_exn, t1, t2);
    return caml_call2
            (iteri, t1, function(i, x1){return caml_call2(f, x1, t2[1 + i]);});
   }
   function map2_exn(t1, t2, f){
    check_length2_exn(cst_Array_map2_exn, t1, t2);
    return caml_call2
            (init,
             t1.length - 1,
             function(i){return caml_call2(f, t1[1 + i], t2[1 + i]);});
   }
   function fold2_exn(t1, t2, init, f){
    check_length2_exn(cst_Array_fold2_exn, t1, t2);
    return foldi
            (t1,
             init,
             function(i, ac, x){return caml_call3(f, ac, x, t2[1 + i]);});
   }
   function filter(t, f){
    return filter_map(t, function(x){return caml_call1(f, x) ? [0, x] : 0;});
   }
   function filteri(t, f){
    return filter_mapi
            (t, function(i, x){return caml_call2(f, i, x) ? [0, x] : 0;});
   }
   function exists(t, f){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call1(f, t[1 + i[1]])){result[1] = 1; continue;}
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function existsi(t, f){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){result[1] = 1; continue;}
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function mem(t, a, equal){return exists(t, caml_call1(equal, a));}
   function for_all(t, f){
    var
     i = [0, caml_call2(Base_Import[92], t.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call1(f, t[1 + i[1]])){
       caml_call1(Base_Import[128], i);
       continue;
      }
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function for_alli(t, f){
    var
     length = t.length - 1,
     i = [0, caml_call2(Base_Import[92], length, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, i[1], t[1 + i[1]])){
       caml_call1(Base_Import[128], i);
       continue;
      }
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function exists2_exn(t1, t2, f){
    check_length2_exn(cst_Array_exists2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[92], t1.length - 1, 1)],
     result = [0, 0];
    for(;;){
     if(0 <= i[1] && ! result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){result[1] = 1; continue;}
      caml_call1(Base_Import[128], i);
      continue;
     }
     return result[1];
    }
   }
   function for_all2_exn(t1, t2, f){
    check_length2_exn(cst_Array_for_all2_exn, t1, t2);
    var
     i = [0, caml_call2(Base_Import[92], t1.length - 1, 1)],
     result = [0, 1];
    for(;;){
     if(0 <= i[1] && result[1]){
      if(caml_call2(f, t1[1 + i[1]], t2[1 + i[1]])){caml_call1(Base_Import[128], i); continue;}
      result[1] = 0;
      continue;
     }
     return result[1];
    }
   }
   function equal(equal, t1, t2){
    var _R_ = t1.length - 1 === t2.length - 1 ? 1 : 0;
    return _R_ ? for_all2_exn(t1, t2, equal) : _R_;
   }
   function map_inplace(t, f){
    var _P_ = caml_call2(Base_Import[92], t.length - 1, 1), _O_ = 0;
    if(_P_ >= 0){
     var i = _O_;
     for(;;){
      t[1 + i] = caml_call1(f, t[1 + i]);
      var _Q_ = i + 1 | 0;
      if(_P_ !== i){var i = _Q_; continue;}
      break;
     }
    }
    return 0;
   }
   function findi_internal(t, f, if_found, if_not_found){
    var length = t.length - 1;
    if(0 === length) return caml_call1(if_not_found, 0);
    var i = [0, 0], found = [0, 0], value_found = [0, t[1]];
    for(;;){
     if(! found[1] && i[1] < length){
      var value = t[1 + i[1]];
      if(caml_call2(f, i[1], value)){
       value_found[1] = value;
       found[1] = 1;
      }
      else
       caml_call1(Base_Import[129], i);
      continue;
     }
     return found[1]
             ? caml_call2(if_found, i[1], value_found[1])
             : caml_call1(if_not_found, 0);
    }
   }
   function findi(t, f){
    function _N_(param){return 0;}
    return findi_internal
            (t, f, function(i, value){return [0, [0, i, value]];}, _N_);
   }
   function findi_exn(t, f){
    function _M_(param){
     throw caml_maybe_attach_backtrace([0, Base_Import[251], _c_], 1);
    }
    return findi_internal
            (t, f, function(i, value){return [0, i, value];}, _M_);
   }
   function find_exn(t, f){
    function _K_(param){
     throw caml_maybe_attach_backtrace([0, Base_Import[251], _d_], 1);
    }
    function _L_(param, value){return value;}
    return findi_internal
            (t, function(i, x){return caml_call1(f, x);}, _L_, _K_);
   }
   function find(t, f){
    function _I_(param){var x = param[2]; return x;}
    var _J_ = findi(t, function(i, x){return caml_call1(f, x);});
    return caml_call2(Base_Option[21], _J_, _I_);
   }
   function find_map(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[49], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call1(f, value);
      caml_call1(Base_Import[129], i);
      continue;
     }
     return value_found[1];
    }
   }
   var not_found = [0, Base_Import[251], _e_];
   function find_map_exn(t, f){
    var match = find_map(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var x = match[1];
    return x;
   }
   function find_mapi(t, f){
    var length = t.length - 1;
    if(0 === length) return 0;
    var i = [0, 0], value_found = [0, 0];
    for(;;){
     if(caml_call1(Base_Option[49], value_found[1]) && i[1] < length){
      var value = t[1 + i[1]];
      value_found[1] = caml_call2(f, i[1], value);
      caml_call1(Base_Import[129], i);
      continue;
     }
     return value_found[1];
    }
   }
   var not_found$0 = [0, Base_Import[251], _f_];
   function find_mapi_exn(t, f){
    var match = find_mapi(t, f);
    if(! match) throw caml_maybe_attach_backtrace(not_found$0, 1);
    var x = match[1];
    return x;
   }
   function find_consecutive_duplicate(t, equal){
    var n = t.length - 1;
    if(1 >= n) return 0;
    var result = [0, 0], i = [0, 1], prev = [0, t[1]];
    for(;;){
     if(i[1] >= n) return result[1];
     var cur = t[1 + i[1]];
     if(caml_call2(equal, cur, prev[1])){
      result[1] = [0, [0, prev[1], cur]];
      i[1] = n;
     }
     else{prev[1] = cur; caml_call1(Base_Import[129], i);}
    }
   }
   function reduce(t, f){
    if(0 === t.length - 1) return 0;
    var
     r = [0, t[1]],
     _G_ = caml_call2(Base_Import[92], t.length - 1, 1),
     _F_ = 1;
    if(_G_ >= 1){
     var i = _F_;
     for(;;){
      r[1] = caml_call2(f, r[1], t[1 + i]);
      var _H_ = i + 1 | 0;
      if(_G_ !== i){var i = _H_; continue;}
      break;
     }
    }
    return [0, r[1]];
   }
   function reduce_exn(t, f){
    var match = reduce(t, f);
    if(! match) return caml_call1(Base_Import[125], cst_Array_reduce_exn);
    var v = match[1];
    return v;
   }
   var permute = Base_Array_permute[24];
   function random_element_exn(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    if(is_empty(t))
     return caml_call1(Base_Import[123], cst_Array_random_element_exn_e);
    var _E_ = caml_call2(Base_Random[18][6], random_state, t.length - 1);
    return caml_check_bound(t, _E_)[1 + _E_];
   }
   function random_element(opt, t){
    if(opt)
     var sth = opt[1], random_state = sth;
    else
     var random_state = Base_Random[18][1];
    try{var _C_ = [0, random_element_exn([0, random_state], t)]; return _C_;}
    catch(_D_){return 0;}
   }
   function zip(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? 0
            : [0, map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];})];
   }
   function zip_exn(t1, t2){
    return t1.length - 1 !== t2.length - 1
            ? caml_call1(Base_Import[123], cst_Array_zip_exn)
            : map2_exn(t1, t2, function(x1, x2){return [0, x1, x2];});
   }
   function unzip(t){
    var n = t.length - 1;
    if(0 === n) return [0, [0], [0]];
    var
     match = caml_check_bound(t, 0)[1],
     y = match[2],
     x = match[1],
     res1 = caml_call2(create, n, x),
     res2 = caml_call2(create, n, y),
     _A_ = caml_call2(Base_Import[92], n, 1),
     _z_ = 1;
    if(_A_ >= 1){
     var i = _z_;
     for(;;){
      var
       match$0 = caml_check_bound(t, i)[1 + i],
       y$0 = match$0[2],
       x$0 = match$0[1];
      caml_check_bound(res1, i)[1 + i] = x$0;
      caml_check_bound(res2, i)[1 + i] = y$0;
      var _B_ = i + 1 | 0;
      if(_A_ !== i){var i = _B_; continue;}
      break;
     }
    }
    return [0, res1, res2];
   }
   function sorted_copy(t, compare){
    var t1 = caml_call1(copy, t);
    sort$2(0, 0, t1, compare);
    return t1;
   }
   function partitioni_tf(t, f){
    var
     both =
       caml_call2
        (mapi,
         t,
         function(i, x){return caml_call2(f, i, x) ? [0, x] : [1, x];}),
     trues =
       filter_map
        (both,
         function(param){
          if(0 !== param[0]) return 0;
          var x = param[1];
          return [0, x];
         }),
     falses =
       filter_map
        (both,
         function(param){
          if(0 === param[0]) return 0;
          var x = param[1];
          return [0, x];
         });
    return [0, trues, falses];
   }
   function partition_tf(t, f){
    return partitioni_tf(t, function(i, x){return caml_call1(f, x);});
   }
   function last(t){
    var _y_ = caml_call2(Base_Import[92], t.length - 1, 1);
    return caml_check_bound(t, _y_)[1 + _y_];
   }
   function to_sequence_mutable(t){
    function _w_(i){
     if(t.length - 1 <= i) return 0;
     var _x_ = caml_call2(Base_Import[90], i, 1);
     return [1, caml_check_bound(t, i)[1 + i], _x_];
    }
    return caml_call2(Base_Sequence[41], 0, _w_);
   }
   function to_sequence(t){return to_sequence_mutable(caml_call1(copy, t));}
   function cartesian_product(t1, t2){
    if(! is_empty(t1) && ! is_empty(t2)){
     var
      n1 = t1.length - 1,
      n2 = t2.length - 1,
      _l_ = caml_check_bound(t2, 0)[1],
      _m_ = [0, caml_check_bound(t1, 0)[1], _l_],
      t = caml_call2(create, caml_call2(Base_Import[87], n1, n2), _m_),
      r = [0, 0],
      _o_ = caml_call2(Base_Import[92], n1, 1),
      _n_ = 0;
     if(_o_ >= 0){
      var i1 = _n_;
      for(;;){
       var _q_ = caml_call2(Base_Import[92], n2, 1), _p_ = 0;
       if(_q_ >= 0){
        var i2 = _p_;
        for(;;){
         var
          _s_ = caml_check_bound(t2, i2)[1 + i2],
          _t_ = [0, caml_check_bound(t1, i1)[1 + i1], _s_],
          _u_ = r[1];
         caml_check_bound(t, _u_)[1 + _u_] = _t_;
         caml_call1(Base_Import[129], r);
         var _v_ = i2 + 1 | 0;
         if(_q_ !== i2){var i2 = _v_; continue;}
         break;
        }
       }
       var _r_ = i1 + 1 | 0;
       if(_o_ !== i1){var i1 = _r_; continue;}
       break;
      }
     }
     return t;
    }
    return [0];
   }
   function transpose(tt){
    if(0 === tt.length - 1) return [0, [0]];
    var width = tt.length - 1, depth = caml_check_bound(tt, 0)[1].length - 1;
    return exists(tt, function(t){return t.length - 1 !== depth ? 1 : 0;})
            ? 0
            : [0,
              caml_call2
               (init,
                depth,
                function(d){
                 return caml_call2
                         (init,
                          width,
                          function(w){
                           return caml_check_bound(caml_check_bound(tt, w)[1 + w], d)
                                   [1 + d];
                          });
                })];
   }
   function transpose_exn(tt){
    var match = transpose(tt);
    if(! match) return caml_call1(Base_Import[125], cst_Array_transpose_exn);
    var tt$0 = match[1];
    return tt$0;
   }
   function get$0(_k_, _j_){return caml_check_bound(_k_, _j_)[1 + _j_];}
   function length(_i_){return _i_.length - 1;}
   var
    include = caml_call1(Base_Binary_searchable[2], [0, get$0, length]),
    binary_search = include[1],
    binary_search_segmented = include[2];
   function length$0(_h_){return _h_.length - 1;}
   function create_like(len, t){
    if(0 === len) return [0];
    if(0 < t.length - 1)
     return caml_call2(create, len, caml_check_bound(t, 0)[1]);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   var
    unsafe_blit = runtime.caml_array_blit,
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length$0, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub$0 = include$0[4],
    subo = include$0[5];
   function invariant(invariant_a, t){
    return caml_call2(iter, t, invariant_a);
   }
   var
    Base_Array =
      [0,
       compare,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       binary_search,
       binary_search_segmented,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       invariant,
       max_length,
       create,
       create_float_uninitialized,
       init,
       make_matrix,
       copy_matrix,
       append,
       concat,
       copy,
       fill,
       blit,
       blito,
       unsafe_blit$0,
       sub$0,
       subo,
       of_list,
       map,
       folding_map,
       folding_mapi,
       fold_map,
       fold_mapi,
       iteri,
       mapi,
       foldi,
       fold_right,
       sort$2,
       stable_sort,
       is_sorted,
       is_sorted_strictly,
       merge,
       concat_map,
       concat_mapi,
       partition_tf,
       partitioni_tf,
       cartesian_product,
       transpose,
       transpose_exn,
       filter_opt,
       filter_map,
       filter_mapi,
       for_alli,
       existsi,
       counti,
       iter2_exn,
       map2_exn,
       fold2_exn,
       for_all2_exn,
       exists2_exn,
       filter,
       filteri,
       swap,
       rev_inplace,
       rev,
       of_list_rev,
       of_list_map,
       of_list_mapi,
       of_list_rev_map,
       of_list_rev_mapi,
       map_inplace,
       find_exn,
       find_map_exn,
       findi,
       findi_exn,
       find_mapi,
       find_mapi_exn,
       find_consecutive_duplicate,
       reduce,
       reduce_exn,
       permute,
       random_element,
       random_element_exn,
       zip,
       zip_exn,
       unzip,
       sorted_copy,
       last,
       equal,
       to_sequence,
       to_sequence_mutable,
       [0, [0, Insertion_sort, Heap_sort, Intro_sort]]];
   runtime.caml_register_global(28, Base_Array, "Base__Array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Obj_array
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Blit, Base__Import, Base__Int0, Base__String0, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Array0 = global_data.Base__Array0,
    Base_Int0 = global_data.Base__Int0,
    Base_String0 = global_data.Base__String0,
    Assert_failure = global_data.Assert_failure,
    Base_Blit = global_data.Base__Blit,
    _b_ = [0, ">", 0],
    cst_Obj_array_t_of_length = "<Obj_array.t of length ",
    _c_ = [0, ""],
    _a_ = [0, "src/obj_array.ml", 11, 18];
   function invariant(t){
    var _t_ = Stdlib_Obj[15];
    if(caml_obj_tag(t) !== _t_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function length(_s_){return _s_.length - 1;}
   function sexp_of_t(t){
    var
     _r_ =
       [0,
        cst_Obj_array_t_of_length,
        [0, caml_call1(Base_Int0[1], t.length - 1), _b_]];
    return [0, caml_call2(Base_String0[14], _c_, _r_)];
   }
   var zero_obj = 0;
   function create_zero(len){
    return caml_call2(Base_Array0[4], len, zero_obj);
   }
   var empty = [0];
   function get(t, i){return caml_check_bound(t, i)[1 + i];}
   function unsafe_get(t, i){return t[1 + i];}
   function unsafe_set_with_caml_modify(t, i, obj){t[1 + i] = obj; return 0;}
   function set_with_caml_modify(t, i, obj){
    caml_check_bound(t, i)[1 + i] = obj;
    return 0;
   }
   function unsafe_set_int_assuming_curren(t, i, int$0){t[1 + i] = int$0; return 0;
   }
   function set(t, i, obj){
    var old_obj = get(t, i);
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _q_ = 1 - caml_call2(Base_Import[127], old_obj, obj);
    return _q_ ? unsafe_set_with_caml_modify(t, i, obj) : _q_;
   }
   function unsafe_set(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    var _p_ = 1 - caml_call2(Base_Import[127], old_obj, obj);
    return _p_ ? unsafe_set_with_caml_modify(t, i, obj) : _p_;
   }
   function unsafe_set_omit_phys_equal_che(t, i, obj){
    var old_obj = t[1 + i];
    if(typeof old_obj === "number" && typeof obj === "number")
     return unsafe_set_int_assuming_curren(t, i, obj);
    return unsafe_set_with_caml_modify(t, i, obj);
   }
   function swap(t, i, j){
    var a = get(t, i), b = get(t, j);
    unsafe_set(t, i, b);
    return unsafe_set(t, j, a);
   }
   function create(len, x){
    var _l_ = Stdlib_Obj[14];
    if(caml_obj_tag(x) !== _l_) return caml_call2(Base_Array0[4], len, x);
    var
     t = create_zero(len),
     _n_ = caml_call2(Base_Import[92], len, 1),
     _m_ = 0;
    if(_n_ >= 0){
     var i = _m_;
     for(;;){
      unsafe_set_with_caml_modify(t, i, x);
      var _o_ = i + 1 | 0;
      if(_n_ !== i){var i = _o_; continue;}
      break;
     }
    }
    return t;
   }
   function singleton(obj){return create(1, obj);}
   function unsafe_set_assuming_currently_(t, i, obj){
    return typeof obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, obj)
            : unsafe_set_with_caml_modify(t, i, obj);
   }
   function unsafe_set_int(t, i, int$0){
    var old_obj = t[1 + i];
    return typeof old_obj === "number"
            ? unsafe_set_int_assuming_curren(t, i, int$0)
            : unsafe_set_with_caml_modify(t, i, int$0);
   }
   function unsafe_clear_if_pointer(t, i){
    var old_obj = t[1 + i], _k_ = 1 - (typeof old_obj === "number" ? 1 : 0);
    return _k_ ? unsafe_set_with_caml_modify(t, i, 0) : _k_;
   }
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    if(dst_pos < src_pos){
     var _e_ = caml_call2(Base_Import[92], len, 1), _d_ = 0;
     if(_e_ >= 0){
      var i = _d_;
      for(;;){
       var _f_ = src[1 + caml_call2(Base_Import[90], src_pos, i)];
       unsafe_set(dst, caml_call2(Base_Import[90], dst_pos, i), _f_);
       var _g_ = i + 1 | 0;
       if(_e_ !== i){var i = _g_; continue;}
       break;
      }
     }
     return 0;
    }
    var _h_ = caml_call2(Base_Import[92], len, 1);
    if(_h_ >= 0){
     var i$0 = _h_;
     for(;;){
      var _i_ = src[1 + caml_call2(Base_Import[90], src_pos, i$0)];
      unsafe_set(dst, caml_call2(Base_Import[90], dst_pos, i$0), _i_);
      var _j_ = i$0 - 1 | 0;
      if(0 !== i$0){var i$0 = _j_; continue;}
      break;
     }
    }
    return 0;
   }
   var
    include = caml_call1(Base_Blit[1], [0, length, create_zero, unsafe_blit]),
    blit = include[1],
    blito = include[2],
    unsafe_blit$0 = include[3],
    sub = include[4],
    subo = include[5];
   function copy(src){
    var dst = create_zero(src.length - 1);
    caml_call6(blito, src, 0, 0, dst, 0, 0);
    return dst;
   }
   var
    Base_Obj_array =
      [0,
       sexp_of_t,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       invariant,
       create,
       create_zero,
       copy,
       singleton,
       empty,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       set_with_caml_modify,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       unsafe_clear_if_pointer];
   runtime.caml_register_global(12, Base_Obj_array, "Base__Obj_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uniform_array
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Blit, Base__Container, Base__Import, Base__List, Base__Obj_array, Base__Sexpable, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_uniform_array_ml = "src/uniform_array.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Container = global_data.Base__Container,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Obj_array = global_data.Base__Obj_array,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Blit = global_data.Base__Blit,
    empty = Base_Obj_array[12],
    _b_ = [0, cst_src_uniform_array_ml, 164, 8],
    cst_Array_map2_exn = "Array.map2_exn",
    cst_Uniform_array_init = "Uniform_array.init",
    _a_ = [0, cst_src_uniform_array_ml, 71, 18];
   function unsafe_create_uninitialized(len){
    return caml_call1(Base_Obj_array[9], len);
   }
   function create_obj_array(len){return caml_call1(Base_Obj_array[9], len);}
   function create(len, x){return caml_call2(Base_Obj_array[8], len, x);}
   function singleton(x){return caml_call1(Base_Obj_array[11], x);}
   function swap(t, i, j){return caml_call3(Base_Obj_array[18], t, i, j);}
   function get(arr, i){return caml_call2(Base_Obj_array[14], arr, i);}
   function set(arr, i, x){return caml_call3(Base_Obj_array[16], arr, i, x);}
   function unsafe_get(arr, i){return caml_call2(Base_Obj_array[15], arr, i);}
   function unsafe_set(arr, i, x){
    return caml_call3(Base_Obj_array[17], arr, i, x);
   }
   function unsafe_set_int(arr, i, x){
    return caml_call3(Base_Obj_array[22], arr, i, x);
   }
   function unsafe_set_int_assuming_curren(arr, i, x){return caml_call3(Base_Obj_array[21], arr, i, x);
   }
   function unsafe_set_assuming_currently_(arr, i, x){return caml_call3(Base_Obj_array[20], arr, i, x);
   }
   var
    length = Base_Obj_array[13],
    unsafe_blit = Base_Obj_array[4],
    copy = Base_Obj_array[10];
   function unsafe_set_omit_phys_equal_che(t, i, x){return caml_call3(Base_Obj_array[23], t, i, x);
   }
   function unsafe_set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[24], t, i, x);
   }
   function set_with_caml_modify(t, i, x){
    return caml_call3(Base_Obj_array[19], t, i, x);
   }
   var unsafe_clear_if_pointer = Base_Obj_array[25];
   function invariant(t){
    var _M_ = Stdlib_Obj[15];
    if(runtime.caml_obj_tag(t) !== _M_) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function init(l, f){
    if(0 > l) return caml_call1(Base_Import[125], cst_Uniform_array_init);
    var
     res = unsafe_create_uninitialized(l),
     _K_ = caml_call2(Base_Import[92], l, 1),
     _J_ = 0;
    if(_K_ >= 0){
     var i = _J_;
     for(;;){
      unsafe_set(res, i, caml_call1(f, i));
      var _L_ = i + 1 | 0;
      if(_K_ !== i){var i = _L_; continue;}
      break;
     }
    }
    return res;
   }
   function of_array(arr){
    return init(arr.length - 1, function(_I_){return arr[1 + _I_];});
   }
   function map(a, f){
    function _H_(i){return caml_call1(f, unsafe_get(a, i));}
    return init(caml_call1(length, a), _H_);
   }
   function mapi(a, f){
    function _G_(i){return caml_call2(f, i, unsafe_get(a, i));}
    return init(caml_call1(length, a), _G_);
   }
   function iter(a, f){
    var
     _D_ = caml_call1(length, a),
     _E_ = caml_call2(Base_Import[92], _D_, 1),
     _C_ = 0;
    if(_E_ >= 0){
     var i = _C_;
     for(;;){
      caml_call1(f, unsafe_get(a, i));
      var _F_ = i + 1 | 0;
      if(_E_ !== i){var i = _F_; continue;}
      break;
     }
    }
    return 0;
   }
   function iteri(a, f){
    var
     _z_ = caml_call1(length, a),
     _A_ = caml_call2(Base_Import[92], _z_, 1),
     _y_ = 0;
    if(_A_ >= 0){
     var i = _y_;
     for(;;){
      caml_call2(f, i, unsafe_get(a, i));
      var _B_ = i + 1 | 0;
      if(_A_ !== i){var i = _B_; continue;}
      break;
     }
    }
    return 0;
   }
   function foldi(a, init, f){
    var
     acc = [0, init],
     _u_ = caml_call1(length, a),
     _v_ = caml_call2(Base_Import[92], _u_, 1),
     _t_ = 0;
    if(_v_ >= 0){
     var i = _t_;
     for(;;){
      var _w_ = unsafe_get(a, i);
      acc[1] = caml_call3(f, i, acc[1], _w_);
      var _x_ = i + 1 | 0;
      if(_v_ !== i){var i = _x_; continue;}
      break;
     }
    }
    return acc[1];
   }
   function to_list(t){
    function _q_(_s_){return get(t, _s_);}
    var _r_ = caml_call1(length, t);
    return caml_call2(Base_List[123], _r_, _q_);
   }
   function of_list(l){
    var
     len = caml_call1(Base_List[7], l),
     res = unsafe_create_uninitialized(len);
    function _p_(i, x){return set(res, i, x);}
    caml_call2(Base_List[98], l, _p_);
    return res;
   }
   function to_array(t){
    function _n_(i){return unsafe_get(t, i);}
    var _o_ = caml_call1(length, t);
    return caml_call2(Base_Array[27], _o_, _n_);
   }
   function exists(t, f){
    var
     _m_ = caml_call1(length, t),
     i$1 = caml_call2(Base_Import[92], _m_, 1),
     i = i$1;
    for(;;){
     if(0 > i) return 0;
     var _l_ = caml_call1(f, unsafe_get(t, i));
     if(_l_) return _l_;
     var i$0 = caml_call2(Base_Import[92], i, 1), i = i$0;
    }
   }
   function for_all(t, f){
    var
     _k_ = caml_call1(length, t),
     i$1 = caml_call2(Base_Import[92], _k_, 1),
     i = i$1;
    for(;;){
     if(0 > i) return 1;
     var _j_ = caml_call1(f, unsafe_get(t, i));
     if(! _j_) return _j_;
     var i$0 = caml_call2(Base_Import[92], i, 1), i = i$0;
    }
   }
   function map2_exn(t1, t2, f){
    var len = caml_call1(length, t1);
    if(caml_call1(length, t2) !== len)
     caml_call1(Base_Import[125], cst_Array_map2_exn);
    return init
            (len,
             function(i){
              var _i_ = unsafe_get(t2, i);
              return caml_call2(f, unsafe_get(t1, i), _i_);
             });
   }
   function t_sexp_grammar(grammar){
    var _h_ = caml_call1(Base_Array[4], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _h_);
   }
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Array[2], Base_Array[3]]),
        [0, to_array, of_array]),
    t_of_sexp = include[1],
    sexp_of_t = include[2];
   function create_like(len, t){
    if(0 === len) return empty;
    if(0 < caml_call1(length, t)) return create(len, get(t, 0));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   var
    include$0 =
      caml_call1(Base_Blit[4], [0, create_like, length, unsafe_blit]),
    blit = include$0[1],
    blito = include$0[2],
    unsafe_blit$0 = include$0[3],
    sub = include$0[4],
    subo = include$0[5];
   function fold(t, init, f){
    var
     r = [0, init],
     _d_ = caml_call1(length, t),
     _e_ = caml_call2(Base_Import[92], _d_, 1),
     _c_ = 0;
    if(_e_ >= 0){
     var i = _c_;
     for(;;){
      var _f_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _f_);
      var _g_ = i + 1 | 0;
      if(_e_ !== i){var i = _g_; continue;}
      break;
     }
    }
    return r[1];
   }
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function compare(compare_elt, a, b){
    if(caml_call2(Base_Import[127], a, b)) return 0;
    var
     len_a = caml_call1(length, a),
     len_b = caml_call1(length, b),
     ret = runtime.caml_int_compare(len_a, len_b);
    if(0 !== ret) return ret;
    var i = 0;
    for(;;){
     if(i === len_a) return 0;
     var
      l = unsafe_get(a, i),
      r = unsafe_get(b, i),
      res = caml_call2(compare_elt, l, r);
     if(0 !== res) return res;
     var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0;
    }
   }
   var
    Base_Uniform_array =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       compare,
       invariant,
       empty,
       create,
       singleton,
       init,
       length,
       get,
       unsafe_get,
       set,
       unsafe_set,
       swap,
       unsafe_set_omit_phys_equal_che,
       unsafe_set_with_caml_modify,
       set_with_caml_modify,
       map,
       mapi,
       iter,
       iteri,
       foldi,
       of_array,
       to_array,
       of_list,
       to_list,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       unsafe_create_uninitialized,
       create_obj_array,
       unsafe_set_assuming_currently_,
       unsafe_set_int_assuming_curren,
       unsafe_set_int,
       unsafe_clear_if_pointer,
       exists,
       for_all,
       map2_exn,
       min_elt,
       max_elt];
   runtime.caml_register_global(14, Base_Uniform_array, "Base__Uniform_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar0
//# unitInfo: Requires: Stdlib__Uchar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Uchar = global_data.Stdlib__Uchar,
    succ = Stdlib_Uchar[5],
    pred = Stdlib_Uchar[6],
    is_valid = Stdlib_Uchar[7],
    is_char = Stdlib_Uchar[11],
    unsafe_to_char = Stdlib_Uchar[14],
    unsafe_of_int = Stdlib_Uchar[9],
    of_int = Stdlib_Uchar[8],
    to_int = Stdlib_Uchar[10],
    of_char = Stdlib_Uchar[12],
    compare = Stdlib_Uchar[16],
    equal = Stdlib_Uchar[15],
    min_value = Stdlib_Uchar[1],
    max_value = Stdlib_Uchar[2],
    Base_Uchar0 =
      [0,
       succ,
       pred,
       is_valid,
       is_char,
       unsafe_to_char,
       unsafe_of_int,
       of_int,
       to_int,
       of_char,
       compare,
       equal,
       min_value,
       max_value];
   runtime.caml_register_global(1, Base_Uchar0, "Base__Uchar0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Floatable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Floatable = [0];
   runtime.caml_register_global(0, Base_Floatable, "Base__Floatable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float0
//# unitInfo: Requires: Assert_failure, Base__Import, Base__Import0, Base__Option, Base__Printf, Stdlib__Float, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_float0_ml = "src/float0.ml",
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_float_of_bits = runtime.caml_int64_float_of_bits,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Float = global_data.Stdlib__Float,
    _g_ = [0, cst_src_float0_ml, 170, 4],
    _f_ = [0, cst_src_float0_ml, 174, 4],
    _d_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _e_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _b_ = [0, runtime.caml_int64_create_lo_mi_hi(0, 0, 0)],
    _a_ =
      [0,
       [8,
        [0, 0, 0],
        0,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [8,
            [0, 0, 0],
            0,
            0,
            [11, " in float0.ml: modulus should be positive", 0]]]]]],
       "%f %% %f in float0.ml: modulus should be positive"];
   function ceil(_p_){return Math.ceil(_p_);}
   function floor(_o_){return Math.floor(_o_);}
   function mod_float(_n_, _m_){return _n_ % _m_;}
   var
    modf = runtime.caml_modf_float,
    float_of_string = runtime.caml_float_of_string,
    nan = Base_Import[84][23],
    infinity = Base_Import[84][21],
    neg_infinity = Base_Import[84][22],
    max_finite_value = Base_Import[84][24],
    epsilon_float = Base_Import[84][26],
    classify_float = runtime.caml_classify_float;
   function abs_float(_l_){return Math.abs(_l_);}
   var is_integer = Stdlib_Float[16];
   function symbol(_k_, _j_){return Math.pow(_k_, _j_);}
   function symbol$0(a, b){
    if(caml_call2(Base_Import[107][1], b, 0.))
     caml_call4(Base_Printf[7], _a_, a, b, 0);
    var m = a % b;
    return caml_call2(Base_Import[107][1], m, 0.)
            ? caml_call2(Base_Import[91], m, b)
            : m;
   }
   var frexp = runtime.caml_frexp_float, ldexp = runtime.caml_ldexp_float;
   function is_nan(x){return caml_call2(Base_Import[107][3], x, x);}
   function to_int64_preserve_order(t){
    return is_nan(t)
            ? 0
            : caml_call2
               (Base_Import[107][4], t, 0.)
              ? _b_
              : caml_call2
                 (Base_Import[107][5], t, 0.)
                ? [0, caml_int64_bits_of_float(t)]
                : [0,
                  caml_int64_neg
                   (caml_int64_bits_of_float(caml_call1(Base_Import[113], t)))];
   }
   function to_int64_preserve_order_exn(x){
    var _i_ = to_int64_preserve_order(x);
    return caml_call4(Base_Option[28], 0, 0, 0, _i_);
   }
   function of_int64_preserve_order(x){
    return runtime.caml_greaterequal(x, _c_)
            ? caml_int64_float_of_bits(x)
            : caml_call1
              (Base_Import[113], caml_int64_float_of_bits(caml_int64_neg(x)));
   }
   function one_ulp(dir, t){
    var match = to_int64_preserve_order(t);
    if(! match) return Base_Import[84][23];
    var x = match[1], _h_ = 759637122 <= dir ? _d_ : _e_;
    return of_int64_preserve_order(runtime.caml_int64_add(x, _h_));
   }
   function upper_bound_for_int(num_bits){
    var exp = caml_call2(Base_Import[92], num_bits, 1);
    return one_ulp(759637122, Math.pow(2., exp));
   }
   function is_x_minus_one_exact(x){
    return 1
           -
            runtime.caml_equal
             (caml_int64_bits_of_float(x),
              caml_int64_bits_of_float(caml_call2(Base_Import[93], x, 1.)));
   }
   function lower_bound_for_int(num_bits){
    var
     exp = caml_call2(Base_Import[92], num_bits, 1),
     min_int_as_float = caml_call1(Base_Import[113], Math.pow(2., exp));
    if(53 <= caml_call2(Base_Import[92], num_bits, 1)){
     if(is_x_minus_one_exact(min_int_as_float))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     return min_int_as_float;
    }
    if(is_x_minus_one_exact(min_int_as_float))
     return one_ulp(19067, caml_call2(Base_Import[93], min_int_as_float, 1.));
    throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[107][1], t, min)
            ? min
            : caml_call2(Base_Import[107][1], max, t) ? max : t;
   }
   var x = 0.;
   function box(f){return caml_call2(Base_Import[91], f, x);}
   var
    include = Base_Import[107],
    symbol$1 = include[1],
    symbol$2 = include[2],
    symbol$3 = include[3],
    symbol$4 = include[4],
    symbol$5 = include[5],
    symbol$6 = include[6],
    ascending = include[7],
    descending = include[8],
    compare = include[9],
    equal = include[10],
    max = include[11],
    min = include[12],
    Base_Float0 =
      [0,
       ceil,
       floor,
       mod_float,
       modf,
       float_of_string,
       nan,
       infinity,
       neg_infinity,
       max_finite_value,
       epsilon_float,
       classify_float,
       abs_float,
       is_integer,
       symbol,
       symbol$0,
       frexp,
       ldexp,
       is_nan,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       upper_bound_for_int,
       is_x_minus_one_exact,
       lower_bound_for_int,
       clamp_unchecked,
       box,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       ascending,
       descending,
       compare,
       equal,
       max,
       min];
   runtime.caml_register_global(21, Base_Float0, "Base__Float0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Char
//# unitInfo: Requires: Base__Array0, Base__Char0, Base__Comparable, Base__Error, Base__Hash, Base__Identifiable, Base__Import, Base__Sexp, Base__String0, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Char",
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_String0 = global_data.Base__String0,
    Base_Char0 = global_data.Base__Char0,
    Base_Identifiable = global_data.Base__Identifiable,
    Base_Array0 = global_data.Base__Array0,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Char0[1],
    escaped = Base_Char0[2],
    lowercase = Base_Char0[3],
    to_int = Base_Char0[4],
    unsafe_of_int = Base_Char0[5],
    uppercase = Base_Char0[6],
    min_value = Base_Char0[8],
    max_value = Base_Char0[9],
    of_int = Base_Char0[10],
    of_int_exn = Base_Char0[11],
    compare = Base_Import[226],
    hash_fold_t = Base_Import[205],
    func = Base_Import[219],
    cst_char = "char",
    cst_Char_get_hex_digit_exn_not =
      "Char.get_hex_digit_exn: not a hexadecimal digit",
    _d_ =
      [0,
       [11, "Char.get_digit_exn ", [1, [11, ": not a digit", 0]]],
       "Char.get_digit_exn %C: not a digit"],
    _b_ = [0, [1, 0], "%C"],
    _a_ = [0, [11, "Char.of_string: ", [3, 0, 0]], "Char.of_string: %S"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[164],
    sexp_of_t = Base_Import[140],
    t_sexp_grammar = Base_Import[184];
   function to_string(t){return caml_call2(Base_String0[9], 1, t);}
   function of_string(s){
    return 1 === runtime.caml_ml_string_length(s)
            ? runtime.caml_string_get(s, 0)
            : caml_call3(failwithf, _a_, s, 0);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = include[1],
    hash$0 = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t$0 = include[4],
    of_string$0 = include[5],
    to_string$0 = include[6],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    hashable = include[24];
   function pp(fmt, c){return caml_call3(Stdlib_Format[129], fmt, _b_, c);}
   function invariant(param){return 0;}
   var
    _c_ = caml_call2(Base_Array0[11], 256, unsafe_of_int),
    all = caml_call1(Base_Array0[15], _c_);
   function is_lowercase(param){return 25 < param - 97 >>> 0 ? 0 : 1;}
   function is_uppercase(param){return 25 < param - 65 >>> 0 ? 0 : 1;}
   function is_print(param){return 94 < param - 32 >>> 0 ? 0 : 1;}
   function is_whitespace(param){
    var switch$0 = 0;
    if(14 <= param){
     if(32 === param) switch$0 = 1;
    }
    else if(9 <= param) switch$0 = 1;
    return switch$0 ? 1 : 0;
   }
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function is_alpha(param){
    var switch$0 = 0;
    if(91 <= param){
     if(25 >= param - 97 >>> 0) switch$0 = 1;
    }
    else if(65 <= param) switch$0 = 1;
    return switch$0 ? 1 : 0;
   }
   function is_alphanum(param){
    var _u_ = param - 48 | 0, switch$0 = 0;
    if(42 < _u_ >>> 0){
     if(25 >= _u_ - 49 >>> 0) switch$0 = 1;
    }
    else if(6 < _u_ - 10 >>> 0) switch$0 = 1;
    return switch$0 ? 1 : 0;
   }
   function get_digit_unsafe(t){
    var _s_ = caml_call1(to_int, 48), _t_ = caml_call1(to_int, t);
    return caml_call2(Base_Import[92], _t_, _s_);
   }
   function get_digit_exn(t){
    return is_digit(t)
            ? get_digit_unsafe(t)
            : caml_call3(failwithf, _d_, t, 0);
   }
   function get_digit(t){return is_digit(t) ? [0, get_digit_unsafe(t)] : 0;}
   function is_hex_digit(param){
    var _r_ = param - 48 | 0, switch$0 = 0;
    if(22 < _r_ >>> 0){
     if(5 >= _r_ - 49 >>> 0) switch$0 = 1;
    }
    else if(6 < _r_ - 10 >>> 0) switch$0 = 1;
    return switch$0 ? 1 : 0;
   }
   function is_hex_digit_lower(param){
    var switch$0 = 0;
    if(58 <= param){
     if(5 >= param - 97 >>> 0) switch$0 = 1;
    }
    else if(48 <= param) switch$0 = 1;
    return switch$0 ? 1 : 0;
   }
   function is_hex_digit_upper(param){
    var switch$0 = 0;
    if(58 <= param){
     if(5 >= param - 65 >>> 0) switch$0 = 1;
    }
    else if(48 <= param) switch$0 = 1;
    return switch$0 ? 1 : 0;
   }
   function get_hex_digit_exn(t){
    if(65 <= t){
     if(97 <= t){
      if(103 > t){
       var
        _j_ = caml_call1(to_int, 97),
        _k_ = caml_call1(to_int, t),
        _l_ = caml_call2(Base_Import[92], _k_, _j_);
       return caml_call2(Base_Import[90], _l_, 10);
      }
     }
     else if(71 > t){
      var
       _m_ = caml_call1(to_int, 65),
       _n_ = caml_call1(to_int, t),
       _o_ = caml_call2(Base_Import[92], _n_, _m_);
      return caml_call2(Base_Import[90], _o_, 10);
     }
    }
    else if(9 >= t - 48 >>> 0){
     var _p_ = caml_call1(to_int, 48), _q_ = caml_call1(to_int, t);
     return caml_call2(Base_Import[92], _q_, _p_);
    }
    var
     _h_ = [0, [0, cst_char, caml_call1(sexp_of_t$0, t)], 0],
     _i_ = caml_call2(Base_Sexp[9], cst_Char_get_hex_digit_exn_not, _h_);
    return caml_call1(Base_Error[30], _i_);
   }
   function get_hex_digit(t){
    return is_hex_digit(t) ? [0, get_hex_digit_exn(t)] : 0;
   }
   var
    symbol = Base_Import[105][6],
    symbol$0 = Base_Import[105][2],
    symbol$1 = Base_Import[105][4],
    symbol$2 = Base_Import[105][5],
    symbol$3 = Base_Import[105][1],
    symbol$4 = Base_Import[105][3],
    O = [0, symbol, symbol$0, symbol$1, symbol$2, symbol$3, symbol$4],
    t_of_sexp$1 = Base_Import[164],
    sexp_of_t$1 = Base_Import[140],
    t_sexp_grammar$0 = Base_Import[184];
   function compare$0(c1, c2){
    var _f_ = caml_call1(lowercase, c2), _g_ = caml_call1(lowercase, c1);
    return caml_call2(Base_Import[105][9], _g_, _f_);
   }
   function hash_fold_t$1(state, t){
    var _e_ = caml_call1(lowercase, t);
    return caml_call2(Base_Import[205], state, _e_);
   }
   function hash$1(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$1, t);}
   var
    include$0 = caml_call1(Base_Comparable[10], [0, compare$0, sexp_of_t$1]),
    symbol$5 = include$0[1],
    symbol$6 = include$0[2],
    symbol$7 = include$0[3],
    symbol$8 = include$0[4],
    symbol$9 = include$0[5],
    symbol$10 = include$0[6],
    equal = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between$0 = include$0[13],
    clamp_exn$0 = include$0[14],
    clamp$0 = include$0[15],
    comparator$0 = include$0[16],
    include$1 = Base_Import[105],
    symbol$11 = include$1[1],
    symbol$12 = include$1[2],
    symbol$13 = include$1[3],
    symbol$14 = include$1[4],
    symbol$15 = include$1[5],
    symbol$16 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    equal$0 = include$1[10],
    max$0 = include$1[11],
    min$0 = include$1[12],
    Base_Char =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$16,
       symbol$12,
       symbol$14,
       symbol$15,
       symbol$11,
       symbol$13,
       equal$0,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       invariant,
       O,
       to_int,
       of_int,
       of_int_exn,
       unsafe_of_int,
       escaped,
       lowercase,
       uppercase,
       is_digit,
       is_lowercase,
       is_uppercase,
       is_alpha,
       is_alphanum,
       is_print,
       is_whitespace,
       get_digit,
       get_digit_exn,
       is_hex_digit,
       is_hex_digit_lower,
       is_hex_digit_upper,
       get_hex_digit,
       get_hex_digit_exn,
       min_value,
       max_value,
       [0,
        hash_fold_t$1,
        hash$1,
        t_of_sexp$1,
        sexp_of_t$1,
        t_sexp_grammar$0,
        symbol$5,
        symbol$6,
        symbol$7,
        symbol$8,
        symbol$9,
        symbol$10,
        equal,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between$0,
        clamp_exn$0,
        clamp$0,
        comparator$0]];
   runtime.caml_register_global(16, Base_Char, "Base__Char");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ppx_enumerate_lib
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Enumerable = [0],
    Base_Ppx_enumerate_lib = [0, Enumerable];
   runtime.caml_register_global
    (0, Base_Ppx_enumerate_lib, "Base__Ppx_enumerate_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes_tr
//# unitInfo: Requires: Base__Bytes0, Base__Char, Base__Import0
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Char = global_data.Base__Char,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Import0 = global_data.Base__Import0;
   function tr_create_map(target, replacement){
    var tr_map = caml_call1(Base_Bytes0[7], 256), i$3 = 0;
    for(;;){
     caml_bytes_unsafe_set(tr_map, i$3, caml_call1(Base_Char[31], i$3));
     var _j_ = i$3 + 1 | 0;
     if(255 !== i$3){var i$3 = _j_; continue;}
     var
      _b_ =
        caml_call2
         (Base_Import0[96][4],
          caml_ml_string_length(target),
          caml_ml_string_length(replacement))
        - 1
        | 0,
      _a_ = 0;
     if(_b_ >= 0){
      var i$2 = _a_;
      for(;;){
       var
        index$0 =
          caml_call1(Base_Char[29], caml_string_unsafe_get(target, i$2));
       caml_bytes_unsafe_set
        (tr_map, index$0, caml_string_unsafe_get(replacement, i$2));
       var _i_ = i$2 + 1 | 0;
       if(_b_ !== i$2){var i$2 = _i_; continue;}
       break;
      }
     }
     var
      last_replacement =
        caml_string_unsafe_get
         (replacement, caml_ml_string_length(replacement) - 1 | 0),
      _c_ =
        caml_call2
         (Base_Import0[96][4],
          caml_ml_string_length(target),
          caml_ml_string_length(replacement)),
      _d_ = caml_ml_string_length(target) - 1 | 0;
     if(_d_ >= _c_){
      var i$1 = _c_;
      for(;;){
       var
        index = caml_call1(Base_Char[29], caml_string_unsafe_get(target, i$1));
       caml_bytes_unsafe_set(tr_map, index, last_replacement);
       var _h_ = i$1 + 1 | 0;
       if(_d_ !== i$1){var i$1 = _h_; continue;}
       break;
      }
     }
     var
      first_target = runtime.caml_string_get(target, 0),
      _f_ =
        caml_bytes_unsafe_get(tr_map, caml_call1(Base_Char[29], first_target));
     if(! caml_call2(Base_Char[14], _f_, first_target)){
      var i = 0;
      for(;;){
       if(256 === i)
        var _g_ = 0;
       else{
        var _e_ = caml_call1(Base_Char[31], i);
        if(! caml_call2(Base_Char[14], caml_bytes_unsafe_get(tr_map, i), _e_)){var i$0 = i + 1 | 0, i = i$0; continue;}
        var _g_ = 1;
       }
       if(! _g_) return 0;
       break;
      }
     }
     return [0, caml_call1(Base_Bytes0[16], tr_map)];
    }
   }
   var Base_Bytes_tr = [0, tr_create_map];
   runtime.caml_register_global(3, Base_Bytes_tr, "Base__Bytes_tr");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Staged
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function stage(_b_){return _b_;}
   function unstage(_a_){return _a_;}
   var Base_Staged = [0, stage, unstage];
   runtime.caml_register_global(0, Base_Staged, "Base__Staged");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__String
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparable, Base__Comparator, Base__Container, Base__Error, Base__Hash, Base__Import, Base__Indexed_container, Base__List, Base__Option, Base__Or_error, Base__Ordered_collection_common, Base__Ppx_compare_lib, Base__Printf, Base__Sexp, Base__Staged, Base__String0, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "",
    cst_case_sensitive = "case_sensitive",
    cst_char$1 = "char",
    cst_escape_char$1 = "escape_char",
    cst_pattern = "pattern",
    cst_pos$1 = "pos",
    cst_src_string_ml = "src/string.ml",
    cst_str$1 = "str",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$10 = cst$11,
    cst$9 = cst$11,
    cst$8 = cst$11,
    cst$6 = cst$11,
    cst$7 = cst$11,
    cst$5 = cst$11,
    cst$4 = cst$11,
    cst$3 = cst$11,
    cst$2 = cst$11,
    cst$1 = cst$11,
    cst$0 = cst$11,
    cst = cst$11,
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Array0 = global_data.Base__Array0,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Container = global_data.Base__Container,
    Base_Hash = global_data.Base__Hash,
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_String0 = global_data.Base__String0,
    Base_Printf = global_data.Base__Printf,
    Base_Error = global_data.Base__Error,
    Base_Staged = global_data.Base__Staged,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    max_length = Base_String0[2],
    symbol = Base_String0[3],
    capitalize = Base_String0[4],
    compare = Base_String0[5],
    copy = Base_String0[6],
    escaped = Base_String0[7],
    lowercase = Base_String0[8],
    make = Base_String0[9],
    uncapitalize = Base_String0[11],
    uppercase = Base_String0[13],
    concat = Base_String0[14],
    iter = Base_String0[15],
    invalid_argf = Base_Printf[7],
    raise_s = Base_Error[30],
    stage = Base_Staged[1],
    hash_fold_t = Base_Import[208],
    func = Base_Import[222],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _G_ = [0, cst_src_string_ml, 1587, 2],
    _F_ = [0, cst_src_string_ml, 1573, 19],
    cst_char$0 = cst_char$1,
    cst_pos$0 = cst_pos$1,
    cst_escape_char$0 = cst_escape_char$1,
    cst_str$0 = cst_str$1,
    cst_rindex_from_exn_not_found = "rindex_from_exn: not found",
    cst_rindex_from = "rindex_from",
    cst_char = cst_char$1,
    cst_pos = cst_pos$1,
    cst_escape_char = cst_escape_char$1,
    cst_str = cst_str$1,
    cst_index_from_exn_not_found = "index_from_exn: not found",
    cst_index_from = "index_from",
    cst_is_char_literal = "is_char_literal",
    cst_is_char_escaped = "is_char_escaped",
    cst_is_char_escaping = "is_char_escaping",
    _E_ = [0, [2, 0, [11, ": out of bounds", 0]], "%s: out of bounds"],
    cst_escapeworthy_map = "escapeworthy_map",
    cst_c_to = "c_to",
    cst_c_from = "c_from",
    cst_escapeworthy_map_not_one_t = "escapeworthy_map not one-to-one",
    _D_ = [0, [3, 0, 0], "%S"],
    _C_ =
      [0,
       [11, "String.chop_suffix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_suffix_exn %S %S"],
    _B_ =
      [0,
       [11, "String.chop_prefix_exn ", [3, 0, [12, 32, [3, 0, 0]]]],
       "String.chop_prefix_exn %S %S"],
    cst_tr_multi_replacement_is_em = "tr_multi replacement is empty string",
    _A_ = [0, cst_src_string_ml, 765, 17],
    cst_suffix = "suffix",
    cst_prefix = "prefix",
    cst_drop_suffix = "drop_suffix",
    cst_drop_prefix = "drop_prefix",
    cst_expecting_nonnegative_argu = " expecting nonnegative argument",
    _x_ = [0, [11, "String.init ", [4, 0, 0, 0, 0]], "String.init %d"],
    _p_ =
      [0,
       [11,
        "String.is_substring_at: invalid index ",
        [4, 0, 0, 0, [11, " for string of length ", [4, 0, 0, 0, 0]]]],
       "String.is_substring_at: invalid index %d for string of length %d"],
    _g_ = [0, "kmp_array"],
    _h_ = [0, cst_case_sensitive],
    _i_ = [0, cst_pattern],
    cst_substring = "substring",
    cst_Substring_not_found = "Substring not found",
    _e_ = [0, cst_case_sensitive],
    _f_ = [0, cst_pattern],
    cst_String_rindex_from_exn = "String.rindex_from_exn",
    cst_String_index_from_exn = "String.index_from_exn",
    _a_ = [0, "String.index_exn: not found"],
    _b_ = [0, "String.index_from_exn: not found"],
    _c_ = [0, "String.rindex_exn: not found"],
    _d_ = [0, "String.rindex_from_exn: not found"],
    _y_ = [0, "String.lsplit2_exn: not found"],
    _z_ = [0, "String.rsplit2_exn: not found"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[162],
    sexp_of_t = Base_Import[138],
    t_sexp_grammar = Base_Import[182],
    hashable = [0, hash, compare, sexp_of_t],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1];
   function invariant(param){return 0;}
   function sub(src, pos, len){
    if(0 === pos && len === caml_ml_string_length(src)) return src;
    caml_call3
     (Base_Ordered_collection_common[2], pos, len, caml_ml_string_length(src));
    if(0 === len) return cst;
    var dst = caml_call1(Base_Bytes0[7], len);
    runtime.caml_blit_string(src, pos, dst, 0, len);
    return caml_call1(Base_Bytes0[16], dst);
   }
   function subo(opt, len, src){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(len)
     var i = len[1], i$0 = i;
    else
     var i$0 = caml_call2(Base_Import[92], caml_ml_string_length(src), pos);
    return sub(src, pos, i$0);
   }
   function contains(opt, len, t, char$0){
    if(opt) var sth = opt[1], pos$1 = sth; else var pos$1 = 0;
    var
     total_length = caml_ml_string_length(t),
     _dt_ = caml_call2(Base_Import[92], total_length, pos$1),
     len$0 = caml_call2(Base_Option[27], len, _dt_);
    caml_call3(Base_Ordered_collection_common[2], pos$1, len$0, total_length);
    var end = caml_call2(Base_Import[90], pos$1, len$0), pos = pos$1;
    for(;;){
     var _dq_ = pos < end ? 1 : 0;
     if(_dq_){
      var
       _dr_ =
         caml_call2(Base_Char[15], caml_string_unsafe_get(t, pos), char$0);
      if(! _dr_){
       var pos$0 = caml_call2(Base_Import[90], pos, 1), pos = pos$0;
       continue;
      }
      var _ds_ = _dr_;
     }
     else
      var _ds_ = _dq_;
     return _ds_;
    }
   }
   function is_empty(t){return 0 === caml_ml_string_length(t) ? 1 : 0;}
   function index_from_exn_internal(string, pos, len, not_found, char$0){
    var pos$0 = pos;
    for(;;){
     if(len <= pos$0) throw caml_maybe_attach_backtrace(not_found, 1);
     if
      (caml_call2
        (Base_Char[15], caml_string_unsafe_get(string, pos$0), char$0))
      return pos$0;
     var pos$1 = caml_call2(Base_Import[90], pos$0, 1), pos$0 = pos$1;
    }
   }
   function index_exn_internal(t, not_found, char$0){
    return index_from_exn_internal
            (t, 0, caml_ml_string_length(t), not_found, char$0);
   }
   var not_found = [0, Base_Import[251], _a_];
   function index_exn(t, char$0){
    return index_exn_internal(t, not_found, char$0);
   }
   var not_found$0 = [0, Base_Import[251], _b_];
   function index_from_exn(t, pos, char$0){
    var len = caml_ml_string_length(t);
    if(0 <= pos && len >= pos)
     return index_from_exn_internal(t, pos, len, not_found$0, char$0);
    return caml_call1(Base_Import[125], cst_String_index_from_exn);
   }
   function rindex_from_exn_internal(string, pos, len, not_found, char$0){
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) throw caml_maybe_attach_backtrace(not_found, 1);
     if
      (caml_call2
        (Base_Char[15], caml_string_unsafe_get(string, pos$0), char$0))
      return pos$0;
     var pos$1 = caml_call2(Base_Import[92], pos$0, 1), pos$0 = pos$1;
    }
   }
   function rindex_exn_internal(t, not_found, char$0){
    var len = caml_ml_string_length(t);
    return rindex_from_exn_internal
            (t, caml_call2(Base_Import[92], len, 1), len, not_found, char$0);
   }
   var not_found$1 = [0, Base_Import[251], _c_];
   function rindex_exn(t, char$0){
    return rindex_exn_internal(t, not_found$1, char$0);
   }
   var not_found$2 = [0, Base_Import[251], _d_];
   function rindex_from_exn(t, pos, char$0){
    var len = caml_ml_string_length(t);
    if(-1 <= pos && len > pos)
     return rindex_from_exn_internal(t, pos, len, not_found$2, char$0);
    return caml_call1(Base_Import[125], cst_String_rindex_from_exn);
   }
   function index(t, char$0){
    try{var _do_ = [0, index_exn(t, char$0)]; return _do_;}
    catch(_dp_){
     var _dn_ = caml_wrap_exception(_dp_);
     if(_dn_[1] !== Base_Import[251] && _dn_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_dn_, 0);
     return 0;
    }
   }
   function rindex(t, char$0){
    try{var _dl_ = [0, rindex_exn(t, char$0)]; return _dl_;}
    catch(_dm_){
     var _dk_ = caml_wrap_exception(_dm_);
     if(_dk_[1] !== Base_Import[251] && _dk_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_dk_, 0);
     return 0;
    }
   }
   function index_from(t, pos, char$0){
    try{var _di_ = [0, index_from_exn(t, pos, char$0)]; return _di_;}
    catch(_dj_){
     var _dh_ = caml_wrap_exception(_dj_);
     if(_dh_[1] !== Base_Import[251] && _dh_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_dh_, 0);
     return 0;
    }
   }
   function rindex_from(t, pos, char$0){
    try{var _df_ = [0, rindex_from_exn(t, pos, char$0)]; return _df_;}
    catch(_dg_){
     var _de_ = caml_wrap_exception(_dg_);
     if(_de_[1] !== Base_Import[251] && _de_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_de_, 0);
     return 0;
    }
   }
   function sexp_of_t$0(param){
    var
     case_sensitive = param[2],
     pattern = param[1],
     _dd_ =
       [0,
        [1, [0, _e_, [0, caml_call1(Base_Import[137], case_sensitive), 0]]],
        0];
    return [1,
            [0,
             [1, [0, _f_, [0, caml_call1(Base_Import[138], pattern), 0]]],
             _dd_]];
   }
   function pattern(t){return t[1];}
   function case_sensitive(t){return t[2];}
   function kmp_internal_loop
   (matched_chars, next_text_char, pattern, kmp_array, char_equal){
    var matched_chars$0 = [0, matched_chars];
    for(;;){
     if
      (0 < matched_chars$0[1]
       &&
        !
        caml_call2
         (char_equal,
          next_text_char,
          caml_string_unsafe_get(pattern, matched_chars$0[1]))){
      matched_chars$0[1] =
       kmp_array[1 + caml_call2(Base_Import[92], matched_chars$0[1], 1)];
      continue;
     }
     if
      (caml_call2
        (char_equal,
         next_text_char,
         caml_string_unsafe_get(pattern, matched_chars$0[1])))
      matched_chars$0[1] = caml_call2(Base_Import[90], matched_chars$0[1], 1);
     return matched_chars$0[1];
    }
   }
   function get_char_equal(case_sensitive){
    return case_sensitive ? Base_Char[15] : Base_Char[52][12];
   }
   function create(pattern, case_sensitive){
    var
     n = caml_ml_string_length(pattern),
     kmp_array = caml_call2(Base_Array0[4], n, -1);
    if(0 < n){
     var char_equal = get_char_equal(case_sensitive);
     kmp_array[1] = 0;
     var
      matched_chars = [0, 0],
      _db_ = caml_call2(Base_Import[92], n, 1),
      _da_ = 1;
     if(_db_ >= 1){
      var i = _da_;
      for(;;){
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1],
          caml_string_unsafe_get(pattern, i),
          pattern,
          kmp_array,
          char_equal);
       kmp_array[1 + i] = matched_chars[1];
       var _dc_ = i + 1 | 0;
       if(_db_ !== i){var i = _dc_; continue;}
       break;
      }
     }
    }
    return [0, pattern, case_sensitive, kmp_array];
   }
   function index_internal(opt, param){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    return function(text){
     if
      (0 <= pos
       &&
        caml_call2
         (Base_Import[92],
          caml_ml_string_length(text),
          caml_ml_string_length(pattern))
        >= pos){
      var
       char_equal = get_char_equal(case_sensitive),
       j = [0, pos],
       matched_chars = [0, 0],
       k = caml_ml_string_length(pattern),
       n = caml_ml_string_length(text);
      for(;;){
       if(j[1] < n && matched_chars[1] < k){
        var next_text_char = caml_string_unsafe_get(text, j[1]);
        matched_chars[1] =
         kmp_internal_loop
          (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
        j[1] = caml_call2(Base_Import[90], j[1], 1);
        continue;
       }
       return matched_chars[1] === k
               ? caml_call2(Base_Import[92], j[1], k)
               : -1;
      }
     }
     return -1;};
   }
   function matches(t, str){
    return 0 <= caml_call1(index_internal(0, t), str) ? 1 : 0;
   }
   function index$0(pos, t, in$0){
    var p = caml_call1(index_internal(pos, t), in$0);
    return 0 <= p ? [0, p] : 0;
   }
   function index_exn$0(pos, t, in$0){
    var p = caml_call1(index_internal(pos, t), in$0);
    if(0 <= p) return p;
    var _c$_ = [0, [0, cst_substring, caml_call1(Base_Import[138], t[1])], 0];
    return caml_call1
            (raise_s, caml_call2(Base_Sexp[9], cst_Substring_not_found, _c$_));
   }
   function index_all(param, may_overlap, text){
    var kmp_array = param[3], case_sensitive = param[2], pattern = param[1];
    if(0 === caml_ml_string_length(pattern)){
     var
      _c5_ = function(_c__){return _c__;},
      _c6_ = caml_call2(Base_Import[90], 1, caml_ml_string_length(text));
     return caml_call2(Base_List[123], _c6_, _c5_);
    }
    var
     char_equal = get_char_equal(case_sensitive),
     matched_chars = [0, 0],
     k = caml_ml_string_length(pattern),
     n = caml_ml_string_length(text),
     found = [0, 0],
     _c7_ = 0;
    if(n >= 0){
     var j = _c7_;
     for(;;){
      if(matched_chars[1] === k){
       var _c8_ = found[1];
       found[1] = [0, caml_call2(Base_Import[92], j, k), _c8_];
       matched_chars[1] =
        may_overlap ? kmp_array[1 + caml_call2(Base_Import[92], k, 1)] : 0;
      }
      if(j < n){
       var next_text_char = caml_string_unsafe_get(text, j);
       matched_chars[1] =
        kmp_internal_loop
         (matched_chars[1], next_text_char, pattern, kmp_array, char_equal);
      }
      var _c9_ = j + 1 | 0;
      if(n !== j){var j = _c9_; continue;}
      break;
     }
    }
    return caml_call1(Base_List[38], found[1]);
   }
   function replace_first(pos, t, s, with$0){
    var match = index$0(pos, t, s);
    if(! match) return s;
    var
     i = match[1],
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     _cZ_ = caml_call2(Base_Import[90], len_s, len_with),
     _c0_ = caml_call2(Base_Import[92], _cZ_, len_t),
     dst = caml_call1(Base_Bytes0[7], _c0_);
    caml_call5(Base_Bytes0[4], s, 0, dst, 0, i);
    caml_call5(Base_Bytes0[4], with$0, 0, dst, i, len_with);
    var
     _c1_ = caml_call2(Base_Import[92], len_s, i),
     _c2_ = caml_call2(Base_Import[92], _c1_, len_t),
     _c3_ = caml_call2(Base_Import[90], i, len_with),
     _c4_ = caml_call2(Base_Import[90], i, len_t);
    caml_call5(Base_Bytes0[4], s, _c4_, dst, _c3_, _c2_);
    return caml_call1(Base_Bytes0[16], dst);
   }
   function replace_all(t, s, with$0){
    var matches = index_all(t, 0, s);
    if(! matches) return s;
    var
     len_s = caml_ml_string_length(s),
     len_t = caml_ml_string_length(t[1]),
     len_with = caml_ml_string_length(with$0),
     num_matches = caml_call1(Base_List[7], matches),
     _cR_ = caml_call2(Base_Import[92], len_with, len_t),
     _cS_ = caml_call2(Base_Import[87], _cR_, num_matches),
     _cT_ = caml_call2(Base_Import[90], len_s, _cS_),
     dst = caml_call1(Base_Bytes0[7], _cT_),
     next_dst_pos = [0, 0],
     next_src_pos = [0, 0];
    function _cU_(i){
     var len = caml_call2(Base_Import[92], i, next_src_pos[1]);
     caml_call5(Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], len);
     var _cW_ = caml_call2(Base_Import[90], next_dst_pos[1], len);
     caml_call5(Base_Bytes0[4], with$0, 0, dst, _cW_, len_with);
     var _cX_ = caml_call2(Base_Import[90], next_dst_pos[1], len);
     next_dst_pos[1] = caml_call2(Base_Import[90], _cX_, len_with);
     var _cY_ = caml_call2(Base_Import[90], next_src_pos[1], len);
     next_src_pos[1] = caml_call2(Base_Import[90], _cY_, len_t);
     return 0;
    }
    caml_call2(Base_List[9], matches, _cU_);
    var _cV_ = caml_call2(Base_Import[92], len_s, next_src_pos[1]);
    caml_call5(Base_Bytes0[4], s, next_src_pos[1], dst, next_dst_pos[1], _cV_);
    return caml_call1(Base_Bytes0[16], dst);
   }
   function split_on(t, s){
    var
     pattern_len = caml_ml_string_length(t[1]),
     matches = index_all(t, 0, s);
    function _cM_(i, j){
     var
      _cP_ = caml_call2(Base_Import[92], j, i),
      _cQ_ = caml_call2(Base_Import[92], _cP_, pattern_len);
     return sub(s, caml_call2(Base_Import[90], i, pattern_len), _cQ_);
    }
    var
     _cN_ =
       caml_call2(Base_Import[110], matches, [0, caml_ml_string_length(s), 0]),
     _cO_ = [0, caml_call1(Base_Import[112], pattern_len), matches];
    return caml_call3(Base_List[83], _cO_, _cN_, _cM_);
   }
   function equal(a_002, b_003){
    if(caml_call2(Base_Ppx_compare_lib[1], a_002, b_003)) return 1;
    var _cJ_ = caml_call2(Base_Import[245], a_002[1], b_003[1]);
    if(_cJ_){
     var _cK_ = caml_call2(Base_Import[238], a_002[2], b_003[2]);
     if(_cK_)
      return caml_call3
              (Base_Import[247], Base_Import[241], a_002[3], b_003[3]);
     var _cL_ = _cK_;
    }
    else
     var _cL_ = _cJ_;
    return _cL_;
   }
   function sexp_of_t$1(param){
    var
     kmp_array_011 = param[3],
     case_sensitive_009 = param[2],
     pattern_007 = param[1],
     arg_012 = caml_call2(Base_Import[152], Base_Import[141], kmp_array_011),
     bnds_006 = [0, [1, [0, _g_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call1(Base_Import[137], case_sensitive_009),
     bnds_006$0 = [0, [1, [0, _h_, [0, arg_010, 0]]], bnds_006],
     arg_008 = caml_call1(Base_Import[138], pattern_007),
     bnds_006$1 = [0, [1, [0, _i_, [0, arg_008, 0]]], bnds_006$0];
    return [1, bnds_006$1];
   }
   function representation(_cI_){return _cI_;}
   var Private = [0, equal, sexp_of_t$1, representation];
   function substr_index_gen(case_sensitive, pos, t, pattern){return index$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_exn_gen(case_sensitive, pos, t, pattern){return index_exn$0(pos, create(pattern, case_sensitive), t);
   }
   function substr_index_all_gen(case_sensitive, t, may_overlap, pattern){return index_all(create(pattern, case_sensitive), may_overlap, t);
   }
   function substr_replace_first_gen(case_sensitive, pos, t, pattern){
    var _cG_ = create(pattern, case_sensitive);
    return function(_cH_){return replace_first(pos, _cG_, t, _cH_);};
   }
   function substr_replace_all_gen(case_sensitive, t, pattern){
    var _cE_ = create(pattern, case_sensitive);
    return function(_cF_){return replace_all(_cE_, t, _cF_);};
   }
   function is_substring_gen(case_sensitive, t, substring){
    var _cD_ = substr_index_gen(case_sensitive, 0, t, substring);
    return caml_call1(Base_Option[50], _cD_);
   }
   var _j_ = 1;
   function substr_index(_cA_, _cB_, _cC_){
    return substr_index_gen(_j_, _cA_, _cB_, _cC_);
   }
   var _k_ = 1;
   function substr_index_exn(_cx_, _cy_, _cz_){
    return substr_index_exn_gen(_k_, _cx_, _cy_, _cz_);
   }
   var _l_ = 1;
   function substr_index_all(_cu_, _cv_, _cw_){
    return substr_index_all_gen(_l_, _cu_, _cv_, _cw_);
   }
   var _m_ = 1;
   function substr_replace_first(_cr_, _cs_, _ct_){
    return substr_replace_first_gen(_m_, _cr_, _cs_, _ct_);
   }
   var _n_ = 1;
   function substr_replace_all(_cp_, _cq_){
    return substr_replace_all_gen(_n_, _cp_, _cq_);
   }
   var _o_ = 1;
   function is_substring(_cn_, _co_){
    return is_substring_gen(_o_, _cn_, _co_);
   }
   function is_substring_at_gen(str, str_pos$1, sub, char_equal){
    var
     str_len = caml_ml_string_length(str),
     sub_len = caml_ml_string_length(sub),
     _ck_ = str_pos$1 < 0 ? 1 : 0,
     _cl_ = _ck_ || (str_len < str_pos$1 ? 1 : 0);
    if(_cl_) caml_call4(invalid_argf, _p_, str_pos$1, str_len, 0);
    var
     _cm_ = caml_call2(Base_Import[90], str_pos$1, sub_len) <= str_len ? 1 : 0;
    if(! _cm_) return _cm_;
    var str_pos = str_pos$1, sub_pos = 0;
    for(;;){
     if(sub_pos === sub_len) return 1;
     if
      (!
       caml_call2
        (char_equal,
         caml_string_unsafe_get(str, str_pos),
         caml_string_unsafe_get(sub, sub_pos)))
      return 0;
     var
      sub_pos$0 = caml_call2(Base_Import[90], sub_pos, 1),
      str_pos$0 = caml_call2(Base_Import[90], str_pos, 1),
      str_pos = str_pos$0,
      sub_pos = sub_pos$0;
    }
   }
   function is_suffix_gen(string, suffix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     suffix_len = caml_ml_string_length(suffix),
     _cj_ = suffix_len <= string_len ? 1 : 0;
    return _cj_
            ? is_substring_at_gen
              (string,
               caml_call2(Base_Import[92], string_len, suffix_len),
               suffix,
               char_equal)
            : _cj_;
   }
   function is_prefix_gen(string, prefix, char_equal){
    var
     string_len = caml_ml_string_length(string),
     prefix_len = caml_ml_string_length(prefix),
     _ci_ = prefix_len <= string_len ? 1 : 0;
    return _ci_ ? is_substring_at_gen(string, 0, prefix, char_equal) : _ci_;
   }
   var
    t_of_sexp$0 = Base_Import[162],
    sexp_of_t$2 = Base_Import[138],
    t_sexp_grammar$0 = Base_Import[182];
   function compare$0(string1, string2){
    if(caml_call2(Base_Import[127], string1, string2)) return 0;
    var
     len2 = caml_ml_string_length(string2),
     len1 = caml_ml_string_length(string1),
     pos = 0;
    for(;;){
     if(pos === len1) return pos === len2 ? 0 : -1;
     if(pos === len2) return 1;
     var
      c2 = caml_string_unsafe_get(string2, pos),
      c1 = caml_string_unsafe_get(string1, pos),
      _cg_ = caml_call1(Base_Char[34], c2),
      _ch_ = caml_call1(Base_Char[34], c1),
      c = caml_call2(Base_Char[16], _ch_, _cg_);
     if(0 !== c) return c;
     var pos$0 = caml_call2(Base_Import[90], pos, 1), pos = pos$0;
    }
   }
   function hash_fold_t$0(state, t){
    var
     len = caml_ml_string_length(t),
     state$0 = [0, caml_call2(Base_Import[206], state, len)],
     _cd_ = caml_call2(Base_Import[92], len, 1),
     _cc_ = 0;
    if(_cd_ >= 0){
     var pos = _cc_;
     for(;;){
      var _ce_ = caml_call1(Base_Char[34], caml_string_unsafe_get(t, pos));
      state$0[1] = caml_call2(Base_Import[205], state$0[1], _ce_);
      var _cf_ = pos + 1 | 0;
      if(_cd_ !== pos){var pos = _cf_; continue;}
      break;
     }
    }
    return state$0[1];
   }
   function hash$0(t){return caml_call3(Base_Hash[14], 0, hash_fold_t$0, t);}
   function is_suffix(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[52][12]);
   }
   function is_prefix(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[52][12]);
   }
   var _q_ = 0;
   function substr_index$0(_b$_, _ca_, _cb_){
    return substr_index_gen(_q_, _b$_, _ca_, _cb_);
   }
   var _r_ = 0;
   function substr_index_exn$0(_b8_, _b9_, _b__){
    return substr_index_exn_gen(_r_, _b8_, _b9_, _b__);
   }
   var _s_ = 0;
   function substr_index_all$0(_b5_, _b6_, _b7_){
    return substr_index_all_gen(_s_, _b5_, _b6_, _b7_);
   }
   var _t_ = 0;
   function substr_replace_first$0(_b2_, _b3_, _b4_){
    return substr_replace_first_gen(_t_, _b2_, _b3_, _b4_);
   }
   var _u_ = 0;
   function substr_replace_all$0(_b0_, _b1_){
    return substr_replace_all_gen(_u_, _b0_, _b1_);
   }
   var _v_ = 0;
   function is_substring$0(_bY_, _bZ_){
    return is_substring_gen(_v_, _bY_, _bZ_);
   }
   var _w_ = Base_Char[52][12];
   function is_substring_at(_bV_){
    return function(_bW_){
     return function(_bX_){
      return is_substring_at_gen(_bV_, _bW_, _bX_, _w_);};};
   }
   var
    include$0 = caml_call1(Base_Comparable[10], [0, compare$0, sexp_of_t$2]),
    symbol$0 = include$0[1],
    symbol$1 = include$0[2],
    symbol$2 = include$0[3],
    symbol$3 = include$0[4],
    symbol$4 = include$0[5],
    symbol$5 = include$0[6],
    equal$0 = include$0[7],
    compare$1 = include$0[8],
    min = include$0[9],
    max = include$0[10],
    ascending = include$0[11],
    descending = include$0[12],
    between = include$0[13],
    clamp_exn = include$0[14],
    clamp = include$0[15],
    comparator$0 = include$0[16];
   function of_string(_bU_){return _bU_;}
   function to_string(_bT_){return _bT_;}
   function init(n, f){
    if(n < 0) caml_call3(invalid_argf, _x_, n, 0);
    var
     t = caml_call1(Base_Bytes0[7], n),
     _bR_ = caml_call2(Base_Import[92], n, 1),
     _bQ_ = 0;
    if(_bR_ >= 0){
     var i = _bQ_;
     for(;;){
      caml_bytes_set(t, i, caml_call1(f, i));
      var _bS_ = i + 1 | 0;
      if(_bR_ !== i){var i = _bS_; continue;}
      break;
     }
    }
    return caml_call1(Base_Bytes0[16], t);
   }
   function to_list(s){
    var
     i$1 = caml_call2(Base_Import[92], caml_ml_string_length(s), 1),
     acc = 0,
     i = i$1;
    for(;;){
     if(0 > i) return acc;
     var
      i$0 = caml_call2(Base_Import[92], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc],
      acc = acc$0,
      i = i$0;
    }
   }
   function to_list_rev(s){
    var len = caml_ml_string_length(s), acc = 0, i = 0;
    for(;;){
     if(i === len) return acc;
     var
      i$0 = caml_call2(Base_Import[90], i, 1),
      acc$0 = [0, caml_string_get(s, i), acc],
      acc = acc$0,
      i = i$0;
    }
   }
   function rev(t){
    var
     len = caml_ml_string_length(t),
     res = caml_call1(Base_Bytes0[7], len),
     _bN_ = caml_call2(Base_Import[92], len, 1),
     _bM_ = 0;
    if(_bN_ >= 0){
     var i = _bM_;
     for(;;){
      var _bO_ = caml_call2(Base_Import[92], len, 1);
      caml_bytes_unsafe_set
       (res,
        i,
        caml_string_unsafe_get(t, caml_call2(Base_Import[92], _bO_, i)));
      var _bP_ = i + 1 | 0;
      if(_bN_ !== i){var i = _bP_; continue;}
      break;
     }
    }
    return caml_call1(Base_Bytes0[16], res);
   }
   var not_found$3 = [0, Base_Import[251], _y_];
   function lsplit2_exn(line, delim){
    var
     pos = index_exn_internal(line, not_found$3, delim),
     _bJ_ = caml_call2(Base_Import[92], caml_ml_string_length(line), pos),
     _bK_ = caml_call2(Base_Import[92], _bJ_, 1),
     _bL_ = sub(line, caml_call2(Base_Import[90], pos, 1), _bK_);
    return [0, sub(line, 0, pos), _bL_];
   }
   var not_found$4 = [0, Base_Import[251], _z_];
   function rsplit2_exn(line, delim){
    var
     pos = rindex_exn_internal(line, not_found$4, delim),
     _bG_ = caml_call2(Base_Import[92], caml_ml_string_length(line), pos),
     _bH_ = caml_call2(Base_Import[92], _bG_, 1),
     _bI_ = sub(line, caml_call2(Base_Import[90], pos, 1), _bH_);
    return [0, sub(line, 0, pos), _bI_];
   }
   function lsplit2(line, on){
    try{var _bE_ = [0, lsplit2_exn(line, on)]; return _bE_;}
    catch(_bF_){
     var _bD_ = caml_wrap_exception(_bF_);
     if(_bD_[1] !== Base_Import[251] && _bD_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_bD_, 0);
     return 0;
    }
   }
   function rsplit2(line, on){
    try{var _bB_ = [0, rsplit2_exn(line, on)]; return _bB_;}
    catch(_bC_){
     var _bA_ = caml_wrap_exception(_bC_);
     if(_bA_[1] !== Base_Import[251] && _bA_ !== Base_Import[84][105])
      throw caml_maybe_attach_backtrace(_bA_, 0);
     return 0;
    }
   }
   function char_list_mem(l, c){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var tl = l$0[2], hd = l$0[1], _bz_ = caml_call2(Base_Char[15], hd, c);
     if(_bz_) return _bz_;
     var l$0 = tl;
    }
   }
   function split_gen(str, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[15], c$0, c);};
    var
     last_pos = caml_ml_string_length(str),
     pos$1 = caml_call2(Base_Import[92], last_pos, 1),
     acc = 0,
     last_pos$1 = last_pos,
     last_pos$0 = pos$1;
    for(;;){
     if(-1 === last_pos$0) return [0, sub(str, 0, last_pos$1), acc];
     if(is_delim(caml_string_get(str, last_pos$0))){
      var
       pos1 = caml_call2(Base_Import[90], last_pos$0, 1),
       sub_str = sub(str, pos1, caml_call2(Base_Import[92], last_pos$1, pos1)),
       pos = caml_call2(Base_Import[92], last_pos$0, 1),
       acc$0 = [0, sub_str, acc],
       acc = acc$0,
       last_pos$1 = last_pos$0,
       last_pos$0 = pos;
      continue;
     }
     var
      pos$0 = caml_call2(Base_Import[92], last_pos$0, 1),
      last_pos$0 = pos$0;
    }
   }
   function split(str, on){return split_gen(str, [0, -1044422954, on]);}
   function split_on_chars(str, chars){
    return split_gen(str, [0, 552554919, chars]);
   }
   function back_up_at_newline(t, pos, eol){
    var switch$0 = 0;
    if(0 < pos[1]){
     var _bx_ = caml_string_get(t, caml_call2(Base_Import[92], pos[1], 1));
     if(caml_call2(Base_Char[15], _bx_, 13)){var _by_ = 2; switch$0 = 1;}
    }
    if(! switch$0) var _by_ = 1;
    pos[1] = caml_call2(Base_Import[92], pos[1], _by_);
    eol[1] = caml_call2(Base_Import[90], pos[1], 1);
    return 0;
   }
   function split_lines(t){
    var n = caml_ml_string_length(t);
    if(0 === n) return 0;
    var
     pos = [0, caml_call2(Base_Import[92], n, 1)],
     eol = [0, n],
     ac = [0, 0],
     _bt_ = caml_string_get(t, pos[1]);
    if(caml_call2(Base_Char[15], _bt_, 10)) back_up_at_newline(t, pos, eol);
    for(;;){
     if(0 > pos[1]){var _bw_ = ac[1]; return [0, sub(t, 0, eol[1]), _bw_];}
     var _bu_ = caml_string_get(t, pos[1]);
     if(caml_call2(Base_Char[14], _bu_, 10)){
      caml_call1(Base_Import[128], pos);
      continue;
     }
     var start = caml_call2(Base_Import[90], pos[1], 1), _bv_ = ac[1];
     ac[1] =
      [0, sub(t, start, caml_call2(Base_Import[92], eol[1], start)), _bv_];
     back_up_at_newline(t, pos, eol);
    }
   }
   function is_suffix$0(s, suffix){
    return is_suffix_gen(s, suffix, Base_Char[15]);
   }
   function is_prefix$0(s, prefix){
    return is_prefix_gen(s, prefix, Base_Char[15]);
   }
   function is_substring_at$0(s, pos, substring){
    return is_substring_at_gen(s, pos, substring, Base_Char[15]);
   }
   function wrap_sub_n(t, n, name, pos, len, on_error){
    if(0 <= n)
     try{var _bq_ = sub(t, pos, len); return _bq_;}
     catch(_bs_){return on_error;}
    var _br_ = caml_call2(symbol, name, cst_expecting_nonnegative_argu);
    return caml_call1(Base_Import[125], _br_);
   }
   function drop_prefix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_prefix,
             n,
             caml_call2(Base_Import[92], caml_ml_string_length(t), n),
             cst$0);
   }
   function drop_suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_drop_suffix,
             0,
             caml_call2(Base_Import[92], caml_ml_string_length(t), n),
             cst$1);
   }
   function prefix(t, n){return wrap_sub_n(t, n, cst_prefix, 0, n, t);}
   function suffix(t, n){
    return wrap_sub_n
            (t,
             n,
             cst_suffix,
             caml_call2(Base_Import[92], caml_ml_string_length(t), n),
             n,
             t);
   }
   function lfindi(opt, t, f){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    var n = caml_ml_string_length(t), i = pos;
    for(;;){
     if(i === n) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0;
    }
   }
   function find(t, f){
    var match = lfindi(0, t, function(param, c){return caml_call1(f, c);});
    if(! match) return 0;
    var i = match[1];
    return [0, caml_string_get(t, i)];
   }
   function find_map(t, f){
    var n = caml_ml_string_length(t), i = 0;
    for(;;){
     if(i === n) return 0;
     var res = caml_call1(f, caml_string_get(t, i));
     if(res) return res;
     var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0;
    }
   }
   function rfindi(pos, t, f){
    if(pos)
     var pos$0 = pos[1], pos$1 = pos$0;
    else
     var pos$1 = caml_call2(Base_Import[92], caml_ml_string_length(t), 1);
    var i = pos$1;
    for(;;){
     if(0 > i) return 0;
     if(caml_call2(f, i, caml_string_get(t, i))) return [0, i];
     var i$0 = caml_call2(Base_Import[92], i, 1), i = i$0;
    }
   }
   function last_non_drop(drop, t){
    return rfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function rstrip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = last_non_drop(drop, t);
    if(! match) return cst$2;
    var i = match[1];
    return i === caml_call2(Base_Import[92], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[90], i, 1));
   }
   function first_non_drop(drop, t){
    return lfindi(0, t, function(param, c){return 1 - caml_call1(drop, c);});
   }
   function lstrip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = first_non_drop(drop, t);
    if(! match) return cst$3;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip(opt, t){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var length = caml_ml_string_length(t);
    if(0 !== length){
     var switch$0 = 0;
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[92], length, 1))))
      switch$0 = 1;
     if(! switch$0){
      var match = first_non_drop(drop, t);
      if(! match) return cst$4;
      var first = match[1], match$0 = last_non_drop(drop, t);
      if(! match$0)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
      var last = match$0[1], _bp_ = caml_call2(Base_Import[92], last, first);
      return sub(t, first, caml_call2(Base_Import[90], _bp_, 1));
     }
    }
    return t;
   }
   function mapi(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _bn_ = caml_call2(Base_Import[92], l, 1),
     _bm_ = 0;
    if(_bn_ >= 0){
     var i = _bm_;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call2(f, i, caml_string_get(t, i)));
      var _bo_ = i + 1 | 0;
      if(_bn_ !== i){var i = _bo_; continue;}
      break;
     }
    }
    return caml_call1(Base_Bytes0[16], t$0);
   }
   function map(t, f){
    var
     l = caml_ml_string_length(t),
     t$0 = caml_call1(Base_Bytes0[7], l),
     _bk_ = caml_call2(Base_Import[92], l, 1),
     _bj_ = 0;
    if(_bk_ >= 0){
     var i = _bj_;
     for(;;){
      caml_bytes_unsafe_set(t$0, i, caml_call1(f, caml_string_get(t, i)));
      var _bl_ = i + 1 | 0;
      if(_bk_ !== i){var i = _bl_; continue;}
      break;
     }
    }
    return caml_call1(Base_Bytes0[16], t$0);
   }
   function to_array(s){
    function _bi_(i){return caml_string_get(s, i);}
    return caml_call2(Base_Array0[11], caml_ml_string_length(s), _bi_);
   }
   function exists(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _bf_ = i < len ? 1 : 0;
     if(_bf_){
      var _bg_ = caml_call1(f, caml_string_get(s, i));
      if(! _bg_){
       var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0;
       continue;
      }
      var _bh_ = _bg_;
     }
     else
      var _bh_ = _bf_;
     return _bh_;
    }
   }
   function for_all(s, f){
    var len = caml_ml_string_length(s), i = 0;
    for(;;){
     var _bc_ = i === len ? 1 : 0;
     if(_bc_)
      var _bd_ = _bc_;
     else{
      var _be_ = caml_call1(f, caml_string_get(s, i));
      if(_be_){
       var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0;
       continue;
      }
      var _bd_ = _be_;
     }
     return _bd_;
    }
   }
   function fold(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call2(f, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[90], i, 1),
      i = i$0,
      ac = ac$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_string_length(t), i = 0, ac = init;
    for(;;){
     if(i === len) return ac;
     var
      ac$0 = caml_call3(f, i, ac, caml_string_get(t, i)),
      i$0 = caml_call2(Base_Import[90], i, 1),
      i = i$0,
      ac = ac$0;
    }
   }
   function iteri(t, f){
    var
     _ba_ = caml_call2(Base_Import[92], caml_ml_string_length(t), 1),
     _a$_ = 0;
    if(_ba_ >= 0){
     var i = _a$_;
     for(;;){
      caml_call2(f, i, caml_string_unsafe_get(t, i));
      var _bb_ = i + 1 | 0;
      if(_ba_ !== i){var i = _bb_; continue;}
      break;
     }
    }
    return 0;
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t){return caml_call2(Base_Container[3], fold, t);}
   function max_elt(t){return caml_call2(Base_Container[4], fold, t);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _a9_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_a__){return caml_call2(_a9_, _a__, t);};
   }
   function find_mapi(t, f){
    return caml_call3(Base_Indexed_container[7], iteri, t, f);
   }
   function findi(t, f){
    return caml_call3(Base_Indexed_container[6], iteri, t, f);
   }
   function counti(t, f){
    return caml_call3(Base_Indexed_container[3], foldi, t, f);
   }
   function for_alli(t, f){
    return caml_call3(Base_Indexed_container[5], iteri, t, f);
   }
   function existsi(t, f){
    return caml_call3(Base_Indexed_container[4], iteri, t, f);
   }
   function mem(t, c){
    var len = caml_ml_string_length(t), i = 0;
    for(;;){
     var _a6_ = i < len ? 1 : 0;
     if(_a6_){
      var _a7_ = caml_call2(Base_Char[15], c, caml_string_unsafe_get(t, i));
      if(! _a7_){
       var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0;
       continue;
      }
      var _a8_ = _a7_;
     }
     else
      var _a8_ = _a6_;
     return _a8_;
    }
   }
   function tr(target, replacement, s){
    return caml_call2(Base_Char[15], target, replacement)
            ? s
            : mem
               (s, target)
              ? map
                (s,
                 function(c){
                  return caml_call2(Base_Char[15], c, target)
                          ? replacement
                          : c;
                 })
              : s;
   }
   function tr_multi(target, replacement){
    if(is_empty(target))
     return caml_call1(stage, function(_a5_){return _a5_;});
    if(is_empty(replacement))
     return caml_call1(Base_Import[125], cst_tr_multi_replacement_is_em);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_a4_){return _a4_;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              return exists
                       (s,
                        function(c){
                         var
                          _a3_ =
                            caml_string_unsafe_get(tr_map, caml_call1(Base_Char[29], c));
                         return caml_call2(Base_Char[14], c, _a3_);
                        })
                      ? map
                        (s,
                         function(c){
                          return caml_string_unsafe_get
                                  (tr_map, caml_call1(Base_Char[29], c));
                         })
                      : s;
             });
   }
   function concat_array(sep, ar){
    return caml_call2(concat, sep, caml_call1(Base_Array0[15], ar));
   }
   function concat_map(sep, s, f){
    var _a2_ = to_array(s);
    return concat_array(sep, caml_call2(Base_Array0[20], _a2_, f));
   }
   function filter(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] < n && caml_call1(f, caml_string_get(t, i[1]))){caml_call1(Base_Import[129], i); continue;}
     if(i[1] === n) return t;
     var
      _a0_ = caml_call2(Base_Import[92], n, 1),
      out = caml_call1(Base_Bytes0[7], _a0_);
     caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
     var out_pos = [0, i[1]];
     caml_call1(Base_Import[129], i);
     for(;;){
      if(i[1] >= n){
       var
        out$0 = caml_call1(Base_Bytes0[16], out),
        _a1_ = caml_call2(Base_Import[92], n, 1);
       return out_pos[1] === _a1_ ? out$0 : sub(out$0, 0, out_pos[1]);
      }
      var c = caml_string_get(t, i[1]);
      if(caml_call1(f, c)){
       caml_bytes_set(out, out_pos[1], c);
       caml_call1(Base_Import[129], out_pos);
      }
      caml_call1(Base_Import[129], i);
     }
    }
   }
   function filteri(t, f){
    var n = caml_ml_string_length(t), i = [0, 0];
    for(;;){
     if(i[1] < n){
      var _aX_ = caml_string_get(t, i[1]);
      if(caml_call2(f, i[1], _aX_)){
       caml_call1(Base_Import[129], i);
       continue;
      }
     }
     if(i[1] === n) return t;
     var
      _aY_ = caml_call2(Base_Import[92], n, 1),
      out = caml_call1(Base_Bytes0[7], _aY_);
     caml_call5(Base_Bytes0[4], t, 0, out, 0, i[1]);
     var out_pos = [0, i[1]];
     caml_call1(Base_Import[129], i);
     for(;;){
      if(i[1] >= n){
       var
        out$0 = caml_call1(Base_Bytes0[16], out),
        _aZ_ = caml_call2(Base_Import[92], n, 1);
       return out_pos[1] === _aZ_ ? out$0 : sub(out$0, 0, out_pos[1]);
      }
      var c = caml_string_get(t, i[1]);
      if(caml_call2(f, i[1], c)){
       caml_bytes_set(out, out_pos[1], c);
       caml_call1(Base_Import[129], out_pos);
      }
      caml_call1(Base_Import[129], i);
     }
    }
   }
   function chop_prefix(s, prefix){
    return is_prefix$0(s, prefix)
            ? [0, drop_prefix(s, caml_ml_string_length(prefix))]
            : 0;
   }
   function chop_prefix_if_exists(s, prefix){
    return is_prefix$0(s, prefix)
            ? drop_prefix(s, caml_ml_string_length(prefix))
            : s;
   }
   function chop_prefix_exn(s, prefix){
    var match = chop_prefix(s, prefix);
    if(! match) return caml_call4(invalid_argf, _B_, s, prefix, 0);
    var str = match[1];
    return str;
   }
   function chop_suffix(s, suffix){
    return is_suffix$0(s, suffix)
            ? [0, drop_suffix(s, caml_ml_string_length(suffix))]
            : 0;
   }
   function chop_suffix_if_exists(s, suffix){
    return is_suffix$0(s, suffix)
            ? drop_suffix(s, caml_ml_string_length(suffix))
            : s;
   }
   function chop_suffix_exn(s, suffix){
    var match = chop_suffix(s, suffix);
    if(! match) return caml_call4(invalid_argf, _C_, s, suffix, 0);
    var str = match[1];
    return str;
   }
   function shorter(a, b){
    return caml_ml_string_length(a) <= caml_ml_string_length(b) ? a : b;
   }
   function shortest(list){
    if(! list) return cst$5;
    var rest = list[2], first = list[1];
    return caml_call3(Base_List[10], rest, first, shorter);
   }
   function pos_from_left(param, i){return i;}
   function pos_from_right(t, i){
    var _aW_ = caml_call2(Base_Import[92], caml_ml_string_length(t), i);
    return caml_call2(Base_Import[92], _aW_, 1);
   }
   function common_generic2_length_loop(a, b, get_pos, max_len, len_so_far){
    var len_so_far$0 = len_so_far;
    for(;;){
     if(max_len <= len_so_far$0) return max_len;
     var
      _aU_ = caml_string_unsafe_get(b, caml_call2(get_pos, b, len_so_far$0)),
      _aV_ = caml_string_unsafe_get(a, caml_call2(get_pos, a, len_so_far$0));
     if(! caml_call2(Base_Char[15], _aV_, _aU_)) return len_so_far$0;
     var
      len_so_far$1 = caml_call2(Base_Import[90], len_so_far$0, 1),
      len_so_far$0 = len_so_far$1;
    }
   }
   function common_generic2_length(a, b, get_pos){
    var
     max_len =
       caml_call2
        (Base_Import[100], caml_ml_string_length(a), caml_ml_string_length(b));
    return common_generic2_length_loop(a, b, get_pos, max_len, 0);
   }
   function common_generic_length_loop(first, list, get_pos, max_len){
    var first$0 = first, list$0 = list, max_len$0 = max_len;
    for(;;){
     if(! list$0) return max_len$0;
     var
      rest = list$0[2],
      second = list$0[1],
      max_len$1 =
        common_generic2_length_loop(first$0, second, get_pos, max_len$0, 0),
      first$0 = second,
      list$0 = rest,
      max_len$0 = max_len$1;
    }
   }
   function common_generic_length(list, get_pos){
    if(! list) return 0;
    var
     rest = list[2],
     first = list[1],
     max_len = caml_ml_string_length(shortest(list));
    return common_generic_length_loop(first, rest, get_pos, max_len);
   }
   function common_generic2(a, b, get_pos, take){
    var len = common_generic2_length(a, b, get_pos);
    return caml_call2(take, shorter(a, b), len);
   }
   function common_generic(list, get_pos, take){
    if(! list) return cst$7;
    var
     rest = list[2],
     first = list[1],
     s = shortest(list),
     max_len = caml_ml_string_length(s);
    if(0 === max_len) return cst$6;
    var len = common_generic_length_loop(first, rest, get_pos, max_len);
    return caml_call2(take, s, len);
   }
   function common_prefix(list){
    return common_generic(list, pos_from_left, prefix);
   }
   function common_suffix(list){
    return common_generic(list, pos_from_right, suffix);
   }
   function common_prefix2(a, b){
    return common_generic2(a, b, pos_from_left, prefix);
   }
   function common_suffix2(a, b){
    return common_generic2(a, b, pos_from_right, suffix);
   }
   function common_prefix_length(list){
    return common_generic_length(list, pos_from_left);
   }
   function common_suffix_length(list){
    return common_generic_length(list, pos_from_right);
   }
   function common_prefix2_length(a, b){
    return common_generic2_length(a, b, pos_from_left);
   }
   function common_suffix2_length(a, b){
    return common_generic2_length(a, b, pos_from_right);
   }
   function pp(ppf, string){
    return caml_call3(Stdlib_Format[129], ppf, _D_, string);
   }
   function of_char(c){return caml_call2(make, 1, c);}
   function of_char_list(l){
    var
     _aS_ = caml_call1(Base_List[7], l),
     t = caml_call1(Base_Bytes0[7], _aS_);
    function _aT_(i, c){return caml_bytes_set(t, i, c);}
    caml_call2(Base_List[98], l, _aT_);
    return caml_call1(Base_Bytes0[16], t);
   }
   function build_and_validate_escapeworth
   (escapeworthy_map, escape_char, func){
    var
     escapeworthy_map$0 =
       caml_call3
         (Base_List[129][7], escapeworthy_map, Base_Char[15], escape_char)
        ? escapeworthy_map
        : [0, [0, escape_char, escape_char], escapeworthy_map],
     arr = caml_call2(Base_Array0[4], 256, -1),
     vals = caml_call2(Base_Array0[4], 256, 0),
     param = escapeworthy_map$0;
    for(;;){
     if(! param) return [0, arr];
     var l = param[2], match = param[1], c_to = match[2], c_from = match[1];
     if(919809722 <= func)
      var v = c_from, k = caml_call1(Base_Char[29], c_to);
     else
      var k$0 = caml_call1(Base_Char[29], c_from), v = c_to, k = k$0;
     if(-1 === caml_check_bound(arr, k)[1 + k]){
      var _aK_ = caml_call1(Base_Char[29], v);
      if(! caml_check_bound(vals, _aK_)[1 + _aK_]){
       var _aQ_ = caml_call1(Base_Char[29], v);
       caml_check_bound(arr, k)[1 + k] = _aQ_;
       var _aR_ = caml_call1(Base_Char[29], v);
       caml_check_bound(vals, _aR_)[1 + _aR_] = 1;
       var param = l;
       continue;
      }
     }
     var
      _aL_ = caml_call2(Base_Import[149], Base_Import[140], Base_Import[140]),
      _aM_ =
        [0,
         [0,
          cst_escapeworthy_map,
          caml_call2(Base_Import[151], _aL_, escapeworthy_map$0)],
         0],
      _aN_ = [0, [0, cst_c_to, caml_call1(Base_Import[140], c_to)], _aM_],
      _aO_ = [0, [0, cst_c_from, caml_call1(Base_Import[140], c_from)], _aN_],
      _aP_ = caml_call2(Base_Sexp[9], cst_escapeworthy_map_not_one_t, _aO_);
     return caml_call1(Base_Or_error[35], _aP_);
    }
   }
   function escape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 258914209);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var
              to_escape_len = [0, 0],
              to_escape =
                foldi
                 (src,
                  0,
                  function(i, acc, c){
                   var
                    _aJ_ = caml_call1(Base_Char[29], c),
                    n = caml_check_bound(escapeworthy, _aJ_)[1 + _aJ_];
                   return -1 === n
                           ? acc
                           : (caml_call1
                              (Base_Import[129], to_escape_len),
                             [0, [0, i, caml_call1(Base_Char[32], n)], acc]);
                  });
             if(! to_escape) return src;
             var
              last_idx = caml_ml_string_length(src),
              last_dst_pos =
                caml_call2(Base_Import[90], last_idx, to_escape_len[1]),
              dst = caml_call1(Base_Bytes0[7], last_dst_pos),
              last_idx$0 = last_idx,
              last_dst_pos$0 = last_dst_pos,
              param = to_escape;
             for(;;){
              if(param){
               var
                to_escape$0 = param[2],
                match = param[1],
                escaped_char = match[2],
                last_idx$1 = match[1],
                _aH_ = caml_call2(Base_Import[92], last_idx$0, last_idx$1),
                len = caml_call2(Base_Import[92], _aH_, 1),
                dst_pos = caml_call2(Base_Import[92], last_dst_pos$0, len),
                _aI_ = caml_call2(Base_Import[90], last_idx$1, 1);
               caml_call5(Base_Bytes0[4], src, _aI_, dst, dst_pos, len);
               var last_dst_pos$1 = caml_call2(Base_Import[92], dst_pos, 2);
               caml_bytes_set(dst, last_dst_pos$1, escape_char);
               caml_bytes_set
                (dst,
                 caml_call2(Base_Import[90], last_dst_pos$1, 1),
                 escaped_char);
               var
                last_idx$0 = last_idx$1,
                last_dst_pos$0 = last_dst_pos$1,
                param = to_escape$0;
               continue;
              }
              caml_call5(Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
              return caml_call1(Base_Bytes0[16], dst);
             }
            }];
   }
   function escape_gen_exn(escapeworthy_map, escape_char){
    var _aG_ = escape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[31], _aG_));
   }
   function escape(escapeworthy, escape_char){
    var
     _aE_ = caml_call2(Base_List[114], escapeworthy, Base_Char[16]),
     _aF_ = Base_List[76],
     escapeworthy_map = caml_call2(_aF_, _aE_, function(c){return [0, c, c];});
    return escape_gen_exn(escapeworthy_map, escape_char);
   }
   function unescape_gen(escapeworthy_map, escape_char){
    var
     x =
       build_and_validate_escapeworth
        (escapeworthy_map, escape_char, 919809722);
    if(0 !== x[0]) return x;
    var escapeworthy = x[1];
    return [0,
            function(src){
             var i = 0, status = -512962225, to_unescape = 0;
             for(;;){
              if(caml_ml_string_length(src) <= i){
               if(! to_unescape) return src;
               var
                to_unescape$0 = to_unescape[2],
                idx = to_unescape[1],
                _ax_ = caml_call1(Base_List[7], to_unescape),
                _ay_ =
                  caml_call2
                   (Base_Import[92], caml_ml_string_length(src), _ax_),
                dst = caml_call1(Base_Bytes0[7], _ay_),
                loop =
                  function(last_idx, last_dst_pos, param){
                   var
                    last_idx$0 = last_idx,
                    last_dst_pos$0 = last_dst_pos,
                    param$0 = param;
                   for(;;){
                    if(! param$0)
                     return caml_call5
                             (Base_Bytes0[4], src, 0, dst, 0, last_idx$0);
                    var
                     to_unescape = param$0[2],
                     last_idx$1 = param$0[1],
                     _az_ = caml_call2(Base_Import[92], last_idx$0, last_idx$1),
                     len = caml_call2(Base_Import[92], _az_, 2),
                     dst_pos = caml_call2(Base_Import[92], last_dst_pos$0, len),
                     _aA_ = caml_call2(Base_Import[90], last_idx$1, 2);
                    caml_call5(Base_Bytes0[4], src, _aA_, dst, dst_pos, len);
                    var
                     last_dst_pos$1 = caml_call2(Base_Import[92], dst_pos, 1),
                     _aB_ =
                       caml_string_get
                        (src, caml_call2(Base_Import[90], last_idx$1, 1)),
                     _aC_ = caml_call1(Base_Char[29], _aB_),
                     n = caml_check_bound(escapeworthy, _aC_)[1 + _aC_],
                     _aD_ =
                       -1 === n
                        ? caml_string_get
                          (src, caml_call2(Base_Import[90], last_idx$1, 1))
                        : caml_call1(Base_Char[32], n);
                    caml_bytes_set(dst, last_dst_pos$1, _aD_);
                    var
                     last_idx$0 = last_idx$1,
                     last_dst_pos$0 = last_dst_pos$1,
                     param$0 = to_unescape;
                   }
                  };
               if
                (idx
                 < caml_call2(Base_Import[92], caml_ml_string_length(src), 1))
                loop
                 (caml_ml_string_length(src),
                  caml_ml_bytes_length(dst),
                  to_unescape);
               else
                loop
                 (caml_call2(Base_Import[92], caml_ml_string_length(src), 1),
                  caml_ml_bytes_length(dst),
                  to_unescape$0);
               return caml_call1(Base_Bytes0[16], dst);
              }
              if(-512962225 <= status)
               var
                _aw_ = caml_string_get(src, i),
                status$0 =
                  caml_call2(Base_Char[15], _aw_, escape_char)
                   ? -767030498
                   : -512962225;
              else
               var status$0 = -244189789;
              var
               acc =
                 -512962225 <= status$0 ? to_unescape : [0, i, to_unescape],
               i$0 = caml_call2(Base_Import[90], i, 1),
               i = i$0,
               status = status$0,
               to_unescape = acc;
             }
            }];
   }
   function unescape_gen_exn(escapeworthy_map, escape_char){
    var _av_ = unescape_gen(escapeworthy_map, escape_char);
    return caml_call1(stage, caml_call1(Base_Or_error[31], _av_));
   }
   function unescape(escape_char){return unescape_gen_exn(0, escape_char);}
   function preceding_escape_chars(str, escape_char, pos){
    var p$1 = caml_call2(Base_Import[92], pos, 1), p = p$1, cnt = 0;
    for(;;){
     if(0 <= p){
      var _au_ = caml_string_get(str, p);
      if(! caml_call2(Base_Char[14], _au_, escape_char)){
       var
        cnt$0 = caml_call2(Base_Import[90], cnt, 1),
        p$0 = caml_call2(Base_Import[92], p, 1),
        p = p$0,
        cnt = cnt$0;
       continue;
      }
     }
     return cnt;
    }
   }
   function update_escape_status(str, escape_char, i, param){
    if(-512962225 > param) return -244189789;
    var _at_ = caml_string_get(str, i);
    return caml_call2(Base_Char[15], _at_, escape_char)
            ? -767030498
            : -512962225;
   }
   function escape_status(str, escape_char, pos){
    var
     _ar_ = preceding_escape_chars(str, escape_char, pos),
     odd = 1 === caml_call2(Base_Import[121], _ar_, 2) ? 1 : 0,
     _as_ = caml_string_get(str, pos),
     match = caml_call2(Base_Char[15], _as_, escape_char);
    return odd ? -244189789 : match ? -767030498 : -512962225;
   }
   function check_bound(str, pos, function_name){
    var
     _ap_ = caml_ml_string_length(str) <= pos ? 1 : 0,
     _aq_ = _ap_ || (pos < 0 ? 1 : 0);
    return _aq_ ? caml_call3(invalid_argf, _E_, function_name, 0) : _aq_;
   }
   function is_char_escaping(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaping);
    return -512962225 <= escape_status(str, escape_char, pos) ? 0 : 1;
   }
   function is_char_escaped(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_escaped);
    return -244189789 <= escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function is_char_literal(str, escape_char, pos){
    check_bound(str, pos, cst_is_char_literal);
    return -512962225 === escape_status(str, escape_char, pos) ? 1 : 0;
   }
   function index_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_index_from);
    var
     status$1 = escape_status(str, escape_char, pos),
     i = pos,
     status = status$1;
    for(;;){
     if(pos <= i){
      var _an_ = -512962225 === status ? 1 : 0;
      if(_an_){
       var _ao_ = caml_string_get(str, i);
       if(caml_call2(Base_Char[15], _ao_, char$0)) return [0, i];
      }
     }
     var i$0 = caml_call2(Base_Import[90], i, 1);
     if(caml_ml_string_length(str) <= i$0) return 0;
     var
      status$0 = update_escape_status(str, escape_char, i$0, status),
      i = i$0,
      status = status$0;
    }
   }
   function index_from_exn$0(str, escape_char, pos, char$0){
    var match = index_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _aj_ = [0, [0, cst_char, caml_call1(Base_Import[140], char$0)], 0],
     _ak_ = [0, [0, cst_pos, caml_call1(Base_Import[141], pos)], _aj_],
     _al_ =
       [0,
        [0, cst_escape_char, caml_call1(Base_Import[140], escape_char)],
        _ak_],
     _am_ = [0, [0, cst_str, caml_call1(sexp_of_t, str)], _al_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_index_from_exn_not_found, _am_));
   }
   function index$1(str, escape_char, char$0){
    return index_from$0(str, escape_char, 0, char$0);
   }
   function index_exn$1(str, escape_char, char$0){
    return index_from_exn$0(str, escape_char, 0, char$0);
   }
   function rindex_from$0(str, escape_char, pos, char$0){
    check_bound(str, pos, cst_rindex_from);
    if(caml_call2(Base_Char[15], char$0, escape_char)) return 0;
    var pos$0 = pos;
    for(;;){
     if(0 > pos$0) return 0;
     var escape_chars = preceding_escape_chars(str, escape_char, pos$0);
     if(0 === caml_call2(Base_Import[121], escape_chars, 2)){
      var _ah_ = caml_string_get(str, pos$0);
      if(caml_call2(Base_Char[15], _ah_, char$0)) return [0, pos$0];
     }
     var
      _ai_ = caml_call2(Base_Import[92], pos$0, escape_chars),
      pos$1 = caml_call2(Base_Import[92], _ai_, 1),
      pos$0 = pos$1;
    }
   }
   function rindex_from_exn$0(str, escape_char, pos, char$0){
    var match = rindex_from$0(str, escape_char, pos, char$0);
    if(match){var pos$0 = match[1]; return pos$0;}
    var
     _ad_ = [0, [0, cst_char$0, caml_call1(Base_Import[140], char$0)], 0],
     _ae_ = [0, [0, cst_pos$0, caml_call1(Base_Import[141], pos)], _ad_],
     _af_ =
       [0,
        [0, cst_escape_char$0, caml_call1(Base_Import[140], escape_char)],
        _ae_],
     _ag_ = [0, [0, cst_str$0, caml_call1(sexp_of_t, str)], _af_];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_rindex_from_exn_not_found, _ag_));
   }
   function rindex$0(str, escape_char, char$0){
    return is_empty(str)
            ? 0
            : rindex_from$0
              (str,
               escape_char,
               caml_call2(Base_Import[92], caml_ml_string_length(str), 1),
               char$0);
   }
   function rindex_exn$0(str, escape_char, char$0){
    return rindex_from_exn$0
            (str,
             escape_char,
             caml_call2(Base_Import[92], caml_ml_string_length(str), 1),
             char$0);
   }
   function split_gen$0(str, escape_char, on){
    if(552554919 <= on[1])
     var l = on[2], is_delim = function(c){return char_list_mem(l, c);};
    else
     var
      c = on[2],
      is_delim = function(c$0){return caml_call2(Base_Char[15], c$0, c);};
    var
     len = caml_ml_string_length(str),
     acc = 0,
     status = -512962225,
     last_pos = 0,
     pos = 0;
    for(;;){
     if(pos === len){
      var
       _ab_ =
         [0,
          sub(str, last_pos, caml_call2(Base_Import[92], len, last_pos)),
          acc];
      return caml_call1(Base_List[38], _ab_);
     }
     var
      status$0 = update_escape_status(str, escape_char, pos, status),
      _ac_ = -512962225 === status$0 ? 1 : 0;
     if(_ac_ && is_delim(caml_string_get(str, pos))){
      var
       sub_str =
         sub(str, last_pos, caml_call2(Base_Import[92], pos, last_pos)),
       pos$0 = caml_call2(Base_Import[90], pos, 1),
       last_pos$0 = caml_call2(Base_Import[90], pos, 1),
       acc$0 = [0, sub_str, acc],
       acc = acc$0,
       status = status$0,
       last_pos = last_pos$0,
       pos = pos$0;
      continue;
     }
     var
      pos$1 = caml_call2(Base_Import[90], pos, 1),
      status = status$0,
      pos = pos$1;
    }
   }
   function split$0(str, on){
    var _$_ = [0, -1044422954, on];
    return function(_aa_){return split_gen$0(str, _aa_, _$_);};
   }
   function split_on_chars$0(str, chars){
    var _Z_ = [0, 552554919, chars];
    return function(___){return split_gen$0(str, ___, _Z_);};
   }
   function split_at(str, pos){
    var
     _W_ = caml_call2(Base_Import[92], caml_ml_string_length(str), pos),
     _X_ = caml_call2(Base_Import[92], _W_, 1),
     _Y_ = sub(str, caml_call2(Base_Import[90], pos, 1), _X_);
    return [0, sub(str, 0, pos), _Y_];
   }
   function lsplit2$0(str, on, escape_char){
    function _U_(x){return split_at(str, x);}
    var _V_ = index$1(str, escape_char, on);
    return caml_call2(Base_Option[21], _V_, _U_);
   }
   function rsplit2$0(str, on, escape_char){
    function _S_(x){return split_at(str, x);}
    var _T_ = rindex$0(str, escape_char, on);
    return caml_call2(Base_Option[21], _T_, _S_);
   }
   function lsplit2_exn$0(str, on, escape_char){
    return split_at(str, index_exn$1(str, escape_char, on));
   }
   function rsplit2_exn$0(str, on, escape_char){
    return split_at(str, rindex_exn$0(str, escape_char, on));
   }
   function last_non_drop_literal(drop, escape_char, t){
    return rfindi
            (0,
             t,
             function(i, c){
              var _P_ = 1 - caml_call1(drop, c);
              if(_P_)
               var _Q_ = _P_;
              else{
               var _R_ = is_char_escaping(t, escape_char, i);
               if(! _R_) return is_char_escaped(t, escape_char, i);
               var _Q_ = _R_;
              }
              return _Q_;
             });
   }
   function first_non_drop_literal(drop, escape_char, t){
    return lfindi
            (0,
             t,
             function(i, c){
              var _M_ = 1 - caml_call1(drop, c);
              if(_M_)
               var _N_ = _M_;
              else{
               var _O_ = is_char_escaping(t, escape_char, i);
               if(! _O_) return is_char_escaped(t, escape_char, i);
               var _N_ = _O_;
              }
              return _N_;
             });
   }
   function rstrip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = last_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$8;
    var i = match[1];
    return i === caml_call2(Base_Import[92], caml_ml_string_length(t), 1)
            ? t
            : prefix(t, caml_call2(Base_Import[90], i, 1));
   }
   function lstrip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var match = first_non_drop_literal(drop, escape_char, t);
    if(! match) return cst$9;
    var n = match[1];
    return 0 === n ? t : drop_prefix(t, n);
   }
   function strip_literal(opt, t, escape_char){
    if(opt) var sth = opt[1], drop = sth; else var drop = Base_Char[42];
    var length = caml_ml_string_length(t);
    if(0 !== length){
     var switch$0 = 0;
     if
      (!
       caml_call1(drop, caml_string_get(t, 0))
       &&
        !
        caml_call1
         (drop, caml_string_get(t, caml_call2(Base_Import[92], length, 1))))
      switch$0 = 1;
     if(! switch$0){
      var match = first_non_drop_literal(drop, escape_char, t);
      if(! match) return cst$10;
      var
       first = match[1],
       match$0 = last_non_drop_literal(drop, escape_char, t);
      if(! match$0)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
      var last = match$0[1], _L_ = caml_call2(Base_Import[92], last, first);
      return sub(t, first, caml_call2(Base_Import[90], _L_, 1));
     }
    }
    return t;
   }
   function between$0(t, low, high){
    var _K_ = caml_call2(Base_Import[108][2], low, t);
    return _K_ ? caml_call2(Base_Import[108][2], t, high) : _K_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[108][1], t, min)
            ? min
            : caml_call2(Base_Import[108][2], t, max) ? t : max;
   }
   function clamp_exn$0(t, min, max){
    if(caml_call2(Base_Import[108][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _G_], 1);
   }
   function clamp$0(t, min, max){
    if(! caml_call2(Base_Import[108][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _H_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _I_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _H_],
     _J_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _I_);
    return caml_call1(Base_Or_error[35], _J_);
   }
   function create$0(opt, pattern){
    if(opt)
     var sth = opt[1], case_sensitive = sth;
    else
     var case_sensitive = 1;
    return create(pattern, case_sensitive);
   }
   var
    include$1 = Base_Import[108],
    symbol$6 = include$1[1],
    symbol$7 = include$1[2],
    symbol$8 = include$1[3],
    symbol$9 = include$1[4],
    symbol$10 = include$1[5],
    symbol$11 = include$1[6],
    ascending$0 = include$1[7],
    descending$0 = include$1[8],
    compare$2 = include$1[9],
    equal$1 = include$1[10],
    max$0 = include$1[11],
    min$0 = include$1[12],
    Base_String =
      [0,
       t_sexp_grammar,
       sub,
       subo,
       mem,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       hash_fold_t,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$11,
       symbol$7,
       symbol$9,
       symbol$10,
       symbol$6,
       symbol$8,
       compare$2,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator,
       pp,
       hashable,
       invariant,
       max_length,
       make,
       copy,
       init,
       symbol,
       concat,
       escaped,
       contains,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       [0,
        hash_fold_t$0,
        hash$0,
        t_of_sexp$0,
        sexp_of_t$2,
        t_sexp_grammar$0,
        symbol$0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$5,
        equal$0,
        compare$1,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator$0,
        is_suffix,
        is_prefix,
        is_substring$0,
        is_substring_at,
        substr_index$0,
        substr_index_exn$0,
        substr_index_all$0,
        substr_replace_first$0,
        substr_replace_all$0],
       index,
       index_exn,
       index_from,
       index_from_exn,
       rindex,
       rindex_exn,
       rindex_from,
       rindex_from_exn,
       [0,
        sexp_of_t$0,
        create$0,
        pattern,
        case_sensitive,
        matches,
        index$0,
        index_exn$0,
        index_all,
        replace_first,
        replace_all,
        split_on,
        Private],
       substr_index,
       substr_index_exn,
       substr_index_all,
       substr_replace_first,
       substr_replace_all,
       is_substring,
       is_substring_at$0,
       to_list_rev,
       rev,
       is_suffix$0,
       is_prefix$0,
       lsplit2_exn,
       rsplit2_exn,
       lsplit2,
       rsplit2,
       split,
       split_on_chars,
       split_lines,
       lfindi,
       rfindi,
       lstrip,
       rstrip,
       strip,
       map,
       mapi,
       foldi,
       concat_map,
       filter,
       filteri,
       tr,
       tr_multi,
       chop_suffix_exn,
       chop_prefix_exn,
       chop_suffix,
       chop_prefix,
       chop_suffix_if_exists,
       chop_prefix_if_exists,
       suffix,
       prefix,
       drop_suffix,
       drop_prefix,
       common_suffix,
       common_prefix,
       common_suffix_length,
       common_prefix_length,
       common_suffix2,
       common_prefix2,
       common_suffix2_length,
       common_prefix2_length,
       concat_array,
       equal$1,
       of_char,
       of_char_list,
       [0,
        escape_gen_exn,
        escape_gen,
        escape,
        unescape_gen_exn,
        unescape_gen,
        unescape,
        is_char_escaping,
        is_char_escaped,
        is_char_literal,
        index$1,
        index_exn$1,
        rindex$0,
        rindex_exn$0,
        index_from$0,
        index_from_exn$0,
        rindex_from$0,
        rindex_from_exn$0,
        split$0,
        split_on_chars$0,
        lsplit2$0,
        lsplit2_exn$0,
        rsplit2$0,
        rsplit2_exn$0,
        lstrip_literal,
        rstrip_literal,
        strip_literal]];
   runtime.caml_register_global(86, Base_String, "Base__String");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bytes
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Blit, Base__Bytes0, Base__Bytes_tr, Base__Char, Base__Comparator, Base__Import, Base__List, Base__Or_error, Base__Ordered_collection_common, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Staged, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_get = runtime.caml_bytes_get,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_bytes_unsafe_get = runtime.caml_bytes_unsafe_get,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Bytes",
    Base_Char = global_data.Base__Char,
    Base_Import = global_data.Base__Import,
    Base_Ordered_collection_common =
      global_data.Base__Ordered_collection_common,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Bytes_tr = global_data.Base__Bytes_tr,
    Base_Array0 = global_data.Base__Array0,
    Base_List = global_data.Base__List,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Format = global_data.Stdlib__Format,
    Base_Staged = global_data.Base__Staged,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Blit = global_data.Base__Blit,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    stage = Base_Staged[1],
    t_of_sexp = Base_Import[163],
    sexp_of_t = Base_Import[139],
    t_sexp_grammar = Base_Import[183],
    max_length = Base_Bytes0[2],
    compare = Base_Bytes0[5],
    copy = Base_Bytes0[6],
    create = Base_Bytes0[7],
    fill = Base_Bytes0[8],
    make = Base_Bytes0[9],
    map = Base_Bytes0[10],
    mapi = Base_Bytes0[11],
    unsafe_blit = Base_Bytes0[13],
    to_string = Base_Bytes0[14],
    of_string = Base_Bytes0[15],
    unsafe_to_string = Base_Bytes0[16],
    unsafe_of_string_promise_no_mu = Base_Bytes0[17],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _c_ = [0, "src/bytes.ml", 128, 2],
    cst_tr_multi_replacement_is_th =
      "tr_multi: replacement is the empty string",
    _b_ = [0, [11, "Bytes.init ", [4, 0, 0, 0, 0]], "Bytes.init %d"],
    _a_ = [0, [3, 0, 0], "%S"];
   function pp(fmt, t){
    var _y_ = caml_call1(to_string, t);
    return caml_call3(Stdlib_Format[129], fmt, _a_, _y_);
   }
   function create$0(len){return caml_call1(create, len);}
   var
    To_bytes =
      caml_call1
       (Base_Blit[1], [0, caml_ml_bytes_length, create$0, unsafe_blit]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit$0 = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    comparator = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t])[1],
    include = caml_call1(Base_Pretty_printer[3], [0, pp, module_name]),
    pp$0 = include[1],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes);
   function create$1(len){return caml_call1(create, len);}
   var
    length = caml_ml_bytes_length,
    unsafe_blit$1 = runtime.caml_blit_string,
    length$0 = caml_ml_string_length,
    From_string =
      caml_call1
       (caml_call1(Base_Blit[2], [0, length$0]),
        [0, length, create$1, unsafe_blit$1]);
   function invariant(param){return 0;}
   function init(n, f){
    if(n < 0) caml_call3(Base_Printf[7], _b_, n, 0);
    var
     t = caml_call1(create, n),
     _w_ = caml_call2(Base_Import[92], n, 1),
     _v_ = 0;
    if(_w_ >= 0){
     var i = _v_;
     for(;;){
      caml_bytes_unsafe_set(t, i, caml_call1(f, i));
      var _x_ = i + 1 | 0;
      if(_w_ !== i){var i = _x_; continue;}
      break;
     }
    }
    return t;
   }
   function of_char_list(l){
    var t = caml_call1(create, caml_call1(Base_List[7], l));
    function _u_(i, c){return caml_bytes_set(t, i, c);}
    caml_call2(Base_List[98], l, _u_);
    return t;
   }
   function to_list(t){
    var
     i$1 = caml_call2(Base_Import[92], caml_ml_bytes_length(t), 1),
     i = i$1,
     acc = 0;
    for(;;){
     if(0 > i) return acc;
     var
      acc$0 = [0, caml_bytes_unsafe_get(t, i), acc],
      i$0 = caml_call2(Base_Import[92], i, 1),
      i = i$0,
      acc = acc$0;
    }
   }
   function to_array(t){
    function _t_(i){return caml_bytes_unsafe_get(t, i);}
    return caml_call2(Base_Array0[11], caml_ml_bytes_length(t), _t_);
   }
   function map$0(t, f){return caml_call2(map, f, t);}
   function mapi$0(t, f){return caml_call2(mapi, f, t);}
   function fold(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call2(f, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[90], pos, 1),
      pos = pos$0,
      acc = acc$0;
    }
   }
   function foldi(t, init, f){
    var len = caml_ml_bytes_length(t), pos = 0, acc = init;
    for(;;){
     if(pos === len) return acc;
     var
      acc$0 = caml_call3(f, pos, acc, caml_bytes_unsafe_get(t, pos)),
      pos$0 = caml_call2(Base_Import[90], pos, 1),
      pos = pos$0,
      acc = acc$0;
    }
   }
   function tr(target, replacement, s){
    var
     _r_ = caml_call2(Base_Import[92], caml_ml_bytes_length(s), 1),
     _q_ = 0;
    if(_r_ >= 0){
     var i = _q_;
     for(;;){
      if(caml_call2(Base_Char[15], caml_bytes_unsafe_get(s, i), target))
       caml_bytes_unsafe_set(s, i, replacement);
      var _s_ = i + 1 | 0;
      if(_r_ !== i){var i = _s_; continue;}
      break;
     }
    }
    return 0;
   }
   function tr_multi(target, replacement){
    if(0 === caml_ml_string_length(target))
     return caml_call1(stage, function(_p_){return 0;});
    if(0 === caml_ml_string_length(replacement))
     return caml_call1(Base_Import[125], cst_tr_multi_replacement_is_th);
    var match = caml_call2(Base_Bytes_tr[1], target, replacement);
    if(! match) return caml_call1(stage, function(_o_){return 0;});
    var tr_map = match[1];
    return caml_call1
            (stage,
             function(s){
              var
               _m_ = caml_call2(Base_Import[92], caml_ml_bytes_length(s), 1),
               _l_ = 0;
              if(_m_ >= 0){
               var i = _l_;
               for(;;){
                caml_bytes_unsafe_set
                 (s,
                  i,
                  runtime.caml_string_unsafe_get
                   (tr_map,
                    caml_call1(Base_Char[29], caml_bytes_unsafe_get(s, i))));
                var _n_ = i + 1 | 0;
                if(_m_ !== i){var i = _n_; continue;}
                break;
               }
              }
              return 0;
             });
   }
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[109][2], low, t);
    return _k_ ? caml_call2(Base_Import[109][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[109][1], t, min)
            ? min
            : caml_call2(Base_Import[109][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[109][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[109][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[35], _j_);
   }
   function contains(pos, len, t, char$0){
    var
     match =
       caml_call4
        (Base_Ordered_collection_common[1],
         pos,
         len,
         0,
         caml_ml_bytes_length(t)),
     len$0 = match[2],
     pos$0 = match[1],
     last = caml_call2(Base_Import[90], pos$0, len$0),
     i = pos$0;
    for(;;){
     var _d_ = i < last ? 1 : 0;
     if(_d_){
      var
       _e_ = caml_bytes_get(t, i),
       _f_ = caml_call2(Base_Char[15], _e_, char$0);
      if(! _f_){
       var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0;
       continue;
      }
      var _g_ = _f_;
     }
     else
      var _g_ = _d_;
     return _g_;
    }
   }
   var
    include$0 = Base_Import[109],
    symbol = include$0[1],
    symbol$0 = include$0[2],
    symbol$1 = include$0[3],
    symbol$2 = include$0[4],
    symbol$3 = include$0[5],
    symbol$4 = include$0[6],
    ascending = include$0[7],
    descending = include$0[8],
    compare$0 = include$0[9],
    equal = include$0[10],
    max = include$0[11],
    min = include$0[12],
    Base_Bytes =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       of_string,
       to_string,
       pp$0,
       invariant,
       To_string,
       From_string,
       create,
       make,
       map$0,
       mapi$0,
       copy,
       init,
       of_char_list,
       caml_bytes_get,
       caml_bytes_set,
       fill,
       tr,
       tr_multi,
       to_list,
       to_array,
       fold,
       foldi,
       contains,
       max_length,
       unsafe_to_string,
       unsafe_of_string_promise_no_mu];
   runtime.caml_register_global(24, Base_Bytes, "Base__Bytes");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hex_lexer
//# unitInfo: Requires: Stdlib__Lexing
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst = "";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    ocaml_lex_tables =
      [0,
       "\0\0\0\0\x01\0\x01\0\x02\0\x1b\0R\0i\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\x01\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\x01\0\x03\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\x06\0\x04\0\0\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x06\0\x04\0\x05\0\0\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",
       "\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\0\0\x02\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\xff\xff\xff\xff\x01\0\x03\0\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\xff\xff\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x01\0\x03\0\x05\0\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x05\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\x06\0\x06\0\x06\0\x06\0\x06\0\x06\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x07\0\xff\xff\x07\0\x07\0\x07\0\x07\0\x07\0\x07\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff",
       cst,
       cst,
       cst,
       cst,
       cst,
       cst],
    Stdlib_Lexing = global_data.Stdlib__Lexing;
   function parse_hex(lexbuf){
    var ocaml_lex_state = 0;
    for(;;){
     var
      ocaml_lex_state$0 =
        caml_call3
         (Stdlib_Lexing[20], ocaml_lex_tables, ocaml_lex_state, lexbuf);
     if(0 === ocaml_lex_state$0){
      var
       body =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 3 | 0, lexbuf[6]);
      return [0, body];
     }
     if(1 === ocaml_lex_state$0){
      var
       body$0 =
         caml_call3(Stdlib_Lexing[16], lexbuf, lexbuf[5] + 2 | 0, lexbuf[6]);
      return [1, body$0];
     }
     caml_call1(lexbuf[1], lexbuf);
     var ocaml_lex_state = ocaml_lex_state$0;
    }
   }
   var Base_Hex_lexer = [0, parse_hex];
   runtime.caml_register_global(2, Base_Hex_lexer, "Base__Hex_lexer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_conversions
//# unitInfo: Requires: Assert_failure, Base__Bytes, Base__Char, Base__Hex_lexer, Base__Import, Base__Int0, Base__Option, Base__Printf, Base__Sexp, Base__Sexpable, Base__String, Base__Sys0, Base__Word_size, Sexplib0__Sexp_grammar, Stdlib__Int32, Stdlib__Int64, Stdlib__Lexing, Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_int$3 = "int",
    cst_int32$3 = "int32",
    cst_int64$3 = "int64",
    cst_nativeint$2 = "nativeint",
    cst_src_int_conversions_ml = "src/int_conversions.ml",
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Hex_lexer = global_data.Base__Hex_lexer,
    Stdlib_Lexing = global_data.Stdlib__Lexing,
    Base_Option = global_data.Base__Option,
    Base_Char = global_data.Base__Char,
    Base_String = global_data.Base__String,
    Base_Printf = global_data.Base__Printf,
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Bytes = global_data.Base__Bytes,
    Base_Sys0 = global_data.Base__Sys0,
    Base_Word_size = global_data.Base__Word_size,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Int0 = global_data.Base__Int0,
    Base_Sexp = global_data.Base__Sexp,
    _g_ =
      [0,
       [2, 0, [11, ".of_string: invalid input ", [3, 0, 0]]],
       "%s.of_string: invalid input %S"],
    cst_0x = "-0x",
    cst_0x$0 = "0x",
    cst_int63 = "int63",
    cst_int64$2 = cst_int64$3,
    cst_nativeint$1 = cst_nativeint$2,
    cst_int64$1 = cst_int64$3,
    cst_int32$2 = cst_int32$3,
    cst_nativeint$0 = cst_nativeint$2,
    cst_int32$1 = cst_int32$3,
    cst_int64$0 = cst_int64$3,
    cst_int$2 = cst_int$3,
    cst_nativeint = cst_nativeint$2,
    cst_int$1 = cst_int$3,
    cst_int64 = cst_int64$3,
    cst_int$0 = cst_int$3,
    cst_int32$0 = cst_int32$3,
    cst_int32 = cst_int32$3,
    cst_int = cst_int$3,
    _a_ =
      [0,
       [11,
        "conversion from ",
        [2,
         0,
         [11,
          " to ",
          [2, 0, [11, " failed: ", [2, 0, [11, " is out of range", 0]]]]]]],
       "conversion from %s to %s failed: %s is out of range"],
    _m_ = [0, cst_src_int_conversions_ml, 19, 9],
    _l_ = [0, cst_src_int_conversions_ml, 75, 9],
    _k_ = [0, cst_src_int_conversions_ml, 96, 9],
    _j_ = [0, cst_src_int_conversions_ml, 148, 9],
    _i_ = [0, cst_src_int_conversions_ml, 176, 9];
   function convert_failure(x, a, b, to_string){
    var _S_ = caml_call1(to_string, x);
    return caml_call5(Base_Printf[6], _a_, a, b, _S_, 0);
   }
   var
    num_bits_int = Base_Sys0[8],
    num_bits_nativeint = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    num_bits_int32 = 32,
    num_bits_int64 = 64;
   if(63 !== num_bits_int && 31 !== num_bits_int && 32 !== num_bits_int)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
   var
    min_int32 = Stdlib_Int32[10],
    max_int32 = Stdlib_Int32[9],
    min_int64 = Stdlib_Int64[10],
    max_int64 = Stdlib_Int64[9],
    min_nativeint = Stdlib_Nativeint[11],
    max_nativeint = Stdlib_Nativeint[10],
    int64_to_string = Stdlib_Int64[14],
    nativeint_to_string = Stdlib_Nativeint[15],
    _b_ = Base_Import[84][32],
    _c_ = Stdlib_Int32[14];
   function int32_to_int_trunc(_R_){return _R_;}
   function int_to_int32_trunc(_Q_){return _Q_;}
   var
    int_is_representable_as_int32 =
      num_bits_int <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _O_ = caml_call2(Base_Import[228], min_int32, x) <= 0 ? 1 : 0,
          _P_ =
            _O_
             ? caml_call2(Base_Import[228], x, max_int32) <= 0 ? 1 : 0
             : _O_;
         return _P_;
        };
   if(32 <= num_bits_int)
    var _d_ = function(param){return 1;};
   else
    var
     min$4 = Base_Int0[6],
     max$4 = Base_Int0[5],
     _d_ =
       function(x){
        var
         _M_ = caml_call2(Base_Import[229], min$4, x) <= 0 ? 1 : 0,
         _N_ = _M_ ? caml_call2(Base_Import[229], x, max$4) <= 0 ? 1 : 0 : _M_;
        return _N_;
       };
   function int_to_int32(x){
    return int_is_representable_as_int32(x) ? [0, x] : 0;
   }
   function int32_to_int(x){return _d_(x) ? [0, x] : 0;}
   function int_to_int32_exn(x){
    return int_is_representable_as_int32(x)
            ? x
            : convert_failure(x, cst_int, cst_int32, _b_);
   }
   function int32_to_int_exn(x){
    return _d_(x) ? x : convert_failure(x, cst_int32$0, cst_int$0, _c_);
   }
   if(num_bits_int >= 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
   var
    int_to_int64 = caml_int64_of_int32,
    int64_to_int_trunc = caml_int64_to_int32,
    min = caml_int64_of_int32(Base_Int0[6]),
    max = caml_int64_of_int32(Base_Int0[5]);
   function int64_is_representable_as_int(x){
    var
     _K_ = caml_call2(Base_Import[230], min, x) <= 0 ? 1 : 0,
     _L_ = _K_ ? caml_call2(Base_Import[230], x, max) <= 0 ? 1 : 0 : _K_;
    return _L_;
   }
   function int64_to_int(x){
    return int64_is_representable_as_int(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int_exn(x){
    return int64_is_representable_as_int(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64, cst_int$1, int64_to_string);
   }
   if(num_bits_int > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   function int_to_nativeint(_J_){return _J_;}
   function nativeint_to_int_trunc(_I_){return _I_;}
   if(num_bits_nativeint <= num_bits_int)
    var _e_ = function(param){return 1;};
   else
    var
     min$3 = Base_Int0[6],
     max$3 = Base_Int0[5],
     _e_ =
       function(x){
        var
         _G_ = caml_call2(Base_Import[231], min$3, x) <= 0 ? 1 : 0,
         _H_ = _G_ ? caml_call2(Base_Import[231], x, max$3) <= 0 ? 1 : 0 : _G_;
        return _H_;
       };
   function nativeint_to_int(x){return _e_(x) ? [0, x] : 0;}
   function nativeint_to_int_exn(x){
    return _e_(x)
            ? x
            : convert_failure
              (x, cst_nativeint, cst_int$2, nativeint_to_string);
   }
   var
    int32_to_int64 = caml_int64_of_int32,
    int64_to_int32_trunc = caml_int64_to_int32,
    min$0 = caml_int64_of_int32(min_int32),
    max$0 = caml_int64_of_int32(max_int32);
   function int64_is_representable_as_int3(x){
    var
     _E_ = caml_call2(Base_Import[230], min$0, x) <= 0 ? 1 : 0,
     _F_ = _E_ ? caml_call2(Base_Import[230], x, max$0) <= 0 ? 1 : 0 : _E_;
    return _F_;
   }
   function int64_to_int32(x){
    return int64_is_representable_as_int3(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_int32_exn(x){
    return int64_is_representable_as_int3(x)
            ? caml_int64_to_int32(x)
            : convert_failure(x, cst_int64$0, cst_int32$1, int64_to_string);
   }
   if(32 > num_bits_nativeint)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   function int32_to_nativeint(_D_){return _D_;}
   function nativeint_to_int32_trunc(_C_){return _C_;}
   var
    _f_ =
      num_bits_nativeint <= 32
       ? function(param){return 1;}
       : function
        (x){
         var
          _A_ = caml_call2(Base_Import[231], min_int32, x) <= 0 ? 1 : 0,
          _B_ =
            _A_
             ? caml_call2(Base_Import[231], x, max_int32) <= 0 ? 1 : 0
             : _A_;
         return _B_;
        };
   function nativeint_to_int32(x){return _f_(x) ? [0, x] : 0;}
   function nativeint_to_int32_exn(x){
    return _f_(x)
            ? x
            : convert_failure
              (x, cst_nativeint$0, cst_int32$2, nativeint_to_string);
   }
   if(num_bits_nativeint > 64)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
   var
    int64_to_nativeint_trunc = caml_int64_to_int32,
    nativeint_to_int64 = caml_int64_of_int32;
   if(64 <= num_bits_nativeint)
    var int64_is_representable_as_nati = function(param){return 1;};
   else
    var
     min$2 = caml_int64_of_int32(min_nativeint),
     max$2 = caml_int64_of_int32(max_nativeint),
     int64_is_representable_as_nati =
       function(x){
        var
         _y_ = caml_call2(Base_Import[230], min$2, x) <= 0 ? 1 : 0,
         _z_ = _y_ ? caml_call2(Base_Import[230], x, max$2) <= 0 ? 1 : 0 : _y_;
        return _z_;
       };
   function int64_to_nativeint(x){
    return int64_is_representable_as_nati(x) ? [0, caml_int64_to_int32(x)] : 0;
   }
   function int64_to_nativeint_exn(x){
    return int64_is_representable_as_nati(x)
            ? caml_int64_to_int32(x)
            : convert_failure
              (x, cst_int64$1, cst_nativeint$1, int64_to_string);
   }
   var
    min$1 = caml_int64_shift_right(min_int64, 1),
    max$1 = caml_int64_shift_right(max_int64, 1);
   function int64_is_representable_as_int6(x){
    var
     _w_ = caml_call2(Base_Import[230], min$1, x) <= 0 ? 1 : 0,
     _x_ = _w_ ? caml_call2(Base_Import[230], x, max$1) <= 0 ? 1 : 0 : _w_;
    return _x_;
   }
   function int64_fit_on_int63_exn(x){
    return int64_is_representable_as_int6(x)
            ? 0
            : convert_failure(x, cst_int64$2, cst_int63, int64_to_string);
   }
   function insert_delimiter_every(input, delimiter, chars_per_delimiter){
    var input_length = runtime.caml_ml_string_length(input);
    if(input_length <= chars_per_delimiter) return input;
    var match = caml_string_get(input, 0), switch$0 = 0;
    if(43 !== match && 45 !== match){var has_sign = 0; switch$0 = 1;}
    if(! switch$0) var has_sign = 1;
    var
     num_digits =
       has_sign ? caml_call2(Base_Import[92], input_length, 1) : input_length,
     _t_ = caml_call2(Base_Import[92], num_digits, 1),
     num_delimiters = caml_call2(Base_Import[94], _t_, chars_per_delimiter),
     output_length = caml_call2(Base_Import[90], input_length, num_delimiters),
     output = caml_call1(Base_Bytes[31], output_length),
     input_pos = [0, caml_call2(Base_Import[92], input_length, 1)],
     output_pos = [0, caml_call2(Base_Import[92], output_length, 1)],
     num_chars_until_delimiter = [0, chars_per_delimiter],
     first_digit_pos = has_sign ? 1 : 0;
    for(;;){
     if(first_digit_pos <= input_pos[1]){
      if(0 === num_chars_until_delimiter[1]){
       caml_call3(Base_Bytes[39], output, output_pos[1], delimiter);
       caml_call1(Base_Import[128], output_pos);
       num_chars_until_delimiter[1] = chars_per_delimiter;
      }
      var _u_ = caml_string_get(input, input_pos[1]);
      caml_call3(Base_Bytes[39], output, output_pos[1], _u_);
      caml_call1(Base_Import[128], input_pos);
      caml_call1(Base_Import[128], output_pos);
      caml_call1(Base_Import[128], num_chars_until_delimiter);
      continue;
     }
     if(has_sign){
      var _v_ = caml_string_get(input, 0);
      caml_call3(Base_Bytes[39], output, 0, _v_);
     }
     return caml_call1(Base_Bytes[49], output);
    }
   }
   function insert_delimiter(input, delimiter){
    return insert_delimiter_every(input, delimiter, 3);
   }
   function insert_underscores(input){return insert_delimiter(input, 95);}
   var sexp_of_int_style = Base_Sexp[19];
   function _h_(I){
    var compare = I[1], hash_fold_t = I[2], func = I[3];
    function hash(x){return caml_call1(func, x);}
    var chars_per_delimiter = 4;
    function to_string(delimiter, t){
     if(delimiter)
      var
       delimiter$0 = delimiter[1],
       make_suffix =
         function(t){
          return insert_delimiter_every
                  (caml_call1(I[4], t), delimiter$0, chars_per_delimiter);
         };
     else
      var make_suffix = I[4];
     if(caml_call2(I[7], t, I[6])){
      var _r_ = caml_call1(make_suffix, caml_call1(I[8], t));
      return caml_call2(Base_Import[111], cst_0x, _r_);
     }
     var _s_ = caml_call1(make_suffix, t);
     return caml_call2(Base_Import[111], cst_0x$0, _s_);
    }
    function to_string$0(t){return to_string(0, t);}
    function to_string_hum(opt, t){
     if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
     return to_string([0, delimiter], t);
    }
    function invalid(str){
     return caml_call4(Base_Printf[6], _g_, I[9], str, 0);
    }
    function of_string_with_delimiter(str){
     function _p_(c){return caml_call2(Base_Char[14], c, 95);}
     var _q_ = caml_call2(Base_String[98], str, _p_);
     return caml_call1(I[5], _q_);
    }
    function of_string(str){
     var lex = caml_call2(Stdlib_Lexing[3], 0, str);
     function _n_(param){return caml_call1(Base_Hex_lexer[1], lex);}
     var result = caml_call1(Base_Option[44], _n_);
     if(lex[6] !== lex[3]) return invalid(str);
     if(! result) return invalid(str);
     var match = result[1];
     if(0 === match[0]){
      var body = match[1], _o_ = of_string_with_delimiter(body);
      return caml_call1(I[8], _o_);
     }
     var body$0 = match[1];
     return of_string_with_delimiter(body$0);
    }
    var
     t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_String[1]),
     include = caml_call1(Base_Sexpable[5], [0, of_string, to_string$0]),
     t_of_sexp = include[1],
     sexp_of_t = include[2];
    return [0,
            [0,
             t_of_sexp,
             sexp_of_t,
             t_sexp_grammar,
             compare,
             hash_fold_t,
             hash,
             of_string,
             to_string$0,
             to_string_hum]];
   }
   var
    Base_Int_conversions =
      [0,
       int_to_int32,
       int_to_int32_exn,
       int_to_int32_trunc,
       int_to_int64,
       int_to_nativeint,
       int32_to_int,
       int32_to_int_exn,
       int32_to_int_trunc,
       int32_to_int64,
       int32_to_nativeint,
       int64_to_int,
       int64_to_int_exn,
       int64_to_int_trunc,
       int64_to_int32,
       int64_to_int32_exn,
       int64_to_int32_trunc,
       int64_to_nativeint,
       int64_to_nativeint_exn,
       int64_to_nativeint_trunc,
       int64_fit_on_int63_exn,
       int64_is_representable_as_int6,
       nativeint_to_int,
       nativeint_to_int_exn,
       nativeint_to_int_trunc,
       nativeint_to_int32,
       nativeint_to_int32_exn,
       nativeint_to_int32_trunc,
       nativeint_to_int64,
       num_bits_int,
       num_bits_int32,
       num_bits_int64,
       num_bits_nativeint,
       function(I){
        var chars_per_delimiter = 3;
        function to_string_hum(opt, t){
         if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
         return insert_delimiter_every
                 (caml_call1(I[1], t), delimiter, chars_per_delimiter);
        }
        function sexp_of_t(t){
         var
          s = caml_call1(I[1], t),
          s$0 =
            1009018843 <= sexp_of_int_style[1]
             ? s
             : insert_delimiter_every(s, 95, chars_per_delimiter);
         return [0, s$0];
        }
        return [0, to_string_hum, sexp_of_t];
       },
       _h_,
       sexp_of_int_style,
       insert_delimiter_every,
       insert_delimiter,
       insert_underscores];
   runtime.caml_register_global
    (44, Base_Int_conversions, "Base__Int_conversions");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Intable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Intable = [0];
   runtime.caml_register_global(0, Base_Intable, "Base__Intable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Int_intf = [0];
   runtime.caml_register_global(0, Base_Int_intf, "Base__Int_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Pow_overflow_bounds
//# unitInfo: Requires: Assert_failure, Base__Array0, Base__Import, Base__Int_conversions
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    overflow_bound_max_int63_on_in =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    overflow_bound_max_int64_value =
      runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
    Base_Import = global_data.Base__Import,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Assert_failure = global_data.Assert_failure,
    Base_Array0 = global_data.Base__Array0,
    int32_positive_overflow_bounds =
      [0,
        2147483647,
        2147483647,
        46340,
        1290,
        215,
        73,
        35,
        21,
        14,
        10,
        8,
        7,
        5,
        5,
        4,
        4,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1].slice
       (),
    overflow_bound_max_int_value = caml_call2(Base_Import[119], -1, 1),
    switcher = Base_Int_conversions[29] - 31 | 0,
    _g_ = [0, "src/pow_overflow_bounds.ml", 218, 9],
    _a_ = runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _c_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
    _i_ =
      [0,
       1073741823,
       1073741823,
       32767,
       1023,
       181,
       63,
       31,
       19,
       13,
       10,
       7,
       6,
       5,
       4,
       4,
       3,
       3,
       3,
       3,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       2,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1,
       1],
    _d_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 16383),
       runtime.caml_int64_create_lo_mi_hi(16777215, 127, 0),
       runtime.caml_int64_create_lo_mi_hi(1664510, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(46340, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5404, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1290, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(463, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(215, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(118, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(73, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(49, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(35, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(27, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(21, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(17, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(14, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(12, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(10, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _e_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 32767),
       runtime.caml_int64_create_lo_mi_hi(324403, 181, 0),
       runtime.caml_int64_create_lo_mi_hi(2097151, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(55108, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6208, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1448, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(511, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(234, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(127, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(78, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(52, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(38, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(28, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(22, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(18, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(15, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(13, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(11, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(9, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(8, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(7, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(6, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(5, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(4, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(3, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 0)],
    _f_ =
      [0,
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(1, 0, 32768),
       runtime.caml_int64_create_lo_mi_hi(16452813, 16777034, 65535),
       runtime.caml_int64_create_lo_mi_hi(14680065, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16722108, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16771008, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16775768, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776705, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16776982, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777089, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777138, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777164, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777178, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777188, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777194, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777198, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777201, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777203, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777205, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777207, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777208, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777209, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777210, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777211, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777212, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777213, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
       runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535)],
    overflow_bound_max_int32_value = 2147483647;
   if(1 < switcher >>> 0){
    if(32 !== switcher)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    var
     int_positive_overflow_bounds =
       [0,
        caml_int64_to_int32(_c_),
        caml_int64_to_int32(_b_),
        caml_int64_to_int32(_a_),
        1664510,
        46340,
        5404,
        1290,
        463,
        215,
        118,
        73,
        49,
        35,
        27,
        21,
        17,
        14,
        12,
        10,
        9,
        8,
        7,
        7,
        6,
        5,
        5,
        5,
        4,
        4,
        4,
        4,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        1,
        1];
   }
   else if(switcher)
    var
     _h_ = function(_j_){return _j_;},
     int_positive_overflow_bounds =
       caml_call2(Base_Array0[20], int32_positive_overflow_bounds, _h_);
   else
    var int_positive_overflow_bounds = _i_.slice();
   var
    int63_on_int64_positive_overfl = _d_.slice(),
    int64_positive_overflow_bounds = _e_.slice(),
    int64_negative_overflow_bounds = _f_.slice(),
    Base_Pow_overflow_bounds =
      [0,
       overflow_bound_max_int32_value,
       int32_positive_overflow_bounds,
       overflow_bound_max_int_value,
       int_positive_overflow_bounds,
       overflow_bound_max_int63_on_in,
       int63_on_int64_positive_overfl,
       overflow_bound_max_int64_value,
       int64_positive_overflow_bounds,
       int64_negative_overflow_bounds];
   runtime.caml_register_global
    (16, Base_Pow_overflow_bounds, "Base__Pow_overflow_bounds");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int_math
//# unitInfo: Requires: Base__Import, Base__Pow_overflow_bounds, Base__Printf, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_exponent_can_not_be_negati = "exponent can not be negative",
    cst_integer_overflow_in_pow = "integer overflow in pow",
    caml_check_bound = runtime.caml_check_bound,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_lessthan = runtime.caml_lessthan;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Pow_overflow_bounds = global_data.Base__Pow_overflow_bounds,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    invalid_argf = Base_Printf[7],
    _m_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"],
    _l_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    _i_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _j_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _k_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _d_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0),
    _h_ = runtime.caml_int64_create_lo_mi_hi(16777215, 16777215, 65535),
    _e_ = runtime.caml_int64_create_lo_mi_hi(63, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _b_ =
      [0, [11, cst_integer_overflow_in_pow, 0], cst_integer_overflow_in_pow],
    _a_ =
      [0,
       [11, cst_exponent_can_not_be_negati, 0],
       cst_exponent_can_not_be_negati];
   function negative_exponent(param){
    return caml_call2(Base_Printf[7], _a_, 0);
   }
   function overflow(param){return caml_call2(Base_Printf[7], _b_, 0);}
   function int_pow(base, exponent){
    if(exponent < 0) negative_exponent(0);
    var _J_ = 1 < caml_call1(Base_Import[122], base) ? 1 : 0;
    if(_J_){
     var _K_ = 63 < exponent ? 1 : 0;
     if(_K_)
      var _L_ = _K_;
     else
      var
       _M_ =
         caml_check_bound(Base_Pow_overflow_bounds[4], exponent)[1 + exponent],
       _L_ = _M_ < caml_call1(Base_Import[122], base) ? 1 : 0;
    }
    else
     var _L_ = _J_;
    if(_L_) overflow(0);
    return runtime.Base_int_math_int_pow_stub(base, exponent);
   }
   var abs = Stdlib_Int64[8];
   function int64_pow(base, exponent){
    if(caml_lessthan(exponent, _c_)) negative_exponent(0);
    var
     _A_ = caml_greaterthan(base, _d_),
     _B_ = _A_ || caml_lessthan(base, _h_);
    if(_B_){
     var _C_ = caml_greaterthan(exponent, _e_);
     if(_C_)
      var _D_ = _C_;
     else{
      var _E_ = runtime.caml_greaterequal(base, _f_);
      if(_E_)
       var
        _F_ = caml_int64_to_int32(exponent),
        _G_ =
          caml_greaterthan
           (base, caml_check_bound(Base_Pow_overflow_bounds[8], _F_)[1 + _F_]);
      else
       var _G_ = _E_;
      if(_G_)
       var _D_ = _G_;
      else{
       var _H_ = caml_lessthan(base, _g_);
       if(_H_)
        var
         _I_ = caml_int64_to_int32(exponent),
         _D_ =
           caml_lessthan
            (base,
             caml_check_bound(Base_Pow_overflow_bounds[9], _I_)[1 + _I_]);
       else
        var _D_ = _H_;
      }
     }
    }
    else
     var _D_ = _B_;
    if(_D_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   function int63_pow_on_int64(base, exponent){
    if(caml_lessthan(exponent, _i_)) negative_exponent(0);
    var _v_ = caml_greaterthan(caml_call1(abs, base), _j_);
    if(_v_){
     var _w_ = caml_greaterthan(exponent, _k_);
     if(_w_)
      var _x_ = _w_;
     else
      var
       _y_ = caml_int64_to_int32(exponent),
       _z_ = caml_check_bound(Base_Pow_overflow_bounds[6], _y_)[1 + _y_],
       _x_ = caml_greaterthan(caml_call1(abs, base), _z_);
    }
    else
     var _x_ = _v_;
    if(_x_) overflow(0);
    return runtime.Base_int_math_int64_pow_stub(base, exponent);
   }
   var
    Private = [0, int_pow, int64_pow, int63_pow_on_int64],
    Base_Int_math =
      [0,
       function(X){
        function symbol(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _u_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _l_, caml_call1(X[4], x), _u_, 0);
         }
         var rval = caml_call2(X[20], x, y);
         return caml_call2(X[14], rval, X[18])
                 ? caml_call2(X[5], rval, y)
                 : rval;
        }
        var one = caml_call1(X[19], 1);
        function symbol$0(x, y){
         if(caml_call2(X[11], y, X[18])){
          var _r_ = caml_call1(X[4], y);
          caml_call4(invalid_argf, _m_, caml_call1(X[4], x), _r_, 0);
         }
         if(! caml_call2(X[14], x, X[18])) return caml_call2(X[8], x, y);
         var _s_ = caml_call2(X[5], x, one), _t_ = caml_call2(X[8], _s_, y);
         return caml_call2(X[6], _t_, one);
        }
        function symbol$1(x, y){
         var _p_ = caml_call1(X[2], y), _q_ = caml_call1(X[2], x);
         return caml_call2(Base_Import[95], _q_, _p_);
        }
        function round_down(i, modulus){
         var _o_ = symbol(i, modulus);
         return caml_call2(X[6], i, _o_);
        }
        function round_up(i, modulus){
         var remainder = symbol(i, modulus);
         if(caml_call2(X[12], remainder, X[18])) return i;
         var _n_ = caml_call2(X[5], i, modulus);
         return caml_call2(X[6], _n_, remainder);
        }
        function round_towards_zero(i, to_multiple_of){
         return caml_call2(X[12], i, X[18])
                 ? X[18]
                 : caml_call2
                    (X[13], i, X[18])
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        function round_nearest(i, modulus){
         var
          remainder = symbol(i, modulus),
          modulus_minus_remainder = caml_call2(X[6], modulus, remainder);
         return caml_call2(X[11], modulus_minus_remainder, remainder)
                 ? caml_call2(X[5], i, modulus_minus_remainder)
                 : caml_call2(X[6], i, remainder);
        }
        function round(opt, i, to_multiple_of){
         if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
         return 857423934 <= dir
                 ? 1003109192
                   <= dir
                   ? round_towards_zero(i, to_multiple_of)
                   : round_nearest(i, to_multiple_of)
                 : 759637122
                   <= dir
                   ? round_down(i, to_multiple_of)
                   : round_up(i, to_multiple_of);
        }
        return [0,
                symbol,
                symbol$0,
                symbol$1,
                round,
                round_towards_zero,
                round_down,
                round_up,
                round_nearest];
       },
       Private];
   runtime.caml_register_global(17, Base_Int_math, "Base__Int_math");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Popcount
//# unitInfo: Requires: Assert_failure, Stdlib__Nativeint
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    global_data = runtime.caml_get_global_data(),
    m1 = runtime.caml_int64_create_lo_mi_hi(5592405, 5592405, 21845),
    m2 = runtime.caml_int64_create_lo_mi_hi(3355443, 3355443, 13107),
    m4 = runtime.caml_int64_create_lo_mi_hi(986895, 986895, 3855),
    h01 = runtime.caml_int64_create_lo_mi_hi(65793, 65793, 257),
    mask = runtime.caml_int64_create_lo_mi_hi(16777215, 255, 0),
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Assert_failure = global_data.Assert_failure,
    _b_ = [0, "src/popcount.ml", 45, 9];
   function int64_popcount(x){
    var
     x$0 =
       runtime.caml_int64_sub
        (x, caml_int64_and(caml_int64_shift_right_unsigne(x, 1), m1)),
     x$1 =
       caml_int64_add
        (caml_int64_and(x$0, m2),
         caml_int64_and(caml_int64_shift_right_unsigne(x$0, 2), m2)),
     x$2 =
       caml_int64_and
        (caml_int64_add(x$1, caml_int64_shift_right_unsigne(x$1, 4)), m4);
    return runtime.caml_int64_to_int32
            (caml_int64_shift_right_unsigne
              (runtime.caml_int64_mul(x$2, h01), 56));
   }
   function int32_popcount(x){
    return int64_popcount(caml_int64_and(caml_int64_of_int32(x), mask));
   }
   var _a_ = Stdlib_Nativeint[9];
   if(32 === _a_)
    var nativeint_popcount = function(x){return int32_popcount(x);};
   else{
    if(64 !== _a_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var
     nativeint_popcount =
       function(x){return int64_popcount(caml_int64_of_int32(x));};
   }
   var
    Base_Popcount =
      [0,
       function(_c_){return runtime.Base_int_math_int_popcount(_c_);},
       int32_popcount,
       int64_popcount,
       nativeint_popcount];
   runtime.caml_register_global(8, Base_Popcount, "Base__Popcount");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign
//# unitInfo: Requires: Base__Identifiable, Base__Import, Base__Sign0
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Sign0 = global_data.Base__Sign0,
    Base_Identifiable = global_data.Base__Identifiable,
    t_sexp_grammar = Base_Sign0[3],
    all = Base_Sign0[6],
    Replace_polymorphic_compare = Base_Sign0[7],
    to_int = Base_Sign0[10],
    of_int = Base_Sign0[13],
    _a_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         Base_Sign0[4],
         Base_Sign0[5],
         Base_Sign0[11],
         Base_Sign0[1],
         Base_Sign0[2],
         Base_Sign0[8],
         Base_Sign0[9],
         Base_Sign0[12]]),
    hash_fold_t = _a_[1],
    hash = _a_[2],
    t_of_sexp = _a_[3],
    sexp_of_t = _a_[4],
    of_string = _a_[5],
    to_string = _a_[6],
    between = _a_[19],
    clamp_exn = _a_[20],
    clamp = _a_[21],
    comparator = _a_[22],
    pp = _a_[23],
    hashable = _a_[24];
   function to_float(param){
    switch(param){case 0: return -1.;case 1: return 0.;default: return 1.;
    }
   }
   function flip(param){
    switch(param){case 0: return 2;case 1: return 1;default: return 0;
    }
   }
   function symbol(t$0, t){
    var _b_ = caml_call1(to_int, t), _c_ = caml_call1(to_int, t$0);
    return caml_call1(of_int, caml_call2(Base_Import[87], _c_, _b_));
   }
   var
    symbol$0 = Replace_polymorphic_compare[1],
    symbol$1 = Replace_polymorphic_compare[2],
    symbol$2 = Replace_polymorphic_compare[3],
    symbol$3 = Replace_polymorphic_compare[4],
    symbol$4 = Replace_polymorphic_compare[5],
    symbol$5 = Replace_polymorphic_compare[6],
    ascending = Replace_polymorphic_compare[7],
    descending = Replace_polymorphic_compare[8],
    compare = Replace_polymorphic_compare[9],
    equal = Replace_polymorphic_compare[10],
    max = Replace_polymorphic_compare[11],
    min = Replace_polymorphic_compare[12],
    Base_Sign =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       of_string,
       to_string,
       symbol$5,
       symbol$1,
       symbol$3,
       symbol$4,
       symbol$0,
       symbol$2,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       of_int,
       to_int,
       to_float,
       flip,
       symbol];
   runtime.caml_register_global(6, Base_Sign, "Base__Sign");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int0, Base__Int_conversions, Base__Int_intf, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Sign, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_x = "%x",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_div = runtime.caml_div,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int.Hex",
    module_name$0 = "Base.Int",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Float0 = global_data.Base__Float0,
    Base_Int0 = global_data.Base__Int0,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Int_math = global_data.Base__Int_math,
    Base_Error = global_data.Base__Error,
    Base_Sign = global_data.Base__Sign,
    Base_Popcount = global_data.Base__Popcount,
    to_string = Base_Int0[1],
    of_string = Base_Int0[2],
    hash_fold_t = Base_Import[206],
    func = Base_Import[220],
    _u_ =
      [0,
       [2,
        0,
        [11,
         " /",
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: divisor should be positive", 0]]]]]],
       "%s /%% %s in core_int.ml: divisor should be positive"],
    _t_ =
      [0,
       [2,
        0,
        [12,
         32,
         [12,
          37,
          [12,
           32,
           [2, 0, [11, " in core_int.ml: modulus should be positive", 0]]]]]],
       "%s %% %s in core_int.ml: modulus should be positive"],
    cst_Int_ceil_log2_got_invalid_ = "[Int.ceil_log2] got invalid input",
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    _g_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _f_ = [0, "src/int.ml", 108, 2],
    _e_ = [0, [4, 6, 0, 0, 0], cst_x],
    _d_ = [0, [4, 6, 0, 0, 0], cst_x],
    _b_ =
      [0,
       [11,
        "Int.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int.of_float: argument (%f) is out of range or NaN"],
    _a_ = [0, [11, "Int.of_string: ", [3, 0, 0]], "Int.of_string: %S"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[165],
    sexp_of_t = Base_Import[141],
    t_sexp_grammar = Base_Import[185],
    hashable = [0, hash, caml_int_compare, sexp_of_t],
    compare = caml_int_compare;
   function of_string$0(s){
    try{var _aF_ = caml_call1(of_string, s); return _aF_;}
    catch(_aG_){return caml_call3(Base_Printf[6], _a_, s, 0);}
   }
   var
    num_bits = Base_Int_conversions[29],
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits);
   function to_float(_aE_){return _aE_;}
   function of_float_unchecked(_aD_){return _aD_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[107][6], f, float_lower_bound)
      && caml_call2(Base_Import[107][2], f, float_upper_bound))
     return f | 0;
    var _aC_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _b_, _aC_, 0);
   }
   var
    comparator = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t])[1],
    _c_ = caml_call1(Base_Comparable[13], [0, compare, sexp_of_t, 0]),
    is_positive = _c_[1],
    is_non_negative = _c_[2],
    is_negative = _c_[3],
    is_non_positive = _c_[4],
    include = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include[1],
    sexp_of_t$0 = include[2],
    compare$0 = Base_Import[228],
    hash_fold_t$0 = Base_Import[206],
    func$0 = Base_Import[220],
    zero = 0,
    one = 1,
    minus_one = -1;
   function hash$0(x){return caml_call1(func$0, x);}
   var neg = Base_Import[112];
   function symbol(_aB_, _aA_){return _aB_ < _aA_ ? 1 : 0;}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$1(s){
    function _ay_(_az_){return _az_;}
    return caml_call3(Stdlib_Scanf[4], s, _e_, _ay_);
   }
   var
    include$0 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$1,
         zero,
         symbol,
         neg,
         module_name]),
    Hex = include$0[1],
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$1[1];
   function invariant(param){return 0;}
   function between(t, low, high){
    var _aw_ = low <= t ? 1 : 0, _ax_ = _aw_ ? t <= high ? 1 : 0 : _aw_;
    return _ax_;
   }
   function clamp_unchecked(t, min, max){
    return t < min ? min : t <= max ? t : max;
   }
   function clamp_exn(t, min, max){
    if(min <= max) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(max >= min) return [0, clamp_unchecked(t, min, max)];
    var
     _at_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _au_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _at_],
     _av_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _au_);
    return caml_call1(Base_Or_error[35], _av_);
   }
   function pred(i){return caml_call2(Base_Import[92], i, 1);}
   function succ(i){return caml_call2(Base_Import[90], i, 1);}
   function to_int(i){return i;}
   function of_int_exn(i){return i;}
   var
    max_value = Base_Import[84][18],
    min_value = Base_Import[84][19],
    of_int32 = Base_Int_conversions[6],
    of_int32_exn = Base_Int_conversions[7],
    to_int32 = Base_Int_conversions[1],
    to_int32_exn = Base_Int_conversions[2],
    of_int64 = Base_Int_conversions[11],
    of_int64_exn = Base_Int_conversions[12],
    to_int64 = Base_Int_conversions[4],
    of_nativeint = Base_Int_conversions[22],
    of_nativeint_exn = Base_Int_conversions[23],
    to_nativeint = Base_Int_conversions[5],
    max_value_30_bits = 1073741823;
   function abs(x){return caml_call1(Base_Import[122], x);}
   function rem(a, b){return caml_call2(Base_Import[121], a, b);}
   function incr(_as_){_as_[1]++; return 0;}
   function decr(_ar_){_ar_[1] += -1; return 0;}
   function shift_right(a, b){return caml_call2(Base_Import[114], a, b);}
   function shift_right_logical(a, b){
    return caml_call2(Base_Import[119], a, b);
   }
   function shift_left(a, b){return caml_call2(Base_Import[118], a, b);}
   function bit_not(a){return caml_call1(Base_Import[116], a);}
   function bit_or(a, b){return caml_call2(Base_Import[117], a, b);}
   function bit_and(a, b){return caml_call2(Base_Import[115], a, b);}
   function bit_xor(a, b){return caml_call2(Base_Import[120], a, b);}
   var pow = Base_Int_math[2][1];
   function symbol$0(b, e){return caml_call2(pow, b, e);}
   var raise_s = Base_Error[30];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _g_, 0);
   }
   function ceil_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     x$0 = caml_call2(Base_Import[92], x, 1),
     _al_ = caml_call2(Base_Import[119], x$0, 1),
     x$1 = caml_call2(Base_Import[117], x$0, _al_),
     _am_ = caml_call2(Base_Import[119], x$1, 2),
     x$2 = caml_call2(Base_Import[117], x$1, _am_),
     _an_ = caml_call2(Base_Import[119], x$2, 4),
     x$3 = caml_call2(Base_Import[117], x$2, _an_),
     _ao_ = caml_call2(Base_Import[119], x$3, 8),
     x$4 = caml_call2(Base_Import[117], x$3, _ao_),
     _ap_ = caml_call2(Base_Import[119], x$4, 16),
     x$5 = caml_call2(Base_Import[117], x$4, _ap_),
     _aq_ = caml_call2(Base_Import[119], x$5, 32),
     x$6 = caml_call2(Base_Import[117], x$5, _aq_);
    return caml_call2(Base_Import[90], x$6, 1);
   }
   function floor_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var
     _ae_ = caml_call2(Base_Import[119], x, 1),
     x$0 = caml_call2(Base_Import[117], x, _ae_),
     _af_ = caml_call2(Base_Import[119], x$0, 2),
     x$1 = caml_call2(Base_Import[117], x$0, _af_),
     _ag_ = caml_call2(Base_Import[119], x$1, 4),
     x$2 = caml_call2(Base_Import[117], x$1, _ag_),
     _ah_ = caml_call2(Base_Import[119], x$2, 8),
     x$3 = caml_call2(Base_Import[117], x$2, _ah_),
     _ai_ = caml_call2(Base_Import[119], x$3, 16),
     x$4 = caml_call2(Base_Import[117], x$3, _ai_),
     _aj_ = caml_call2(Base_Import[119], x$4, 32),
     x$5 = caml_call2(Base_Import[117], x$4, _aj_),
     _ak_ = caml_call2(Base_Import[119], x$5, 1);
    return caml_call2(Base_Import[92], x$5, _ak_);
   }
   function is_pow2(x){
    if(x <= 0) non_positive_argument(0);
    var _ad_ = caml_call2(Base_Import[92], x, 1);
    return 0 === caml_call2(Base_Import[115], x, _ad_) ? 1 : 0;
   }
   function floor_log2(i){
    if(i <= 0){
     var _aa_ = [0, [0, cst, caml_call1(Base_Import[141], i)], 0];
     caml_call1
      (raise_s,
       caml_call2(Base_Sexp[9], cst_Int_floor_log2_got_invalid, _aa_));
    }
    var
     _ab_ = runtime.Base_int_math_int_clz(i),
     _ac_ = caml_call2(Base_Import[92], num_bits, 1);
    return caml_call2(Base_Import[92], _ac_, _ab_);
   }
   function ceil_log2(i){
    if(i <= 0){
     var ___ = [0, [0, cst$0, caml_call1(Base_Import[141], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_ceil_log2_got_invalid_, ___));
    }
    if(1 === i) return 0;
    var
     _$_ = runtime.Base_int_math_int_clz(caml_call2(Base_Import[92], i, 1));
    return caml_call2(Base_Import[92], num_bits, _$_);
   }
   var sign = Base_Sign[27], popcount = Base_Popcount[1];
   function _h_(_Z_){return - _Z_ | 0;}
   function _i_(_Y_, _X_){return _Y_ !== _X_ ? 1 : 0;}
   function _j_(_W_, _V_){return _W_ < _V_ ? 1 : 0;}
   function _k_(_U_, _T_){return _T_ < _U_ ? 1 : 0;}
   function _l_(_S_, _R_){return _S_ === _R_ ? 1 : 0;}
   function _m_(_Q_, _P_){return _Q_ <= _P_ ? 1 : 0;}
   function _n_(_O_, _N_){return _N_ <= _O_ ? 1 : 0;}
   function _o_(_M_){return - _M_ | 0;}
   var _p_ = caml_div, _q_ = runtime.caml_mul;
   function _r_(_L_, _K_){return _L_ - _K_ | 0;}
   var
    _s_ =
      [0,
       of_float,
       to_float,
       of_string$0,
       to_string,
       function(_J_, _I_){return _J_ + _I_ | 0;},
       _r_,
       _q_,
       _p_,
       _o_,
       _n_,
       _m_,
       _l_,
       _k_,
       _j_,
       _i_,
       abs,
       _h_,
       zero,
       of_int_exn,
       rem],
    F = caml_call1(Base_Int_math[1], _s_),
    round = F[4],
    round_towards_zero = F[5],
    round_down = F[6],
    round_up = F[7],
    round_nearest = F[8];
   function symbol$1(x, y){
    if(y <= 0){
     var _G_ = caml_call1(to_string, y), _H_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _t_, _H_, _G_, 0);
    }
    var rval = rem(x, y);
    return rval < 0 ? rval + y | 0 : rval;
   }
   function symbol$2(x, y){
    if(y <= 0){
     var _E_ = caml_call1(to_string, y), _F_ = caml_call1(to_string, x);
     caml_call4(Base_Printf[7], _u_, _F_, _E_, 0);
    }
    return x < 0 ? caml_div(x + 1 | 0, y) - 1 | 0 : caml_div(x, y);
   }
   function symbol$3(x, y){return caml_call2(Base_Import[95], x, y);}
   var
    lnot = Base_Import[116],
    include$2 = Base_Import[96],
    ascending = include$2[1],
    descending = include$2[2],
    max = include$2[3],
    min = include$2[4],
    _v_ = [0, [0, F[1], F[2], F[3]]],
    _w_ = [0, symbol$0, lnot, abs, zero, symbol$1, symbol$2, symbol$3];
   function _x_(_D_){return runtime.Base_int_math_int_ctz(_D_);}
   function _y_(_C_){return runtime.Base_int_math_int_clz(_C_);}
   var
    _z_ = caml_int_compare,
    Base_Int =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string$0,
       to_string,
       function(_B_, _A_){return _B_ === _A_ ? 1 : 0;},
       _z_,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       _y_,
       _x_,
       _w_,
       symbol$0,
       lnot,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       max_value_30_bits,
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_int64,
       of_nativeint,
       to_nativeint,
       _v_];
   runtime.caml_register_global(33, Base_Int, "Base__Int");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Uchar
//# unitInfo: Requires: Base__Comparable, Base__Hash, Base__Import, Base__Pretty_printer, Base__Printf, Base__String, Base__Uchar0, Sexplib0__Sexp_grammar, Stdlib, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_U = "U+",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    module_name = "Base.Uchar",
    Base_Uchar0 = global_data.Base__Uchar0,
    Stdlib = global_data.Stdlib,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Hash = global_data.Base__Hash,
    Base_String = global_data.Base__String,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Comparable = global_data.Base__Comparable,
    failwithf = Base_Printf[6],
    is_valid = Base_Uchar0[3],
    is_char = Base_Uchar0[4],
    unsafe_to_char = Base_Uchar0[5],
    unsafe_of_int = Base_Uchar0[6],
    to_int = Base_Uchar0[8],
    of_char = Base_Uchar0[9],
    compare = Base_Uchar0[10],
    min_value = Base_Uchar0[12],
    max_value = Base_Uchar0[13],
    _g_ =
      [0,
       [11,
        "Uchar.to_char_exn got a non latin-1 character: U+",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.to_char_exn got a non latin-1 character: U+%04X"],
    _f_ =
      [0,
       [11,
        "Uchar.of_int_exn got a invalid Unicode scalar value: ",
        [4, 8, [0, 2, 4], 0, 0]],
       "Uchar.of_int_exn got a invalid Unicode scalar value: %04X"],
    _e_ = [0, [11, "Uchar.pred_exn: ", [2, 0, 0]], "Uchar.pred_exn: %s"],
    _d_ = [0, [11, "Uchar.succ_exn: ", [2, 0, 0]], "Uchar.succ_exn: %s"],
    _b_ = [0, [11, cst_U, [4, 8, 0, 0, 0]], "U+%X"],
    cst_Uchar_t_of_sexp_atom_of_th =
      "Uchar.t_of_sexp: atom of the form U+XXXX needed",
    cst_Uchar_t_of_sexp_atom_neede = "Uchar.t_of_sexp: atom needed",
    _a_ = [0, [11, cst_U, [4, 8, [0, 2, 4], 0, 0]], "U+%04X"];
   function hash_fold_t(state, t){
    var _t_ = caml_call1(to_int, t);
    return caml_call2(Base_Hash[3], state, _t_);
   }
   function hash(t){return caml_call3(Base_Hash[14], 0, hash_fold_t, t);}
   function to_string(t){
    var _s_ = caml_call1(to_int, t);
    return caml_call2(Base_Printf[2], _a_, _s_);
   }
   function sexp_of_t(t){return [0, to_string(t)];}
   function t_of_sexp(sexp){
    if(0 !== sexp[0])
     return caml_call2(Base_Import[158], cst_Uchar_t_of_sexp_atom_neede, sexp);
    var s = sexp[1];
    try{
     var
      _p_ = function(i){return caml_call1(Base_Uchar0[7], i);},
      _q_ = caml_call3(Stdlib_Scanf[4], s, _b_, _p_);
     return _q_;
    }
    catch(_r_){
     return caml_call2(Base_Import[158], cst_Uchar_t_of_sexp_atom_of_th, sexp);
    }
   }
   var
    t_sexp_grammar = caml_call1(Sexplib0_Sexp_grammar[1], Base_String[1]),
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name, to_string])[1],
    _c_ = caml_call1(Base_Comparable[10], [0, compare, sexp_of_t]),
    between = _c_[13],
    clamp_exn = _c_[14],
    clamp = _c_[15],
    comparator = _c_[16];
   function invariant(param){return 0;}
   function succ_exn(c){
    try{var _o_ = caml_call1(Base_Uchar0[1], c); return _o_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _d_, msg, 0);
    }
   }
   function succ(c){
    try{var _m_ = [0, caml_call1(Base_Uchar0[1], c)]; return _m_;}
    catch(_n_){
     var _l_ = caml_wrap_exception(_n_);
     if(_l_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_l_, 0);
    }
   }
   function pred_exn(c){
    try{var _k_ = caml_call1(Base_Uchar0[2], c); return _k_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(exn, 0);
     var msg = exn[2];
     return caml_call3(failwithf, _e_, msg, 0);
    }
   }
   function pred(c){
    try{var _i_ = [0, caml_call1(Base_Uchar0[2], c)]; return _i_;}
    catch(_j_){
     var _h_ = caml_wrap_exception(_j_);
     if(_h_[1] === Stdlib[6]) return 0;
     throw caml_maybe_attach_backtrace(_h_, 0);
    }
   }
   function of_scalar(i){
    return caml_call1(is_valid, i) ? [0, caml_call1(unsafe_of_int, i)] : 0;
   }
   function of_scalar_exn(i){
    return caml_call1(is_valid, i)
            ? caml_call1(unsafe_of_int, i)
            : caml_call3(failwithf, _f_, i, 0);
   }
   function to_scalar(t){return caml_call1(Base_Uchar0[8], t);}
   function to_char(c){
    return caml_call1(is_char, c) ? [0, caml_call1(unsafe_to_char, c)] : 0;
   }
   function to_char_exn(c){
    return caml_call1(is_char, c)
            ? caml_call1(unsafe_to_char, c)
            : caml_call3(failwithf, _g_, caml_call1(to_int, c), 0);
   }
   function utf8_byte_length(uchar){
    var codepoint = to_scalar(uchar);
    return 128 <= codepoint
            ? 2048 <= codepoint ? 65536 <= codepoint ? 4 : 3 : 2
            : 1;
   }
   var
    include = Base_Import[106],
    symbol = include[2],
    symbol$0 = include[3],
    symbol$1 = include[4],
    symbol$2 = include[5],
    symbol$3 = include[6],
    symbol$4 = include[7],
    ascending = include[8],
    descending = include[9],
    compare$0 = include[10],
    equal = include[11],
    max = include[12],
    min = include[13],
    Base_Uchar =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       invariant,
       succ,
       succ_exn,
       pred,
       pred_exn,
       is_char,
       to_char,
       to_char_exn,
       of_char,
       is_valid,
       of_scalar,
       of_scalar_exn,
       to_scalar,
       utf8_byte_length,
       min_value,
       max_value];
   runtime.caml_register_global(19, Base_Uchar, "Base__Uchar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Type_equal
//# unitInfo: Requires: Base__Error, Base__Import, Base__Int, Base__Option, Base__Sexp, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    some_t = [0, 0],
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Int = global_data.Base__Int,
    cst_Type_equal_Id_same_witness =
      "Type_equal.Id.same_witness_exn got different ids",
    _d_ = [0, "witness"],
    _e_ = [0, "name"],
    cst_Key = "Key",
    _c_ = [0, "type_witness"],
    _b_ = [0, 0, 0],
    _a_ = [0, "T"];
   function sexp_of_t(of_a_001, of_b_002, param){return _a_;}
   var refl = 0;
   function sym(param){return 0;}
   function trans(param, _$_){return 0;}
   function conv(param, a){return a;}
   function Lift(X){function lift(param){return 0;} return [0, lift];}
   function Lift2(X){function lift(param, ___){return 0;} return [0, lift];}
   function Lift3(X){
    function lift(param, _Z_, _Y_){return 0;}
    return [0, lift];
   }
   function detuple2(param){return _b_;}
   function tuple2(param, _X_){return 0;}
   function Composition_preserves_injectiv(M1, M2){
    function strip(e){
     var _W_ = caml_call1(M2[1], e);
     return caml_call1(M1[1], _W_);
    }
    return [0, strip];
   }
   function sexp_of_t$0(param, _V_){
    var name = _V_[2], witness = _V_[1];
    if(Base_Import[131]) return [0, name];
    var
     t = witness[1],
     _U_ = caml_call1(Stdlib_Obj[22][1], t),
     v_005 = caml_call1(Stdlib_Obj[22][3], _U_);
    return [1,
            [0,
             [1, [0, _e_, [0, [0, name], 0]]],
             [0,
              [1,
               [0,
                _d_,
                [0,
                 [1, [0, _c_, [0, caml_call1(Base_Import[141], v_005), 0]]],
                 0]]],
              0]]];
   }
   function to_sexp(t){return t[3];}
   function name(t){return t[2];}
   function create(name, to_sexp){
    var Key = [248, cst_Key, runtime.caml_fresh_oo_id(0)];
    return [0, [0, Key], name, to_sexp];
   }
   function uid(t){
    var M = t[1], _T_ = caml_call1(Stdlib_Obj[22][1], M[1]);
    return caml_call1(Stdlib_Obj[22][3], _T_);
   }
   function hash(t){return uid(t);}
   function hash_fold_t(s, t){
    var _S_ = uid(t);
    return caml_call2(Base_Import[206], s, _S_);
   }
   function same_witness(t1, t2){
    var b = t2[1], a = t1[1];
    return a[1] === b[1] ? some_t : 0;
   }
   function same(t1, t2){
    var _R_ = same_witness(t1, t2);
    return caml_call1(Base_Option[50], _R_);
   }
   function same_witness_exn(t1, t2){
    var match = same_witness(t1, t2);
    if(match){var w = match[1]; return w;}
    var _H_ = 0, _I_ = [0, t1, t2], _J_ = Base_Import[154];
    function _K_(_Q_){return sexp_of_t$0(_J_, _Q_);}
    var _L_ = Base_Import[154];
    function _M_(_P_){return sexp_of_t$0(_L_, _P_);}
    var
     _N_ = [0, [0, cst, caml_call3(Base_Import[149], _M_, _K_, _I_)], _H_],
     _O_ = caml_call2(Base_Sexp[9], cst_Type_equal_Id_same_witness, _N_);
    return caml_call1(Base_Error[30], _O_);
   }
   var
    _f_ = Base_Int[21],
    _g_ = Base_Int[20],
    _h_ = Base_Int[19],
    _i_ = Base_Int[18],
    _j_ = Base_Int[17],
    _k_ = Base_Int[16],
    _l_ = Base_Int[15],
    _m_ = Base_Int[14],
    _n_ = Base_Int[13],
    _o_ = Base_Int[12];
   function _p_(_G_, _F_){return _G_ !== _F_ ? 1 : 0;}
   function _q_(_E_, _D_){return _E_ < _D_ ? 1 : 0;}
   function _r_(_C_, _B_){return _B_ < _C_ ? 1 : 0;}
   function _s_(_A_, _z_){return _A_ === _z_ ? 1 : 0;}
   function _t_(_y_, _x_){return _y_ <= _x_ ? 1 : 0;}
   function _u_(_w_, _v_){return _v_ <= _w_ ? 1 : 0;}
   var
    Base_Type_equal =
      [0,
       sexp_of_t,
       refl,
       sym,
       trans,
       conv,
       Lift,
       Lift2,
       Lift3,
       detuple2,
       tuple2,
       Composition_preserves_injectiv,
       [0,
        sexp_of_t$0,
        [0,
         Base_Int[6],
         Base_Int[7],
         Base_Int[8],
         Base_Int[9],
         _u_,
         _t_,
         _s_,
         _r_,
         _q_,
         _p_,
         _o_,
         _n_,
         _m_,
         _l_,
         _k_,
         _j_,
         _i_,
         _h_,
         _g_,
         _f_],
        uid,
        create,
        hash,
        name,
        to_sexp,
        hash_fold_t,
        same,
        same_witness,
        same_witness_exn]];
   runtime.caml_register_global(15, Base_Type_equal, "Base__Type_equal");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__T
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_T = [0];
   runtime.caml_register_global(0, Base_T, "Base__T");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Stack_intf = [0];
   runtime.caml_register_global(0, Base_Stack_intf, "Base__Stack_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Option_array
//# unitInfo: Requires: Base__Array, Base__Blit, Base__Import, Base__Indexed_container, Base__Option, Base__Sexpable, Base__Uniform_array, Sexplib0__Sexp_grammar, Stdlib__Obj
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Array = global_data.Base__Array,
    Base_Import = global_data.Base__Import,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Option = global_data.Base__Option,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_Obj = global_data.Stdlib__Obj,
    Base_Sexpable = global_data.Base__Sexpable,
    Base_Indexed_container = global_data.Base__Indexed_container,
    Base_Blit = global_data.Base__Blit,
    none_substitute = runtime.caml_obj_block(Stdlib_Obj[12], 1),
    cst_Option_array_get_some_exn_ =
      "Option_array.get_some_exn: the element is [None]",
    none = 24791911;
   function is_none(x){return caml_call2(Base_Import[127], x, none);}
   function is_some(x){return 1 - caml_call2(Base_Import[127], x, none);}
   function some(x){
    return caml_call2(Base_Import[127], x, none) ? none_substitute : x;
   }
   function value_unsafe(x){
    return caml_call2(Base_Import[127], x, none_substitute) ? none : x;
   }
   function value_exn(x){
    return is_some(x)
            ? value_unsafe(x)
            : caml_call1(Base_Import[123], cst_Option_array_get_some_exn_);
   }
   function of_sexpable(param){
    if(! param) return none;
    var x = param[1];
    return some(x);
   }
   function to_sexpable(x){return is_some(x) ? [0, value_unsafe(x)] : 0;}
   var
    include =
      caml_call1
       (caml_call1(Base_Sexpable[2], [0, Base_Option[6], Base_Option[7]]),
        [0, to_sexpable, of_sexpable]),
    t_of_sexp = include[1],
    sexp_of_t = include[2];
   function t_of_sexp$0(of_a_001, x_003){
    var _A_ = caml_call1(t_of_sexp, of_a_001);
    return caml_call2(Base_Uniform_array[1], _A_, x_003);
   }
   function sexp_of_t$0(of_a_004, x_005){
    var _z_ = caml_call1(sexp_of_t, of_a_004);
    return caml_call2(Base_Uniform_array[2], _z_, x_005);
   }
   function t_sexp_grammar(a_sexp_grammar){
    var
     _x_ = caml_call1(Base_Option[3], a_sexp_grammar),
     _y_ = caml_call1(Sexplib0_Sexp_grammar[1], _x_);
    return caml_call1(Base_Uniform_array[3], _y_);
   }
   var empty = Base_Uniform_array[6];
   function create(len){return caml_call2(Base_Uniform_array[7], len, none);}
   function init(n, f){
    function _w_(i){return of_sexpable(caml_call1(f, i));}
    return caml_call2(Base_Uniform_array[9], n, _w_);
   }
   function init_some(n, f){
    function _v_(i){return some(caml_call1(f, i));}
    return caml_call2(Base_Uniform_array[9], n, _v_);
   }
   var _a_ = Base_Uniform_array[10];
   function get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[11], t, i));
   }
   function get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[11], t, i));
   }
   function is_none$0(t, i){
    return is_none(caml_call2(Base_Uniform_array[11], t, i));
   }
   function is_some$0(t, i){
    return is_some(caml_call2(Base_Uniform_array[11], t, i));
   }
   function set(t, i, x){
    var _u_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[13], t, i, _u_);
   }
   function set_some(t, i, x){
    var _t_ = some(x);
    return caml_call3(Base_Uniform_array[13], t, i, _t_);
   }
   function set_none(t, i){
    return caml_call3(Base_Uniform_array[13], t, i, none);
   }
   function swap(t, i, j){return caml_call3(Base_Uniform_array[15], t, i, j);}
   function unsafe_get(t, i){
    return to_sexpable(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_get_some_exn(t, i){
    return value_exn(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_get_some_assuming_some(t, i){
    return value_unsafe(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_is_some(t, i){
    return is_some(caml_call2(Base_Uniform_array[12], t, i));
   }
   function unsafe_set(t, i, x){
    var _s_ = of_sexpable(x);
    return caml_call3(Base_Uniform_array[14], t, i, _s_);
   }
   function unsafe_set_some(t, i, x){
    var _r_ = some(x);
    return caml_call3(Base_Uniform_array[14], t, i, _r_);
   }
   function unsafe_set_none(t, i){
    return caml_call3(Base_Uniform_array[14], t, i, none);
   }
   function clear(t){
    var
     _o_ = caml_call1(_a_, t),
     _p_ = caml_call2(Base_Import[92], _o_, 1),
     _n_ = 0;
    if(_p_ >= 0){
     var i = _n_;
     for(;;){
      unsafe_set_none(t, i);
      var _q_ = i + 1 | 0;
      if(_p_ !== i){var i = _q_; continue;}
      break;
     }
    }
    return 0;
   }
   function _b_(input, f){
    var
     _k_ = caml_call1(_a_, input),
     _l_ = caml_call2(Base_Import[92], _k_, 1),
     _j_ = 0;
    if(_l_ >= 0){
     var i = _j_;
     for(;;){
      caml_call2(f, i, unsafe_get(input, i));
      var _m_ = i + 1 | 0;
      if(_l_ !== i){var i = _m_; continue;}
      break;
     }
    }
    return 0;
   }
   function _c_(input, f){
    return _b_(input, function(param, x){return caml_call1(f, x);});
   }
   function _d_(input, init, f){
    var acc = [0, init];
    _b_
     (input,
      function(i, elem){acc[1] = caml_call3(f, i, acc[1], elem); return 0;});
    return acc[1];
   }
   function fold(input, init, f){
    return _d_
            (input,
             init,
             function(param, acc, x){return caml_call2(f, acc, x);});
   }
   var
    foldi = [0, -198771759, _d_],
    iter = [0, -198771759, _c_],
    iteri = [0, -198771759, _b_],
    length = [0, -198771759, _a_],
    include$0 =
      caml_call1
       (Base_Indexed_container[10], [0, fold, iter, length, iteri, foldi]),
    length$0 = include$0[1],
    is_empty = include$0[2],
    iter$0 = include$0[3],
    fold$0 = include$0[4],
    fold_result = include$0[5],
    fold_until = include$0[6],
    exists = include$0[7],
    for_all = include$0[8],
    count = include$0[9],
    sum = include$0[10],
    find = include$0[11],
    find_map = include$0[12],
    to_list = include$0[13],
    min_elt = include$0[15],
    max_elt = include$0[16],
    foldi$0 = include$0[17],
    iteri$0 = include$0[18],
    existsi = include$0[19],
    for_alli = include$0[20],
    counti = include$0[21],
    findi = include$0[22],
    find_mapi = include$0[23];
   function map(input, f){
    var output = create(caml_call1(length$0, input));
    caml_call2
     (iteri$0,
      input,
      function(i, elem){return unsafe_set(output, i, caml_call1(f, elem));});
    return output;
   }
   function map_some(input, f){
    var
     len = caml_call1(length$0, input),
     output = create(len),
     _h_ = caml_call2(Base_Import[92], len, 1),
     _g_ = 0;
    if(_h_ >= 0){
     var i = _g_;
     for(;;){
      var opt = caml_call2(Base_Uniform_array[12], input, i);
      if(is_some(opt)){
       var x = value_unsafe(opt);
       unsafe_set_some(output, i, caml_call1(f, x));
      }
      var _i_ = i + 1 | 0;
      if(_h_ !== i){var i = _i_; continue;}
      break;
     }
    }
    return output;
   }
   function of_array(array){
    return init(array.length - 1, function(i){return array[1 + i];});
   }
   function of_array_some(array){
    return init_some(array.length - 1, function(i){return array[1 + i];});
   }
   function to_array(t){
    function _e_(i){return unsafe_get(t, i);}
    var _f_ = caml_call1(length$0, t);
    return caml_call2(Base_Array[27], _f_, _e_);
   }
   function create_like(len, param){return create(len);}
   var
    unsafe_blit = Base_Uniform_array[30],
    include$1 =
      caml_call1(Base_Blit[5], [0, create_like, length$0, unsafe_blit]),
    blit = include$1[1],
    blito = include$1[2],
    unsafe_blit$0 = include$1[3],
    sub = include$1[4],
    subo = include$1[5],
    copy = Base_Uniform_array[33],
    Base_Option_array =
      [0,
       t_of_sexp$0,
       sexp_of_t$0,
       t_sexp_grammar,
       empty,
       create,
       length$0,
       is_empty,
       iter$0,
       fold$0,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       min_elt,
       max_elt,
       foldi$0,
       iteri$0,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       init_some,
       init,
       of_array,
       of_array_some,
       to_array,
       get,
       get_some_exn,
       is_none$0,
       is_some$0,
       unsafe_get,
       unsafe_get_some_exn,
       unsafe_get_some_assuming_some,
       unsafe_is_some,
       set,
       set_some,
       set_none,
       swap,
       clear,
       map,
       map_some,
       unsafe_set,
       unsafe_set_some,
       unsafe_set_none,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       copy,
       [0,
        [0,
         t_of_sexp,
         sexp_of_t,
         none,
         some,
         is_none,
         is_some,
         value_exn,
         value_unsafe,
         to_sexpable,
         of_sexpable]]];
   runtime.caml_register_global(10, Base_Option_array, "Base__Option_array");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Stack
//# unitInfo: Requires: Assert_failure, Base__Container, Base__Error, Base__Exn, Base__Import, Base__List, Base__Option_array, Base__Sexp, Base__Stack_intf, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_stack_ml = "src/stack.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Error = global_data.Base__Error,
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Exn = global_data.Base__Exn,
    Base_Sexp = global_data.Base__Sexp,
    Base_Container = global_data.Base__Container,
    raise_s = Base_Error[30],
    _e_ = [0, cst_src_stack_ml, 107, 14],
    _d_ = [0, cst_src_stack_ml, 39, 4],
    _c_ = [0, cst_src_stack_ml, 46, 6],
    cst_stack = "stack",
    cst_exn = "exn",
    cst_Stack_invariant_failed = "Stack.invariant failed",
    _a_ = [0, "elts"],
    _b_ = [0, "length"],
    cst_Stack_pop_of_empty_stack = "Stack.pop of empty stack",
    cst_Stack_top_of_empty_stack = "Stack.top of empty stack";
   function capacity(t){return caml_call1(Base_Option_array[6], t[2]);}
   function invariant(invariant_a, t){
    var length = t[1], elts = t[2];
    try{
     if(0 <= length && length <= caml_call1(Base_Option_array[6], elts)){
      var _B_ = caml_call2(Base_Import[92], length, 1), _A_ = 0;
      if(_B_ >= 0){
       var i$0 = _A_;
       for(;;){
        caml_call1(invariant_a, caml_call2(Base_Option_array[34], elts, i$0));
        var _G_ = i$0 + 1 | 0;
        if(_B_ !== i$0){var i$0 = _G_; continue;}
        break;
       }
      }
      var
       _C_ = caml_call1(Base_Option_array[6], elts),
       _D_ = caml_call2(Base_Import[92], _C_, 1);
      if(_D_ >= length){
       var i = length;
       for(;;){
        if(caml_call2(Base_Option_array[36], elts, i))
         throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
        var _F_ = i + 1 | 0;
        if(_D_ !== i){var i = _F_; continue;}
        break;
       }
      }
      var _E_ = 0;
      return _E_;
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
    catch(exn$0){
     var
      exn = caml_wrap_exception(exn$0),
      of_a_001 = Base_Import[154],
      length_003 = t[1],
      elts_005 = t[2],
      arg_006 = caml_call2(Base_Option_array[2], of_a_001, elts_005),
      bnds_002 = [0, [1, [0, _a_, [0, arg_006, 0]]], 0],
      arg_004 = caml_call1(Base_Import[141], length_003),
      bnds_002$0 = [0, [1, [0, _b_, [0, arg_004, 0]]], bnds_002],
      _z_ =
        [0,
         [0, cst_exn, caml_call1(Base_Exn[1], exn)],
         [0, [0, cst_stack, [1, bnds_002$0]], 0]];
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[9], cst_Stack_invariant_failed, _z_));
    }
   }
   function create(param){return [0, 0, Base_Option_array[4]];}
   function length(t){return t[1];}
   function is_empty(t){return 0 === t[1] ? 1 : 0;}
   function fold(t, init, f){
    var r = [0, init], _w_ = caml_call2(Base_Import[92], t[1], 1);
    if(_w_ >= 0){
     var i = _w_;
     for(;;){
      var _x_ = caml_call2(Base_Option_array[34], t[2], i);
      r[1] = caml_call2(f, r[1], _x_);
      var _y_ = i - 1 | 0;
      if(0 !== i){var i = _y_; continue;}
      break;
     }
    }
    return r[1];
   }
   function iter(t, f){
    var _u_ = caml_call2(Base_Import[92], t[1], 1);
    if(_u_ >= 0){
     var i = _u_;
     for(;;){
      caml_call1(f, caml_call2(Base_Option_array[34], t[2], i));
      var _v_ = i - 1 | 0;
      if(0 !== i){var i = _v_; continue;}
      break;
     }
    }
    return 0;
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C = caml_call1(Base_Container[16], [0, fold, iter$0, length$0]),
    mem = C[1],
    exists = C[8],
    for_all = C[9],
    count = C[10],
    sum = C[11],
    find = C[12],
    find_map = C[13],
    to_list = C[14],
    to_array = C[15],
    min_elt = C[16],
    max_elt = C[17],
    fold_result = C[6],
    fold_until = C[7];
   function of_list(l){
    if(caml_call1(Base_List[8], l)) return create(0);
    var
     length = caml_call1(Base_List[7], l),
     _r_ = caml_call2(Base_Import[87], 2, length),
     elts = caml_call1(Base_Option_array[5], _r_),
     r = [0, l],
     _s_ = caml_call2(Base_Import[92], length, 1);
    if(_s_ >= 0){
     var i = _s_;
     for(;;){
      var match = r[1];
      if(! match)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var l$0 = match[2], a = match[1];
      caml_call3(Base_Option_array[42], elts, i, a);
      r[1] = l$0;
      var _t_ = i - 1 | 0;
      if(0 !== i){var i = _t_; continue;}
      break;
     }
    }
    return [0, length, elts];
   }
   function sexp_of_t(sexp_of_a, t){
    var _q_ = caml_call1(to_list, t);
    return caml_call2(Base_List[4], sexp_of_a, _q_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[3], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _p_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _p_);
   }
   function resize(t, size){
    var arr = caml_call1(Base_Option_array[5], size);
    caml_call5(Base_Option_array[51], t[2], 0, arr, 0, t[1]);
    t[2] = arr;
    return 0;
   }
   function set_capacity(t, new_capacity){
    var
     new_capacity$0 = caml_call2(Base_Import[99], new_capacity, t[1]),
     _o_ = new_capacity$0 !== capacity(t) ? 1 : 0;
    return _o_ ? resize(t, new_capacity$0) : _o_;
   }
   function push(t, a){
    var _m_ = caml_call1(Base_Option_array[6], t[2]);
    if(t[1] === _m_){
     var _n_ = caml_call2(Base_Import[90], t[1], 1);
     resize(t, caml_call2(Base_Import[87], 2, _n_));
    }
    caml_call3(Base_Option_array[42], t[2], t[1], a);
    t[1] = caml_call2(Base_Import[90], t[1], 1);
    return 0;
   }
   function pop_nonempty(t){
    var
     i = caml_call2(Base_Import[92], t[1], 1),
     result = caml_call2(Base_Option_array[34], t[2], i);
    caml_call2(Base_Option_array[43], t[2], i);
    t[1] = i;
    return result;
   }
   var pop_error = caml_call1(Base_Error[12], cst_Stack_pop_of_empty_stack);
   function pop(t){return is_empty(t) ? 0 : [0, pop_nonempty(t)];}
   function pop_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[29], pop_error)
            : pop_nonempty(t);
   }
   function top_nonempty(t){
    var _l_ = caml_call2(Base_Import[92], t[1], 1);
    return caml_call2(Base_Option_array[34], t[2], _l_);
   }
   var top_error = caml_call1(Base_Error[12], cst_Stack_top_of_empty_stack);
   function top(t){return is_empty(t) ? 0 : [0, top_nonempty(t)];}
   function top_exn(t){
    return is_empty(t)
            ? caml_call1(Base_Error[29], top_error)
            : top_nonempty(t);
   }
   function copy(param){
    var length = param[1], elts = param[2];
    return [0, length, caml_call1(Base_Option_array[56], elts)];
   }
   function clear(t){
    var _g_ = 0 < t[1] ? 1 : 0;
    if(_g_){
     var _i_ = caml_call2(Base_Import[92], t[1], 1), _h_ = 0;
     if(_i_ >= 0){
      var i = _h_;
      for(;;){
       caml_call2(Base_Option_array[43], t[2], i);
       var _k_ = i + 1 | 0;
       if(_i_ !== i){var i = _k_; continue;}
       break;
      }
     }
     t[1] = 0;
     var _j_ = 0;
    }
    else
     var _j_ = _g_;
    return _j_;
   }
   function until_empty(t, f){
    for(;;){
     var _f_ = 0 < t[1] ? 1 : 0;
     if(! _f_) return _f_;
     caml_call1(f, pop_nonempty(t));
    }
   }
   function singleton(x){var t = create(0); push(t, x); return t;}
   var
    Base_Stack =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       invariant,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       of_list,
       create,
       singleton,
       push,
       pop,
       pop_exn,
       top,
       top_exn,
       clear,
       copy,
       until_empty,
       capacity,
       set_capacity];
   runtime.caml_register_global(19, Base_Stack, "Base__Stack");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Source_code_position
//# unitInfo: Requires: Base__Comparable, Base__Import, Base__Int, Base__Source_code_position0, Base__String
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Int = global_data.Base__Int,
    Base_Import = global_data.Base__Import,
    Base_Source_code_position0 = global_data.Base__Source_code_position0,
    Base_Comparable = global_data.Base__Comparable;
   function hash_override(param){
    var
     pos_cnum = param[4],
     pos_bol = param[3],
     pos_lnum = param[2],
     pos_fname = param[1],
     _a_ = caml_call1(Base_Int[7], pos_cnum),
     _b_ = caml_call1(Base_Int[7], pos_bol),
     _c_ = caml_call1(Base_Int[7], pos_lnum),
     _d_ = runtime.Base_hash_string(pos_fname),
     _e_ = caml_call2(Base_Import[120], _d_, _c_),
     _f_ = caml_call2(Base_Import[120], _e_, _b_);
    return caml_call2(Base_Import[120], _f_, _a_);
   }
   var
    hash_fold_t = Base_Source_code_position0[3],
    comparator = Base_Source_code_position0[5],
    to_string = Base_Source_code_position0[7],
    sexp_of_t = Base_Source_code_position0[8],
    include = caml_call1(Base_Comparable[11], [0, sexp_of_t, comparator]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator$0 = include[16];
   function of_pos(param){
    var pos_cnum = param[3], pos_lnum = param[2], pos_fname = param[1];
    return [0, pos_fname, pos_lnum, 0, pos_cnum];
   }
   var
    Base_Source_code_position =
      [0,
       hash_fold_t,
       hash_override,
       sexp_of_t,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator$0,
       to_string,
       of_pos];
   runtime.caml_register_global
    (4, Base_Source_code_position, "Base__Source_code_position");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sign_or_nan
//# unitInfo: Requires: Base__Hash, Base__Identifiable, Base__Import, Base__Poly0, Base__Sign, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Nan = "Nan",
    cst_Neg = "Neg",
    cst_Pos = "Pos",
    cst_Zero = "Zero",
    cst_nan = "nan",
    cst_neg = "neg",
    cst_pos = "pos",
    cst_zero = "zero",
    caml_int_compare = runtime.caml_int_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_003 = "sign_or_nan.ml.T.t",
    t_sexp_grammar =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Neg, 0]],
         [0,
          [1, [0, cst_Zero, 0]],
          [0, [1, [0, cst_Pos, 0]], [0, [1, [0, cst_Nan, 0]], 0]]]]]],
    all = [0, 0, [0, 1, [0, 2, [0, 3, 0]]]],
    module_name = "Base.Sign_or_nan",
    Base_Sign = global_data.Base__Sign,
    Base_Import = global_data.Base__Import,
    Base_Poly0 = global_data.Base__Poly0,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Identifiable = global_data.Base__Identifiable,
    cst_Base_Sign_or_nan_to_sign_e = "Base.Sign_or_nan.to_sign_exn: Nan",
    _a_ = [0, cst_Neg],
    _b_ = [0, cst_Zero],
    _c_ = [0, cst_Pos],
    _d_ = [0, cst_Nan];
   function t_of_sexp(sexp_004){
    if(0 === sexp_004[0]){
     var _k_ = sexp_004[1], switch$0 = 0;
     if(caml_string_notequal(_k_, cst_Nan)){
      var switch$1 = 0;
      if(caml_string_notequal(_k_, cst_Neg)){
       var switch$2 = 0;
       if(caml_string_notequal(_k_, cst_Pos)){
        var switch$3 = 0;
        if(caml_string_notequal(_k_, cst_Zero)){
         if(caml_string_notequal(_k_, cst_nan))
          if(caml_string_notequal(_k_, cst_neg))
           if(caml_string_notequal(_k_, cst_pos))
            if(caml_string_notequal(_k_, cst_zero))
             switch$0 = 1;
            else
             switch$3 = 1;
           else
            switch$2 = 1;
          else
           switch$1 = 1;
        }
        else
         switch$3 = 1;
        if(switch$3) return 1;
       }
       else
        switch$2 = 1;
       if(switch$2) return 2;
      }
      else
       switch$1 = 1;
      if(switch$1) return 0;
     }
     if(! switch$0) return 3;
    }
    else{
     var _l_ = sexp_004[1];
     if(! _l_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_003, sexp_004);
     var _m_ = _l_[1];
     if(0 !== _m_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_003, sexp_004);
     var _n_ = _m_[1], switch$4 = 0;
     if(caml_string_notequal(_n_, cst_Nan)){
      var switch$5 = 0;
      if(caml_string_notequal(_n_, cst_Neg)){
       var switch$6 = 0;
       if(caml_string_notequal(_n_, cst_Pos)){
        var switch$7 = 0;
        if(caml_string_notequal(_n_, cst_Zero)){
         if(caml_string_notequal(_n_, cst_nan))
          if(caml_string_notequal(_n_, cst_neg))
           if(caml_string_notequal(_n_, cst_pos))
            if(caml_string_notequal(_n_, cst_zero))
             switch$4 = 1;
            else
             switch$7 = 1;
           else
            switch$6 = 1;
          else
           switch$5 = 1;
        }
        else
         switch$7 = 1;
        if(switch$7)
         return caml_call2
                 (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
       }
       else
        switch$6 = 1;
       if(switch$6)
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
      }
      else
       switch$5 = 1;
      if(switch$5)
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
     }
     if(! switch$4)
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_003, sexp_004);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_003, sexp_004);
   }
   function sexp_of_t(param){
    switch(param){
      case 0:
       return _a_;
      case 1:
       return _b_;
      case 2:
       return _c_;
      default: return _d_;
    }
   }
   var compare = caml_int_compare;
   function hash_fold_t(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      case 2:
       return caml_call2(Base_Hash[3], hsv, 2);
      default: return caml_call2(Base_Hash[3], hsv, 3);
    }
   }
   function hash(arg){
    var hsv = caml_call2(Base_Hash[11], 0, 0), _j_ = hash_fold_t(hsv, arg);
    return caml_call1(Base_Hash[9], _j_);
   }
   function of_string(s){return t_of_sexp(caml_call1(Base_Import[138], s));}
   function to_string(t){
    var _i_ = sexp_of_t(t);
    return caml_call1(Base_Import[162], _i_);
   }
   function symbol(x, y){return x < y ? 1 : 0;}
   function symbol$0(x, y){return x <= y ? 1 : 0;}
   function symbol$1(x, y){return x !== y ? 1 : 0;}
   function symbol$2(x, y){return x === y ? 1 : 0;}
   function symbol$3(x, y){return y < x ? 1 : 0;}
   function symbol$4(x, y){return y <= x ? 1 : 0;}
   function ascending(x, y){return caml_call2(Base_Poly0[1], x, y);}
   function descending(x, y){return caml_call2(Base_Poly0[2], x, y);}
   var compare$0 = caml_int_compare;
   function equal(x, y){return x === y ? 1 : 0;}
   function max(x, y){return y <= x ? x : y;}
   function min(x, y){return x <= y ? x : y;}
   var
    _e_ =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         hash,
         t_of_sexp,
         sexp_of_t,
         of_string,
         to_string,
         module_name]),
    hash_fold_t$0 = _e_[1],
    hash$0 = _e_[2],
    t_of_sexp$0 = _e_[3],
    sexp_of_t$0 = _e_[4],
    of_string$0 = _e_[5],
    to_string$0 = _e_[6],
    between = _e_[19],
    clamp_exn = _e_[20],
    clamp = _e_[21],
    comparator = _e_[22],
    pp = _e_[23],
    hashable = _e_[24];
   function of_sign(param){
    switch(param){case 0: return 0;case 1: return 1;default: return 2;
    }
   }
   function to_sign_exn(param){
    switch(param){
      case 0:
       return 0;
      case 1:
       return 1;
      case 2:
       return 2;
      default:
       return caml_call1(Base_Import[125], cst_Base_Sign_or_nan_to_sign_e);
    }
   }
   function of_int(n){return of_sign(caml_call1(Base_Sign[27], n));}
   function to_int_exn(t){
    var _h_ = to_sign_exn(t);
    return caml_call1(Base_Sign[28], _h_);
   }
   function flip(param){
    switch(param){
      case 0:
       return 2;
      case 1:
       return 1;
      case 2:
       return 0;
      default: return 3;
    }
   }
   function symbol$5(t$0, t){
    if(3 > t$0 && 3 > t){
     var _f_ = to_sign_exn(t), _g_ = to_sign_exn(t$0);
     return of_sign(caml_call2(Base_Sign[31], _g_, _f_));
    }
    return 3;
   }
   var
    Base_Sign_or_nan =
      [0,
       all,
       t_sexp_grammar,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$4,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol,
       symbol$1,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       of_int,
       to_int_exn,
       of_sign,
       to_sign_exn,
       flip,
       symbol$5];
   runtime.caml_register_global(31, Base_Sign_or_nan, "Base__Sign_or_nan");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Sexp_with_comparable
//# unitInfo: Requires: Base__Comparable, Base__Sexp
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Base_Comparable = global_data.Base__Comparable,
    hash_fold_t = Base_Sexp[1],
    hash = Base_Sexp[2],
    t_of_sexp = Base_Sexp[3],
    sexp_of_t = Base_Sexp[4],
    Not_found_s = Base_Sexp[7],
    Of_sexp_error = Base_Sexp[8],
    message = Base_Sexp[9],
    default_indent = Base_Sexp[10],
    pp_hum = Base_Sexp[11],
    pp_hum_indent = Base_Sexp[12],
    pp_mach = Base_Sexp[13],
    pp = Base_Sexp[14],
    to_string_hum = Base_Sexp[15],
    to_string_mach = Base_Sexp[16],
    to_string = Base_Sexp[17],
    of_float_style = Base_Sexp[18],
    of_int_style = Base_Sexp[19],
    t_sexp_grammar = Base_Sexp[21],
    invariant = Base_Sexp[22],
    of_string = Base_Sexp[23],
    include = caml_call1(Base_Comparable[10], [0, Base_Sexp[6], Base_Sexp[4]]),
    symbol = include[1],
    symbol$0 = include[2],
    symbol$1 = include[3],
    symbol$2 = include[4],
    symbol$3 = include[5],
    symbol$4 = include[6],
    equal = include[7],
    compare = include[8],
    min = include[9],
    max = include[10],
    ascending = include[11],
    descending = include[12],
    between = include[13],
    clamp_exn = include[14],
    clamp = include[15],
    comparator = include[16],
    Base_Sexp_with_comparable =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator];
   runtime.caml_register_global
    (2, Base_Sexp_with_comparable, "Base__Sexp_with_comparable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hasher
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hasher = [0];
   runtime.caml_register_global(0, Base_Hasher, "Base__Hasher");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Maybe_bound
//# unitInfo: Requires: Base__Hash, Base__Import, Base__List, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Above_upper_bound = "Above_upper_bound",
    cst_Below_lower_bound = "Below_lower_bound",
    cst_Excl$0 = "Excl",
    cst_In_range = "In_range",
    cst_Incl$0 = "Incl",
    cst_Unbounded = "Unbounded",
    cst_above_upper_bound = "above_upper_bound",
    cst_below_lower_bound = "below_lower_bound",
    cst_excl = "excl",
    cst_in_range = "in_range",
    cst_incl = "incl",
    cst_unbounded = "unbounded",
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_006 = "maybe_bound.ml.t",
    error_source_027 = "maybe_bound.ml.interval_comparison",
    interval_comparison_sexp_gramm =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Below_lower_bound, 0]],
         [0,
          [1, [0, cst_In_range, 0]],
          [0, [1, [0, cst_Above_upper_bound, 0]], 0]]]]],
    Base_Import = global_data.Base__Import,
    Base_Hash = global_data.Base__Hash,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_List = global_data.Base__List,
    cst_Maybe_bound_compare_to_int =
      "Maybe_bound.compare_to_interval_exn: lower bound > upper bound",
    _f_ = [0, cst_Below_lower_bound],
    _g_ = [0, cst_In_range],
    _h_ = [0, cst_Above_upper_bound],
    _e_ = [0, [1, [0, cst_Unbounded, 0]], 0],
    cst_Excl = cst_Excl$0,
    cst_Incl = cst_Incl$0,
    _b_ = [0, cst_Unbounded],
    _c_ = [0, cst_Incl$0],
    _d_ = [0, cst_Excl$0],
    _a_ = [0, 0, 0];
   function all(all_of_a){
    var l = all_of_a, acc = 0;
    for(;;){
     if(l){
      var
       l$0 = l[2],
       enumerate_002 = l[1],
       acc$0 = [0, [1, enumerate_002], acc],
       l = l$0,
       acc = acc$0;
      continue;
     }
     var
      _q_ = caml_call1(Base_List[38], acc),
      l$1 = all_of_a,
      acc$1 = 0,
      _r_ = caml_call2(Base_List[75], _q_, _a_);
     for(;;){
      if(l$1){
       var
        l$2 = l$1[2],
        enumerate_001 = l$1[1],
        acc$2 = [0, [0, enumerate_001], acc$1],
        l$1 = l$2,
        acc$1 = acc$2;
       continue;
      }
      var _s_ = caml_call1(Base_List[38], acc$1);
      return caml_call2(Base_List[75], _s_, _r_);
     }
    }
   }
   function t_of_sexp(of_a_003, sexp_008){
    if(0 === sexp_008[0]){
     var _n_ = sexp_008[1], switch$0 = 0;
     if(caml_string_notequal(_n_, cst_Excl$0)){
      var switch$1 = 0;
      if(caml_string_notequal(_n_, cst_Incl$0)){
       var switch$2 = 0;
       if(caml_string_notequal(_n_, cst_Unbounded)){
        if(caml_string_notequal(_n_, cst_excl))
         if(caml_string_notequal(_n_, cst_incl))
          if(caml_string_notequal(_n_, cst_unbounded))
           switch$0 = 1;
          else
           switch$2 = 1;
         else
          switch$1 = 1;
       }
       else
        switch$2 = 1;
       if(switch$2) return 0;
      }
      else
       switch$1 = 1;
      if(switch$1)
       return caml_call2
               (Sexplib0_Sexp_conv_error[5], error_source_006, sexp_008);
     }
     if(! switch$0)
      return caml_call2
              (Sexplib0_Sexp_conv_error[5], error_source_006, sexp_008);
    }
    else{
     var _o_ = sexp_008[1];
     if(! _o_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_006, sexp_008);
     var _p_ = _o_[1];
     if(0 !== _p_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_006, sexp_008);
     var tag_009 = _p_[1], switch$3 = 0;
     if(caml_string_notequal(tag_009, cst_Excl$0)){
      var switch$4 = 0;
      if(caml_string_notequal(tag_009, cst_Incl$0)){
       var switch$5 = 0;
       if(caml_string_notequal(tag_009, cst_Unbounded)){
        if(caml_string_notequal(tag_009, cst_excl))
         if(caml_string_notequal(tag_009, cst_incl))
          if(caml_string_notequal(tag_009, cst_unbounded))
           switch$3 = 1;
          else
           switch$5 = 1;
         else
          switch$4 = 1;
       }
       else
        switch$5 = 1;
       if(switch$5)
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_008);
      }
      else
       switch$4 = 1;
      if(switch$4){
       var sexp_args_010 = _o_[2];
       if(sexp_args_010 && ! sexp_args_010[2]){
        var
         arg0_011 = sexp_args_010[1],
         res0_012 = caml_call1(of_a_003, arg0_011);
        return [0, res0_012];
       }
       return caml_call3
               (Sexplib0_Sexp_conv_error[4],
                error_source_006,
                tag_009,
                sexp_008);
      }
     }
     if(! switch$3){
      var sexp_args_015 = _o_[2];
      if(sexp_args_015 && ! sexp_args_015[2]){
       var
        arg0_016 = sexp_args_015[1],
        res0_017 = caml_call1(of_a_003, arg0_016);
       return [1, res0_017];
      }
      return caml_call3
              (Sexplib0_Sexp_conv_error[4],
               error_source_006,
               tag_009,
               sexp_008);
     }
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_006, sexp_008);
   }
   function sexp_of_t(of_a_019, param){
    if(typeof param === "number") return _b_;
    if(0 === param[0]){
     var arg0_020 = param[1], res0_021 = caml_call1(of_a_019, arg0_020);
     return [1, [0, _c_, [0, res0_021, 0]]];
    }
    var arg0_022 = param[1], res0_023 = caml_call1(of_a_019, arg0_022);
    return [1, [0, _d_, [0, res0_023, 0]]];
   }
   function t_sexp_grammar(a_sexp_grammar){
    return [3,
            [0,
             2,
             [0,
              [1, [0, cst_Incl, [0, [0, a_sexp_grammar, 0]]]],
              [0, [1, [0, cst_Excl, [0, [0, a_sexp_grammar, 0]]]], _e_]]]];
   }
   function interval_comparison_of_sexp(sexp_028){
    if(0 === sexp_028[0]){
     var _j_ = sexp_028[1], switch$0 = 0;
     if(caml_string_notequal(_j_, cst_Above_upper_bound)){
      var switch$1 = 0;
      if(caml_string_notequal(_j_, cst_Below_lower_bound)){
       var switch$2 = 0;
       if(caml_string_notequal(_j_, cst_In_range)){
        if(caml_string_notequal(_j_, cst_above_upper_bound))
         if(caml_string_notequal(_j_, cst_below_lower_bound))
          if(caml_string_notequal(_j_, cst_in_range))
           switch$0 = 1;
          else
           switch$2 = 1;
         else
          switch$1 = 1;
       }
       else
        switch$2 = 1;
       if(switch$2) return 1;
      }
      else
       switch$1 = 1;
      if(switch$1) return 0;
     }
     if(! switch$0) return 2;
    }
    else{
     var _k_ = sexp_028[1];
     if(! _k_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_027, sexp_028);
     var _l_ = _k_[1];
     if(0 !== _l_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_027, sexp_028);
     var _m_ = _l_[1], switch$3 = 0;
     if(caml_string_notequal(_m_, cst_Above_upper_bound)){
      var switch$4 = 0;
      if(caml_string_notequal(_m_, cst_Below_lower_bound)){
       var switch$5 = 0;
       if(caml_string_notequal(_m_, cst_In_range)){
        if(caml_string_notequal(_m_, cst_above_upper_bound))
         if(caml_string_notequal(_m_, cst_below_lower_bound))
          if(caml_string_notequal(_m_, cst_in_range))
           switch$3 = 1;
          else
           switch$5 = 1;
         else
          switch$4 = 1;
       }
       else
        switch$5 = 1;
       if(switch$5)
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
      }
      else
       switch$4 = 1;
      if(switch$4)
       return caml_call2
               (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
     }
     if(! switch$3)
      return caml_call2
              (Sexplib0_Sexp_conv_error[3], error_source_027, sexp_028);
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_027, sexp_028);
   }
   function sexp_of_interval_comparison(param){
    switch(param){case 0: return _f_;case 1: return _g_;default: return _h_;
    }
   }
   var compare_interval_comparison = runtime.caml_int_compare;
   function hash_fold_interval_comparison(hsv, arg){
    switch(arg){
      case 0:
       return caml_call2(Base_Hash[3], hsv, 0);
      case 1:
       return caml_call2(Base_Hash[3], hsv, 1);
      default: return caml_call2(Base_Hash[3], hsv, 2);
    }
   }
   function hash_interval_comparison(arg){
    var
     hsv = caml_call2(Base_Hash[11], 0, 0),
     _i_ = hash_fold_interval_comparison(hsv, arg);
    return caml_call1(Base_Hash[9], _i_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var incl = t[1]; return [0, caml_call1(f, incl)];}
    var excl = t[1];
    return [1, caml_call1(f, excl)];
   }
   function is_lower_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, incl, a) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, excl, a) < 0 ? 1 : 0;
   }
   function is_upper_bound(t, a, compare){
    if(typeof t === "number") return 1;
    if(0 === t[0]){
     var incl = t[1];
     return caml_call2(compare, a, incl) <= 0 ? 1 : 0;
    }
    var excl = t[1];
    return caml_call2(compare, a, excl) < 0 ? 1 : 0;
   }
   function bounds_crossed(lower, upper, compare){
    if(typeof lower === "number") return 0;
    var lower$0 = lower[1];
    if(typeof upper === "number") return 0;
    var upper$0 = upper[1];
    return 0 < caml_call2(compare, lower$0, upper$0) ? 1 : 0;
   }
   function compare_to_interval_exn(lower, upper, a, compare){
    if(bounds_crossed(lower, upper, compare))
     caml_call1(Base_Import[123], cst_Maybe_bound_compare_to_int);
    return is_lower_bound(lower, a, compare)
            ? is_upper_bound(upper, a, compare) ? 1 : 2
            : 0;
   }
   function interval_contains_exn(lower, upper, a, compare){
    return 1 === compare_to_interval_exn(lower, upper, a, compare) ? 1 : 0;
   }
   var
    Base_Maybe_bound =
      [0,
       all,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       map,
       is_lower_bound,
       is_upper_bound,
       interval_contains_exn,
       bounds_crossed,
       sexp_of_interval_comparison,
       interval_comparison_of_sexp,
       interval_comparison_sexp_gramm,
       compare_interval_comparison,
       hash_fold_interval_comparison,
       hash_interval_comparison,
       compare_to_interval_exn];
   runtime.caml_register_global(42, Base_Maybe_bound, "Base__Maybe_bound");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map_intf
//# unitInfo: Requires: Base__Ppx_compare_lib, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Left$0 = "Left",
    cst_Right$0 = "Right",
    cst_Unequal$0 = "Unequal",
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_057 = "map_intf.ml.Symmetric_diff_element.t",
    all = [0, 0, [0, 1, 0]],
    all$0 = [0, 0, [0, 1, 0]],
    Base_Ppx_compare_lib = global_data.Base__Ppx_compare_lib,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    _k_ = [0, "Unfinished"],
    _l_ = [0, "Finished"],
    _i_ = [0, "Stop"],
    _j_ = [0, "Continue"],
    _g_ = [0, cst_Left$0],
    _h_ = [0, cst_Right$0],
    _f_ = [0, "Both"],
    cst_Unequal = cst_Unequal$0,
    cst_Right = cst_Right$0,
    cst_Left = cst_Left$0,
    _d_ = [0, cst_Unequal$0],
    _e_ = [0, cst_Right$0],
    _c_ = [0, cst_Left$0],
    _a_ = [0, "Duplicate"],
    _b_ = [0, "Ok"];
   function compare(cmp_a, a_001, b_002){
    if(caml_call2(Base_Ppx_compare_lib[1], a_001, b_002)) return 0;
    if(typeof a_001 === "number"){
     if(-1024851605 === b_002) return 0;
    }
    else if(typeof b_002 !== "number" && 17724 === b_002[1]){
     var right_004 = b_002[2], left_003 = a_001[2];
     return caml_call2(cmp_a, left_003, right_004);
    }
    return caml_compare(a_001, b_002);
   }
   function equal(cmp_a, a_005, b_006){
    if(caml_call2(Base_Ppx_compare_lib[1], a_005, b_006)) return 1;
    if(typeof a_005 === "number"){
     if(-1024851605 === b_006) return 1;
    }
    else if(typeof b_006 !== "number" && 17724 === b_006[1]){
     var right_008 = b_006[2], left_007 = a_005[2];
     return caml_call2(cmp_a, left_007, right_008);
    }
    return caml_equal(a_005, b_006);
   }
   function sexp_of_t(of_a_009, param){
    if(typeof param === "number") return _a_;
    var v_010 = param[2];
    return [1, [0, _b_, [0, caml_call1(of_a_009, v_010), 0]]];
   }
   var
    Or_duplicate = [0, compare, equal, sexp_of_t],
    Without_comparator = [0],
    With_comparator = [0],
    With_first_class_module = [0];
   function compare$0(cmp_k, cmp_v, a_011, b_012){
    var
     t_014 = a_011[2],
     t_013 = a_011[1],
     t_016 = b_012[2],
     t_015 = b_012[1],
     n = caml_call2(cmp_k, t_013, t_015);
    if(0 !== n) return n;
    if(caml_call2(Base_Ppx_compare_lib[1], t_014, t_016)) return 0;
    var _O_ = t_014[1];
    if(847852583 === _O_){
     if(typeof t_016 !== "number" && 847852583 === t_016[1]){
      var right_018 = t_016[2], left_017 = t_014[2];
      return caml_call2(cmp_v, left_017, right_018);
     }
    }
    else
     if(1013247643 <= _O_){
      if(typeof t_016 !== "number" && 1013247643 === t_016[1]){
       var
        right_022 = t_016[2],
        left_021 = t_014[2],
        t_024 = left_021[2],
        t_023 = left_021[1],
        t_026 = right_022[2],
        t_025 = right_022[1],
        n$0 = caml_call2(cmp_v, t_023, t_025);
       return 0 === n$0 ? caml_call2(cmp_v, t_024, t_026) : n$0;
      }
     }
     else if(typeof t_016 !== "number" && -57574468 === t_016[1]){
      var right_020 = t_016[2], left_019 = t_014[2];
      return caml_call2(cmp_v, left_019, right_020);
     }
    return caml_compare(t_014, t_016);
   }
   function equal$0(cmp_k, cmp_v, a_027, b_028){
    var
     t_030 = a_027[2],
     t_029 = a_027[1],
     t_032 = b_028[2],
     t_031 = b_028[1],
     _K_ = caml_call2(cmp_k, t_029, t_031);
    if(_K_){
     if(caml_call2(Base_Ppx_compare_lib[1], t_030, t_032)) return 1;
     var _L_ = t_030[1];
     if(847852583 === _L_){
      if(typeof t_032 !== "number" && 847852583 === t_032[1]){
       var right_034 = t_032[2], left_033 = t_030[2];
       return caml_call2(cmp_v, left_033, right_034);
      }
     }
     else
      if(1013247643 <= _L_){
       if(typeof t_032 !== "number" && 1013247643 === t_032[1]){
        var
         right_038 = t_032[2],
         left_037 = t_030[2],
         t_040 = left_037[2],
         t_039 = left_037[1],
         t_042 = right_038[2],
         t_041 = right_038[1],
         _N_ = caml_call2(cmp_v, t_039, t_041);
        return _N_ ? caml_call2(cmp_v, t_040, t_042) : _N_;
       }
      }
      else if(typeof t_032 !== "number" && -57574468 === t_032[1]){
       var right_036 = t_032[2], left_035 = t_030[2];
       return caml_call2(cmp_v, left_035, right_036);
      }
     var _M_ = caml_equal(t_030, t_032);
    }
    else
     var _M_ = _K_;
    return _M_;
   }
   function t_of_sexp(of_k_043, of_v_044, sexp_071){
    if(1 === sexp_071[0]){
     var _v_ = sexp_071[1];
     if(_v_){
      var _w_ = _v_[2];
      if(_w_ && ! _w_[2]){
       var
        arg1_068 = _w_[1],
        arg0_067 = _v_[1],
        res0_069 = caml_call1(of_k_043, arg0_067);
       try{
        if(0 === arg1_068[0])
         var
          atom_047 = arg1_068[1],
          _y_ =
            caml_string_notequal(atom_047, cst_Left$0)
             ? caml_string_notequal
                (atom_047, cst_Right$0)
               ? caml_string_notequal
                  (atom_047, cst_Unequal$0)
                 ? caml_call1(Sexplib0_Sexp_conv_error[19], 0)
                 : caml_call2
                   (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068)
               : caml_call2
                 (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068)
             : caml_call2
               (Sexplib0_Sexp_conv_error[23], error_source_057, arg1_068),
          _z_ = _y_;
        else{
         var _A_ = arg1_068[1];
         if(_A_){
          var match = _A_[1];
          if(0 === match[0]){
           var sexp_args_050 = _A_[2], atom_047$0 = match[1];
           if(caml_string_notequal(atom_047$0, cst_Left$0))
            if(caml_string_notequal(atom_047$0, cst_Right$0))
             if(caml_string_notequal(atom_047$0, cst_Unequal$0))
              var _B_ = caml_call1(Sexplib0_Sexp_conv_error[19], 0);
             else{
              var switch$0 = 0;
              if(sexp_args_050 && ! sexp_args_050[2]){
               var arg0_058 = sexp_args_050[1], switch$1 = 0;
               if(1 === arg0_058[0]){
                var _F_ = arg0_058[1];
                if(_F_){
                 var _G_ = _F_[2];
                 if(_G_ && ! _G_[2]){
                  var
                   arg1_053 = _G_[1],
                   arg0_052 = _F_[1],
                   res0_054 = caml_call1(of_v_044, arg0_052),
                   res1_055 = caml_call1(of_v_044, arg1_053),
                   res0_059 = [0, res0_054, res1_055];
                  switch$1 = 1;
                 }
                }
               }
               if(! switch$1)
                var
                 res0_059 =
                   caml_call3
                    (Sexplib0_Sexp_conv_error[2], error_source_057, 2, arg0_058);
               var _E_ = [0, 1013247643, res0_059];
               switch$0 = 1;
              }
              if(! switch$0)
               var
                _E_ =
                  caml_call3
                   (Sexplib0_Sexp_conv_error[22],
                    error_source_057,
                    atom_047$0,
                    arg1_068);
              var _B_ = _E_;
             }
            else{
             var switch$2 = 0;
             if(sexp_args_050 && ! sexp_args_050[2]){
              var
               arg0_061 = sexp_args_050[1],
               res0_062 = caml_call1(of_v_044, arg0_061),
               _H_ = [0, -57574468, res0_062];
              switch$2 = 1;
             }
             if(! switch$2)
              var
               _H_ =
                 caml_call3
                  (Sexplib0_Sexp_conv_error[22],
                   error_source_057,
                   atom_047$0,
                   arg1_068);
             var _B_ = _H_;
            }
           else{
            var switch$3 = 0;
            if(sexp_args_050 && ! sexp_args_050[2]){
             var
              arg0_064 = sexp_args_050[1],
              res0_065 = caml_call1(of_v_044, arg0_064),
              _I_ = [0, 847852583, res0_065];
             switch$3 = 1;
            }
            if(! switch$3)
             var
              _I_ =
                caml_call3
                 (Sexplib0_Sexp_conv_error[22],
                  error_source_057,
                  atom_047$0,
                  arg1_068);
            var _B_ = _I_;
           }
           var _C_ = _B_;
          }
          else
           var
            _C_ =
              caml_call2
               (Sexplib0_Sexp_conv_error[24], error_source_057, arg1_068);
          var _D_ = _C_;
         }
         else
          var
           _D_ =
             caml_call2
              (Sexplib0_Sexp_conv_error[25], error_source_057, arg1_068);
         var _z_ = _D_;
        }
        var res1_070 = _z_;
       }
       catch(_J_){
        var _x_ = caml_wrap_exception(_J_);
        if(_x_ !== Sexplib0_Sexp_conv_error[18])
         throw caml_maybe_attach_backtrace(_x_, 0);
        var
         res1_070 =
           caml_call2
            (Sexplib0_Sexp_conv_error[20], error_source_057, arg1_068);
       }
       return [0, res0_069, res1_070];
      }
     }
    }
    return caml_call3
            (Sexplib0_Sexp_conv_error[2], error_source_057, 2, sexp_071);
   }
   function sexp_of_t$0(of_k_072, of_v_073, param){
    var
     arg1_082 = param[2],
     arg0_081 = param[1],
     res0_083 = caml_call1(of_k_072, arg0_081),
     _u_ = arg1_082[1];
    if(847852583 === _u_)
     var
      v_074 = arg1_082[2],
      res1_084 = [1, [0, _c_, [0, caml_call1(of_v_073, v_074), 0]]];
    else if(1013247643 <= _u_)
     var
      v_076 = arg1_082[2],
      arg1_078 = v_076[2],
      arg0_077 = v_076[1],
      res0_079 = caml_call1(of_v_073, arg0_077),
      res1_080 = caml_call1(of_v_073, arg1_078),
      res1_084 = [1, [0, _d_, [0, [1, [0, res0_079, [0, res1_080, 0]]], 0]]];
    else
     var
      v_075 = arg1_082[2],
      res1_084 = [1, [0, _e_, [0, caml_call1(of_v_073, v_075), 0]]];
    return [1, [0, res0_083, [0, res1_084, 0]]];
   }
   function t_sexp_grammar(k_sexp_grammar, v_sexp_grammar){
    return [2,
            [0,
             k_sexp_grammar,
             [0,
              [3,
               [0,
                1,
                [0,
                 [1, [0, cst_Left, [0, [0, v_sexp_grammar, 0]]]],
                 [0,
                  [1, [0, cst_Right, [0, [0, v_sexp_grammar, 0]]]],
                  [0,
                   [1,
                    [0,
                     cst_Unequal,
                     [0,
                      [0, [2, [0, v_sexp_grammar, [0, v_sexp_grammar, 0]]], 0]]]],
                   0]]]]],
              0]]];
   }
   var
    Symmetric_diff_element =
      [0, compare$0, equal$0, t_of_sexp, sexp_of_t$0, t_sexp_grammar];
   function compare$1(cmp_left, cmp_right, a_085, b_086){
    if(caml_call2(Base_Ppx_compare_lib[1], a_085, b_086)) return 0;
    var _t_ = a_085[1];
    if(737457313 === _t_){
     if(typeof b_086 !== "number" && 737457313 === b_086[1]){
      var
       right_092 = b_086[2],
       left_091 = a_085[2],
       t_094 = left_091[2],
       t_093 = left_091[1],
       t_096 = right_092[2],
       t_095 = right_092[1],
       n = caml_call2(cmp_left, t_093, t_095);
      return 0 === n ? caml_call2(cmp_right, t_094, t_096) : n;
     }
    }
    else
     if(847852583 <= _t_){
      if(typeof b_086 !== "number" && 847852583 === b_086[1]){
       var right_088 = b_086[2], left_087 = a_085[2];
       return caml_call2(cmp_left, left_087, right_088);
      }
     }
     else if(typeof b_086 !== "number" && -57574468 === b_086[1]){
      var right_090 = b_086[2], left_089 = a_085[2];
      return caml_call2(cmp_right, left_089, right_090);
     }
    return caml_compare(a_085, b_086);
   }
   function equal$1(cmp_left, cmp_right, a_097, b_098){
    if(caml_call2(Base_Ppx_compare_lib[1], a_097, b_098)) return 1;
    var _r_ = a_097[1];
    if(737457313 === _r_){
     if(typeof b_098 !== "number" && 737457313 === b_098[1]){
      var
       right_104 = b_098[2],
       left_103 = a_097[2],
       t_106 = left_103[2],
       t_105 = left_103[1],
       t_108 = right_104[2],
       t_107 = right_104[1],
       _s_ = caml_call2(cmp_left, t_105, t_107);
      return _s_ ? caml_call2(cmp_right, t_106, t_108) : _s_;
     }
    }
    else
     if(847852583 <= _r_){
      if(typeof b_098 !== "number" && 847852583 === b_098[1]){
       var right_100 = b_098[2], left_099 = a_097[2];
       return caml_call2(cmp_left, left_099, right_100);
      }
     }
     else if(typeof b_098 !== "number" && -57574468 === b_098[1]){
      var right_102 = b_098[2], left_101 = a_097[2];
      return caml_call2(cmp_right, left_101, right_102);
     }
    return caml_equal(a_097, b_098);
   }
   function sexp_of_t$1(of_left_109, of_right_110, param){
    var _q_ = param[1];
    if(737457313 === _q_){
     var
      v_113 = param[2],
      arg1_115 = v_113[2],
      arg0_114 = v_113[1],
      res0_116 = caml_call1(of_left_109, arg0_114),
      res1_117 = caml_call1(of_right_110, arg1_115);
     return [1, [0, _f_, [0, [1, [0, res0_116, [0, res1_117, 0]]], 0]]];
    }
    if(847852583 <= _q_){
     var v_111 = param[2];
     return [1, [0, _g_, [0, caml_call1(of_left_109, v_111), 0]]];
    }
    var v_112 = param[2];
    return [1, [0, _h_, [0, caml_call1(of_right_110, v_112), 0]]];
   }
   var
    Merge_element = [0, compare$1, equal$1, sexp_of_t$1],
    compare$2 = caml_int_compare;
   function equal$2(_p_, _o_){return _p_ === _o_ ? 1 : 0;}
   function sexp_of_t$2(param){return param ? _i_ : _j_;}
   var
    Continue_or_stop = [0, compare$2, all, equal$2, sexp_of_t$2],
    compare$3 = caml_int_compare;
   function equal$3(_n_, _m_){return _n_ === _m_ ? 1 : 0;}
   function sexp_of_t$3(param){return param ? _k_ : _l_;}
   var Finished_or_unfinished = [0, compare$3, all$0, equal$3, sexp_of_t$3];
   function Check_accessors(T, Tree, Key, Cmp, Options, symbol){return [0];}
   function Check_accessors1(M){return [0];}
   function Check_accessors2(M){return [0];}
   function Check_accessors3(M){return [0];}
   function Check_accessors3_with_comparat(M){return [0];}
   function Check_creators(T, Tree, Key, Cmp, Options, symbol){return [0];}
   function Check_creators1(M){return [0];}
   function Check_creators2(M){return [0];}
   function Check_creators3_with_comparato(M){return [0];}
   var
    Base_Map_intf =
      [0,
       Or_duplicate,
       Without_comparator,
       With_comparator,
       With_first_class_module,
       Symmetric_diff_element,
       Merge_element,
       Continue_or_stop,
       Finished_or_unfinished,
       Check_accessors,
       Check_accessors1,
       Check_accessors2,
       Check_accessors3,
       Check_accessors3_with_comparat,
       Check_creators,
       Check_creators1,
       Check_creators2,
       Check_creators3_with_comparato];
   runtime.caml_register_global(26, Base_Map_intf, "Base__Map_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set_intf
//# unitInfo: Requires: Base__Map_intf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data();
   global_data.Base__Map_intf;
   function Check_accessors(T, Tree, Elt, Named, Cmp, Options, symbol){return [0];
   }
   function Check_accessors0(M){return [0];}
   function Check_accessors1(M){return [0];}
   function Check_accessors2(M){return [0];}
   function Check_accessors2_with_comparat(M){return [0];}
   function Check_creators(T, Tree, Elt, Cmp, Options, symbol){return [0];}
   function Check_creators0(M){return [0];}
   function Check_creators1(M){return [0];}
   function Check_creators2(M){return [0];}
   function Check_creators2_with_comparato(M){return [0];}
   var
    Base_Set_intf =
      [0,
       Check_accessors,
       Check_accessors0,
       Check_accessors1,
       Check_accessors2,
       Check_accessors2_with_comparat,
       Check_creators,
       Check_creators0,
       Check_creators1,
       Check_creators2,
       Check_creators2_with_comparato];
   runtime.caml_register_global(1, Base_Set_intf, "Base__Set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Set
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Comparator, Base__Container, Base__Fn, Base__Hash, Base__Import, Base__List, Base__Option, Base__Or_error, Base__Sequence, Base__Set_intf, Base__Sexp, Base__With_return, Sexplib0__Sexp_conv, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_set_ml = "src/set.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Hash = global_data.Base__Hash,
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Or_error = global_data.Base__Or_error,
    Base_Container = global_data.Base__Container,
    Base_List = global_data.Base__List,
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Array = global_data.Base__Array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Fn = global_data.Base__Fn,
    Base_Option = global_data.Base__Option,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Comparator = global_data.Base__Comparator,
    with_return = Base_With_return[1],
    _t_ = [0, "_"],
    cst_Set_remove_min_elt = "Set.remove_min_elt",
    _s_ = [0, 0],
    cst_invalid_elements = "invalid_elements",
    cst_is_not_a_subset_of = " is not a subset of ",
    cst_Set_t_of_sexp_duplicate_el = "Set.t_of_sexp: duplicate element in set",
    cst_Set_t_of_sexp_list_needed = "Set.t_of_sexp: list needed",
    _r_ = [0, cst_src_set_ml, 1047, 8],
    cst_Set_find_exn_failed_to_fin =
      "Set.find_exn failed to find a matching element",
    _p_ = [0, 0, 0],
    _o_ = [0, 0, 0, 0],
    _m_ = [0, "set.ml.Tree0.Set_max_elt_exn_of_empty_set"],
    _n_ = [0, cst_src_set_ml, 309, 15],
    _j_ = [0, "set.ml.Tree0.Set_min_elt_exn_of_empty_set"],
    _k_ = [0, cst_src_set_ml, 296, 15],
    _a_ = [0, cst_src_set_ml, 199, 17],
    _b_ = [0, cst_src_set_ml, 200, 18],
    _c_ = [0, cst_src_set_ml, 206, 21],
    _d_ = [0, cst_src_set_ml, 208, 12],
    _e_ = [0, cst_src_set_ml, 214, 17],
    _f_ = [0, cst_src_set_ml, 215, 18],
    _g_ = [0, cst_src_set_ml, 221, 21],
    _h_ = [0, cst_src_set_ml, 223, 12],
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    cst_Base_Set_Tree0_Same = "Base__Set.Tree0.Same",
    cst_Base_Set_Tree0_Set_min_elt =
      "Base__Set.Tree0.Set_min_elt_exn_of_empty_set",
    cst_Base_Set_Tree0_Set_max_elt =
      "Base__Set.Tree0.Set_max_elt_exn_of_empty_set",
    _q_ = [0, "Set.choose_exn: empty set"];
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[4];
    return h;
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var s = param[5];
    return s;
   }
   function in_range(lower, upper, compare_elt, v){
    if(lower)
     var
      lower$0 = lower[1],
      _bP_ = caml_call2(compare_elt, lower$0, v) < 0 ? 1 : 0;
    else
     var _bP_ = 1;
    if(_bP_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_elt, v, upper$0) < 0 ? 1 : 0;
     }
     var _bQ_ = 1;
    }
    else
     var _bQ_ = _bP_;
    return _bQ_;
   }
   function loop(lower, upper, compare_elt, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var v = t$0[1];
      return in_range(lower$0, upper, compare_elt, v);
     }
     var
      n = t$0[5],
      h = t$0[4],
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _bE_ = caml_call2(Base_Import[92], hl, hr),
      _bF_ = caml_call1(Base_Import[122], _bE_) <= 2 ? 1 : 0;
     if(_bF_){
      var
       _bG_ = caml_call2(Base_Import[99], hl, hr),
       _bH_ = h === caml_call2(Base_Import[90], _bG_, 1) ? 1 : 0;
      if(_bH_){
       var
        _bI_ = length(r),
        _bJ_ = length(l),
        _bK_ = caml_call2(Base_Import[90], _bJ_, _bI_),
        _bL_ = n === caml_call2(Base_Import[90], _bK_, 1) ? 1 : 0;
       if(_bL_){
        var _bM_ = in_range(lower$0, upper, compare_elt, v$0);
        if(_bM_){
         var _bN_ = loop(lower$0, [0, v$0], compare_elt, l);
         if(_bN_){
          var lower$1 = [0, v$0], lower$0 = lower$1, t$0 = r;
          continue;
         }
         var _bO_ = _bN_;
        }
        else
         var _bO_ = _bM_;
       }
       else
        var _bO_ = _bL_;
      }
      else
       var _bO_ = _bH_;
     }
     else
      var _bO_ = _bF_;
     return _bO_;
    }
   }
   function invariants(t, compare_elt){return loop(0, 0, compare_elt, t);}
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function create(l, v, r){
    if(typeof l === "number")
     var hl = 0;
    else if(0 === l[0]) var hl = 1; else var h$1 = l[4], hl = h$1;
    if(typeof r === "number")
     var hr = 0;
    else if(0 === r[0]) var hr = 1; else var h$0 = r[4], hr = h$0;
    var
     h =
       hr <= hl
        ? caml_call2(Base_Import[90], hl, 1)
        : caml_call2(Base_Import[90], hr, 1);
    if(1 === h) return [0, v];
    if(typeof l === "number")
     var sl = 0;
    else if(0 === l[0]) var sl = 1; else var s$0 = l[5], sl = s$0;
    if(typeof r === "number")
     var sr = 0;
    else if(0 === r[0]) var sr = 1; else var s = r[5], sr = s;
    var _bD_ = caml_call2(Base_Import[90], sl, sr);
    return [1, l, v, r, h, caml_call2(Base_Import[90], _bD_, 1)];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var k$0 = caml_call1(f, i); return [0, k$0];
        case 2:
         var
          kl = caml_call1(f, i),
          k$1 = caml_call1(f, caml_call2(Base_Import[90], i, 1));
         return create([0, kl], k$1, 0);
        default:
         var
          kl$0 = caml_call1(f, i),
          k$2 = caml_call1(f, caml_call2(Base_Import[90], i, 1)),
          kr = caml_call1(f, caml_call2(Base_Import[90], i, 2));
         return create([0, kl$0], k$2, [0, kr]);
      }
     var
      left_length = caml_call2(Base_Import[119], n, 1),
      _bB_ = caml_call2(Base_Import[92], n, left_length),
      right_length = caml_call2(Base_Import[92], _bB_, 1),
      left = loop(left_length, f, i),
      k = caml_call1(f, caml_call2(Base_Import[90], i, left_length)),
      _bC_ = caml_call2(Base_Import[90], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[90], _bC_, 1));
     return create(left, k, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_elt){
    var array_length = array.length - 1, switch$0 = 0;
    if(2 <= array_length){
     var _by_ = caml_check_bound(array, 1)[2];
     if(0 <= caml_call2(compare_elt, caml_check_bound(array, 0)[1], _by_)){
      var
       next =
         function(i){
          var
           _bz_ = caml_call2(Base_Import[92], array_length, 1),
           _bA_ = caml_call2(Base_Import[92], _bz_, i);
          return caml_check_bound(array, _bA_)[1 + _bA_];
         };
      switch$0 = 1;
     }
    }
    if(! switch$0)
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    return of_increasing_iterator_uncheck(array_length, next);
   }
   function of_sorted_array(array, compare_elt){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _bs_ = caml_check_bound(array, 1)[2],
                i =
                  caml_call2(compare_elt, caml_check_bound(array, 0)[1], _bs_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[36], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _bu_ = caml_call2(Base_Import[92], array.length - 1, 2),
                _bt_ = 1;
               if(_bu_ >= 1){
                var i$0 = _bt_;
                for(;;){
                 var
                  _bv_ = caml_call2(Base_Import[90], i$0, 1),
                  _bw_ = caml_check_bound(array, _bv_)[1 + _bv_],
                  i$1 =
                    caml_call2
                     (compare_elt, caml_check_bound(array, i$0)[1 + i$0], _bw_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_elements_a));
                 var _bx_ = i$0 + 1 | 0;
                 if(_bu_ !== i$0){var i$0 = _bx_; continue;}
                 break;
                }
               }
               return [0, of_sorted_array_unchecked(array, compare_elt)];
              });
    return [0, of_sorted_array_unchecked(array, compare_elt)];
   }
   function bal(l, v, r){
    if(typeof l === "number")
     var hl = 0;
    else if(0 === l[0]) var hl = 1; else var h$1 = l[4], hl = h$1;
    if(typeof r === "number")
     var hr = 0;
    else if(0 === r[0]) var hr = 1; else var h$0 = r[4], hr = h$0;
    if(caml_call2(Base_Import[90], hr, 2) < hl){
     if(typeof l === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
     var lr = l[3], lv = l[2], ll = l[1], _bl_ = height(lr);
     if(_bl_ <= height(ll)) return create(ll, lv, create(lr, v, r));
     if(typeof lr === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
     if(0 !== lr[0]){
      var lrr = lr[3], lrv$0 = lr[2], lrl = lr[1], _bn_ = create(lrr, v, r);
      return create(create(ll, lv, lrl), lrv$0, _bn_);
     }
     var lrv = lr[1];
     if(! is_empty(ll))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     var _bm_ = create(0, v, r);
     return create(create(ll, lv, 0), lrv, _bm_);
    }
    if(caml_call2(Base_Import[90], hl, 2) < hr){
     if(typeof r === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
     if(0 === r[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     var rr = r[3], rv = r[2], rl = r[1], _bo_ = height(rl);
     if(_bo_ <= height(rr)) return create(create(l, v, rl), rv, rr);
     if(typeof rl === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
     if(0 !== rl[0]){
      var rlr = rl[3], rlv$0 = rl[2], rll = rl[1], _bq_ = create(rlr, rv, rr);
      return create(create(l, v, rll), rlv$0, _bq_);
     }
     var rlv = rl[1];
     if(! is_empty(rr))
      throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     var _bp_ = create(0, rv, rr);
     return create(create(l, v, 0), rlv, _bp_);
    }
    var
     h =
       hr <= hl
        ? caml_call2(Base_Import[90], hl, 1)
        : caml_call2(Base_Import[90], hr, 1);
    if(typeof l === "number")
     var sl = 0;
    else if(0 === l[0]) var sl = 1; else var s$0 = l[5], sl = s$0;
    if(typeof r === "number")
     var sr = 0;
    else if(0 === r[0]) var sr = 1; else var s = r[5], sr = s;
    if(1 === h) return [0, v];
    var _br_ = caml_call2(Base_Import[90], sl, sr);
    return [1, l, v, r, h, caml_call2(Base_Import[90], _br_, 1)];
   }
   var Same = [248, cst_Base_Set_Tree0_Same, caml_fresh_oo_id(0)];
   function add(t, x, compare_elt){
    function aux(param){
     if(typeof param === "number") return [0, x];
     if(0 === param[0]){
      var v = param[1], c = caml_call2(compare_elt, x, v);
      if(0 === c) throw caml_maybe_attach_backtrace(Same, 1);
      return 0 <= c ? create(0, v, [0, x]) : create([0, x], v, 0);
     }
     var
      r = param[3],
      v$0 = param[2],
      l = param[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     if(0 === c$0) throw caml_maybe_attach_backtrace(Same, 1);
     return 0 <= c$0 ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
    }
    try{var _bj_ = aux(t); return _bj_;}
    catch(_bk_){
     var _bi_ = caml_wrap_exception(_bk_);
     if(_bi_ === Same) return t;
     throw caml_maybe_attach_backtrace(_bi_, 0);
    }
   }
   function join(l, v, r, compare_elt){
    if(typeof l === "number") return add(r, v, compare_elt);
    if(1 === l[0]){
     var lh = l[4], lr = l[3], lv$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){
       var rv = r[1];
       return add(add(l, v, compare_elt), rv, compare_elt);
      }
      var rh = r[4], rr = r[3], rv$0 = r[2], rl = r[1];
      return caml_call2(Base_Import[90], rh, 2) < lh
              ? bal(ll, lv$0, join(lr, v, r, compare_elt))
              : caml_call2
                 (Base_Import[90], lh, 2)
                < rh
                ? bal(join(l, v, rl, compare_elt), rv$0, rr)
                : create(l, v, r);
     }
    }
    if(typeof r === "number") return add(l, v, compare_elt);
    var lv = l[1];
    return add(add(r, v, compare_elt), lv, compare_elt);
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      var l = param$0[1];
      if(typeof l !== "number"){var param$0 = l; continue;}
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   var
    Set_min_elt_exn_of_empty_set =
      [248, cst_Base_Set_Tree0_Set_min_elt, caml_fresh_oo_id(0)];
   function _i_(param){
    if(param === Set_min_elt_exn_of_empty_set) return _j_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[70][1], 0, 0, Set_min_elt_exn_of_empty_set, _i_);
   var
    Set_max_elt_exn_of_empty_set =
      [248, cst_Base_Set_Tree0_Set_max_elt, caml_fresh_oo_id(0)];
   function _l_(param){
    if(param === Set_max_elt_exn_of_empty_set) return _m_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[70][1], 0, 0, Set_max_elt_exn_of_empty_set, _l_);
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_min_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function fold_until(t, init, f, finish){
    function fold_until_helper(f, t, acc){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var value = t$0[1];
       return caml_call2(f, acc$0, value);
      }
      var
       right = t$0[3],
       value$0 = t$0[2],
       left = t$0[1],
       x = fold_until_helper(f, left, acc$0);
      if(0 !== x[0]) return x;
      var acc$1 = x[1], x$0 = caml_call2(f, acc$1, value$0);
      if(0 !== x$0[0]) return x$0;
      var acc$2 = x$0[1], t$0 = right, acc$0 = acc$2;
     }
    }
    var match = fold_until_helper(f, t, init);
    if(0 === match[0]){var x = match[1]; return caml_call1(finish, x);}
    var x$0 = match[1];
    return x$0;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0])
      var v = param$0[1];
     else{
      if(typeof param$0[3] !== "number"){
       var r = param$0[3], param$0 = r;
       continue;
      }
      var v = param$0[2];
     }
     return [0, v];
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Set_max_elt_exn_of_empty_set, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(param){
    if(typeof param === "number")
     return caml_call1(Base_Import[125], cst_Set_remove_min_elt);
    if(0 === param[0]) return 0;
    var l = param[1];
    if(typeof l === "number"){var r = param[3]; return r;}
    var r$0 = param[3], v = param[2];
    return bal(remove_min_elt(l), v, r$0);
   }
   function merge(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var _bh_ = remove_min_elt(t2);
    return bal(t1, min_elt_exn(t2), _bh_);
   }
   function concat(t1, t2, compare_elt){
    if(typeof t1 === "number")
     var t = t2;
    else{
     if(typeof t2 !== "number"){
      var _bg_ = remove_min_elt(t2);
      return join(t1, min_elt_exn(t2), _bg_, compare_elt);
     }
     var t = t1;
    }
    return t;
   }
   function split(t, x, compare_elt){
    function split(t){
     if(typeof t === "number") return _o_;
     if(0 === t[0]){
      var v = t[1], c = caml_call2(compare_elt, x, v);
      return 0 === c
              ? [0, 0, [0, v], 0]
              : 0 <= c ? [0, [0, v], 0, 0] : [0, 0, 0, [0, v]];
     }
     var
      r = t[3],
      v$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_elt, x, v$0);
     if(0 === c$0) return [0, l, [0, v$0], r];
     if(0 <= c$0){
      var
       match = split(r),
       rr = match[3],
       maybe_elt = match[2],
       lr = match[1];
      return [0, join(l, v$0, lr, compare_elt), maybe_elt, rr];
     }
     var
      match$0 = split(l),
      rl = match$0[3],
      maybe_elt$0 = match$0[2],
      ll = match$0[1];
     return [0, ll, maybe_elt$0, join(rl, v$0, r, compare_elt)];
    }
    return split(t);
   }
   var empty_without_value_restrictio = 0;
   function mem(t, x, compare_elt){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[1], c = caml_call2(compare_elt, x, v);
      return 0 === c ? 1 : 0;
     }
     var
      r = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c$0 = caml_call2(compare_elt, x, v$0),
      _bf_ = 0 === c$0 ? 1 : 0;
     if(_bf_) return _bf_;
     var r$0 = 0 <= c$0 ? r : l, t$0 = r$0;
    }
   }
   function remove(t, x, compare_elt){
    function aux(t){
     if(typeof t === "number") throw caml_maybe_attach_backtrace(Same, 1);
     if(0 !== t[0]){
      var r = t[3], v$0 = t[2], l = t[1], c = caml_call2(compare_elt, x, v$0);
      return 0 === c
              ? merge(l, r)
              : 0 <= c ? bal(l, v$0, aux(r)) : bal(aux(l), v$0, r);
     }
     var v = t[1];
     if(0 === caml_call2(compare_elt, x, v)) return 0;
     throw caml_maybe_attach_backtrace(Same, 1);
    }
    try{var _bd_ = aux(t); return _bd_;}
    catch(_be_){
     var _bc_ = caml_wrap_exception(_be_);
     if(_bc_ === Same) return t;
     throw caml_maybe_attach_backtrace(_bc_, 0);
    }
   }
   function remove_index(t, i, param){
    function aux(t, i){
     if(typeof t === "number") throw caml_maybe_attach_backtrace(Same, 1);
     if(0 === t[0]){
      if(0 === i) return 0;
      throw caml_maybe_attach_backtrace(Same, 1);
     }
     var
      r = t[3],
      v = t[2],
      l = t[1],
      l_size = length(l),
      c = caml_int_compare(i, l_size);
     if(0 === c) return merge(l, r);
     if(0 > c) return bal(aux(l, i), v, r);
     var _bb_ = caml_call2(Base_Import[92], i, l_size);
     return bal(l, v, aux(r, caml_call2(Base_Import[92], _bb_, 1)));
    }
    try{var _a$_ = aux(t, i); return _a$_;}
    catch(_ba_){
     var _a__ = caml_wrap_exception(_ba_);
     if(_a__ === Same) return t;
     throw caml_maybe_attach_backtrace(_a__, 0);
    }
   }
   function union(s1, s2, compare_elt){
    function union(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(caml_call2(Base_Import[127], s1$0, s2$0)) return s1$0;
      var switch$0 = 0;
      if(typeof s1$0 === "number"){var t = s2$0; switch$0 = 1;
      }
      else if(1 === s1$0[0]){
       var h1 = s1$0[4], r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
       if(typeof s2$0 !== "number"){
        if(0 === s2$0[0]){
         var v2 = s2$0[1], s2$1 = [1, 0, v2, 0, 1, 1], s2$0 = s2$1;
         continue;
        }
        var h2 = s2$0[4], r2 = s2$0[3], v2$0 = s2$0[2], l2 = s2$0[1];
        if(h2 <= h1){
         if(1 === h2) return add(s1$0, v2$0, compare_elt);
         var
          match = split(s2$0, v1$0, compare_elt),
          r2$0 = match[3],
          l2$0 = match[1],
          _a8_ = union(r1, r2$0);
         return join(union(l1, l2$0), v1$0, _a8_, compare_elt);
        }
        if(1 === h1) return add(s2$0, v1$0, compare_elt);
        var
         match$0 = split(s1$0, v2$0, compare_elt),
         r1$0 = match$0[3],
         l1$0 = match$0[1],
         _a9_ = union(r1$0, r2);
        return join(union(l1$0, l2), v2$0, _a9_, compare_elt);
       }
      }
      if(! switch$0){
       if(typeof s2$0 !== "number"){
        var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1], s1$0 = s1$1;
        continue;
       }
       var t = s1$0;
      }
      return t;
     }
    }
    return union(s1, s2);
   }
   function union_list(comparator, to_tree, xs){
    var compare_elt = comparator[1];
    function _a7_(ac, x){
     return union(ac, caml_call1(to_tree, x), compare_elt);
    }
    return caml_call3(Base_List[10], xs, empty_without_value_restrictio, _a7_);
   }
   function inter(s1, s2, compare_elt){
    function inter(s1, s2){
     if(caml_call2(Base_Import[127], s1, s2)) return s1;
     if(typeof s1 !== "number" && typeof s2 !== "number"){
      var switch$0 = 0;
      if(typeof s1 !== "number" && 0 !== s1[0]){
       if(typeof s2 !== "number" && 0 !== s2[0]){
        var
         r1 = s1[3],
         v1 = s1[2],
         l1 = s1[1],
         _a4_ = split(s2, v1, compare_elt),
         match = _a4_[2],
         l2 = _a4_[1];
        if(match){
         var r2 = _a4_[3], v1$0 = match[1], _a5_ = inter(r1, r2);
         return join(inter(l1, l2), v1$0, _a5_, compare_elt);
        }
        var r2$0 = _a4_[3], _a6_ = inter(r1, r2$0);
        return concat(inter(l1, l2), _a6_, compare_elt);
       }
       var other_set = s1, singleton = s2, elt = s2[1];
       switch$0 = 1;
      }
      if(! switch$0) var other_set = s2, singleton = s1, elt = s1[1];
      return mem(other_set, elt, compare_elt) ? singleton : 0;
     }
     return 0;
    }
    return inter(s1, s2);
   }
   function diff(s1, s2, compare_elt){
    function diff(s1, s2){
     var s1$0 = s1;
     for(;;){
      if(caml_call2(Base_Import[127], s1$0, s2)) return 0;
      if(typeof s1$0 === "number") return 0;
      if(typeof s2 === "number") return s1$0;
      if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
       var
        r1 = s1$0[3],
        v1$0 = s1$0[2],
        l1 = s1$0[1],
        _a1_ = split(s2, v1$0, compare_elt),
        l2 = _a1_[1];
       if(_a1_[2]){
        var r2 = _a1_[3], _a2_ = diff(r1, r2);
        return concat(diff(l1, l2), _a2_, compare_elt);
       }
       var r2$0 = _a1_[3], _a3_ = diff(r1, r2$0);
       return join(diff(l1, l2), v1$0, _a3_, compare_elt);
      }
      var v1 = s1$0[1], s1$1 = [1, 0, v1, 0, 1, 1], s1$0 = s1$1;
     }
    }
    return diff(s1, s2);
   }
   function cons(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      e$1 = [0, v$0, r, e$0],
      s$0 = l,
      e$0 = e$1;
    }
   }
   function cons_right(s, e){
    var s$0 = s, e$0 = e;
    for(;;){
     if(typeof s$0 === "number") return e$0;
     if(0 === s$0[0]){var v = s$0[1]; return [0, v, 0, e$0];}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      e$1 = [0, v$0, l, e$0],
      s$0 = r,
      e$0 = e$1;
    }
   }
   function of_set(s){return cons(s, 0);}
   function iter(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var enum$0 = param$0[3], tree = param$0[2], a = param$0[1];
     caml_call1(f, a);
     var param$0 = cons(tree, enum$0);
    }
   }
   function symmetric_diff(t1, t2, compare_elt){
    function step(state){
     var left = state[1];
     if(! left){
      var match = state[2];
      if(! match) return 0;
      var enum$0 = match[3], tree = match[2], elt$0 = match[1];
      return [1, [1, elt$0], [0, 0, cons(tree, enum$0)]];
     }
     var right = state[2], enum1 = left[3], tree1 = left[2], elt = left[1];
     if(! right) return [1, [0, elt], [0, cons(tree1, enum1), 0]];
     var
      enum2 = right[3],
      tree2 = right[2],
      a2 = right[1],
      compare_result = caml_call2(compare_elt, elt, a2);
     if(0 !== compare_result)
      return 0 <= compare_result
              ? [1, [1, a2], [0, left, cons(tree2, enum2)]]
              : [1, [0, elt], [0, cons(tree1, enum1), right]];
     if(caml_call2(Base_Import[127], tree1, tree2))
      var next_state = [0, enum1, enum2];
     else
      var
       _a0_ = cons(tree2, enum2),
       next_state = [0, cons(tree1, enum1), _a0_];
     return [0, next_state];
    }
    var _aY_ = of_set(t2), _aZ_ = [0, of_set(t1), _aY_];
    return caml_call2(Base_Sequence[41], _aZ_, step);
   }
   function to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$3){
    if(opt) var sth = opt[1], order = sth; else var order = 608542111;
    function inclusive_bound(side, t, bound){
     var
      compare_elt = comparator[1],
      match = split(t, bound, compare_elt),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var elt = maybe[1];
     return add(t$0, elt, compare_elt);
    }
    if(608542111 <= order){
     var
      _aQ_ = Base_Import[124],
      _aR_ = function(_aW_, _aX_){return inclusive_bound(_aQ_, _aW_, _aX_);},
      t$4 = caml_call3(Base_Option[31], less_or_equal_to, t$3, _aR_),
      next =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[3], t = enum$0[2], k = enum$0[1];
         return [1, k, cons(t, e)];
        };
     if(greater_or_equal_to){
      var
       key = greater_or_equal_to[1],
       compare = comparator[1],
       t = t$4,
       e = 0;
      for(;;){
       if(typeof t !== "number"){
        if(0 === t[0]){
         var v = t[1], t$0 = [1, 0, v, 0, 1, 1], t = t$0;
         continue;
        }
        var l = t[1], r = t[3], v$0 = t[2];
        if(0 <= caml_call2(compare, v$0, key)){
         var r$0 = t[3], v$1 = t[2], e$0 = [0, v$1, r$0, e], t = l, e = e$0;
         continue;
        }
        var t = r;
        continue;
       }
       var init = e;
       break;
      }
     }
     else
      var init = of_set(t$4);
     return caml_call2(Base_Sequence[41], init, next);
    }
    var _aS_ = Base_Import[126];
    function _aT_(_aU_, _aV_){return inclusive_bound(_aS_, _aU_, _aV_);}
    var t$5 = caml_call3(Base_Option[31], greater_or_equal_to, t$3, _aT_);
    function next$0(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[3], t = enum$0[2], k = enum$0[1];
     return [1, k, cons_right(t, e)];
    }
    if(less_or_equal_to){
     var
      key$0 = less_or_equal_to[1],
      compare$0 = comparator[1],
      t$1 = t$5,
      e$1 = 0;
     for(;;){
      if(typeof t$1 !== "number"){
       if(0 === t$1[0]){
        var v$2 = t$1[1], t$2 = [1, 0, v$2, 0, 1, 1], t$1 = t$2;
        continue;
       }
       var l$0 = t$1[1], v$3 = t$1[2];
       if(0 < caml_call2(compare$0, v$3, key$0)){var t$1 = l$0; continue;}
       var
        r$1 = t$1[3],
        v$4 = t$1[2],
        e$2 = [0, v$4, l$0, e$1],
        t$1 = r$1,
        e$1 = e$2;
       continue;
      }
      var init$0 = e$1;
      break;
     }
    }
    else
     var init$0 = cons_right(t$5, 0);
    return caml_call2(Base_Sequence[41], init$0, next$0);
   }
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, v$0];
     }
     var t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, v$0];
     }
     var t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;})
               : find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) < 0 ? 1 : 0;})
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;})
               : find_first_satisfying
                 (t,
                  function(x){return 0 < caml_call2(compare, x, v) ? 1 : 0;});
    if(-1055410545 <= how){
     var
      elt =
        find_last_satisfying
         (t, function(x){return caml_call2(compare, x, v) <= 0 ? 1 : 0;});
     if(elt){var x = elt[1]; if(0 === caml_call2(compare, x, v)) return elt;}
     return 0;
    }
    var
     elt$0 =
       find_first_satisfying
        (t, function(x){return 0 <= caml_call2(compare, x, v) ? 1 : 0;});
    if(elt$0){
     var x$0 = elt$0[1];
     if(0 === caml_call2(compare, x$0, v)) return elt$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(x){
     return 847852583 <= caml_call1(segment_of, x) ? 1 : 0;
    }
    function is_right(x){return 1 - is_left(x);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function merge_to_sequence
   (comparator, opt, greater_or_equal_to, less_or_equal_to, t$0, t){
    if(opt) var sth = opt[1], order = sth; else var order = 608542111;
    var
     _aN_ =
       608542111 <= order
        ? comparator[1]
        : caml_call1(Base_Fn[6], comparator[1]),
     _aO_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t),
     _aP_ =
       to_sequence
        (comparator, [0, order], greater_or_equal_to, less_or_equal_to, t$0);
    return caml_call3(Base_Sequence[56], _aP_, _aO_, _aN_);
   }
   function compare(compare_elt, s1, s2){
    var e2$2 = of_set(s2), e1$2 = of_set(s1), e1 = e1$2, e2 = e2$2;
    for(;;){
     if(! e1) return e2 ? -1 : 0;
     if(! e2) return 1;
     var
      e2$0 = e2[3],
      r2 = e2[2],
      v2 = e2[1],
      e1$0 = e1[3],
      r1 = e1[2],
      v1 = e1[1],
      c = caml_call2(compare_elt, v1, v2);
     if(0 !== c) return c;
     if(caml_call2(Base_Import[127], r1, r2)){var e1 = e1$0, e2 = e2$0; continue;}
     var e2$1 = cons(r2, e2$0), e1$1 = cons(r1, e1$0), e1 = e1$1, e2 = e2$1;
    }
   }
   function iter2(s1, s2, compare_elt){
    var t2 = of_set(s2), t1 = of_set(s1);
    return function(f){
     var t1$0 = t1, t2$0 = t2;
     for(;;){
      if(! t1$0)
       return t2$0
               ? iter
                 (function(a){return caml_call1(f, [0, -57574468, a]);}, t2$0)
               : 0;
      if(! t2$0)
       return iter
               (function(a){return caml_call1(f, [0, 847852583, a]);}, t1$0);
      var
       enum2 = t2$0[3],
       tree2 = t2$0[2],
       a2 = t2$0[1],
       enum1 = t1$0[3],
       tree1 = t1$0[2],
       a1 = t1$0[1],
       compare_result = caml_call2(compare_elt, a1, a2);
      if(0 === compare_result){
       caml_call1(f, [0, 737457313, [0, a1, a2]]);
       var
        t2$1 = cons(tree2, enum2),
        t1$1 = cons(tree1, enum1),
        t1$0 = t1$1,
        t2$0 = t2$1;
       continue;
      }
      if(0 <= compare_result){
       caml_call1(f, [0, -57574468, a2]);
       var t2$2 = cons(tree2, enum2), t2$0 = t2$2;
       continue;
      }
      caml_call1(f, [0, 847852583, a1]);
      var t1$2 = cons(tree1, enum1), t1$0 = t1$2;
     }};
   }
   function equal(s1, s2, compare_elt){
    return 0 === compare(compare_elt, s1, s2) ? 1 : 0;
   }
   function is_subset(s1, s2, compare_elt){
    function is_subset(s1, s2){
     var s1$0 = s1, s2$0 = s2;
     for(;;){
      if(typeof s1$0 === "number") return 1;
      if(1 === s1$0[0]){
       var r1 = s1$0[3], v1$0 = s1$0[2], l1 = s1$0[1];
       if(typeof s2$0 !== "number"){
        if(0 === s2$0[0]){
         var v2 = s2$0[1];
         if(typeof l1 === "number" && typeof r1 === "number")
          return 0 === caml_call2(compare_elt, v1$0, v2) ? 1 : 0;
         return 0;
        }
        var
         r2 = s2$0[3],
         v2$0 = s2$0[2],
         l2 = s2$0[1],
         c = caml_call2(compare_elt, v1$0, v2$0);
        if(0 !== c){
         if(0 <= c){
          var _aL_ = is_subset([1, 0, v1$0, r1, 0, 0], r2);
          if(! _aL_) return _aL_;
          var s1$0 = l1;
          continue;
         }
         var _aM_ = is_subset([1, l1, v1$0, 0, 0, 0], l2);
         if(! _aM_) return _aM_;
         var s1$0 = r1;
         continue;
        }
        var _aI_ = caml_call2(Base_Import[127], s1$0, s2$0);
        if(_aI_)
         var _aJ_ = _aI_;
        else{
         var _aK_ = is_subset(l1, l2);
         if(_aK_){var s1$0 = r1, s2$0 = r2; continue;}
         var _aJ_ = _aK_;
        }
        return _aJ_;
       }
      }
      if(typeof s2$0 === "number") return 0;
      var v1 = s1$0[1];
      return mem(s2$0, v1, compare_elt);
     }
    }
    return is_subset(s1, s2);
   }
   function are_disjoint(s1, s2, compare_elt){
    var s1$0 = s1, s2$0 = s2;
    for(;;){
     if(typeof s1$0 !== "number" && typeof s2$0 !== "number"){
      var switch$0 = 0;
      if(typeof s1$0 !== "number" && 0 !== s1$0[0]){
       if(typeof s2$0 !== "number" && 0 !== s2$0[0]){
        var r1 = s1$0[3], v1 = s1$0[2], l1 = s1$0[1];
        if(caml_call2(Base_Import[127], s1$0, s2$0)) return 0;
        var _aG_ = split(s2$0, v1, compare_elt), l2 = _aG_[1];
        if(_aG_[2]) return 0;
        var r2 = _aG_[3], _aH_ = are_disjoint(l1, l2, compare_elt);
        if(! _aH_) return _aH_;
        var s1$0 = r1, s2$0 = r2;
        continue;
       }
       var other_set = s1$0, elt = s2$0[1];
       switch$0 = 1;
      }
      if(! switch$0) var other_set = s2$0, elt = s1$0[1];
      return 1 - mem(other_set, elt, compare_elt);
     }
     return 1;
    }
   }
   function iter$0(t, f){
    function iter(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return 0;
      if(0 === param$0[0]){var v = param$0[1]; return caml_call1(f, v);}
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      iter(l);
      caml_call1(f, v$0);
      var param$0 = r;
     }
    }
    return iter(t);
   }
   function fold(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, accu$0, v);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, fold(l, accu$0, f), v$0),
      s$0 = r,
      accu$0 = accu$1;
    }
   }
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function fold_right(s, accu, f){
    var s$0 = s, accu$0 = accu;
    for(;;){
     if(typeof s$0 === "number") return accu$0;
     if(0 === s$0[0]){var v = s$0[1]; return caml_call2(f, v, accu$0);}
     var
      r = s$0[3],
      v$0 = s$0[2],
      l = s$0[1],
      accu$1 = caml_call2(f, v$0, fold_right(r, accu$0, f)),
      s$0 = l,
      accu$0 = accu$1;
    }
   }
   function for_all(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _aD_ = caml_call1(p, v$0);
     if(_aD_){
      var _aE_ = for_all(l, p);
      if(_aE_){var t$0 = r; continue;}
      var _aF_ = _aE_;
     }
     else
      var _aF_ = _aD_;
     return _aF_;
    }
   }
   function exists(t, p){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(p, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], _aA_ = caml_call1(p, v$0);
     if(_aA_)
      var _aB_ = _aA_;
     else{
      var _aC_ = exists(l, p);
      if(! _aC_){var t$0 = r; continue;}
      var _aB_ = _aC_;
     }
     return _aB_;
    }
   }
   function filter(s, p, compare_elt){
    function filt(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1];
       return caml_call1(p, v) ? add(accu$0, v, compare_elt) : accu$0;
      }
      var
       r = param$0[3],
       v$0 = param$0[2],
       l = param$0[1],
       _az_ = caml_call1(p, v$0) ? add(accu$0, v$0, compare_elt) : accu$0,
       accu$1 = filt(_az_, l),
       accu$0 = accu$1,
       param$0 = r;
     }
    }
    return filt(0, s);
   }
   function filter_map(s, p, compare_elt){
    function filt(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1], match = caml_call1(p, v);
       if(! match) return accu$0;
       var v$0 = match[1];
       return add(accu$0, v$0, compare_elt);
      }
      var
       r = param$0[3],
       v$1 = param$0[2],
       l = param$0[1],
       match$0 = caml_call1(p, v$1);
      if(match$0)
       var v$2 = match$0[1], _ay_ = add(accu$0, v$2, compare_elt);
      else
       var _ay_ = accu$0;
      var accu$1 = filt(_ay_, l), accu$0 = accu$1, param$0 = r;
     }
    }
    return filt(0, s);
   }
   function partition_tf(s, p, compare_elt){
    function part(accu, param){
     var accu$0 = accu, param$0 = param;
     for(;;){
      var f = accu$0[2], t = accu$0[1];
      if(typeof param$0 === "number") return accu$0;
      if(0 === param$0[0]){
       var v = param$0[1];
       return caml_call1(p, v)
               ? [0, add(t, v, compare_elt), f]
               : [0, t, add(f, v, compare_elt)];
      }
      var
       r = param$0[3],
       v$0 = param$0[2],
       l = param$0[1],
       _ax_ =
         caml_call1(p, v$0)
          ? [0, add(t, v$0, compare_elt), f]
          : [0, t, add(f, v$0, compare_elt)],
       accu$1 = part(_ax_, l),
       accu$0 = accu$1,
       param$0 = r;
     }
    }
    return part(_p_, s);
   }
   function elements_aux(accu, param){
    var accu$0 = accu, param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return accu$0;
     if(0 === param$0[0]){var v = param$0[1]; return [0, v, accu$0];}
     var
      r = param$0[3],
      v$0 = param$0[2],
      l = param$0[1],
      accu$1 = [0, v$0, elements_aux(accu$0, r)],
      accu$0 = accu$1,
      param$0 = l;
    }
   }
   function elements(s){return elements_aux(0, s);}
   function choose(t){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var v = t[1]; return [0, v];}
    var v$0 = t[2];
    return [0, v$0];
   }
   var not_found = [0, Base_Import[251], _q_];
   function choose_exn(t){
    var match = choose(t);
    if(! match) throw caml_maybe_attach_backtrace(not_found, 1);
    var v = match[1];
    return v;
   }
   function of_list(lst, compare_elt){
    function _aw_(t, x){return add(t, x, compare_elt);}
    return caml_call3
            (Base_List[10], lst, empty_without_value_restrictio, _aw_);
   }
   function of_sequence(sequence, compare_elt){
    function _av_(t, x){return add(t, x, compare_elt);}
    return caml_call3
            (Base_Sequence[8], sequence, empty_without_value_restrictio, _av_);
   }
   function to_list(s){return elements(s);}
   function of_array(a, compare_elt){
    function _au_(t, x){return add(t, x, compare_elt);}
    return caml_call3(Base_Array[10], a, empty_without_value_restrictio, _au_);
   }
   function to_array(param){
    if(typeof param === "number") return [0];
    if(0 === param[0]){var v = param[1]; return [0, v];}
    var
     s = param[5],
     r = param[3],
     v$0 = param[2],
     l = param[1],
     res = caml_call2(Base_Array[25], s, v$0),
     pos_ref = [0, 0];
    function loop(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return 0;
      if(0 === param$0[0]){
       var v = param$0[1], _as_ = pos_ref[1];
       caml_check_bound(res, _as_)[1 + _as_] = v;
       return caml_call1(Base_Import[129], pos_ref);
      }
      var r = param$0[3], v$0 = param$0[2], l = param$0[1];
      loop(l);
      var _at_ = pos_ref[1];
      caml_check_bound(res, _at_)[1 + _at_] = v$0;
      caml_call1(Base_Import[129], pos_ref);
      var param$0 = r;
     }
    }
    loop(l);
    caml_call1(Base_Import[129], pos_ref);
    loop(r);
    return res;
   }
   function map(t, f, compare_elt){
    return fold
            (t,
             empty_without_value_restrictio,
             function(t, x){return add(t, caml_call1(f, x), compare_elt);});
   }
   function group_by(set, equiv, compare_elt){
    var set$0 = set, equiv_classes = 0;
    for(;;){
     if(is_empty(set$0)) return equiv_classes;
     var
      x = choose_exn(set$0),
      match =
        partition_tf
         (set$0,
          function(x){
            return function(elt){
             var _ar_ = caml_call2(Base_Import[127], x, elt);
             return _ar_ ? _ar_ : caml_call2(equiv, x, elt);};
           }
           (x),
          compare_elt),
      not_equiv_x = match[2],
      equiv_x = match[1],
      equiv_classes$0 = [0, equiv_x, equiv_classes],
      set$0 = not_equiv_x,
      equiv_classes = equiv_classes$0;
    }
   }
   function find(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v) ? [0, v] : 0;}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(caml_call1(f, v$0)) return [0, v$0];
     var r$0 = find(l, f);
     if(r$0) return r$0;
     var t$0 = r;
    }
   }
   function find_map(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[3], v$0 = t$0[2], l = t$0[1], r$0 = caml_call1(f, v$0);
     if(r$0) return r$0;
     var r$1 = find_map(l, f);
     if(r$1) return r$1;
     var t$0 = r;
    }
   }
   function find_exn(t, f){
    var match = find(t, f);
    if(! match)
     return caml_call1(Base_Import[123], cst_Set_find_exn_failed_to_fin);
    var e = match[1];
    return e;
   }
   function nth(t, i){
    var t$0 = t, i$0 = i;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return 0 === i$0 ? [0, v] : 0;}
     var s = t$0[5], r = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(s <= i$0) return 0;
     var l_size = length(l), c = caml_int_compare(i$0, l_size);
     if(0 > c){var t$0 = l; continue;}
     if(0 === c) return [0, v$0];
     var
      _aq_ = caml_call2(Base_Import[92], i$0, l_size),
      i$1 = caml_call2(Base_Import[92], _aq_, 1),
      t$0 = r,
      i$0 = i$1;
    }
   }
   function stable_dedup_list(xs, compare_elt){
    var
     xs$0 = xs,
     leftovers = 0,
     already_seen = empty_without_value_restrictio;
    for(;;){
     if(! xs$0) return caml_call1(Base_List[38], leftovers);
     var tl = xs$0[2], hd = xs$0[1];
     if(mem(already_seen, hd, compare_elt)){var xs$0 = tl; continue;}
     var
      already_seen$0 = add(already_seen, hd, compare_elt),
      leftovers$0 = [0, hd, leftovers],
      xs$0 = tl,
      leftovers = leftovers$0,
      already_seen = already_seen$0;
    }
   }
   function t_of_sexp_direct(a_of_sexp, sexp, compare_elt){
    if(0 === sexp[0])
     return caml_call2(Base_Import[158], cst_Set_t_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     elt_lst = caml_call2(Base_List[76], lst, a_of_sexp),
     set = of_list(elt_lst, compare_elt),
     _ao_ = caml_call1(Base_List[7], lst);
    if(length(set) === _ao_) return set;
    var set$0 = [0, empty_without_value_restrictio];
    function _ap_(el_sexp, el){
     return mem(set$0[1], el, compare_elt)
             ? caml_call2
               (Base_Import[158], cst_Set_t_of_sexp_duplicate_el, el_sexp)
             : (set$0[1] = add(set$0[1], el, compare_elt), 0);
    }
    caml_call3(Base_List[42], lst, elt_lst, _ap_);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
   }
   function sexp_of_t(sexp_of_a, t){
    return [1,
            fold_right
             (t,
              0,
              function(el, acc){return [0, caml_call1(sexp_of_a, el), acc];})];
   }
   function is_subset$0(subset, superset, sexp_of_elt, compare_elt){
    var invalid_elements = diff(subset[1], superset[1], compare_elt);
    if(is_empty(invalid_elements)) return _s_;
    var
     invalid_elements_sexp = sexp_of_t(sexp_of_elt, invalid_elements),
     _al_ = caml_call2(Base_Import[111], cst_is_not_a_subset_of, superset[2]),
     _am_ = caml_call2(Base_Import[111], subset[2], _al_),
     _an_ =
       caml_call2
        (Base_Sexp[9],
         _am_,
         [0, [0, cst_invalid_elements, invalid_elements_sexp], 0]);
    return caml_call1(Base_Or_error[35], _an_);
   }
   function like(param, tree){
    var comparator = param[1];
    return [0, comparator, tree];
   }
   function compare_elt(t){return t[1][1];}
   function comparator(t){return t[1];}
   function invariants$0(t){
    var _ak_ = compare_elt(t);
    return invariants(t[2], _ak_);
   }
   function length$0(t){return length(t[2]);}
   function is_empty$0(t){return is_empty(t[2]);}
   function elements$0(t){return elements(t[2]);}
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function choose$0(t){return choose(t[2]);}
   function choose_exn$0(t){return choose_exn(t[2]);}
   function to_list$0(t){return to_list(t[2]);}
   function to_array$0(t){return to_array(t[2]);}
   function fold$0(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f){
    var _ai_ = t[2];
    return function(_aj_){return fold_until(_ai_, init, f, _aj_);};
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold$0, init, f, t);
   }
   function iter$1(t, f){return iter$0(t[2], f);}
   function iter2$0(a, b, f){
    var _ah_ = compare_elt(a);
    return caml_call1(iter2(a[2], b[2], _ah_), f);
   }
   function exists$0(t, f){return exists(t[2], f);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function sum$0(m, t, f){return sum(m, t[2], f);}
   function find$0(t, f){return find(t[2], f);}
   function find_exn$0(t, f){return find_exn(t[2], f);}
   function find_map$0(t, f){return find_map(t[2], f);}
   function mem$0(t, a){var _ag_ = compare_elt(t); return mem(t[2], a, _ag_);}
   function filter$0(t, f){
    var _af_ = compare_elt(t);
    return like(t, filter(t[2], f, _af_));
   }
   function add$0(t, a){
    var _ae_ = compare_elt(t);
    return like(t, add(t[2], a, _ae_));
   }
   function remove$0(t, a){
    var _ad_ = compare_elt(t);
    return like(t, remove(t[2], a, _ad_));
   }
   function union$0(t1, t2){
    var _ac_ = compare_elt(t1);
    return like(t1, union(t1[2], t2[2], _ac_));
   }
   function inter$0(t1, t2){
    var _ab_ = compare_elt(t1);
    return like(t1, inter(t1[2], t2[2], _ab_));
   }
   function diff$0(t1, t2){
    var _aa_ = compare_elt(t1);
    return like(t1, diff(t1[2], t2[2], _aa_));
   }
   function symmetric_diff$0(t1, t2){
    var _$_ = compare_elt(t1);
    return symmetric_diff(t1[2], t2[2], _$_);
   }
   function compare_direct(t1, t2){
    var _Z_ = t2[2], ___ = t1[2];
    return compare(compare_elt(t1), ___, _Z_);
   }
   function equal$0(t1, t2){
    var _Y_ = compare_elt(t1);
    return equal(t1[2], t2[2], _Y_);
   }
   function is_subset$1(t, of){
    var _X_ = compare_elt(t);
    return is_subset(t[2], of[2], _X_);
   }
   function are_disjoint$0(t1, t2){
    var _W_ = compare_elt(t1);
    return are_disjoint(t1[2], t2[2], _W_);
   }
   function to_named_tree(param){
    var name = param[2], set = param[1];
    return [0, set[2], name];
   }
   function is_subset$2(subset, superset){
    var
     _T_ = compare_elt(subset[1]),
     _U_ = subset[1][1][2],
     _V_ = to_named_tree(superset);
    return is_subset$0(to_named_tree(subset), _V_, _U_, _T_);
   }
   function equal$1(t1, t2){
    var
     _R_ = [0, is_subset$2(t2, t1), 0],
     _S_ = [0, is_subset$2(t1, t2), _R_];
    return caml_call1(Base_Or_error[47], _S_);
   }
   function partition_tf$0(t, f){
    var
     _P_ = compare_elt(t),
     match = partition_tf(t[2], f, _P_),
     tree_f = match[2],
     tree_t = match[1],
     _Q_ = like(t, tree_f);
    return [0, like(t, tree_t), _Q_];
   }
   function split$0(t, a){
    var
     _N_ = compare_elt(t),
     match = split(t[2], a, _N_),
     tree2 = match[3],
     b = match[2],
     tree1 = match[1],
     _O_ = like(t, tree2);
    return [0, like(t, tree1), b, _O_];
   }
   function group_by$0(t, equiv){
    function _J_(_M_){return like(t, _M_);}
    var _K_ = compare_elt(t), _L_ = group_by(t[2], equiv, _K_);
    return caml_call2(Base_List[76], _L_, _J_);
   }
   function nth$0(t, i){return nth(t[2], i);}
   function remove_index$0(t, i){
    var _I_ = compare_elt(t);
    return like(t, remove_index(t[2], i, _I_));
   }
   function sexp_of_t$0(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t[2]);
   }
   function to_sequence$0(order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (t[1], order, greater_or_equal_to, less_or_equal_to, t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function merge_to_sequence$0
   (order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (t$0[1],
             order,
             greater_or_equal_to,
             less_or_equal_to,
             t$0[2],
             t[2]);
   }
   function hash_fold_direct(hash_fold_elem, state, t){
    var t$0 = t[2], _H_ = length(t$0);
    return fold(t$0, caml_call2(Base_Import[206], state, _H_), hash_fold_elem);
   }
   function compare$0(param, _G_, t1, t2){return compare_direct(t1, t2);}
   function t_of_sexp_direct$0(comparator, a_of_sexp, sexp){
    return t_of_sexp_direct(a_of_sexp, sexp, comparator[1]);
   }
   function empty(param){return empty_without_value_restrictio;}
   function singleton(param, e){return [0, e];}
   function length$1(t){return length(t);}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function elements$1(t){return elements(t);}
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function choose$1(t){return choose(t);}
   function choose_exn$1(t){return choose_exn(t);}
   function to_list$1(t){return to_list(t);}
   function to_array$1(t){return to_array(t);}
   function iter$2(t, f){return iter$0(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function for_all$1(t, f){return for_all(t, f);}
   function count$1(t, f){return count(t, f);}
   function sum$1(m, t, f){return sum(m, t, f);}
   function find$1(t, f){return find(t, f);}
   function find_exn$1(t, f){return find_exn(t, f);}
   function find_map$1(t, f){return find_map(t, f);}
   function fold$1(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f){
    return function(_F_){return fold_until(t, init, f, _F_);};
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function map$0(comparator, t, f){return map(t, f, comparator[1]);}
   function filter$1(comparator, t, f){return filter(t, f, comparator[1]);}
   function filter_map$0(comparator, t, f){
    return filter_map(t, f, comparator[1]);
   }
   function partition_tf$1(comparator, t, f){
    return partition_tf(t, f, comparator[1]);
   }
   function iter2$1(comparator, a, b, f){
    return caml_call1(iter2(a, b, comparator[1]), f);
   }
   function mem$1(comparator, t, a){return mem(t, a, comparator[1]);}
   function add$1(comparator, t, a){return add(t, a, comparator[1]);}
   function remove$1(comparator, t, a){return remove(t, a, comparator[1]);}
   function union$1(comparator, t1, t2){return union(t1, t2, comparator[1]);}
   function inter$1(comparator, t1, t2){return inter(t1, t2, comparator[1]);}
   function diff$1(comparator, t1, t2){return diff(t1, t2, comparator[1]);}
   function symmetric_diff$1(comparator, t1, t2){
    return symmetric_diff(t1, t2, comparator[1]);
   }
   function compare_direct$0(comparator, t1, t2){return compare(comparator[1], t1, t2);
   }
   function equal$2(comparator, t1, t2){return equal(t1, t2, comparator[1]);}
   function is_subset$3(comparator, t, of){
    return is_subset(t, of, comparator[1]);
   }
   function are_disjoint$1(comparator, t1, t2){
    return are_disjoint(t1, t2, comparator[1]);
   }
   function of_list$0(comparator, l){return of_list(l, comparator[1]);}
   function of_sequence$0(comparator, s){
    return of_sequence(s, comparator[1]);
   }
   function of_array$0(comparator, a){return of_array(a, comparator[1]);}
   function of_sorted_array_unchecked$0(comparator, a){
    return of_sorted_array_unchecked(a, comparator[1]);
   }
   function of_increasing_iterator_uncheck$0(param, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_sorted_array$0(comparator, a){
    return of_sorted_array(a, comparator[1]);
   }
   function union_list$0(comparator, l){
    return union_list(comparator, function(_E_){return _E_;}, l);
   }
   function stable_dedup_list$0(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function group_by$1(comparator, t, equiv){
    return group_by(t, equiv, comparator[1]);
   }
   function split$1(comparator, t, a){return split(t, a, comparator[1]);}
   function nth$1(t, i){return nth(t, i);}
   function remove_index$1(comparator, t, i){
    return remove_index(t, i, comparator[1]);
   }
   function sexp_of_t$1(sexp_of_a, param, t){return sexp_of_t(sexp_of_a, t);}
   function to_tree(t){return t;}
   function of_tree(param, t){return t;}
   function to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t){
    return to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function merge_to_sequence$1
   (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t){
    return merge_to_sequence
            (comparator, order, greater_or_equal_to, less_or_equal_to, t$0, t);
   }
   function fold_result$0(t, init, f){
    return caml_call4(Base_Container[8], fold$1, init, f, t);
   }
   function is_subset$4(comparator, t1, t2){
    return is_subset$0(t1, t2, comparator[2], comparator[1]);
   }
   function equal$3(comparator, t1, t2){
    var
     compare_elt = comparator[1],
     sexp_of_elt = comparator[2],
     _C_ = [0, is_subset$0(t2, t1, sexp_of_elt, compare_elt), 0],
     _D_ = [0, is_subset$0(t1, t2, sexp_of_elt, compare_elt), _C_];
    return caml_call1(Base_Or_error[47], _D_);
   }
   var Named = [0, is_subset$4, equal$3];
   function to_tree$0(t){return t[2];}
   function of_tree$0(comparator, tree){return [0, comparator, tree];}
   function t_of_sexp_direct$1(comparator, a_of_sexp, sexp){
    return [0, comparator, t_of_sexp_direct(a_of_sexp, sexp, comparator[1])];
   }
   function empty$0(comparator){
    return [0, comparator, empty_without_value_restrictio];
   }
   function Empty_without_value_restrictio(Elt){
    var empty = [0, Elt[1], empty_without_value_restrictio];
    return [0, empty];
   }
   function singleton$0(comparator, e){return [0, comparator, [0, e]];}
   function union_list$1(comparator, l){
    return [0, comparator, union_list(comparator, to_tree$0, l)];
   }
   function of_sorted_array_unchecked$1(comparator, array){
    var tree = of_sorted_array_unchecked(array, comparator[1]);
    return [0, comparator, tree];
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    return [0, comparator, of_increasing_iterator_uncheck(len, f)];
   }
   function of_sorted_array$1(comparator, array){
    function _A_(tree){return [0, comparator, tree];}
    var _B_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[18][2], _B_, _A_);
   }
   function of_list$1(comparator, l){
    return [0, comparator, of_list(l, comparator[1])];
   }
   function of_sequence$1(comparator, s){
    return [0, comparator, of_sequence(s, comparator[1])];
   }
   function of_array$1(comparator, a){
    return [0, comparator, of_array(a, comparator[1])];
   }
   function stable_dedup_list$1(comparator, xs){
    return stable_dedup_list(xs, comparator[1]);
   }
   function map$1(comparator, t, f){
    return [0, comparator, map(t[2], f, comparator[1])];
   }
   function filter_map$1(comparator, t, f){
    return [0, comparator, filter_map(t[2], f, comparator[1])];
   }
   function comparator_s(t){var comparator = t[1]; return [0, comparator];}
   function empty$1(m){return empty$0(m[1]);}
   function singleton$1(m, a){return singleton$0(m[1], a);}
   function union_list$2(m, a){return union_list$1(m[1], a);}
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(m[1], a);
   }
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1(m[1], len, f);
   }
   function of_sorted_array$2(m, a){return of_sorted_array$1(m[1], a);}
   function of_list$2(m, a){return of_list$1(m[1], a);}
   function of_sequence$2(m, a){return of_sequence$1(m[1], a);}
   function of_array$2(m, a){return of_array$1(m[1], a);}
   function stable_dedup_list$2(m, a){return stable_dedup_list$1(m[1], a);}
   function map$2(m, a, f){return map$1(m[1], a, f);}
   function filter_map$2(m, a, f){return filter_map$1(m[1], a, f);}
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt){
    return function(t){
     function _z_(param){return _t_;}
     return sexp_of_t$0(Elt[1], _z_, t);};
   }
   function m_t_of_sexp(Elt){
    return function(sexp){return t_of_sexp_direct$1(Elt[2], Elt[1], sexp);};
   }
   function m_t_sexp_grammar(Elt){
    var _y_ = caml_call1(Base_Import[194], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _y_);
   }
   function compare_m_t(param, t1, t2){return compare_direct(t1, t2);}
   function equal_m_t(param, t1, t2){return equal$0(t1, t2);}
   function hash_fold_m_t(Elt){
    return function(state){
     var _w_ = Elt[1];
     return function(_x_){return hash_fold_direct(_w_, state, _x_);};};
   }
   function hash_m_t(folder, t){
    var
     _v_ = caml_call2(Base_Hash[11], 0, 0),
     state = caml_call2(hash_fold_m_t(folder), _v_, t);
    return caml_call1(Base_Hash[9], state);
   }
   var
    comparator$0 = Base_Comparator[2][1],
    include = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$2 = include[1];
   function singleton$2(a){return singleton$0(comparator$0, a);}
   function union_list$3(a){return union_list$1(comparator$0, a);}
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_list$3(a){return of_list$1(comparator$0, a);}
   function of_sequence$3(a){return of_sequence$1(comparator$0, a);}
   function of_array$3(a){return of_array$1(comparator$0, a);}
   function stable_dedup_list$3(a){
    return stable_dedup_list$1(comparator$0, a);
   }
   function map$3(a, f){return map$1(comparator$0, a, f);}
   function filter_map$3(a, f){return filter_map$1(comparator$0, a, f);}
   function of_tree$1(tree){return [0, comparator$0, tree];}
   function to_tree$1(t){return t[2];}
   var
    _u_ = Base_Sequence[55],
    Base_Set =
      [0,
       compare$0,
       invariants$0,
       comparator_s,
       comparator,
       empty$1,
       singleton$1,
       length$0,
       is_empty$0,
       mem$0,
       add$0,
       remove$0,
       union$0,
       union_list$2,
       inter$0,
       diff$0,
       symmetric_diff$0,
       compare_direct,
       hash_fold_direct,
       equal$0,
       exists$0,
       for_all$0,
       count$0,
       sum$0,
       find$0,
       find_map$0,
       find_exn$0,
       nth$0,
       remove_index$0,
       is_subset$1,
       are_disjoint$0,
       [0, is_subset$2, equal$1],
       of_list$2,
       of_sequence$2,
       of_array$2,
       to_list$0,
       to_array$0,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       stable_dedup_list$2,
       map$2,
       filter_map$2,
       filter$0,
       fold$0,
       fold_result,
       fold_until$0,
       fold_right$0,
       iter$1,
       iter2$0,
       partition_tf$0,
       elements$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       choose$0,
       choose_exn$0,
       split$0,
       group_by$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       [0, _u_[1], _u_[3], _u_[4]],
       merge_to_sequence$0,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       hash_m_t,
       [0,
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list$0,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$1,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$2,
        singleton$2,
        union_list$3,
        of_list$3,
        of_sequence$3,
        of_array$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        stable_dedup_list$3,
        map$3,
        filter_map$3,
        of_tree$1],
       [0,
        sexp_of_t$0,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$1,
         t_of_sexp_direct$0,
         Named,
         length$1,
         is_empty$1,
         iter$2,
         fold$1,
         fold_result$0,
         exists$1,
         for_all$1,
         count$1,
         sum$1,
         find$1,
         find_map$1,
         to_list$1,
         to_array$1,
         invariants$1,
         mem$1,
         add$1,
         remove$1,
         union$1,
         inter$1,
         diff$1,
         symmetric_diff$1,
         compare_direct$0,
         equal$2,
         is_subset$3,
         are_disjoint$1,
         fold_until$1,
         fold_right$1,
         iter2$1,
         filter$1,
         partition_tf$1,
         elements$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         choose$1,
         choose_exn$1,
         split$1,
         group_by$1,
         find_exn$1,
         nth$1,
         remove_index$1,
         to_tree,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         merge_to_sequence$1,
         empty,
         singleton,
         union_list$0,
         of_list$0,
         of_sequence$0,
         of_array$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         stable_dedup_list$0,
         map$0,
         filter_map$0,
         of_tree,
         empty_without_value_restrictio],
        length$0,
        is_empty$0,
        iter$1,
        fold$0,
        fold_result,
        exists$0,
        for_all$0,
        count$0,
        sum$0,
        find$0,
        find_map$0,
        to_list$0,
        to_array$0,
        invariants$0,
        mem$0,
        add$0,
        remove$0,
        union$0,
        inter$0,
        diff$0,
        symmetric_diff$0,
        compare_direct,
        equal$0,
        is_subset$1,
        are_disjoint$0,
        [0, is_subset$2, equal$1],
        fold_until$0,
        fold_right$0,
        iter2$0,
        filter$0,
        partition_tf$0,
        elements$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        choose$0,
        choose_exn$0,
        split$0,
        group_by$0,
        find_exn$0,
        nth$0,
        remove_index$0,
        to_tree$0,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        merge_to_sequence$0,
        empty$0,
        singleton$0,
        union_list$1,
        of_list$1,
        of_sequence$1,
        of_array$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        stable_dedup_list$1,
        map$1,
        filter_map$1,
        of_tree$0,
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio]];
   runtime.caml_register_global(45, Base_Set, "Base__Set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Ref
//# unitInfo: Requires: Base__Exn, Base__Import, Base__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Exn = global_data.Base__Exn,
    Base_List = global_data.Base__List,
    Base_Import = global_data.Base__Import,
    compare = Base_Import[237],
    equal = Base_Import[250],
    t_of_sexp = Base_Import[170],
    sexp_of_t = Base_Import[146];
   function t_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Import[191], a_sexp_grammar);
   }
   function swap(t1, t2){
    var tmp = t1[1];
    t1[1] = t2[1];
    t2[1] = tmp;
    return 0;
   }
   function replace(t, f){t[1] = caml_call1(f, t[1]); return 0;}
   function set_temporarily(t, a, f){
    var restore_to = t[1];
    t[1] = a;
    function _b_(param){t[1] = restore_to; return 0;}
    return caml_call2(Base_Exn[13], f, _b_);
   }
   function set(param){var a = param[2], r = param[1]; r[1] = a; return 0;}
   function sets(ts){return caml_call2(Base_List[9], ts, set);}
   function snapshot(param){var r = param[1]; return [0, r, r[1]];}
   function sets_temporarily(and_values, f){
    var restore_to = caml_call2(Base_List[76], and_values, snapshot);
    sets(and_values);
    function _a_(param){return sets(restore_to);}
    return caml_call2(Base_Exn[13], f, _a_);
   }
   var
    Base_Ref =
      [0,
       compare,
       equal,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       swap,
       replace,
       set_temporarily,
       [0, set, sets, snapshot],
       sets_temporarily];
   runtime.caml_register_global(3, Base_Ref, "Base__Ref");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Queue_intf = [0];
   runtime.caml_register_global(0, Base_Queue_intf, "Base__Queue_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Queue
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Error, Base__Import, Base__Indexed_container, Base__Int, Base__List, Base__Option_array, Base__Sexp, Sexplib0__Sexp_grammar, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_length$2 = "length",
    cst_src_queue_ml = "src/queue.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Option_array = global_data.Base__Option_array,
    Base_Array = global_data.Base__Array,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Base_Indexed_container = global_data.Base__Indexed_container,
    cst_length$1 = cst_length$2,
    cst_Queue_init_negative_length = "Queue.init: negative length",
    _p_ = [0, cst_src_queue_ml, 451, 2],
    cst_length$0 = cst_length$2,
    cst_Queue_blit_transfer_negati = "Queue.blit_transfer: negative length",
    _o_ = [0, cst_src_queue_ml, 193, 2],
    cst_capacity = "capacity",
    cst_cannot_have_queue_with_neg =
      "cannot have queue with negative capacity",
    _n_ = [0, cst_src_queue_ml, 152, 2],
    _m_ = [0, cst_src_queue_ml, 153, 2],
    _l_ = [0, cst_src_queue_ml, 155, 2],
    _k_ = [0, cst_src_queue_ml, 156, 2],
    _j_ = [0, cst_src_queue_ml, 157, 2],
    _i_ = [0, cst_src_queue_ml, 158, 2],
    _h_ = [0, cst_src_queue_ml, 159, 2],
    _g_ = [0, cst_src_queue_ml, 165, 9],
    _f_ = [0, "_"],
    cst_mutation_of_queue_during_i = "mutation of queue during iteration",
    cst_length = cst_length$2,
    cst_index = "index",
    cst_Queue_index_out_of_bounds = "Queue index out of bounds",
    _a_ = [0, "elts"],
    _b_ = [0, cst_length$2],
    _c_ = [0, "mask"],
    _d_ = [0, "front"],
    _e_ = [0, "num_mutations"];
   function inc_num_mutations(t){
    t[1] = caml_call2(Base_Import[90], t[1], 1);
    return 0;
   }
   function capacity(t){return caml_call2(Base_Import[90], t[3], 1);}
   function elts_index(t, i){
    var _a3_ = t[3], _a4_ = caml_call2(Base_Import[90], t[2], i);
    return caml_call2(Base_Import[115], _a4_, _a3_);
   }
   function unsafe_get(t, i){
    var _a2_ = elts_index(t, i);
    return caml_call2(Base_Option_array[38], t[5], _a2_);
   }
   function unsafe_set(t, i, a){
    var _a1_ = elts_index(t, i);
    return caml_call3(Base_Option_array[49], t[5], _a1_, a);
   }
   function check_index_exn(t, i){
    var _aW_ = i < 0 ? 1 : 0, _aX_ = _aW_ || (t[4] <= i ? 1 : 0);
    if(! _aX_) return _aX_;
    var
     _aY_ = [0, [0, cst_length, caml_call1(Base_Int[9], t[4])], 0],
     _aZ_ = [0, [0, cst_index, caml_call1(Base_Int[9], i)], _aY_],
     _a0_ = caml_call2(Base_Sexp[9], cst_Queue_index_out_of_bounds, _aZ_);
    return caml_call1(Base_Error[30], _a0_);
   }
   function get(t, i){check_index_exn(t, i); return unsafe_get(t, i);}
   function set(t, i, a){
    check_index_exn(t, i);
    inc_num_mutations(t);
    return unsafe_set(t, i, a);
   }
   function is_empty(t){return 0 === t[4] ? 1 : 0;}
   function length(param){var length = param[4]; return length;}
   function ensure_no_mutation(t, num_mutations){
    var _aT_ = t[1] !== num_mutations ? 1 : 0;
    if(! _aT_) return _aT_;
    var _aU_ = 0;
    function of_a_001(param){return _f_;}
    var
     num_mutations_003 = t[1],
     front_005 = t[2],
     mask_007 = t[3],
     length_009 = t[4],
     elts_011 = t[5],
     arg_012 = caml_call2(Base_Option_array[2], of_a_001, elts_011),
     bnds_002 = [0, [1, [0, _a_, [0, arg_012, 0]]], 0],
     arg_010 = caml_call1(Base_Import[141], length_009),
     bnds_002$0 = [0, [1, [0, _b_, [0, arg_010, 0]]], bnds_002],
     arg_008 = caml_call1(Base_Import[141], mask_007),
     bnds_002$1 = [0, [1, [0, _c_, [0, arg_008, 0]]], bnds_002$0],
     arg_006 = caml_call1(Base_Import[141], front_005),
     bnds_002$2 = [0, [1, [0, _d_, [0, arg_006, 0]]], bnds_002$1],
     arg_004 = caml_call1(Base_Import[141], num_mutations_003),
     bnds_002$3 = [0, [1, [0, _e_, [0, arg_004, 0]]], bnds_002$2],
     _aV_ =
       caml_call2
        (Base_Sexp[9],
         cst_mutation_of_queue_during_i,
         [0, [0, cst, [1, bnds_002$3]], _aU_]);
    return caml_call1(Base_Error[30], _aV_);
   }
   function compare(compare_elt, t1, t2){
    if(caml_call2(Base_Import[127], t1, t2)) return 0;
    var mut2 = t2[1], mut1 = t1[1], len2 = t2[4], len1 = t1[4], pos = 0;
    for(;;){
     var match = pos === len2 ? 1 : 0;
     if(pos === len1) return match ? 0 : -1;
     if(match) return 1;
     var
      _aS_ = unsafe_get(t2, pos),
      x = caml_call2(compare_elt, unsafe_get(t1, pos), _aS_);
     ensure_no_mutation(t1, mut1);
     ensure_no_mutation(t2, mut2);
     if(0 !== x) return x;
     var pos$0 = caml_call2(Base_Import[90], pos, 1), pos = pos$0;
    }
   }
   function equal(equal_elt, t1, t2){
    var _aP_ = caml_call2(Base_Import[127], t1, t2);
    if(_aP_)
     var _aQ_ = _aP_;
    else{
     var len1 = t1[4], len2 = t2[4], _aR_ = len1 === len2 ? 1 : 0;
     if(_aR_){
      var mut2 = t2[1], mut1 = t1[1], pos = 0;
      for(;;){
       var _aM_ = pos === len1 ? 1 : 0;
       if(_aM_)
        var _aN_ = _aM_;
       else{
        var
         _aO_ = unsafe_get(t2, pos),
         b = caml_call2(equal_elt, unsafe_get(t1, pos), _aO_);
        ensure_no_mutation(t1, mut1);
        ensure_no_mutation(t2, mut2);
        if(b){
         var pos$0 = caml_call2(Base_Import[90], pos, 1), pos = pos$0;
         continue;
        }
        var _aN_ = b;
       }
       return _aN_;
      }
     }
     var _aQ_ = _aR_;
    }
    return _aQ_;
   }
   function invariant(invariant_a, t){
    var num_mutations = t[1], front = t[2], length = t[4], elts = t[5];
    if(0 > front)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
    if(front >= capacity(t))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
    var capacity$0 = capacity(t);
    if(capacity$0 !== caml_call1(Base_Option_array[6], elts))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(1 > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
    if(! caml_call1(Base_Int[67], capacity$0))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
    if(0 > length)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
    if(length > capacity$0)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    var _aK_ = caml_call2(Base_Import[92], capacity$0, 1), _aJ_ = 0;
    if(_aK_ >= 0){
     var i = _aJ_;
     for(;;){
      if(i < t[4]){
       caml_call1(invariant_a, unsafe_get(t, i));
       ensure_no_mutation(t, num_mutations);
      }
      else{
       var _aI_ = elts_index(t, i);
       if(caml_call2(Base_Option_array[40], t[5], _aI_))
        throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      var _aL_ = i + 1 | 0;
      if(_aK_ !== i){var i = _aL_; continue;}
      break;
     }
    }
    return 0;
   }
   function create(capacity, param){
    if(capacity){
     var capacity$0 = capacity[1];
     if(0 <= capacity$0)
      var _aE_ = 0 === capacity$0 ? 1 : caml_call1(Base_Int[63], capacity$0);
     else
      var
       _aG_ = [0, [0, cst_capacity, caml_call1(Base_Int[9], capacity$0)], 0],
       _aH_ = caml_call2(Base_Sexp[9], cst_cannot_have_queue_with_neg, _aG_),
       _aE_ = caml_call1(Base_Error[30], _aH_);
     var capacity$1 = _aE_;
    }
    else
     var capacity$1 = 1;
    var _aF_ = caml_call1(Base_Option_array[5], capacity$1);
    return [0, 0, 0, caml_call2(Base_Import[92], capacity$1, 1), 0, _aF_];
   }
   function blit_to_array(src, dst){
    var _aA_ = caml_call1(Base_Option_array[6], dst);
    if(src[4] > _aA_)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _o_], 1);
    var
     _aB_ = src[2],
     _aC_ = capacity(src),
     _aD_ = caml_call2(Base_Import[92], _aC_, _aB_),
     front_len = caml_call2(Base_Int[14], src[4], _aD_),
     rest_len = caml_call2(Base_Import[92], src[4], front_len);
    caml_call5(Base_Option_array[51], src[5], src[2], dst, 0, front_len);
    return caml_call5
            (Base_Option_array[51], src[5], 0, dst, front_len, rest_len);
   }
   function set_capacity(t, desired_capacity){
    inc_num_mutations(t);
    var
     _aw_ = caml_call2(Base_Import[99], desired_capacity, t[4]),
     _ax_ = caml_call2(Base_Import[99], 1, _aw_),
     new_capacity = caml_call1(Base_Int[63], _ax_),
     _ay_ = new_capacity !== capacity(t) ? 1 : 0;
    if(_ay_){
     var dst = caml_call1(Base_Option_array[5], new_capacity);
     blit_to_array(t, dst);
     t[2] = 0;
     t[3] = caml_call2(Base_Import[92], new_capacity, 1);
     t[5] = dst;
     var _az_ = 0;
    }
    else
     var _az_ = _ay_;
    return _az_;
   }
   function enqueue(t, a){
    inc_num_mutations(t);
    var _av_ = capacity(t);
    if(t[4] === _av_) set_capacity(t, caml_call2(Base_Import[87], 2, t[4]));
    unsafe_set(t, t[4], a);
    t[4] = caml_call2(Base_Import[90], t[4], 1);
    return 0;
   }
   function dequeue_nonempty(t){
    inc_num_mutations(t);
    var
     elts = t[5],
     front = t[2],
     res = caml_call2(Base_Option_array[34], elts, front);
    caml_call2(Base_Option_array[43], elts, front);
    t[2] = elts_index(t, 1);
    t[4] = caml_call2(Base_Import[92], t[4], 1);
    return res;
   }
   function dequeue_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return dequeue_nonempty(t);
   }
   function dequeue(t){return is_empty(t) ? 0 : [0, dequeue_nonempty(t)];}
   function front_nonempty(t){
    return caml_call2(Base_Option_array[38], t[5], t[2]);
   }
   function last_nonempty(t){
    return unsafe_get(t, caml_call2(Base_Import[92], t[4], 1));
   }
   function peek(t){return is_empty(t) ? 0 : [0, front_nonempty(t)];}
   function peek_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return front_nonempty(t);
   }
   function last(t){return is_empty(t) ? 0 : [0, last_nonempty(t)];}
   function last_exn(t){
    if(is_empty(t)) throw caml_maybe_attach_backtrace(Stdlib_Queue[1], 1);
    return last_nonempty(t);
   }
   function clear(t){
    inc_num_mutations(t);
    var _aq_ = 0 < t[4] ? 1 : 0;
    if(_aq_){
     var _as_ = caml_call2(Base_Import[92], t[4], 1), _ar_ = 0;
     if(_as_ >= 0){
      var i = _ar_;
      for(;;){
       var _ap_ = elts_index(t, i);
       caml_call2(Base_Option_array[50], t[5], _ap_);
       var _au_ = i + 1 | 0;
       if(_as_ !== i){var i = _au_; continue;}
       break;
      }
     }
     t[4] = 0;
     t[2] = 0;
     var _at_ = 0;
    }
    else
     var _at_ = _aq_;
    return _at_;
   }
   function blit_transfer(src, dst, len, param){
    inc_num_mutations(src);
    inc_num_mutations(dst);
    if(len){
     var len$0 = len[1];
     if(len$0 < 0){
      var
       _$_ = [0, [0, cst_length$0, caml_call1(Base_Int[9], len$0)], 0],
       _aa_ = caml_call2(Base_Sexp[9], cst_Queue_blit_transfer_negati, _$_);
      caml_call1(Base_Error[30], _aa_);
     }
     var len$1 = caml_call2(Base_Import[100], len$0, src[4]);
    }
    else
     var len$1 = src[4];
    var _ab_ = 0 < len$1 ? 1 : 0;
    if(_ab_){
     var
      _ac_ = caml_call2(Base_Import[90], dst[4], len$1),
      _ad_ = capacity(dst);
     set_capacity(dst, caml_call2(Base_Import[99], _ad_, _ac_));
     var
      dst_start = caml_call2(Base_Import[90], dst[2], dst[4]),
      _af_ = caml_call2(Base_Import[92], len$1, 1),
      _ae_ = 0;
     if(_af_ >= 0){
      var i = _ae_;
      for(;;){
       var
        _aj_ = src[3],
        _ak_ = caml_call2(Base_Import[90], src[2], i),
        src_i = caml_call2(Base_Import[115], _ak_, _aj_),
        _al_ = dst[3],
        _am_ = caml_call2(Base_Import[90], dst_start, i),
        dst_i = caml_call2(Base_Import[115], _am_, _al_),
        _an_ = caml_call2(Base_Option_array[38], src[5], src_i);
       caml_call3(Base_Option_array[49], dst[5], dst_i, _an_);
       caml_call2(Base_Option_array[50], src[5], src_i);
       var _ao_ = i + 1 | 0;
       if(_af_ !== i){var i = _ao_; continue;}
       break;
      }
     }
     dst[4] = caml_call2(Base_Import[90], dst[4], len$1);
     var _ag_ = src[3], _ah_ = caml_call2(Base_Import[90], src[2], len$1);
     src[2] = caml_call2(Base_Import[115], _ah_, _ag_);
     src[4] = caml_call2(Base_Import[92], src[4], len$1);
     var _ai_ = 0;
    }
    else
     var _ai_ = _ab_;
    return _ai_;
   }
   function enqueue_all(t, l){
    var
     _X_ = caml_call1(Base_List[7], l),
     _Y_ = caml_call2(Base_Import[90], t[4], _X_),
     _Z_ = capacity(t);
    set_capacity(t, caml_call2(Base_Int[15], _Z_, _Y_));
    function ___(x){return enqueue(t, x);}
    return caml_call2(Base_List[9], l, ___);
   }
   function fold(t, init, f){
    if(0 === t[4]) return init;
    var
     num_mutations = t[1],
     r = [0, init],
     _U_ = caml_call2(Base_Import[92], t[4], 1),
     _T_ = 0;
    if(_U_ >= 0){
     var i = _T_;
     for(;;){
      var _V_ = unsafe_get(t, i);
      r[1] = caml_call2(f, r[1], _V_);
      ensure_no_mutation(t, num_mutations);
      var _W_ = i + 1 | 0;
      if(_U_ !== i){var i = _W_; continue;}
      break;
     }
    }
    return r[1];
   }
   function foldi(t, init, f){
    var i = [0, 0];
    return fold
            (t,
             init,
             function(acc, a){
              var acc$0 = caml_call3(f, i[1], acc, a);
              i[1] = caml_call2(Base_Import[90], i[1], 1);
              return acc$0;
             });
   }
   function iter(t, f){
    var
     num_mutations = t[1],
     _R_ = caml_call2(Base_Import[92], t[4], 1),
     _Q_ = 0;
    if(_R_ >= 0){
     var i = _Q_;
     for(;;){
      caml_call1(f, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _S_ = i + 1 | 0;
      if(_R_ !== i){var i = _S_; continue;}
      break;
     }
    }
    return 0;
   }
   function iteri(t, f){
    var
     num_mutations = t[1],
     _O_ = caml_call2(Base_Import[92], t[4], 1),
     _N_ = 0;
    if(_O_ >= 0){
     var i = _N_;
     for(;;){
      caml_call2(f, i, unsafe_get(t, i));
      ensure_no_mutation(t, num_mutations);
      var _P_ = i + 1 | 0;
      if(_O_ !== i){var i = _P_; continue;}
      break;
     }
    }
    return 0;
   }
   function to_list(t){
    var result = [0, 0], _K_ = caml_call2(Base_Import[92], t[4], 1);
    if(_K_ >= 0){
     var i = _K_;
     for(;;){
      var _L_ = result[1];
      result[1] = [0, unsafe_get(t, i), _L_];
      var _M_ = i - 1 | 0;
      if(0 !== i){var i = _M_; continue;}
      break;
     }
    }
    return result[1];
   }
   var
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    foldi$0 = [0, -198771759, foldi],
    iteri$0 = [0, -198771759, iteri],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, iteri$0, foldi$0]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    for_alli = C[21];
   function concat_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       function _I_(b){return enqueue(t_result, b);}
       var _J_ = caml_call1(f, a);
       return caml_call2(Base_List[9], _J_, _I_);
      });
    return t_result;
   }
   function concat_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       function _G_(b){return enqueue(t_result, b);}
       var _H_ = caml_call2(f, i, a);
       return caml_call2(Base_List[9], _H_, _G_);
      });
    return t_result;
   }
   function filter_map(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter_mapi(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(t_result, b);
      });
    return t_result;
   }
   function filter(t, f){
    var t_result = create(0, 0);
    iter
     (t,
      function(a){
       var _F_ = caml_call1(f, a);
       return _F_ ? enqueue(t_result, a) : _F_;
      });
    return t_result;
   }
   function filteri(t, f){
    var t_result = create(0, 0);
    iteri
     (t,
      function(i, a){
       var _E_ = caml_call2(f, i, a);
       return _E_ ? enqueue(t_result, a) : _E_;
      });
    return t_result;
   }
   function filter_inplace(t, f){
    var t2 = filter(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function filteri_inplace(t, f){
    var t2 = filteri(t, f);
    clear(t);
    return blit_transfer(t2, t, 0, 0);
   }
   function copy(src){
    var dst = create([0, src[4]], 0);
    blit_to_array(src, dst[5]);
    dst[4] = src[4];
    return dst;
   }
   function of_list(l){
    var t = create([0, caml_call1(Base_List[7], l)], 0);
    function _D_(x){return enqueue(t, x);}
    caml_call2(Base_List[9], l, _D_);
    return t;
   }
   function init(len, f){
    if(len < 0){
     var
      _x_ = [0, [0, cst_length$1, caml_call1(Base_Int[9], len)], 0],
      _y_ = caml_call2(Base_Sexp[9], cst_Queue_init_negative_length, _x_);
     caml_call1(Base_Error[30], _y_);
    }
    var t = create([0, len], 0);
    if(len > caml_call1(Base_Option_array[6], t[5]))
     throw caml_maybe_attach_backtrace([0, Assert_failure, _p_], 1);
    var _A_ = caml_call2(Base_Import[92], len, 1), _z_ = 0;
    if(_A_ >= 0){
     var i = _z_;
     for(;;){
      var _B_ = caml_call1(f, i);
      caml_call3(Base_Option_array[49], t[5], i, _B_);
      var _C_ = i + 1 | 0;
      if(_A_ !== i){var i = _C_; continue;}
      break;
     }
    }
    t[4] = len;
    return t;
   }
   function of_array(a){
    return init(a.length - 1, function(_w_){return a[1 + _w_];});
   }
   function to_array(t){
    function _v_(i){return unsafe_get(t, i);}
    return caml_call2(Base_Array[27], t[4], _v_);
   }
   function map(ta, f){
    var num_mutations = ta[1], tb = create([0, ta[4]], 0);
    tb[4] = ta[4];
    var _t_ = caml_call2(Base_Import[92], ta[4], 1), _s_ = 0;
    if(_t_ >= 0){
     var i = _s_;
     for(;;){
      var b = caml_call1(f, unsafe_get(ta, i));
      ensure_no_mutation(ta, num_mutations);
      caml_call3(Base_Option_array[49], tb[5], i, b);
      var _u_ = i + 1 | 0;
      if(_t_ !== i){var i = _u_; continue;}
      break;
     }
    }
    return tb;
   }
   function mapi(t, f){
    var i = [0, 0];
    return map
            (t,
             function(a){
              var result = caml_call2(f, i[1], a);
              i[1] = caml_call2(Base_Import[90], i[1], 1);
              return result;
             });
   }
   function singleton(x){var t = create(0, 0); enqueue(t, x); return t;}
   function sexp_of_t(sexp_of_a, t){
    var _r_ = to_list(t);
    return caml_call1(caml_call1(Base_List[4], sexp_of_a), _r_);
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_List[3], a_of_sexp, sexp));
   }
   function t_sexp_grammar(grammar){
    var _q_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _q_);
   }
   var
    Base_Queue =
      [0,
       compare,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       equal,
       invariant,
       create,
       last,
       last_exn,
       blit_transfer,
       get,
       set,
       capacity,
       set_capacity];
   runtime.caml_register_global(38, Base_Queue, "Base__Queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nothing
//# unitInfo: Requires: Base__Identifiable, Base__Import, Match_failure, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    t_sexp_grammar = [4, 0],
    module_name = "Base.Nothing",
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Match_failure = global_data.Match_failure,
    Base_Identifiable = global_data.Base__Identifiable,
    cst_Base_Nothing_of_string_not = "Base.Nothing.of_string: not supported",
    cst_Base_Nothing_t = "Base.Nothing.t",
    _a_ = [0, "src/nothing.ml", 6, 25];
   function unreachable_code(param){
    throw caml_maybe_attach_backtrace([0, Match_failure, _a_], 1);
   }
   var all = 0;
   function hash_fold_t(param, t){return unreachable_code(t);}
   function compare(a, param){return unreachable_code(a);}
   function t_of_sexp(sexp){
    return caml_call2(Sexplib0_Sexp_conv_error[26], cst_Base_Nothing_t, sexp);
   }
   function of_string(param){
    return caml_call1(Base_Import[123], cst_Base_Nothing_of_string_not);
   }
   var
    include =
      caml_call1
       (Base_Identifiable[1],
        [0,
         compare,
         hash_fold_t,
         unreachable_code,
         t_of_sexp,
         unreachable_code,
         of_string,
         unreachable_code,
         module_name]),
    hash_fold_t$0 = include[1],
    hash = include[2],
    t_of_sexp$0 = include[3],
    sexp_of_t = include[4],
    of_string$0 = include[5],
    to_string = include[6],
    symbol = include[7],
    symbol$0 = include[8],
    symbol$1 = include[9],
    symbol$2 = include[10],
    symbol$3 = include[11],
    symbol$4 = include[12],
    equal = include[13],
    compare$0 = include[14],
    min = include[15],
    max = include[16],
    ascending = include[17],
    descending = include[18],
    between = include[19],
    clamp_exn = include[20],
    clamp = include[21],
    comparator = include[22],
    pp = include[23],
    hashable = include[24],
    Base_Nothing =
      [0,
       all,
       t_sexp_grammar,
       unreachable_code,
       hash_fold_t$0,
       hash,
       t_of_sexp$0,
       sexp_of_t,
       of_string$0,
       to_string,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       equal,
       compare$0,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable];
   runtime.caml_register_global(9, Base_Nothing, "Base__Nothing");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Nativeint
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__Word_size, Stdlib__Nativeint, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_nx = "%nx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_lessequal = runtime.caml_lessequal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Nativeint.Hex",
    module_name$0 = "Base.Nativeint",
    Base_Int_math = global_data.Base__Int_math,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Base_Printf = global_data.Base__Printf,
    Base_Float0 = global_data.Base__Float0,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    Base_Word_size = global_data.Base__Word_size,
    Base_Error = global_data.Base__Error,
    Base_Popcount = global_data.Base__Popcount,
    include = Base_Import[103],
    compare = include[9],
    hash_fold_t = Base_Import[202],
    func = Base_Import[216],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _f_ = [0, "src/nativeint.ml", 202, 2],
    cst_Nativeint_ceil_log2_got_in = "[Nativeint.ceil_log2] got invalid input",
    cst_Nativeint_floor_log2_got_i =
      "[Nativeint.floor_log2] got invalid input",
    _e_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    _d_ =
      [0,
       [11,
        "Nativeint.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Nativeint.of_float: argument (%f) is out of range or NaN"],
    _c_ = [0, [6, 6, 0, 0, 0], cst_nx],
    _b_ = [0, [6, 6, 0, 0, 0], cst_nx];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[169],
    sexp_of_t = Base_Import[145],
    t_sexp_grammar = Base_Import[189],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[103][9],
    to_string = Stdlib_Nativeint[15],
    of_string = runtime.caml_int_of_string,
    comparator = caml_call1(Base_Comparator[5], [0, compare$0, sexp_of_t])[1],
    zero = Stdlib_Nativeint[1],
    _a_ = caml_call1(Base_Comparable[13], [0, compare$0, sexp_of_t, zero]),
    is_positive = _a_[1],
    is_non_negative = _a_[2],
    is_negative = _a_[3],
    is_non_positive = _a_[4],
    sign = _a_[5],
    include$0 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$0 = include$0[2],
    compare$1 = Base_Import[231],
    hash_fold_t$0 = Base_Import[202],
    func$0 = Base_Import[216];
   function hash$0(x){return caml_call1(func$0, x);}
   var zero$0 = Stdlib_Nativeint[1];
   function neg(_U_){return - _U_ | 0;}
   var symbol = Base_Import[103][1];
   function to_string$0(i){return caml_call2(Base_Printf[2], _b_, i);}
   function of_string$0(s){
    function _S_(_T_){return _T_;}
    return caml_call3(Stdlib_Scanf[4], s, _c_, _S_);
   }
   var
    include$1 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$1,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero$0,
         symbol,
         neg,
         module_name]),
    Hex = include$1[1],
    include$2 =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string]),
    pp = include$2[1];
   function invariant(param){return 0;}
   var
    num_bits = caml_call1(Base_Word_size[2], Base_Word_size[3]),
    float_lower_bound = caml_call1(Base_Float0[25], num_bits),
    float_upper_bound = caml_call1(Base_Float0[23], num_bits);
   function shift_right_logical(_R_, _Q_){return _R_ >>> _Q_ | 0;}
   function shift_right(_P_, _O_){return _P_ >> _O_;}
   function shift_left(_N_, _M_){return _N_ << _M_;}
   var bit_not = Stdlib_Nativeint[12];
   function bit_xor(_L_, _K_){return _L_ ^ _K_;}
   function bit_or(_J_, _I_){return _J_ | _I_;}
   function bit_and(_H_, _G_){return _H_ & _G_;}
   var
    min_value = Stdlib_Nativeint[11],
    max_value = Stdlib_Nativeint[10],
    abs = Stdlib_Nativeint[8],
    pred = Stdlib_Nativeint[7],
    succ = Stdlib_Nativeint[6],
    rem = runtime.caml_mod;
   function symbol$0(_F_){return - _F_ | 0;}
   var
    minus_one = Stdlib_Nativeint[3],
    one = Stdlib_Nativeint[2],
    zero$1 = Stdlib_Nativeint[1];
   function to_float(_E_){return _E_;}
   function of_float_unchecked(_D_){return _D_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[107][6], f, float_lower_bound)
      && caml_call2(Base_Import[107][2], f, float_upper_bound))
     return f | 0;
    var _C_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _d_, _C_, 0);
   }
   var raise_s = Base_Error[30];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _e_, 0);
   }
   function ceil_pow2(x){
    if(caml_call2(Base_Import[103][2], x, 0)) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Nativeint[7], x),
     x$1 = x$0 | x$0 >>> 1 | 0,
     x$2 = x$1 | x$1 >>> 2 | 0,
     x$3 = x$2 | x$2 >>> 4 | 0,
     x$4 = x$3 | x$3 >>> 8 | 0,
     x$5 = x$4 | x$4 >>> 16 | 0,
     x$6 = x$5 | x$5 >>> 32 | 0;
    return caml_call1(Stdlib_Nativeint[6], x$6);
   }
   function floor_pow2(x){
    if(caml_call2(Base_Import[103][2], x, 0)) non_positive_argument(0);
    var
     x$0 = x | x >>> 1 | 0,
     x$1 = x$0 | x$0 >>> 2 | 0,
     x$2 = x$1 | x$1 >>> 4 | 0,
     x$3 = x$2 | x$2 >>> 8 | 0,
     x$4 = x$3 | x$3 >>> 16 | 0,
     x$5 = x$4 | x$4 >>> 32 | 0;
    return x$5 - (x$5 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[103][2], x, 0)) non_positive_argument(0);
    var _B_ = x & caml_call1(Stdlib_Nativeint[7], x);
    return caml_call2(Base_Import[103][4], _B_, 0);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _y_ = [0, [0, cst, caml_call1(Base_Import[145], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Nativeint_floor_log2_got_i, _y_));
    }
    var
     _z_ = runtime.Base_int_math_nativeint_clz(i),
     _A_ = caml_call2(Base_Import[92], num_bits, 1);
    return caml_call2(Base_Import[92], _A_, _z_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Nativeint[1])){
     var _w_ = [0, [0, cst$0, caml_call1(Base_Import[145], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Nativeint_ceil_log2_got_in, _w_));
    }
    if(caml_call2(Stdlib_Nativeint[18], i, Stdlib_Nativeint[2])) return 0;
    var
     _x_ =
       runtime.Base_int_math_nativeint_clz(caml_call1(Stdlib_Nativeint[7], i));
    return caml_call2(Base_Import[92], num_bits, _x_);
   }
   function between(t, low, high){
    var _v_ = caml_call2(Base_Import[103][2], low, t);
    return _v_ ? caml_call2(Base_Import[103][2], t, high) : _v_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[103][1], t, min)
            ? min
            : caml_call2(Base_Import[103][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[103][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[103][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _s_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _t_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _s_],
     _u_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _t_);
    return caml_call1(Base_Or_error[35], _u_);
   }
   var symbol$1 = runtime.caml_div, symbol$2 = runtime.caml_mul;
   function symbol$3(_r_, _q_){return _r_ - _q_ | 0;}
   function symbol$4(_p_, _o_){return _p_ + _o_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_nativeint(t){return t;}
   function to_nativeint(t){return t;}
   var
    popcount = Base_Popcount[4],
    of_int_exn = Base_Int_conversions[5],
    to_int = Base_Int_conversions[22],
    to_int_exn = Base_Int_conversions[23],
    to_int_trunc = Base_Int_conversions[24],
    of_int32 = Base_Int_conversions[10],
    to_int32 = Base_Int_conversions[25],
    to_int32_exn = Base_Int_conversions[26],
    to_int32_trunc = Base_Int_conversions[27],
    of_int64 = Base_Int_conversions[17],
    of_int64_exn = Base_Int_conversions[18],
    of_int64_trunc = Base_Int_conversions[19],
    to_int64 = Base_Int_conversions[28];
   function pow(b, e){
    var _m_ = caml_call1(to_int_exn, e), _n_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _n_, _m_));
   }
   function symbol$5(b, e){return pow(b, e);}
   var
    _g_ = Base_Import[103],
    symbol$6 = _g_[3],
    symbol$7 = _g_[1],
    symbol$8 = _g_[5],
    symbol$9 = _g_[4],
    symbol$10 = _g_[2],
    symbol$11 = _g_[6],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$4,
         symbol$3,
         symbol$2,
         symbol$1,
         symbol$0,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$0,
         zero$1,
         of_int_exn,
         rem]),
    symbol$12 = include$3[1],
    symbol$13 = include$3[2],
    symbol$14 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[103],
    symbol$15 = include$4[1],
    symbol$16 = include$4[2],
    symbol$17 = include$4[3],
    symbol$18 = include$4[4],
    symbol$19 = include$4[5],
    symbol$20 = include$4[6],
    ascending = include$4[7],
    descending = include$4[8],
    compare$2 = include$4[9],
    equal = include$4[10],
    max = include$4[11],
    min = include$4[12],
    _h_ = runtime.caml_int32_bswap,
    _i_ =
      [0,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$1,
       symbol$0,
       symbol$5,
       symbol$11,
       symbol$10,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$6,
       abs,
       symbol$0,
       zero$1,
       symbol$12,
       symbol$13,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       shift_right_logical];
   function _j_(_l_){return runtime.Base_int_math_nativeint_ctz(_l_);}
   var
    Base_Nativeint =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$20,
       symbol$16,
       symbol$18,
       symbol$19,
       symbol$15,
       symbol$17,
       equal,
       compare$2,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       zero$1,
       one,
       minus_one,
       symbol$4,
       symbol$3,
       symbol$2,
       symbol$5,
       symbol$0,
       symbol$0,
       symbol$13,
       symbol$12,
       symbol$1,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_k_){return runtime.Base_int_math_nativeint_clz(_k_);},
       _j_,
       _i_,
       of_int_exn,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       to_int_trunc,
       to_int32_trunc,
       of_int64_trunc,
       _h_];
   runtime.caml_register_global(34, Base_Nativeint, "Base__Nativeint");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Map
//# unitInfo: Requires: Assert_failure, Base__Comparator, Base__Error, Base__Exn, Base__Import, Base__List0, Base__Map_intf, Base__Maybe_bound, Base__Option, Base__Or_error, Base__Result, Base__Sequence, Base__Sexp, Base__Uniform_array, Base__With_return, Sexplib0__Sexp_conv
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Map_bal$3 = "Map.bal",
    cst_Map_of$1 = "Map.of_",
    cst_key$1 = "key",
    cst_of_sorted_array_duplicated$1 = "of_sorted_array: duplicated elements",
    cst_src_map_ml = "src/map.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    empty = [0, 0],
    name = "alist",
    name$0 = "sequence",
    Base_Result = global_data.Base__Result,
    Base_Or_error = global_data.Base__Or_error,
    Base_Error = global_data.Base__Error,
    Base_Import = global_data.Base__Import,
    Base_Option = global_data.Base__Option,
    Base_Exn = global_data.Base__Exn,
    Base_Sexp = global_data.Base__Sexp,
    Base_List0 = global_data.Base__List0,
    Assert_failure = global_data.Assert_failure,
    Base_Uniform_array = global_data.Base__Uniform_array,
    Base_Sequence = global_data.Base__Sequence,
    Base_Maybe_bound = global_data.Base__Maybe_bound,
    Base_Map_intf = global_data.Base__Map_intf,
    Base_With_return = global_data.Base__With_return,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Comparator = global_data.Base__Comparator,
    Symmetric_diff_element = Base_Map_intf[5],
    include = Base_Map_intf[8],
    compare = include[1],
    all = include[2],
    equal = include[3],
    sexp_of_t = include[4],
    _z_ = [0, "_"],
    _y_ = [0, "Map.Build_increasing.add: non-increasing key"],
    _x_ = [0, 0, 0],
    _g_ = [0, 0, 0, 0],
    cst_Map_remove_min_elt = "Map.remove_min_elt",
    _u_ = [0, 0],
    cst_key$0 = cst_key$1,
    cst_Map_map_keys_exn_duplicate = "Map.map_keys_exn: duplicate key",
    cst_Map_t_of_sexp_direct_dupli = "Map.t_of_sexp_direct: duplicate key",
    _w_ = [0, cst_src_map_ml, 1639, 6],
    cst_Map_of_iteri_exn_duplicate = "Map.of_iteri_exn: duplicate key",
    _v_ = [0, 0],
    cst_exn_duplicate_key = "_exn: duplicate key",
    cst_Map_of$0 = cst_Map_of$1,
    cst_or_error_duplicate_key = "_or_error: duplicate key",
    cst_Map_of = cst_Map_of$1,
    _t_ = [0, [0, 0, 0], [0, 0, 0]],
    _s_ = [0, 0, 0],
    _r_ = [0, 0, 0],
    _q_ = [0, 0, 0],
    _p_ = [0, 0, 0],
    _o_ = [0, 0, 0],
    _m_ = [0, "map.ml.Tree0.Map_max_elt_exn_of_empty_map"],
    _n_ = [0, cst_src_map_ml, 547, 15],
    _j_ = [0, "map.ml.Tree0.Map_min_elt_exn_of_empty_map"],
    _k_ = [0, cst_src_map_ml, 534, 15],
    _h_ = [0, "Map.find_exn: not found"],
    cst_of_increasing_sequence_non =
      "of_increasing_sequence: non-increasing key",
    cst_Map_singleton_to_tree_exn_ =
      "Map.singleton_to_tree_exn: not a singleton",
    _f_ = [1, 0],
    cst_key = cst_key$1,
    cst_Map_add_exn_got_key_alread = "[Map.add_exn] got key already present",
    cst_Map_bal = cst_Map_bal$3,
    _d_ = [0, cst_src_map_ml, 196, 18],
    cst_Map_bal$0 = cst_Map_bal$3,
    cst_Map_bal$1 = cst_Map_bal$3,
    _e_ = [0, cst_src_map_ml, 210, 18],
    cst_Map_bal$2 = cst_Map_bal$3,
    cst_of_sorted_array_duplicated = cst_of_sorted_array_duplicated$1,
    cst_of_sorted_array_elements_a =
      "of_sorted_array: elements are not ordered",
    cst_of_sorted_array_duplicated$0 = cst_of_sorted_array_duplicated$1,
    _b_ = [0, "map.ml.Duplicate"],
    _c_ = [0, cst_src_map_ml, 67, 11],
    cst_Base_Map_Duplicate = "Base__Map.Duplicate",
    cst_Base_Map_Tree0_Map_min_elt =
      "Base__Map.Tree0.Map_min_elt_exn_of_empty_map",
    cst_Base_Map_Tree0_Map_max_elt =
      "Base__Map.Tree0.Map_max_elt_exn_of_empty_map",
    cst_Base_Map_Tree0_Remove_no_o = "Base__Map.Tree0.Remove_no_op",
    cst_Base_Map_Tree0_Change_no_o = "Base__Map.Tree0.Change_no_op";
   function of_continue_or_stop(_dE_){return _dE_;}
   function to_continue_or_stop(_dD_){return _dD_;}
   var
    Finished_or_unfinished =
      [0,
       compare,
       all,
       equal,
       sexp_of_t,
       of_continue_or_stop,
       to_continue_or_stop],
    include$0 = Base_Map_intf[6],
    compare$0 = include$0[1],
    equal$0 = include$0[2],
    sexp_of_t$0 = include$0[3];
   function left(param){
    var _dC_ = param[1];
    if(737457313 === _dC_)
     var left = param[2][1];
    else{if(847852583 > _dC_) return 0; var left = param[2];}
    return [0, left];
   }
   function right(param){
    var _dB_ = param[1];
    if(737457313 === _dB_)
     var right = param[2][2];
    else{if(847852583 <= _dB_) return 0; var right = param[2];}
    return [0, right];
   }
   function left_value(t, default$0){
    var _dA_ = t[1];
    if(737457313 === _dA_)
     var left = t[2][1];
    else{if(847852583 > _dA_) return default$0; var left = t[2];}
    return left;
   }
   function right_value(t, default$0){
    var _dz_ = t[1];
    if(737457313 === _dz_)
     var right = t[2][2];
    else{if(847852583 <= _dz_) return default$0; var right = t[2];}
    return right;
   }
   function values(t, left_default, right_default){
    var _dy_ = t[1];
    if(737457313 === _dy_){
     var match = t[2], right = match[2], left = match[1];
     return [0, left, right];
    }
    if(847852583 <= _dy_){
     var left$0 = t[2];
     return [0, left$0, right_default];
    }
    var right$0 = t[2];
    return [0, left_default, right$0];
   }
   var
    Merge_element =
      [0,
       compare$0,
       equal$0,
       sexp_of_t$0,
       left,
       right,
       left_value,
       right_value,
       values],
    with_return = Base_With_return[1],
    Duplicate = [248, cst_Base_Map_Duplicate, caml_fresh_oo_id(0)];
   function _a_(param){
    if(param === Duplicate) return _b_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   caml_call4(Sexplib0_Sexp_conv[70][1], 0, 0, Duplicate, _a_);
   function height(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var h = param[5];
    return h;
   }
   function in_range(lower, upper, compare_key, k){
    if(lower)
     var
      lower$0 = lower[1],
      _dw_ = caml_call2(compare_key, lower$0, k) < 0 ? 1 : 0;
    else
     var _dw_ = 1;
    if(_dw_){
     if(upper){
      var upper$0 = upper[1];
      return caml_call2(compare_key, k, upper$0) < 0 ? 1 : 0;
     }
     var _dx_ = 1;
    }
    else
     var _dx_ = _dw_;
    return _dx_;
   }
   function loop(lower, upper, compare_key, t){
    var lower$0 = lower, t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 1;
     if(0 === t$0[0]){
      var k = t$0[1];
      return in_range(lower$0, upper, compare_key, k);
     }
     var
      h = t$0[5],
      r = t$0[4],
      k$0 = t$0[2],
      l = t$0[1],
      hl = height(l),
      hr = height(r),
      _dp_ = caml_call2(Base_Import[92], hl, hr),
      _dq_ = caml_call1(Base_Import[122], _dp_) <= 2 ? 1 : 0;
     if(_dq_){
      var
       _dr_ = caml_call2(Base_Import[99], hl, hr),
       _ds_ = h === caml_call2(Base_Import[90], _dr_, 1) ? 1 : 0;
      if(_ds_){
       var _dt_ = in_range(lower$0, upper, compare_key, k$0);
       if(_dt_){
        var _du_ = loop(lower$0, [0, k$0], compare_key, l);
        if(_du_){
         var lower$1 = [0, k$0], lower$0 = lower$1, t$0 = r;
         continue;
        }
        var _dv_ = _du_;
       }
       else
        var _dv_ = _dt_;
      }
      else
       var _dv_ = _ds_;
     }
     else
      var _dv_ = _dq_;
     return _dv_;
    }
   }
   function invariants(t, compare_key){return loop(0, 0, compare_key, t);}
   function create(l, x, d, r){
    var hl = height(l), hr = height(r);
    if(0 === hl && 0 === hr) return [0, x, d];
    var
     _do_ =
       hr <= hl
        ? caml_call2(Base_Import[90], hl, 1)
        : caml_call2(Base_Import[90], hr, 1);
    return [1, l, x, d, r, _do_];
   }
   function of_increasing_iterator_uncheck(len, f){
    function loop(n, f, i){
     if(3 >= n >>> 0)
      switch(n){
        case 0:
         return 0;
        case 1:
         var match$0 = caml_call1(f, i), v$0 = match$0[2], k$0 = match$0[1];
         return [0, k$0, v$0];
        case 2:
         var
          match$1 = caml_call1(f, i),
          vl = match$1[2],
          kl = match$1[1],
          match$2 = caml_call1(f, caml_call2(Base_Import[90], i, 1)),
          v$1 = match$2[2],
          k$1 = match$2[1];
         return [1, [0, kl, vl], k$1, v$1, 0, 2];
        default:
         var
          match$3 = caml_call1(f, i),
          vl$0 = match$3[2],
          kl$0 = match$3[1],
          match$4 = caml_call1(f, caml_call2(Base_Import[90], i, 1)),
          v$2 = match$4[2],
          k$2 = match$4[1],
          match$5 = caml_call1(f, caml_call2(Base_Import[90], i, 2)),
          vr = match$5[2],
          kr = match$5[1];
         return [1, [0, kl$0, vl$0], k$2, v$2, [0, kr, vr], 2];
      }
     var
      left_length = caml_call2(Base_Import[119], n, 1),
      _dm_ = caml_call2(Base_Import[92], n, left_length),
      right_length = caml_call2(Base_Import[92], _dm_, 1),
      left = loop(left_length, f, i),
      match = caml_call1(f, caml_call2(Base_Import[90], i, left_length)),
      v = match[2],
      k = match[1],
      _dn_ = caml_call2(Base_Import[90], i, left_length),
      right = loop(right_length, f, caml_call2(Base_Import[90], _dn_, 1));
     return create(left, k, v, right);
    }
    return loop(len, f, 0);
   }
   function of_sorted_array_unchecked(array, compare_key){
    var array_length = array.length - 1, switch$0 = 0;
    if(2 <= array_length){
     var
      k0 = caml_check_bound(array, 0)[1][1],
      k1 = caml_check_bound(array, 1)[2][1];
     if(caml_call2(compare_key, k0, k1) >= 0){
      var
       next =
         function(i){
          var
           _dk_ = caml_call2(Base_Import[92], array_length, 1),
           _dl_ = caml_call2(Base_Import[92], _dk_, i);
          return caml_check_bound(array, _dl_)[1 + _dl_];
         };
      switch$0 = 1;
     }
    }
    if(! switch$0)
     var next = function(i){return caml_check_bound(array, i)[1 + i];};
    return [0,
            of_increasing_iterator_uncheck(array_length, next),
            array_length];
   }
   function of_sorted_array(array, compare_key){
    var len = array.length - 1;
    if(1 !== len && len)
     return caml_call1
             (with_return,
              function(r){
               var
                _da_ = caml_check_bound(array, 1)[2],
                _db_ = caml_call1(Base_Import[124], _da_),
                _dc_ = caml_check_bound(array, 0)[1],
                i =
                  caml_call2
                   (compare_key, caml_call1(Base_Import[124], _dc_), _db_),
                increasing =
                  0 === i
                   ? caml_call1
                     (r,
                      caml_call1
                       (Base_Or_error[36], cst_of_sorted_array_duplicated))
                   : i < 0 ? 1 : 0,
                _de_ = caml_call2(Base_Import[92], array.length - 1, 2),
                _dd_ = 1;
               if(_de_ >= 1){
                var i$0 = _dd_;
                for(;;){
                 var
                  _df_ = caml_call2(Base_Import[90], i$0, 1),
                  _dg_ = caml_check_bound(array, _df_)[1 + _df_],
                  _dh_ = caml_call1(Base_Import[124], _dg_),
                  _di_ = caml_check_bound(array, i$0)[1 + i$0],
                  i$1 =
                    caml_call2
                     (compare_key, caml_call1(Base_Import[124], _di_), _dh_);
                 if(0 === i$1)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_duplicated$0));
                 else if((i$1 < 0 ? 1 : 0) !== increasing)
                  caml_call1
                   (r,
                    caml_call1
                     (Base_Or_error[36], cst_of_sorted_array_elements_a));
                 var _dj_ = i$0 + 1 | 0;
                 if(_de_ !== i$0){var i$0 = _dj_; continue;}
                 break;
                }
               }
               return [0, of_sorted_array_unchecked(array, compare_key)];
              });
    return [0, of_sorted_array_unchecked(array, compare_key)];
   }
   function bal(l, x, d, r){
    var hl = height(l), hr = height(r);
    if(caml_call2(Base_Import[90], hr, 2) < hl){
     if(typeof l === "number")
      return caml_call1(Base_Import[125], cst_Map_bal);
     if(0 === l[0])
      throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
     var lr = l[4], ld = l[3], lv = l[2], ll = l[1], _c6_ = height(lr);
     if(_c6_ <= height(ll)) return create(ll, lv, ld, create(lr, x, d, r));
     if(typeof lr === "number")
      return caml_call1(Base_Import[125], cst_Map_bal$0);
     if(0 === lr[0]){
      var lrd = lr[2], lrv = lr[1], _c7_ = create(0, x, d, r);
      return create(create(ll, lv, ld, 0), lrv, lrd, _c7_);
     }
     var
      lrr = lr[4],
      lrd$0 = lr[3],
      lrv$0 = lr[2],
      lrl = lr[1],
      _c8_ = create(lrr, x, d, r);
     return create(create(ll, lv, ld, lrl), lrv$0, lrd$0, _c8_);
    }
    if(caml_call2(Base_Import[90], hl, 2) >= hr) return create(l, x, d, r);
    if(typeof r === "number")
     return caml_call1(Base_Import[125], cst_Map_bal$1);
    if(0 === r[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
    var rr = r[4], rd = r[3], rv = r[2], rl = r[1], _c9_ = height(rl);
    if(_c9_ <= height(rr)) return create(create(l, x, d, rl), rv, rd, rr);
    if(typeof rl === "number")
     return caml_call1(Base_Import[125], cst_Map_bal$2);
    if(0 === rl[0]){
     var rld = rl[2], rlv = rl[1], _c__ = create(0, rv, rd, rr);
     return create(create(l, x, d, 0), rlv, rld, _c__);
    }
    var
     rlr = rl[4],
     rld$0 = rl[3],
     rlv$0 = rl[2],
     rll = rl[1],
     _c$_ = create(rlr, rv, rd, rr);
    return create(create(l, x, d, rll), rlv$0, rld$0, _c$_);
   }
   var empty_without_value_restrictio = 0;
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function raise_key_already_present(key, sexp_of_key){
    var
     _c4_ = [0, [0, cst_key, caml_call1(sexp_of_key, key)], 0],
     _c5_ = caml_call2(Base_Sexp[9], cst_Map_add_exn_got_key_alread, _c4_);
    return caml_call1(Base_Error[30], _c5_);
   }
   function find_and_add_or_set
   (t, length, x, data, compare_key, sexp_of_key, add_or_set){
    if(typeof t === "number")
     return [0, [0, x, data], caml_call2(Base_Import[90], length, 1)];
    if(0 === t[0]){
     var d = t[2], v = t[1], c = caml_call2(compare_key, x, v);
     if(0 === c)
      switch(add_or_set){
        case 0:
         return caml_call1(Base_Exn[6], Duplicate);
        case 1:
         return raise_key_already_present(x, sexp_of_key);
        default: return [0, [0, x, data], length];
      }
     return 0 <= c
             ? [0,
               [1, 0, v, d, [0, x, data], 2],
               caml_call2(Base_Import[90], length, 1)]
             : [0,
               [1, [0, x, data], v, d, 0, 2],
               caml_call2(Base_Import[90], length, 1)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     c$0 = caml_call2(compare_key, x, v$0);
    if(0 === c$0)
     switch(add_or_set){
       case 0:
        return caml_call1(Base_Exn[6], Duplicate);
       case 1:
        return raise_key_already_present(x, sexp_of_key);
       default: return [0, [1, l, x, data, r, h], length];
     }
    if(0 <= c$0){
     var
      match =
        find_and_add_or_set
         (r, length, x, data, compare_key, sexp_of_key, add_or_set),
      length$0 = match[2],
      r$0 = match[1];
     return [0, bal(l, v$0, d$0, r$0), length$0];
    }
    var
     match$0 =
       find_and_add_or_set
        (l, length, x, data, compare_key, sexp_of_key, add_or_set),
     length$1 = match$0[2],
     l$0 = match$0[1];
    return [0, bal(l$0, v$0, d$0, r), length$1];
   }
   function add_exn(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 1);
   }
   function add_exn_internal(t, length, key, data, compare_key, sexp_of_key){
    return find_and_add_or_set
            (t, length, key, data, compare_key, sexp_of_key, 0);
   }
   function set(t, length, key, data, compare_key){
    var _c3_ = 2;
    return find_and_add_or_set
            (t,
             length,
             key,
             data,
             compare_key,
             function(param){return _f_;},
             _c3_);
   }
   function set$0(t, key, data, compare_key){
    var _c2_ = set(t, 0, key, data, compare_key);
    return caml_call1(Base_Import[124], _c2_);
   }
   function singleton_to_tree_exn(param){
    if(typeof param[1] !== "number")
     return caml_call1(Base_Import[123], cst_Map_singleton_to_tree_exn_);
    var data = param[3], key = param[2];
    return [0, key, data];
   }
   function collapse(l, r){return create(l[1], l[2], l[3], r);}
   function join(l, r){
    var _c0_ = r[3], _c1_ = r[2];
    return [0, collapse(l, r[1]), _c1_, _c0_];
   }
   function go(t, x){
    switch(t[0]){
      case 0:
       return [1, t, x];
      case 1:
       var y = t[2], t$0 = t[1]; return [2, t$0, y, x];
      default:
       var y$0 = t[3], z = t[2], t$1 = t[1];
       return [1, go(t$1, join(z, y$0)), x];
    }
   }
   function add_unchecked(t, key, data){return go(t, [0, 0, key, data]);}
   function go$0(t, r){
    var t$0 = t, r$0 = r;
    for(;;)
     switch(t$0[0]){
       case 0:
        return r$0;
       case 1:
        var
         l = t$0[2],
         t$1 = t$0[1],
         r$1 = collapse(l, r$0),
         t$0 = t$1,
         r$0 = r$1;
        continue;
       default:
        var
         l$0 = t$0[3],
         ll = t$0[2],
         t$2 = t$0[1],
         r$2 = collapse(join(ll, l$0), r$0),
         t$0 = t$2,
         r$0 = r$2;
        continue;
     }
   }
   function to_tree_unchecked(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var r = param[2], t = param[1];
       return go$0(t, singleton_to_tree_exn(r));
      default:
       var r$0 = param[3], l = param[2], t$0 = param[1];
       return go$0([1, t$0, l], singleton_to_tree_exn(r$0));
    }
   }
   function max_key(param){
    switch(param[0]){
      case 0:
       return 0;
      case 1:
       var r = param[2]; break;
      default: var r = param[3];
    }
    return [0, r[2]];
   }
   function of_increasing_sequence(seq, compare_key){
    return caml_call1
            (with_return,
             function(param){
              function _cX_(param$0, _cY_){
               var
                data = _cY_[2],
                key = _cY_[1],
                length = param$0[2],
                builder = param$0[1],
                match = max_key(builder);
               if(match){
                var prev_key = match[1];
                if(0 <= caml_call2(compare_key, prev_key, key))
                 return caml_call1
                         (param,
                          caml_call1
                           (Base_Or_error[36], cst_of_increasing_sequence_non));
               }
               var _cZ_ = caml_call2(Base_Import[90], length, 1);
               return [0, add_unchecked(builder, key, data), _cZ_];
              }
              var
               match = caml_call3(Base_Sequence[8], seq, [0, empty, 0], _cX_),
               length = match[2],
               builder = match[1];
              return [0, [0, to_tree_unchecked(builder), length]];
             });
   }
   function join$0(l, k, d, r, compare_key){
    if(typeof l === "number") return set$0(r, k, d, compare_key);
    if(1 === l[0]){
     var lh = l[5], lr = l[4], ld$0 = l[3], lk$0 = l[2], ll = l[1];
     if(typeof r !== "number"){
      if(0 === r[0]){
       var rd = r[2], rk = r[1];
       return set$0(set$0(l, k, d, compare_key), rk, rd, compare_key);
      }
      var rh = r[5], rr = r[4], rd$0 = r[3], rk$0 = r[2], rl = r[1];
      return caml_call2(Base_Import[90], rh, 3) < lh
              ? bal(ll, lk$0, ld$0, join$0(lr, k, d, r, compare_key))
              : caml_call2
                 (Base_Import[90], lh, 3)
                < rh
                ? bal(join$0(l, k, d, rl, compare_key), rk$0, rd$0, rr)
                : bal(l, k, d, r);
     }
    }
    if(typeof r === "number") return set$0(l, k, d, compare_key);
    var ld = l[2], lk = l[1];
    return set$0(set$0(r, k, d, compare_key), lk, ld, compare_key);
   }
   function split(t, x, compare_key){
    if(typeof t === "number") return _g_;
    if(0 === t[0]){
     var d = t[2], k = t[1], cmp = caml_call2(compare_key, x, k);
     return 0 === cmp
             ? [0, 0, [0, [0, k, d]], 0]
             : 0 <= cmp ? [0, t, 0, 0] : [0, 0, 0, t];
    }
    var
     r = t[4],
     d$0 = t[3],
     k$0 = t[2],
     l = t[1],
     cmp$0 = caml_call2(compare_key, x, k$0);
    if(0 === cmp$0) return [0, l, [0, [0, k$0, d$0]], r];
    if(0 <= cmp$0){
     var
      match = split(r, x, compare_key),
      rr = match[3],
      maybe = match[2],
      rl = match[1];
     return [0, join$0(l, k$0, d$0, rl, compare_key), maybe, rr];
    }
    var
     match$0 = split(l, x, compare_key),
     lr = match$0[3],
     maybe$0 = match$0[2],
     ll = match$0[1];
    return [0, ll, maybe$0, join$0(lr, k$0, d$0, r, compare_key)];
   }
   function split_and_reinsert_boundary(t, into, x, compare_key){
    var
     match = split(t, x, compare_key),
     right = match[3],
     boundary_opt = match[2],
     left = match[1];
    if(! boundary_opt) return [0, left, right];
    var match$0 = boundary_opt[1], data = match$0[2], key = match$0[1];
    function insert_into(tree){
     var _cW_ = set(tree, 0, key, data, compare_key);
     return caml_call1(Base_Import[124], _cW_);
    }
    return 847852583 <= into
            ? [0, insert_into(left), right]
            : [0, left, insert_into(right)];
   }
   function split_range(t, lower_bound, upper_bound, compare_key){
    if(caml_call3(Base_Maybe_bound[9], lower_bound, upper_bound, compare_key))
     return [0,
             empty_without_value_restrictio,
             empty_without_value_restrictio,
             empty_without_value_restrictio];
    if(typeof lower_bound === "number")
     var mid_and_right = t, left = empty_without_value_restrictio;
    else if(0 === lower_bound[0])
     var
      lb$1 = lower_bound[1],
      _cU_ = split_and_reinsert_boundary(t, -57574468, lb$1, compare_key),
      mid_and_right = _cU_[2],
      left = _cU_[1];
    else
     var
      lb$2 = lower_bound[1],
      _cV_ = split_and_reinsert_boundary(t, 847852583, lb$2, compare_key),
      mid_and_right$0 = _cV_[2],
      left$0 = _cV_[1],
      mid_and_right = mid_and_right$0,
      left = left$0;
    if(typeof upper_bound === "number")
     var right = empty_without_value_restrictio, mid = mid_and_right;
    else if(0 === upper_bound[0])
     var
      lb = upper_bound[1],
      _cS_ =
        split_and_reinsert_boundary(mid_and_right, 847852583, lb, compare_key),
      right = _cS_[2],
      mid = _cS_[1];
    else
     var
      lb$0 = upper_bound[1],
      _cT_ =
        split_and_reinsert_boundary
         (mid_and_right, -57574468, lb$0, compare_key),
      right$0 = _cT_[2],
      mid$0 = _cT_[1],
      right = right$0,
      mid = mid$0;
    return [0, left, mid, right];
   }
   function find(t, x, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v) ? [0, d] : 0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return [0, d$0];
     var r$0 = 0 <= c ? r : l, t$0 = r$0;
    }
   }
   function add_multi(t, length, key, data, compare_key){
    var
     _cR_ = find(t, key, compare_key),
     data$0 = [0, data, caml_call2(Base_Option[27], _cR_, 0)];
    return set(t, length, key, data$0, compare_key);
   }
   function find_multi(t, x, compare_key){
    var match = find(t, x, compare_key);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function if_not_found(key, sexp_of_key){
    var _cQ_ = [1, [0, _h_, [0, caml_call1(sexp_of_key, key), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[251], _cQ_], 1);
   }
   function find_exn(t, x, compare_key, sexp_of_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return if_not_found(x, sexp_of_key);
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return 0 === caml_call2(compare_key, x, v)
              ? d
              : if_not_found(x, sexp_of_key);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c) return d$0;
     var r$0 = 0 <= c ? r : l, t$0 = r$0;
    }
   }
   function mem(t, x, compare_key){
    var _cP_ = find(t, x, compare_key);
    return caml_call1(Base_Option[50], _cP_);
   }
   function min_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     var l = param$0[1];
     if(typeof l === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     var param$0 = l;
    }
   }
   var
    Map_min_elt_exn_of_empty_map =
      [248, cst_Base_Map_Tree0_Map_min_elt, caml_fresh_oo_id(0)];
   function _i_(param){
    if(param === Map_min_elt_exn_of_empty_map) return _j_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[70][1], 0, 0, Map_min_elt_exn_of_empty_map, _i_);
   var
    Map_max_elt_exn_of_empty_map =
      [248, cst_Base_Map_Tree0_Map_max_elt, caml_fresh_oo_id(0)];
   function _l_(param){
    if(param === Map_max_elt_exn_of_empty_map) return _m_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   caml_call4
    (Sexplib0_Sexp_conv[70][1], 0, 0, Map_max_elt_exn_of_empty_map, _l_);
   function min_elt_exn(t){
    var match = min_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_min_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function max_elt(param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var d = param$0[2], k = param$0[1];
      return [0, [0, k, d]];
     }
     if(typeof param$0[4] === "number"){
      var d$0 = param$0[3], k$0 = param$0[2];
      return [0, [0, k$0, d$0]];
     }
     var r = param$0[4], param$0 = r;
    }
   }
   function max_elt_exn(t){
    var match = max_elt(t);
    if(! match)
     throw caml_maybe_attach_backtrace(Map_max_elt_exn_of_empty_map, 1);
    var v = match[1];
    return v;
   }
   function remove_min_elt(t){
    if(typeof t === "number")
     return caml_call1(Base_Import[125], cst_Map_remove_min_elt);
    if(0 === t[0]) return 0;
    var l = t[1];
    if(typeof l === "number"){var r = t[4]; return r;}
    var r$0 = t[4], d = t[3], x = t[2];
    return bal(remove_min_elt(l), x, d, r$0);
   }
   function append(lower_part, upper_part, compare_key){
    var match = max_elt(lower_part), match$0 = min_elt(upper_part);
    if(! match) return [0, 17724, upper_part];
    if(! match$0) return [0, 17724, lower_part];
    var
     _cO_ = match$0[1],
     v = _cO_[2],
     min_upper = _cO_[1],
     max_lower = match[1][1];
    if(0 <= caml_call2(compare_key, max_lower, min_upper)) return 838882908;
    var upper_part_without_min = remove_min_elt(upper_part);
    return [0,
            17724,
            join$0
             (lower_part, min_upper, v, upper_part_without_min, compare_key)];
   }
   function go$1(t, min, max, init, f, compare_key){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 === t$0[0]){
      var d = t$0[2], k = t$0[1];
      if
       (0 <= caml_call2(compare_key, k, min)
        && 0 >= caml_call2(compare_key, k, max))
       return caml_call3(f, k, d, init$0);
      return init$0;
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      k$0 = t$0[2],
      l = t$0[1],
      c_min = caml_call2(compare_key, k$0, min);
     if(0 > c_min){var t$0 = r; continue;}
     if(0 === c_min){
      var init$1 = caml_call3(f, k$0, d$0, init$0), t$0 = r, init$0 = init$1;
      continue;
     }
     var
      z = go$1(l, min, max, init$0, f, compare_key),
      c_max = caml_call2(compare_key, k$0, max);
     if(0 < c_max) return z;
     var init$2 = caml_call3(f, k$0, d$0, z);
     if(0 === c_max) return init$2;
     var t$0 = r, init$0 = init$2;
    }
   }
   function fold_range_inclusive(t, min, max, init, f, compare_key){
    return 0 < caml_call2(compare_key, min, max)
            ? init
            : go$1(t, min, max, init, f, compare_key);
   }
   function range_to_alist(t, min, max, compare_key){
    var
     _cN_ =
       fold_range_inclusive
        (t,
         min,
         max,
         0,
         function(key, data, l){return [0, [0, key, data], l];},
         compare_key);
    return caml_call1(Base_List0[21], _cN_);
   }
   function concat_unchecked(t1, t2){
    if(typeof t1 === "number") return t2;
    if(typeof t2 === "number") return t1;
    var match = min_elt_exn(t2), d = match[2], x = match[1];
    return bal(t1, x, d, remove_min_elt(t2));
   }
   var
    Remove_no_op = [248, cst_Base_Map_Tree0_Remove_no_o, caml_fresh_oo_id(0)];
   function remove(t, x, length, compare_key){
    function remove_loop(t, x, length, compare_key){
     if(typeof t === "number") return caml_call1(Base_Exn[6], Remove_no_op);
     if(0 === t[0]){
      var v = t[1];
      return 0 === caml_call2(compare_key, x, v)
              ? [0, 0, caml_call2(Base_Import[92], length, 1)]
              : caml_call1(Base_Exn[6], Remove_no_op);
     }
     var
      r = t[4],
      d = t[3],
      v$0 = t[2],
      l = t[1],
      c = caml_call2(compare_key, x, v$0);
     if(0 === c){
      var _cM_ = caml_call2(Base_Import[92], length, 1);
      return [0, concat_unchecked(l, r), _cM_];
     }
     if(0 <= c){
      var
       match = remove_loop(r, x, length, compare_key),
       length$0 = match[2],
       r$0 = match[1];
      return [0, bal(l, v$0, d, r$0), length$0];
     }
     var
      match$0 = remove_loop(l, x, length, compare_key),
      length$1 = match$0[2],
      l$0 = match$0[1];
     return [0, bal(l$0, v$0, d, r), length$1];
    }
    try{var _cK_ = remove_loop(t, x, length, compare_key); return _cK_;}
    catch(_cL_){
     var _cJ_ = caml_wrap_exception(_cL_);
     if(_cJ_ === Remove_no_op) return [0, t, length];
     throw caml_maybe_attach_backtrace(_cJ_, 0);
    }
   }
   var
    Change_no_op = [248, cst_Base_Map_Tree0_Change_no_o, caml_fresh_oo_id(0)];
   function change(t, key, f, length, compare_key){
    function change_core(t, key, f){
     if(typeof t === "number"){
      var match = caml_call1(f, 0);
      if(! match) throw caml_maybe_attach_backtrace(Change_no_op, 1);
      var data = match[1];
      return [0, [0, key, data], caml_call2(Base_Import[90], length, 1)];
     }
     if(0 === t[0]){
      var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
      if(0 === c){
       var match$0 = caml_call1(f, [0, d]);
       if(! match$0) return [0, 0, caml_call2(Base_Import[92], length, 1)];
       var d$0 = match$0[1];
       return [0, [0, v, d$0], length];
      }
      if(0 <= c){
       var
        match$1 = change_core(0, key, f),
        length$0 = match$1[2],
        r = match$1[1];
       return [0, bal(0, v, d, r), length$0];
      }
      var
       match$2 = change_core(0, key, f),
       length$1 = match$2[2],
       l = match$2[1];
      return [0, bal(l, v, d, 0), length$1];
     }
     var
      h = t[5],
      r$0 = t[4],
      d$1 = t[3],
      v$0 = t[2],
      l$0 = t[1],
      c$0 = caml_call2(compare_key, key, v$0);
     if(0 === c$0){
      var match$3 = caml_call1(f, [0, d$1]);
      if(match$3){
       var data$0 = match$3[1];
       return [0, [1, l$0, key, data$0, r$0, h], length];
      }
      var _cI_ = caml_call2(Base_Import[92], length, 1);
      return [0, concat_unchecked(l$0, r$0), _cI_];
     }
     if(0 <= c$0){
      var
       match$4 = change_core(r$0, key, f),
       length$2 = match$4[2],
       r$1 = match$4[1];
      return [0, bal(l$0, v$0, d$1, r$1), length$2];
     }
     var
      match$5 = change_core(l$0, key, f),
      length$3 = match$5[2],
      l$1 = match$5[1];
     return [0, bal(l$1, v$0, d$1, r$0), length$3];
    }
    try{var _cG_ = change_core(t, key, f); return _cG_;}
    catch(_cH_){
     var _cF_ = caml_wrap_exception(_cH_);
     if(_cF_ === Change_no_op) return [0, t, length];
     throw caml_maybe_attach_backtrace(_cF_, 0);
    }
   }
   function update(t, key, f, length, compare_key){
    function update_core(t, key, f){
     if(typeof t === "number"){
      var data = caml_call1(f, 0);
      return [0, [0, key, data], caml_call2(Base_Import[90], length, 1)];
     }
     if(0 === t[0]){
      var d = t[2], v = t[1], c = caml_call2(compare_key, key, v);
      if(0 === c){
       var d$0 = caml_call1(f, [0, d]);
       return [0, [0, v, d$0], length];
      }
      if(0 <= c){
       var match = update_core(0, key, f), length$0 = match[2], r = match[1];
       return [0, bal(0, v, d, r), length$0];
      }
      var
       match$0 = update_core(0, key, f),
       length$1 = match$0[2],
       l = match$0[1];
      return [0, bal(l, v, d, 0), length$1];
     }
     var
      h = t[5],
      r$0 = t[4],
      d$1 = t[3],
      v$0 = t[2],
      l$0 = t[1],
      c$0 = caml_call2(compare_key, key, v$0);
     if(0 === c$0){
      var data$0 = caml_call1(f, [0, d$1]);
      return [0, [1, l$0, key, data$0, r$0, h], length];
     }
     if(0 <= c$0){
      var
       match$1 = update_core(r$0, key, f),
       length$2 = match$1[2],
       r$1 = match$1[1];
      return [0, bal(l$0, v$0, d$1, r$1), length$2];
     }
     var
      match$2 = update_core(l$0, key, f),
      length$3 = match$2[2],
      l$1 = match$2[1];
     return [0, bal(l$1, v$0, d$1, r$0), length$3];
    }
    return update_core(t, key, f);
   }
   function remove_multi(t, key, length, compare_key){
    return change
            (t,
             key,
             function(param){
              if(param){
               var _cE_ = param[1];
               if(_cE_){
                var non_empty_tail = _cE_[2];
                if(non_empty_tail) return [0, non_empty_tail];
               }
              }
              return 0;
             },
             length,
             compare_key);
   }
   function iter_keys(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var v = t$0[1]; return caml_call1(f, v);}
     var r = t$0[4], v$0 = t$0[2], l = t$0[1];
     iter_keys(l, f);
     caml_call1(f, v$0);
     var t$0 = r;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2]; return caml_call1(f, d);}
     var r = t$0[4], d$0 = t$0[3], l = t$0[1];
     iter(l, f);
     caml_call1(f, d$0);
     var t$0 = r;
    }
   }
   function iteri(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     iteri(l, f);
     caml_call2(f, v$0, d$0);
     var t$0 = r;
    }
   }
   function iteri_until_loop(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return caml_call2(f, v, d);}
     var r = t$0[4], d$0 = t$0[3], v$0 = t$0[2], l = t$0[1];
     if(iteri_until_loop(l, f)) return 1;
     if(caml_call2(f, v$0, d$0)) return 1;
     var t$0 = r;
    }
   }
   function iteri_until(t, f){
    var _cD_ = iteri_until_loop(t, f);
    return caml_call1(Finished_or_unfinished[5], _cD_);
   }
   function map(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){var d = t[2], v = t[1]; return [0, v, caml_call1(f, d)];}
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = map(l, f),
     d$1 = caml_call1(f, d$0),
     r$0 = map(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function mapi(t, f){
    if(typeof t === "number") return 0;
    if(0 === t[0]){
     var d = t[2], v = t[1];
     return [0, v, caml_call2(f, v, d)];
    }
    var
     h = t[5],
     r = t[4],
     d$0 = t[3],
     v$0 = t[2],
     l = t[1],
     l$0 = mapi(l, f),
     d$1 = caml_call2(f, v$0, d$0),
     r$0 = mapi(r, f);
    return [1, l$0, v$0, d$1, r$0, h];
   }
   function fold(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold(l, accu$0, f)),
      t$0 = r,
      accu$0 = accu$1;
    }
   }
   function fold_until(t, init, f, finish){
    function fold_until_loop(t, acc, f){
     var t$0 = t, acc$0 = acc;
     for(;;){
      if(typeof t$0 === "number") return [0, acc$0];
      if(0 === t$0[0]){
       var d = t$0[2], v = t$0[1];
       return caml_call3(f, v, d, acc$0);
      }
      var
       r = t$0[4],
       d$0 = t$0[3],
       v$0 = t$0[2],
       l = t$0[1],
       match = fold_until_loop(l, acc$0, f);
      if(0 !== match[0]){var final$1 = match[1]; return [1, final$1];}
      var acc$1 = match[1], match$0 = caml_call3(f, v$0, d$0, acc$1);
      if(0 === match$0[0]){
       var acc$2 = match$0[1], t$0 = r, acc$0 = acc$2;
       continue;
      }
      var final$0 = match$0[1];
      return [1, final$0];
     }
    }
    var match = fold_until_loop(t, init, f);
    if(0 === match[0]){var acc = match[1]; return caml_call1(finish, acc);}
    var stop = match[1];
    return stop;
   }
   function fold_right(t, accu, f){
    var t$0 = t, accu$0 = accu;
    for(;;){
     if(typeof t$0 === "number") return accu$0;
     if(0 === t$0[0]){
      var d = t$0[2], v = t$0[1];
      return caml_call3(f, v, d, accu$0);
     }
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      accu$1 = caml_call3(f, v$0, d$0, fold_right(r, accu$0, f)),
      t$0 = l,
      accu$0 = accu$1;
    }
   }
   function filter_keys(t, f, compare_key){
    return fold
            (t,
             _o_,
             function(key, data, param){
              var length = param[2], accu = param[1];
              return caml_call1(f, key)
                      ? set(accu, length, key, data, compare_key)
                      : [0, accu, length];
             });
   }
   function filter(t, f, compare_key){
    return fold
            (t,
             _p_,
             function(key, data, param){
              var length = param[2], accu = param[1];
              return caml_call1(f, data)
                      ? set(accu, length, key, data, compare_key)
                      : [0, accu, length];
             });
   }
   function filteri(t, f, compare_key){
    return fold
            (t,
             _q_,
             function(key, data, param){
              var length = param[2], accu = param[1];
              return caml_call2(f, key, data)
                      ? set(accu, length, key, data, compare_key)
                      : [0, accu, length];
             });
   }
   function filter_map(t, f, compare_key){
    return fold
            (t,
             _r_,
             function(key, data, param){
              var
               length = param[2],
               accu = param[1],
               match = caml_call1(f, data);
              if(! match) return [0, accu, length];
              var b = match[1];
              return set(accu, length, key, b, compare_key);
             });
   }
   function filter_mapi(t, f, compare_key){
    return fold
            (t,
             _s_,
             function(key, data, param){
              var
               length = param[2],
               accu = param[1],
               match = caml_call2(f, key, data);
              if(! match) return [0, accu, length];
              var b = match[1];
              return set(accu, length, key, b, compare_key);
             });
   }
   function partition_mapi(t, f, compare_key){
    return fold
            (t,
             _t_,
             function(key, data, param){
              var
               pair2 = param[2],
               pair1 = param[1],
               match = caml_call2(f, key, data);
              if(0 === match[0]){
               var x = match[1], length = pair1[2], t = pair1[1];
               return [0, set(t, length, key, x, compare_key), pair2];
              }
              var y = match[1], length$0 = pair2[2], t$0 = pair2[1];
              return [0, pair1, set(t$0, length$0, key, y, compare_key)];
             });
   }
   function partition_map(t, f, compare_key){
    return partition_mapi
            (t,
             function(param, data){return caml_call1(f, data);},
             compare_key);
   }
   function partitioni_tf(t, f, compare_key){
    return partition_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : [1, data];
             },
             compare_key);
   }
   function partition_tf(t, f, compare_key){
    return partition_mapi
            (t,
             function(param, data){
              return caml_call1(f, data) ? [0, data] : [1, data];
             },
             compare_key);
   }
   function cons(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, r, e$0],
      t$0 = l,
      e$0 = e$1;
    }
   }
   function cons_right(t, e){
    var t$0 = t, e$0 = e;
    for(;;){
     if(typeof t$0 === "number") return e$0;
     if(0 === t$0[0]){var d = t$0[2], v = t$0[1]; return [0, v, d, 0, e$0];}
     var
      r = t$0[4],
      d$0 = t$0[3],
      v$0 = t$0[2],
      l = t$0[1],
      e$1 = [0, v$0, d$0, l, e$0],
      t$0 = r,
      e$0 = e$1;
    }
   }
   function of_tree(tree){return cons(tree, 0);}
   function fold$0(init, f, param){
    var init$0 = init, param$0 = param;
    for(;;){
     if(! param$0) return init$0;
     var
      enum$0 = param$0[4],
      tree = param$0[3],
      data = param$0[2],
      key = param$0[1],
      next = caml_call3(f, key, data, init$0),
      init$0 = next,
      param$0 = cons(tree, enum$0);
    }
   }
   function fold2(compare_key, t1, t2, init, f){
    var t1$0 = t1, t2$0 = t2, curr = init;
    for(;;){
     if(! t1$0)
      return t2$0
              ? fold$0
                (curr,
                 function(key, data, acc){
                  return caml_call3(f, key, [0, -57574468, data], acc);
                 },
                 t2$0)
              : curr;
     if(! t2$0)
      return fold$0
              (curr,
               function(key, data, acc){
                return caml_call3(f, key, [0, 847852583, data], acc);
               },
               t1$0);
     var
      enum2 = t2$0[4],
      tree2 = t2$0[3],
      v2 = t2$0[2],
      k2 = t2$0[1],
      enum1 = t1$0[4],
      tree1 = t1$0[3],
      v1 = t1$0[2],
      k1 = t1$0[1],
      compare_result = caml_call2(compare_key, k1, k2);
     if(0 === compare_result){
      var
       next = caml_call3(f, k1, [0, 737457313, [0, v1, v2]], curr),
       t2$1 = cons(tree2, enum2),
       t1$1 = cons(tree1, enum1),
       t1$0 = t1$1,
       t2$0 = t2$1,
       curr = next;
      continue;
     }
     if(0 <= compare_result){
      var
       next$0 = caml_call3(f, k2, [0, -57574468, v2], curr),
       t2$2 = cons(tree2, enum2),
       t2$0 = t2$2,
       curr = next$0;
      continue;
     }
     var
      next$1 = caml_call3(f, k1, [0, 847852583, v1], curr),
      t1$2 = cons(tree1, enum1),
      t1$0 = t1$2,
      curr = next$1;
    }
   }
   function symmetric_diff(t1, t2, compare_key, data_equal){
    function step(state){
     var left = state[1];
     if(! left){
      var match = state[2];
      if(! match) return 0;
      var
       enum$0 = match[4],
       tree = match[3],
       data$0 = match[2],
       key$0 = match[1];
      return [1,
              [0, key$0, [0, -57574468, data$0]],
              [0, 0, cons(tree, enum$0)]];
     }
     var
      right = state[2],
      enum1 = left[4],
      tree1 = left[3],
      data = left[2],
      key = left[1];
     if(! right)
      return [1, [0, key, [0, 847852583, data]], [0, cons(tree1, enum1), 0]];
     var
      enum2 = right[4],
      tree2 = right[3],
      v2 = right[2],
      k2 = right[1],
      compare_result = caml_call2(compare_key, key, k2);
     if(0 !== compare_result)
      return 0 <= compare_result
              ? [1,
                [0, k2, [0, -57574468, v2]],
                [0, left, cons(tree2, enum2)]]
              : [1,
                [0, key, [0, 847852583, data]],
                [0, cons(tree1, enum1), right]];
     if(caml_call2(Base_Import[127], tree1, tree2))
      var next_state = [0, enum1, enum2];
     else
      var
       _cC_ = cons(tree2, enum2),
       next_state = [0, cons(tree1, enum1), _cC_];
     return caml_call2(data_equal, data, v2)
             ? [0, next_state]
             : [1, [0, key, [0, 1013247643, [0, data, v2]]], next_state];
    }
    var _cA_ = of_tree(t2), _cB_ = [0, of_tree(t1), _cA_];
    return caml_call2(Base_Sequence[41], _cB_, step);
   }
   function to_sequence
   (comparator, opt, keys_greater_or_equal_to, keys_less_or_equal_to, t$3){
    if(opt) var sth = opt[1], order = sth; else var order = -542431297;
    function inclusive_bound(side, t, bound){
     var
      compare_key = comparator[1],
      match = split(t, bound, compare_key),
      r = match[3],
      maybe = match[2],
      l = match[1],
      t$0 = caml_call1(side, [0, l, r]);
     if(! maybe) return t$0;
     var match$0 = maybe[1], data = match$0[2], key = match$0[1];
     return set$0(t$0, key, data, compare_key);
    }
    if(511974747 <= order){
     var
      _cs_ = Base_Import[126],
      _ct_ = function(_cy_, _cz_){return inclusive_bound(_cs_, _cy_, _cz_);},
      tree = caml_call3(Base_Option[31], keys_greater_or_equal_to, t$3, _ct_),
      next$0 =
        function(enum$0){
         if(! enum$0) return 0;
         var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
         return [1, [0, k, v], cons_right(t, e)];
        };
     if(keys_less_or_equal_to){
      var
       key$0 = keys_less_or_equal_to[1],
       compare$0 = comparator[1],
       t$1 = tree,
       e$1 = 0;
      for(;;){
       if(typeof t$1 !== "number"){
        if(0 === t$1[0]){
         var
          d$1 = t$1[2],
          v$2 = t$1[1],
          t$2 = [1, 0, v$2, d$1, 0, 1],
          t$1 = t$2;
         continue;
        }
        var l$0 = t$1[1], v$3 = t$1[2];
        if(0 < caml_call2(compare$0, v$3, key$0)){var t$1 = l$0; continue;}
        var
         r$1 = t$1[4],
         d$2 = t$1[3],
         v$4 = t$1[2],
         e$2 = [0, v$4, d$2, l$0, e$1],
         t$1 = r$1,
         e$1 = e$2;
        continue;
       }
       var init$0 = e$1;
       break;
      }
     }
     else
      var init$0 = cons_right(tree, 0);
     return caml_call2(Base_Sequence[41], init$0, next$0);
    }
    var _cu_ = Base_Import[124];
    function _cv_(_cw_, _cx_){return inclusive_bound(_cu_, _cw_, _cx_);}
    var t$4 = caml_call3(Base_Option[31], keys_less_or_equal_to, t$3, _cv_);
    function next(enum$0){
     if(! enum$0) return 0;
     var e = enum$0[4], t = enum$0[3], v = enum$0[2], k = enum$0[1];
     return [1, [0, k, v], cons(t, e)];
    }
    if(keys_greater_or_equal_to){
     var
      key = keys_greater_or_equal_to[1],
      compare = comparator[1],
      t = t$4,
      e = 0;
     for(;;){
      if(typeof t !== "number"){
       if(0 === t[0]){
        var d = t[2], v = t[1], t$0 = [1, 0, v, d, 0, 1], t = t$0;
        continue;
       }
       var l = t[1], r = t[4], v$0 = t[2];
       if(0 <= caml_call2(compare, v$0, key)){
        var
         r$0 = t[4],
         d$0 = t[3],
         v$1 = t[2],
         e$0 = [0, v$1, d$0, r$0, e],
         t = l,
         e = e$0;
        continue;
       }
       var t = r;
       continue;
      }
      var init = e;
      break;
     }
    }
    else
     var init = of_tree(t$4);
    return caml_call2(Base_Sequence[41], init, next);
   }
   function compare$1(compare_key, compare_data, t1$1, t2$1){
    var t2$2 = of_tree(t2$1), t1$2 = of_tree(t1$1), t1 = t1$2, t2 = t2$2;
    for(;;){
     if(! t1) return t2 ? -1 : 0;
     if(! t2) return 1;
     var
      e2 = t2[4],
      r2 = t2[3],
      d2 = t2[2],
      v2 = t2[1],
      e1 = t1[4],
      r1 = t1[3],
      d1 = t1[2],
      v1 = t1[1],
      c = caml_call2(compare_key, v1, v2);
     if(0 !== c) return c;
     var c$0 = caml_call2(compare_data, d1, d2);
     if(0 !== c$0) return c$0;
     if(caml_call2(Base_Import[127], r1, r2)){var t1 = e1, t2 = e2; continue;}
     var t2$0 = cons(r2, e2), t1$0 = cons(r1, e1), t1 = t1$0, t2 = t2$0;
    }
   }
   function equal$1(compare_key, compare_data, t1$1, t2$1){
    var t2$2 = of_tree(t2$1), t1$2 = of_tree(t1$1), t1 = t1$2, t2 = t2$2;
    for(;;){
     if(t1){
      if(t2){
       var
        e2 = t2[4],
        r2 = t2[3],
        d2 = t2[2],
        v2 = t2[1],
        e1 = t1[4],
        r1 = t1[3],
        d1 = t1[2],
        v1 = t1[1],
        _cp_ = 0 === caml_call2(compare_key, v1, v2) ? 1 : 0;
       if(_cp_){
        var _cq_ = caml_call2(compare_data, d1, d2);
        if(_cq_){
         if(caml_call2(Base_Import[127], r1, r2)){var t1 = e1, t2 = e2; continue;}
         var t2$0 = cons(r2, e2), t1$0 = cons(r1, e1), t1 = t1$0, t2 = t2$0;
         continue;
        }
        var _cr_ = _cq_;
       }
       else
        var _cr_ = _cp_;
       return _cr_;
      }
     }
     else if(! t2) return 1;
     return 0;
    }
   }
   function iter2(t1, t2, f, compare_key){
    function _cn_(key, data, param){return caml_call2(f, key, data);}
    var _co_ = of_tree(t2);
    return fold2(compare_key, of_tree(t1), _co_, 0, _cn_);
   }
   function fold2$0(t1, t2, init, f, compare_key){
    var _cm_ = of_tree(t2);
    return fold2(compare_key, of_tree(t1), _cm_, init, f);
   }
   function fold_symmetric_diff(t1, t2, compare_key, data_equal, init, f){
    function add(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
    }
    function remove(acc, k, v){
     return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
    }
    function delta(acc, k, v$0, v){
     return caml_call2(data_equal, v$0, v)
             ? acc
             : caml_call2(f, acc, [0, k, [0, 1013247643, [0, v$0, v]]]);
    }
    function loop(t$0, t, acc$3){
     var t1 = t$0, t2 = t, init = acc$3;
     for(;;){
      if(caml_call2(Base_Import[127], t1, t2)) return init;
      var switch$0 = 0;
      if(typeof t1 === "number")
       return fold
               (t2,
                init,
                function(key, data, acc){return add(acc, key, data);});
      if(0 === t1[0]){
       var v = t1[2], k = t1[1];
       if(typeof t2 === "number")
        switch$0 = 1;
       else if(0 === t2[0]){
        var v$0 = t2[2], k$0 = t2[1], x = caml_call2(compare_key, k, k$0);
        if(0 === x) return delta(init, k, v, v$0);
        if(0 <= x){
         var acc$4 = add(init, k$0, v$0);
         return remove(acc$4, k, v);
        }
        var acc$5 = remove(init, k, v);
        return add(acc$5, k$0, v$0);
       }
      }
      else{
       var r = t1[4], v$1 = t1[3], k$1 = t1[2], l = t1[1];
       if(typeof t2 === "number")
        switch$0 = 1;
       else if(0 !== t2[0]){
        var l$0 = t2[1], r$0 = t2[4], v$2 = t2[3], k$2 = t2[2];
        if(0 === caml_call2(compare_key, k$1, k$2)){
         var
          acc$6 = loop(l, l$0, init),
          acc$7 = delta(acc$6, k$1, v$1, v$2),
          t1 = r,
          t2 = r$0,
          init = acc$7;
         continue;
        }
       }
      }
      if(switch$0)
       return fold
               (t1,
                init,
                function(key, data, acc){return remove(acc, key, data);});
      var
       add$0 =
         function(acc, k, v){
          return caml_call2(f, acc, [0, k, [0, -57574468, v]]);
         },
       remove$0 =
         function(acc, k, v){
          return caml_call2(f, acc, [0, k, [0, 847852583, v]]);
         },
       right$2 = of_tree(t2),
       left$2 = of_tree(t1),
       left = left$2,
       right = right$2,
       acc = init;
      for(;;){
       if(! left)
        return fold$0
                (acc,
                 function(key, data, acc){return add$0(acc, key, data);},
                 right);
       if(! right)
        return fold$0
                (acc,
                 function(key, data, acc){return remove$0(acc, key, data);},
                 left);
       var
        enum2 = right[4],
        tree2 = right[3],
        v2 = right[2],
        k2 = right[1],
        enum1 = left[4],
        tree1 = left[3],
        v1 = left[2],
        k1 = left[1],
        compare_result = caml_call2(compare_key, k1, k2);
       if(0 === compare_result){
        var
         acc$0 =
           caml_call2(data_equal, v1, v2)
            ? acc
            : caml_call2(f, acc, [0, k1, [0, 1013247643, [0, v1, v2]]]);
        if(caml_call2(Base_Import[127], tree1, tree2)){
         var left = enum1, right = enum2, acc = acc$0;
         continue;
        }
        var
         right$0 = cons(tree2, enum2),
         left$0 = cons(tree1, enum1),
         left = left$0,
         right = right$0,
         acc = acc$0;
        continue;
       }
       if(0 <= compare_result){
        var
         acc$1 = add$0(acc, k2, v2),
         right$1 = cons(tree2, enum2),
         right = right$1,
         acc = acc$1;
        continue;
       }
       var
        acc$2 = remove$0(acc, k1, v1),
        left$1 = cons(tree1, enum1),
        left = left$1,
        acc = acc$2;
      }
     }
    }
    return loop(t1, t2, init);
   }
   function length(param){
    if(typeof param === "number") return 0;
    if(0 === param[0]) return 1;
    var
     r = param[4],
     l = param[1],
     _cj_ = length(r),
     _ck_ = length(l),
     _cl_ = caml_call2(Base_Import[90], _ck_, _cj_);
    return caml_call2(Base_Import[90], _cl_, 1);
   }
   function keys(t){
    return fold_right
            (t, 0, function(key, param, list){return [0, key, list];});
   }
   function data(t){
    return fold_right
            (t, 0, function(param, data, list){return [0, data, list];});
   }
   function Of_foldable(M){
    function of_foldable_fold(foldable, init, f, compare_key){
     function _ch_(param, _ci_){
      var
       data = _ci_[2],
       key = _ci_[1],
       length = param[2],
       accum = param[1],
       match = find(accum, key, compare_key);
      if(match)
       var prev = match[1], prev_data = prev;
      else
       var prev_data = init;
      var data$0 = caml_call2(f, prev_data, data);
      return set(accum, length, key, data$0, compare_key);
     }
     return caml_call3
             (M[2], foldable, [0, empty_without_value_restrictio, 0], _ch_);
    }
    function of_foldable_reduce(foldable, f, compare_key){
     function _cf_(param, _cg_){
      var
       data = _cg_[2],
       key = _cg_[1],
       length = param[2],
       accum = param[1],
       match = find(accum, key, compare_key);
      if(match)
       var prev = match[1], new_data = caml_call2(f, prev, data);
      else
       var new_data = data;
      return set(accum, length, key, new_data, compare_key);
     }
     return caml_call3
             (M[2], foldable, [0, empty_without_value_restrictio, 0], _cf_);
    }
    function of_foldable(foldable, compare_key){
     return caml_call1
             (with_return,
              function(r){
               function _cd_(param, _ce_){
                var
                 data = _ce_[2],
                 key = _ce_[1],
                 length = param[2],
                 t = param[1],
                 acc = set(t, length, key, data, compare_key),
                 length$0 = acc[2];
                return length === length$0
                        ? caml_call1(r, [0, -1048878709, key])
                        : acc;
               }
               var
                map =
                  caml_call3
                   (M[2],
                    foldable,
                    [0, empty_without_value_restrictio, 0],
                    _cd_);
               return [0, 17724, map];
              });
    }
    function of_foldable_or_error(foldable, comparator){
     var match = of_foldable(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return [0, x];}
     var
      key = match[2],
      _ca_ = comparator[2],
      _cb_ = caml_call2(Base_Import[111], M[1], cst_or_error_duplicate_key),
      _cc_ = caml_call2(Base_Import[111], cst_Map_of, _cb_);
     return caml_call5(Base_Or_error[34], 0, 0, _cc_, key, _ca_);
    }
    function of_foldable_exn(foldable, comparator){
     var match = of_foldable(foldable, comparator[1]);
     if(17724 <= match[1]){var x = match[2]; return x;}
     var
      key = match[2],
      _b8_ = comparator[2],
      _b9_ = caml_call2(Base_Import[111], M[1], cst_exn_duplicate_key),
      _b__ = caml_call2(Base_Import[111], cst_Map_of$0, _b9_),
      _b$_ = caml_call5(Base_Error[17], 0, 0, _b__, key, _b8_);
     return caml_call1(Base_Error[29], _b$_);
    }
    return [0,
            of_foldable_fold,
            of_foldable_reduce,
            of_foldable,
            of_foldable_or_error,
            of_foldable_exn];
   }
   var
    fold$1 = Base_List0[8],
    Of_alist = Of_foldable([0, name, fold$1]),
    of_alist_fold = Of_alist[1],
    of_alist_reduce = Of_alist[2],
    of_alist = Of_alist[3],
    of_alist_or_error = Of_alist[4],
    of_alist_exn = Of_alist[5];
   function of_foldable_multi(foldable, fold, compare_key){
    var
     alist = caml_call3(fold, foldable, 0, function(l, x){return [0, x, l];});
    return caml_call4
            (of_alist_fold,
             alist,
             0,
             function(l, x){return [0, x, l];},
             compare_key);
   }
   function of_alist_multi(alist, compare_key){
    return of_foldable_multi(alist, Base_List0[8], compare_key);
   }
   var
    fold$2 = Base_Sequence[8],
    Of_sequence = Of_foldable([0, name$0, fold$2]),
    of_sequence_fold = Of_sequence[1],
    of_sequence_reduce = Of_sequence[2],
    of_sequence = Of_sequence[3],
    of_sequence_or_error = Of_sequence[4],
    of_sequence_exn = Of_sequence[5];
   function of_sequence_multi(sequence, compare_key){
    return of_foldable_multi(sequence, Base_Sequence[8], compare_key);
   }
   function for_all(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _b7_ = 1 - caml_call1(f, data);
                 return _b7_ ? caml_call1(r, 0) : _b7_;
                });
              return 1;
             });
   }
   function for_alli(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _b6_ = 1 - caml_call2(f, key, data);
                 return _b6_ ? caml_call1(r, 0) : _b6_;
                });
              return 1;
             });
   }
   function exists(t, f){
    return caml_call1
            (with_return,
             function(r){
              iter
               (t,
                function(data){
                 var _b5_ = caml_call1(f, data);
                 return _b5_ ? caml_call1(r, 1) : _b5_;
                });
              return 0;
             });
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _b4_ = caml_call2(f, key, data);
                 return _b4_ ? caml_call1(r, 1) : _b4_;
                });
              return 0;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[90], acc, 1)
                      : acc;
             });
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[90], acc, 1)
                      : acc;
             });
   }
   function to_alist(opt, t){
    if(opt) var sth = opt[1], key_order = sth; else var key_order = 608542111;
    return 608542111 <= key_order
            ? fold_right
              (t, 0, function(key, data, x){return [0, [0, key, data], x];})
            : fold
              (t, 0, function(key, data, x){return [0, [0, key, data], x];});
   }
   function merge(t1, t2, f, compare_key){
    var
     _b1_ = length(t2),
     _b2_ = length(t1),
     _b3_ = caml_call2(Base_Import[90], _b2_, _b1_),
     elts = caml_call1(Base_Uniform_array[34], _b3_),
     i = [0, 0];
    iter2
     (t1,
      t2,
      function(key, values){
       var match = caml_call2(f, key, values);
       if(! match) return 0;
       var value = match[1];
       caml_call3(Base_Uniform_array[13], elts, i[1], [0, key, value]);
       return caml_call1(Base_Import[129], i);
      },
      compare_key);
    var len = i[1];
    function get(i){return caml_call2(Base_Uniform_array[11], elts, i);}
    var tree = of_increasing_iterator_uncheck(len, get);
    return [0, tree, len];
   }
   function merge_large_first
   (length_large, t_large, t_small, call, combine, compare_key){
    return fold
            (t_small,
             [0, t_large, length_large],
             function(key, data, param){
              var length = param[2], t = param[1];
              return update
                      (t,
                       key,
                       function(param){
                        if(! param) return data;
                        var data$0 = param[1];
                        return caml_call4(call, combine, key, data$0, data);
                       },
                       length,
                       compare_key);
             });
   }
   function call(f, key, x, y){return caml_call3(f, key, x, y);}
   function swap(f, key, x, y){return caml_call3(f, key, y, x);}
   function merge_skewed(t1, t2, length1, length2, combine, compare_key){
    return length2 <= length1
            ? merge_large_first(length1, t1, t2, call, combine, compare_key)
            : merge_large_first(length2, t2, t1, swap, combine, compare_key);
   }
   function repackage(marker, k, v){return marker ? [0, [0, k, v]] : 0;}
   function closest_key(t$0, dir, k$0, compare_key){
    var t = t$0, found_marker = 0, found_key = 0, found_value = 0;
    for(;;){
     if(typeof t === "number")
      return repackage(found_marker, found_key, found_value);
     if(0 === t[0]){
      var
       v = t[2],
       k = t[1],
       c = caml_call2(compare_key, k, k$0),
       _b0_ =
         521507869 <= dir
          ? 927731004 <= dir ? c <= 0 ? 1 : 0 : 0 <= c ? 1 : 0
          : -640801497 <= dir ? c < 0 ? 1 : 0 : 0 < c ? 1 : 0;
      return _b0_
              ? [0, [0, k, v]]
              : repackage(found_marker, found_key, found_value);
     }
     var
      r = t[4],
      found_value$0 = t[3],
      found_key$0 = t[2],
      l = t[1],
      c$0 = caml_call2(compare_key, found_key$0, k$0);
     if(0 === c$0)
      return -640801497 === dir
              ? is_empty
                 (l)
                ? repackage(found_marker, found_key, found_value)
                : max_elt(l)
              : -779285465
                <= dir
                ? [0, [0, found_key$0, found_value$0]]
                : is_empty
                   (r)
                  ? repackage(found_marker, found_key, found_value)
                  : min_elt(r);
     if(-640801497 !== dir && 927731004 > dir){
      if(0 < c$0){
       var
        t = l,
        found_marker = 1,
        found_key = found_key$0,
        found_value = found_value$0;
       continue;
      }
      var t = r;
      continue;
     }
     if(0 <= c$0){var t = l; continue;}
     var
      t = r,
      found_marker = 1,
      found_key = found_key$0,
      found_value = found_value$0;
    }
   }
   function rank(t, k, compare_key){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var k$0 = t$0[1];
      return 0 === caml_call2(compare_key, k$0, k) ? _u_ : 0;
     }
     var
      r = t$0[4],
      k$1 = t$0[2],
      l = t$0[1],
      c = caml_call2(compare_key, k$1, k);
     if(0 === c) return [0, length(l)];
     if(0 < c){var t$0 = l; continue;}
     var
      _bW_ =
        function(rank){
         var _bY_ = length(l), _bZ_ = caml_call2(Base_Import[90], rank, 1);
         return caml_call2(Base_Import[90], _bZ_, _bY_);
        },
      _bX_ = rank(r, k, compare_key);
     return caml_call2(Base_Option[21], _bX_, _bW_);
    }
   }
   function nth(num_to_search, param){
    var param$0 = param;
    for(;;){
     if(typeof param$0 === "number") return 0;
     if(0 === param$0[0]){
      var v = param$0[2], k = param$0[1];
      return 0 === num_to_search[1]
              ? [0, [0, k, v]]
              : (caml_call1(Base_Import[128], num_to_search), 0);
     }
     var
      r = param$0[4],
      v$0 = param$0[3],
      k$0 = param$0[2],
      l = param$0[1],
      some = nth(num_to_search, l);
     if(some) return some;
     if(0 === num_to_search[1]) return [0, [0, k$0, v$0]];
     caml_call1(Base_Import[128], num_to_search);
     var param$0 = r;
    }
   }
   function nth$0(t, n){return nth([0, n], t);}
   function find_first_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_first_satisfying(l, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     var t$0 = r;
    }
   }
   function find_last_satisfying(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var v = t$0[2], k = t$0[1];
      return caml_call2(f, k, v) ? [0, [0, k, v]] : 0;
     }
     var r = t$0[4], v$0 = t$0[3], k$0 = t$0[2], l = t$0[1];
     if(caml_call2(f, k$0, v$0)){
      var x = find_last_satisfying(r, f);
      return x ? x : [0, [0, k$0, v$0]];
     }
     var t$0 = l;
    }
   }
   function binary_search(t, compare, how, v){
    if(-839473056 <= how)
     return 200870407 <= how
             ? 926943384
               <= how
               ? find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
                  })
               : find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) < 0 ? 1 : 0;
                  })
             : -253007807
               <= how
               ? find_last_satisfying
                 (t,
                  function(key, data){
                   return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
                  })
               : find_first_satisfying
                 (t,
                  function(key, data){
                   return 0 < caml_call3(compare, key, data, v) ? 1 : 0;
                  });
    if(-1055410545 <= how){
     var
      pair =
        find_last_satisfying
         (t,
          function(key, data){
           return caml_call3(compare, key, data, v) <= 0 ? 1 : 0;
          });
     if(pair){
      var match = pair[1], data = match[2], key = match[1];
      if(0 === caml_call3(compare, key, data, v)) return pair;
     }
     return 0;
    }
    var
     pair$0 =
       find_first_satisfying
        (t,
         function(key, data){
          return 0 <= caml_call3(compare, key, data, v) ? 1 : 0;
         });
    if(pair$0){
     var match$0 = pair$0[1], data$0 = match$0[2], key$0 = match$0[1];
     if(0 === caml_call3(compare, key$0, data$0, v)) return pair$0;
    }
    return 0;
   }
   function binary_search_segmented(t, segment_of, how){
    function is_left(key, data){
     return 847852583 <= caml_call2(segment_of, key, data) ? 1 : 0;
    }
    function is_right(key, data){return 1 - is_left(key, data);}
    return 125585502 <= how
            ? find_last_satisfying(t, is_left)
            : find_first_satisfying(t, is_right);
   }
   function binary_search_one_sided_bound
   (t, maybe_bound, compare, if_exclusive, if_inclusive){
    function find_bound(t, how, bound, compare){
     var match = binary_search(t, compare, how, bound);
     if(! match) return 0;
     var bound$0 = match[1][1];
     return [0, [0, bound$0]];
    }
    if(typeof maybe_bound === "number") return _v_;
    if(0 === maybe_bound[0]){
     var bound = maybe_bound[1];
     return find_bound(t, if_inclusive, bound, compare);
    }
    var bound$0 = maybe_bound[1];
    return find_bound(t, if_exclusive, bound$0, compare);
   }
   function binary_search_two_sided_bounds
   (t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_one_sided_bound
        (t, lower_bound, compare, -839473056, 926943384);
    if(! match) return 0;
    var
     lower_bound$0 = match[1],
     match$0 =
       binary_search_one_sided_bound
        (t, upper_bound, compare, 200870407, -253007807);
    if(! match$0) return 0;
    var upper_bound$0 = match$0[1];
    return [0, [0, lower_bound$0, upper_bound$0]];
   }
   function of_iteri(iteri, compare_key){
    var acc = [0, 0, [0, empty_without_value_restrictio, 0]];
    caml_call1
     (iteri,
      function(key, data){
       var
        match = acc[2],
        length = match[2],
        map = match[1],
        pair = set(map, length, key, data, compare_key),
        length$0 = pair[2];
       if(length === length$0 && caml_call1(Base_Option[49], acc[1])){acc[1] = [0, key]; return 0;}
       acc[2] = pair;
       return 0;
      });
    var match = acc[1];
    if(! match) return [0, 17724, acc[2]];
    var key = match[1];
    return [0, -1048878709, key];
   }
   function of_iteri_exn(iteri, comparator){
    var match = of_iteri(iteri, comparator[1]);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var
     key = match[2],
     _bV_ =
       caml_call5
        (Base_Error[17],
         0,
         0,
         cst_Map_of_iteri_exn_duplicate,
         key,
         comparator[2]);
    return caml_call1(Base_Error[29], _bV_);
   }
   function t_of_sexp_direct(key_of_sexp, value_of_sexp, sexp, comparator){
    var
     _bL_ = caml_call2(Base_Import[173], key_of_sexp, value_of_sexp),
     alist = caml_call2(Base_Import[175], _bL_, sexp),
     compare_key = comparator[1],
     match = caml_call2(of_alist, alist, compare_key);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var k = match[2];
    function _bM_(_bU_){return _bU_;}
    function _bN_(_bT_){return _bT_;}
    var
     _bO_ = caml_call2(Base_Import[173], _bN_, _bM_),
     alist_sexps = caml_call2(Base_Import[175], _bO_, sexp),
     found_first_k = [0, 0];
    function _bP_(param, _bQ_){
     var
      k2_sexp = _bQ_[1],
      k2 = param[1],
      _bR_ = 0 === caml_call2(compare_key, k, k2) ? 1 : 0;
     if(_bR_){
      if(found_first_k[1])
       return caml_call2
               (Base_Import[158], cst_Map_t_of_sexp_direct_dupli, k2_sexp);
      found_first_k[1] = 1;
      var _bS_ = 0;
     }
     else
      var _bS_ = _bR_;
     return _bS_;
    }
    caml_call3(Base_List0[13], alist, alist_sexps, _bP_);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _w_], 1);
   }
   function sexp_of_t$1(sexp_of_key, sexp_of_value, t){
    function f(key, data, acc){
     var _bK_ = [0, caml_call1(sexp_of_value, data), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, key), _bK_]], acc];
    }
    return [1, fold_right(t, 0, f)];
   }
   function combine_errors(t, compare_key, sexp_of_key){
    var
     _bI_ = partition_map(t, Base_Result[35], compare_key),
     error_tree = _bI_[2][1],
     oks = _bI_[1];
    if(is_empty(error_tree)) return [0, oks];
    var _bJ_ = sexp_of_t$1(sexp_of_key, Base_Error[6], error_tree);
    return caml_call1(Base_Or_error[35], _bJ_);
   }
   function map_keys(t1, f, param){
    var sexp_of_key = param[2], compare_key = param[1];
    return caml_call1
            (with_return,
             function(param){
              return [0,
                      17724,
                      fold
                       (t1,
                        [0, empty_without_value_restrictio, 0],
                        function(key, data, param$0){
                         var
                          length = param$0[2],
                          t2 = param$0[1],
                          key$0 = caml_call1(f, key);
                         try{
                          var
                           _bG_ =
                             add_exn_internal
                              (t2, length, key$0, data, compare_key, sexp_of_key);
                          return _bG_;
                         }
                         catch(_bH_){
                          var _bF_ = caml_wrap_exception(_bH_);
                          if(_bF_ === Duplicate)
                           return caml_call1(param, [0, -1048878709, key$0]);
                          throw caml_maybe_attach_backtrace(_bF_, 0);
                         }
                        })];
             });
   }
   function map_keys_exn(t, f, comparator){
    var match = map_keys(t, f, comparator);
    if(17724 <= match[1]){var result = match[2]; return result;}
    var
     key = match[2],
     sexp_of_key = comparator[2],
     _bD_ = [0, [0, cst_key$0, caml_call1(sexp_of_key, key)], 0],
     _bE_ = caml_call2(Base_Sexp[9], cst_Map_map_keys_exn_duplicate, _bD_);
    return caml_call1(Base_Error[30], _bE_);
   }
   function compare_key(t){return t[1][1];}
   function like(param, _bC_){
    var length = _bC_[2], tree = _bC_[1], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function like2(x, param){
    var z = param[2], y = param[1], _bB_ = like(x, z);
    return [0, like(x, y), _bB_];
   }
   function like_maybe_no_op(old_t, param){
    var
     length = param[2],
     tree = param[1],
     old_tree = old_t[2],
     comparator = old_t[1];
    return caml_call2(Base_Import[127], old_tree, tree)
            ? old_t
            : [0, comparator, tree, length];
   }
   function with_same_length(param, tree){
    var length = param[3], comparator = param[1];
    return [0, comparator, tree, length];
   }
   function of_tree$0(comparator, tree){
    return [0, comparator, tree, length(tree)];
   }
   function comparator(t){return t[1];}
   function to_tree(t){return t[2];}
   function invariants$0(t){
    var _bx_ = compare_key(t), _by_ = invariants(t[2], _bx_);
    if(_by_)
     var _bz_ = t[3], _bA_ = length(t[2]) === _bz_ ? 1 : 0;
    else
     var _bA_ = _by_;
    return _bA_;
   }
   function is_empty$0(t){return is_empty(t[2]);}
   function length$0(t){return t[3];}
   function set$1(t, key, data){
    var _bw_ = compare_key(t);
    return like(t, set(t[2], t[3], key, data, _bw_));
   }
   function add_exn$0(t, key, data){
    var _bu_ = t[1][2], _bv_ = compare_key(t);
    return like(t, add_exn(t[2], t[3], key, data, _bv_, _bu_));
   }
   function add(t, key, data){
    try{
     var
      _bq_ = t[1][2],
      _br_ = compare_key(t),
      result = like(t, add_exn_internal(t[2], t[3], key, data, _br_, _bq_));
    }
    catch(_bt_){
     var _bs_ = caml_wrap_exception(_bt_);
     if(_bs_ === Duplicate) return -1024851605;
     throw caml_maybe_attach_backtrace(_bs_, 0);
    }
    return [0, 17724, result];
   }
   function add_multi$0(t, key, data){
    var _bp_ = compare_key(t);
    return like(t, add_multi(t[2], t[3], key, data, _bp_));
   }
   function remove_multi$0(t, key){
    var _bo_ = compare_key(t);
    return like(t, remove_multi(t[2], key, t[3], _bo_));
   }
   function find_multi$0(t, key){
    var _bn_ = compare_key(t);
    return find_multi(t[2], key, _bn_);
   }
   function change$0(t, key, f){
    var _bm_ = compare_key(t);
    return like(t, change(t[2], key, f, t[3], _bm_));
   }
   function update$0(t, key, f){
    var _bl_ = compare_key(t);
    return like(t, update(t[2], key, f, t[3], _bl_));
   }
   function find_exn$0(t, key){
    var _bj_ = t[1][2], _bk_ = compare_key(t);
    return find_exn(t[2], key, _bk_, _bj_);
   }
   function find$0(t, key){
    var _bi_ = compare_key(t);
    return find(t[2], key, _bi_);
   }
   function remove$0(t, key){
    var _bh_ = compare_key(t);
    return like_maybe_no_op(t, remove(t[2], key, t[3], _bh_));
   }
   function mem$0(t, key){
    var _bg_ = compare_key(t);
    return mem(t[2], key, _bg_);
   }
   function iter_keys$0(t, f){return iter_keys(t[2], f);}
   function iter$0(t, f){return iter(t[2], f);}
   function iteri$0(t, f){return iteri(t[2], f);}
   function iteri_until$0(t, f){return iteri_until(t[2], f);}
   function iter2$0(t1, t2, f){
    var _bf_ = compare_key(t1);
    return iter2(t1[2], t2[2], f, _bf_);
   }
   function map$0(t, f){return with_same_length(t, map(t[2], f));}
   function mapi$0(t, f){return with_same_length(t, mapi(t[2], f));}
   function fold$3(t, init, f){return fold(t[2], init, f);}
   function fold_until$0(t, init, f){
    var _bd_ = t[2];
    return function(_be_){return fold_until(_bd_, init, f, _be_);};
   }
   function fold_right$0(t, init, f){return fold_right(t[2], init, f);}
   function fold2$1(t1, t2, init, f){
    var _bc_ = compare_key(t1);
    return fold2$0(t1[2], t2[2], init, f, _bc_);
   }
   function filter_keys$0(t, f){
    var _bb_ = compare_key(t);
    return like(t, filter_keys(t[2], f, _bb_));
   }
   function filter$0(t, f){
    var _ba_ = compare_key(t);
    return like(t, filter(t[2], f, _ba_));
   }
   function filteri$0(t, f){
    var _a$_ = compare_key(t);
    return like(t, filteri(t[2], f, _a$_));
   }
   function filter_map$0(t, f){
    var _a__ = compare_key(t);
    return like(t, filter_map(t[2], f, _a__));
   }
   function filter_mapi$0(t, f){
    var _a9_ = compare_key(t);
    return like(t, filter_mapi(t[2], f, _a9_));
   }
   function partition_mapi$0(t, f){
    var _a8_ = compare_key(t);
    return like2(t, partition_mapi(t[2], f, _a8_));
   }
   function partition_map$0(t, f){
    var _a7_ = compare_key(t);
    return like2(t, partition_map(t[2], f, _a7_));
   }
   function partitioni_tf$0(t, f){
    var _a6_ = compare_key(t);
    return like2(t, partitioni_tf(t[2], f, _a6_));
   }
   function partition_tf$0(t, f){
    var _a5_ = compare_key(t);
    return like2(t, partition_tf(t[2], f, _a5_));
   }
   function combine_errors$0(t){
    function _a0_(_a4_){return like(t, _a4_);}
    var
     _a1_ = t[1][2],
     _a2_ = compare_key(t),
     _a3_ = combine_errors(t[2], _a2_, _a1_);
    return caml_call2(Base_Or_error[43], _a3_, _a0_);
   }
   function compare_direct(compare_data, t1, t2){
    var _aY_ = t2[2], _aZ_ = t1[2];
    return compare$1(compare_key(t1), compare_data, _aZ_, _aY_);
   }
   function equal$2(compare_data, t1, t2){
    var _aW_ = t2[2], _aX_ = t1[2];
    return equal$1(compare_key(t1), compare_data, _aX_, _aW_);
   }
   function keys$0(t){return keys(t[2]);}
   function data$0(t){return data(t[2]);}
   function to_alist$0(key_order, t){return to_alist(key_order, t[2]);}
   function symmetric_diff$0(t1, t2, data_equal){
    var _aV_ = compare_key(t1);
    return symmetric_diff(t1[2], t2[2], _aV_, data_equal);
   }
   function fold_symmetric_diff$0(t1, t2, data_equal, init, f){
    var _aU_ = compare_key(t1);
    return fold_symmetric_diff(t1[2], t2[2], _aU_, data_equal, init, f);
   }
   function merge$0(t1, t2, f){
    var _aT_ = compare_key(t1);
    return like(t1, merge(t1[2], t2[2], f, _aT_));
   }
   function merge_skewed$0(t1, t2, combine){
    var
     _aR_ = compare_key(t1),
     _aS_ = merge_skewed(t1[2], t2[2], t1[3], t2[3], combine, _aR_),
     t1$0 = t2[3] <= t1[3] ? t1 : t2;
    return like_maybe_no_op(t1$0, _aS_);
   }
   function min_elt$0(t){return min_elt(t[2]);}
   function min_elt_exn$0(t){return min_elt_exn(t[2]);}
   function max_elt$0(t){return max_elt(t[2]);}
   function max_elt_exn$0(t){return max_elt_exn(t[2]);}
   function for_all$0(t, f){return for_all(t[2], f);}
   function for_alli$0(t, f){return for_alli(t[2], f);}
   function exists$0(t, f){return exists(t[2], f);}
   function existsi$0(t, f){return existsi(t[2], f);}
   function count$0(t, f){return count(t[2], f);}
   function counti$0(t, f){return counti(t[2], f);}
   function split$0(t, k){
    var
     _aP_ = compare_key(t),
     match = split(t[2], k, _aP_),
     r = match[3],
     maybe = match[2],
     l = match[1],
     comparator = t[1],
     both_len =
       caml_call1(Base_Option[50], maybe)
        ? caml_call2(Base_Import[92], t[3], 1)
        : t[3],
     _aQ_ = height(r);
    if(height(l) < _aQ_){
     var l$0 = of_tree$0(comparator, l);
     return [0,
             l$0,
             maybe,
             [0, comparator, r, caml_call2(Base_Import[92], both_len, l$0[3])]];
    }
    var r$0 = of_tree$0(comparator, r);
    return [0,
            [0, comparator, l, caml_call2(Base_Import[92], both_len, r$0[3])],
            maybe,
            r$0];
   }
   function subrange(t, lower_bound, upper_bound){
    var
     _aL_ = compare_key(t),
     match = split_range(t[2], lower_bound, upper_bound, _aL_),
     right = match[3],
     mid = match[2],
     left = match[1],
     h_l = height(left),
     h_r = height(right),
     outer_joined_height =
       h_l === h_r
        ? caml_call2(Base_Import[90], h_l, 1)
        : caml_call2(Base_Import[99], h_l, h_r);
    if(outer_joined_height >= height(mid)) return of_tree$0(t[1], mid);
    var
     _aM_ = length(right),
     _aN_ = length(left),
     _aO_ = caml_call2(Base_Import[90], _aN_, _aM_),
     mid_length = caml_call2(Base_Import[92], t[3], _aO_);
    return [0, t[1], mid, mid_length];
   }
   function append$0(lower_part, upper_part){
    var
     _aJ_ = compare_key(lower_part),
     match = append(lower_part[2], upper_part[2], _aJ_);
    if(typeof match === "number") return 838882908;
    var
     tree = match[2],
     _aK_ = caml_call2(Base_Import[90], lower_part[3], upper_part[3]);
    return [0, 17724, [0, lower_part[1], tree, _aK_]];
   }
   function fold_range_inclusive$0(t, min, max, init, f){
    var _aI_ = compare_key(t);
    return fold_range_inclusive(t[2], min, max, init, f, _aI_);
   }
   function range_to_alist$0(t, min, max){
    var _aH_ = compare_key(t);
    return range_to_alist(t[2], min, max, _aH_);
   }
   function closest_key$0(t, dir, key){
    var _aG_ = compare_key(t);
    return closest_key(t[2], dir, key, _aG_);
   }
   function nth$1(t, n){return nth$0(t[2], n);}
   function nth_exn(t, n){
    var _aF_ = nth$1(t, n);
    return caml_call4(Base_Option[28], 0, 0, 0, _aF_);
   }
   function rank$0(t, key){
    var _aE_ = compare_key(t);
    return rank(t[2], key, _aE_);
   }
   function sexp_of_t$2(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t[2]);
   }
   function to_sequence$0
   (order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (t[1],
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t[2]);
   }
   function binary_search$0(t, compare, how, v){
    return binary_search(t[2], compare, how, v);
   }
   function binary_search_segmented$0(t, segment_of, how){
    return binary_search_segmented(t[2], segment_of, how);
   }
   function hash_fold_direct(hash_fold_key, hash_fold_data, state, t){
    var t$0 = t[2];
    function _aC_(key, data, state){
     return caml_call2
             (hash_fold_data, caml_call2(hash_fold_key, state, key), data);
    }
    var _aD_ = length(t$0);
    return fold(t$0, caml_call2(Base_Import[206], state, _aD_), _aC_);
   }
   function binary_search_subrange(t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t[2], compare, lower_bound, upper_bound);
    if(! match) return like_maybe_no_op(t, _x_);
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange(t, lower_bound$0, upper_bound$0);
   }
   function empty$0(param){return empty_without_value_restrictio;}
   function of_tree$1(param, tree){return tree;}
   function singleton(param, k, v){return [0, k, v];}
   function of_sorted_array_unchecked$0(comparator, array){
    var _aB_ = of_sorted_array_unchecked(array, comparator[1]);
    return caml_call1(Base_Import[124], _aB_);
   }
   function of_sorted_array$0(comparator, array){
    var _aA_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[43], _aA_, Base_Import[124]);
   }
   function of_alist$0(comparator, alist){
    var d = caml_call2(of_alist, alist, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_alist_or_error$0(comparator, alist){
    var _az_ = caml_call2(of_alist_or_error, alist, comparator);
    return caml_call2(Base_Or_error[43], _az_, Base_Import[124]);
   }
   function of_alist_exn$0(comparator, alist){
    var _ay_ = caml_call2(of_alist_exn, alist, comparator);
    return caml_call1(Base_Import[124], _ay_);
   }
   function of_alist_multi$0(comparator, alist){
    var _ax_ = of_alist_multi(alist, comparator[1]);
    return caml_call1(Base_Import[124], _ax_);
   }
   function of_alist_fold$0(comparator, alist, init, f){
    var _aw_ = caml_call4(of_alist_fold, alist, init, f, comparator[1]);
    return caml_call1(Base_Import[124], _aw_);
   }
   function of_alist_reduce$0(comparator, alist, f){
    var _av_ = caml_call3(of_alist_reduce, alist, f, comparator[1]);
    return caml_call1(Base_Import[124], _av_);
   }
   function of_iteri$0(comparator, iteri){
    var d = of_iteri(iteri, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_iteri_exn$0(comparator, iteri){
    var _au_ = of_iteri_exn(iteri, comparator);
    return caml_call1(Base_Import[124], _au_);
   }
   function of_increasing_iterator_uncheck$0(required_by_intf, len, f){return of_increasing_iterator_uncheck(len, f);
   }
   function of_increasing_sequence$0(comparator, seq){
    var
     _as_ = Base_Import[124],
     _at_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2(Base_Or_error[43], _at_, _as_);
   }
   function of_sequence$0(comparator, seq){
    var d = caml_call2(of_sequence, seq, comparator[1]);
    if(17724 > d[1]) return d;
    var tree = d[2][1];
    return [0, 17724, tree];
   }
   function of_sequence_or_error$0(comparator, seq){
    var _ar_ = caml_call2(of_sequence_or_error, seq, comparator);
    return caml_call2(Base_Or_error[43], _ar_, Base_Import[124]);
   }
   function of_sequence_exn$0(comparator, seq){
    var _aq_ = caml_call2(of_sequence_exn, seq, comparator);
    return caml_call1(Base_Import[124], _aq_);
   }
   function of_sequence_multi$0(comparator, seq){
    var _ap_ = of_sequence_multi(seq, comparator[1]);
    return caml_call1(Base_Import[124], _ap_);
   }
   function of_sequence_fold$0(comparator, seq, init, f){
    var _ao_ = caml_call4(of_sequence_fold, seq, init, f, comparator[1]);
    return caml_call1(Base_Import[124], _ao_);
   }
   function of_sequence_reduce$0(comparator, seq, f){
    var _an_ = caml_call3(of_sequence_reduce, seq, f, comparator[1]);
    return caml_call1(Base_Import[124], _an_);
   }
   function to_tree$0(t){return t;}
   function invariants$1(comparator, t){return invariants(t, comparator[1]);}
   function is_empty$1(t){return is_empty(t);}
   function length$1(t){return length(t);}
   function set$2(comparator, t, key, data){
    var _am_ = set(t, 0, key, data, comparator[1]);
    return caml_call1(Base_Import[124], _am_);
   }
   function add_exn$1(comparator, t, key, data){
    var _al_ = add_exn(t, 0, key, data, comparator[1], comparator[2]);
    return caml_call1(Base_Import[124], _al_);
   }
   function add$0(comparator, t, key, data){
    try{
     var _aj_ = [0, 17724, add_exn$1(comparator, t, key, data)];
     return _aj_;
    }
    catch(_ak_){return -1024851605;}
   }
   function add_multi$1(comparator, t, key, data){
    var _ai_ = add_multi(t, 0, key, data, comparator[1]);
    return caml_call1(Base_Import[124], _ai_);
   }
   function remove_multi$1(comparator, t, key){
    var _ah_ = remove_multi(t, key, 0, comparator[1]);
    return caml_call1(Base_Import[124], _ah_);
   }
   function find_multi$1(comparator, t, key){
    return find_multi(t, key, comparator[1]);
   }
   function change$1(comparator, t, key, f){
    var _ag_ = change(t, key, f, 0, comparator[1]);
    return caml_call1(Base_Import[124], _ag_);
   }
   function update$1(comparator, t, key, f){
    return change$1
            (comparator,
             t,
             key,
             function(data){return [0, caml_call1(f, data)];});
   }
   function find_exn$1(comparator, t, key){
    return find_exn(t, key, comparator[1], comparator[2]);
   }
   function find$1(comparator, t, key){return find(t, key, comparator[1]);}
   function remove$1(comparator, t, key){
    var _af_ = remove(t, key, 0, comparator[1]);
    return caml_call1(Base_Import[124], _af_);
   }
   function mem$1(comparator, t, key){return mem(t, key, comparator[1]);}
   function iter_keys$1(t, f){return iter_keys(t, f);}
   function iter$1(t, f){return iter(t, f);}
   function iteri$1(t, f){return iteri(t, f);}
   function iteri_until$1(t, f){return iteri_until(t, f);}
   function iter2$1(comparator, t1, t2, f){
    return iter2(t1, t2, f, comparator[1]);
   }
   function map$1(t, f){return map(t, f);}
   function mapi$1(t, f){return mapi(t, f);}
   function fold$4(t, init, f){return fold(t, init, f);}
   function fold_until$1(t, init, f, finish){return fold_until(t, init, f, finish);
   }
   function fold_right$1(t, init, f){return fold_right(t, init, f);}
   function fold2$2(comparator, t1, t2, init, f){
    return fold2$0(t1, t2, init, f, comparator[1]);
   }
   function filter_keys$1(comparator, t, f){
    var _ae_ = filter_keys(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _ae_);
   }
   function filter$1(comparator, t, f){
    var _ad_ = filter(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _ad_);
   }
   function filteri$1(comparator, t, f){
    var _ac_ = filteri(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _ac_);
   }
   function filter_map$1(comparator, t, f){
    var _ab_ = filter_map(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _ab_);
   }
   function filter_mapi$1(comparator, t, f){
    var _aa_ = filter_mapi(t, f, comparator[1]);
    return caml_call1(Base_Import[124], _aa_);
   }
   function partition_mapi$1(comparator, t, f){
    var
     _$_ = partition_mapi(t, f, comparator[1]),
     b = _$_[2][1],
     a = _$_[1][1];
    return [0, a, b];
   }
   function partition_map$1(comparator, t, f){
    var
     ___ = partition_map(t, f, comparator[1]),
     b = ___[2][1],
     a = ___[1][1];
    return [0, a, b];
   }
   function partitioni_tf$1(comparator, t, f){
    var
     _Z_ = partitioni_tf(t, f, comparator[1]),
     b = _Z_[2][1],
     a = _Z_[1][1];
    return [0, a, b];
   }
   function partition_tf$1(comparator, t, f){
    var _Y_ = partition_tf(t, f, comparator[1]), b = _Y_[2][1], a = _Y_[1][1];
    return [0, a, b];
   }
   function combine_errors$1(comparator, t){
    var
     _W_ = Base_Import[124],
     _X_ = combine_errors(t, comparator[1], comparator[2]);
    return caml_call2(Base_Or_error[43], _X_, _W_);
   }
   function compare_direct$0(comparator, compare_data, t1, t2){return compare$1(comparator[1], compare_data, t1, t2);
   }
   function equal$3(comparator, compare_data, t1, t2){
    return equal$1(comparator[1], compare_data, t1, t2);
   }
   function keys$1(t){return keys(t);}
   function data$1(t){return data(t);}
   function to_alist$1(key_order, t){return to_alist(key_order, t);}
   function symmetric_diff$1(comparator, t1, t2, data_equal){
    return symmetric_diff(t1, t2, comparator[1], data_equal);
   }
   function fold_symmetric_diff$1(comparator, t1, t2, data_equal, init, f){
    return fold_symmetric_diff(t1, t2, comparator[1], data_equal, init, f);
   }
   function merge$1(comparator, t1, t2, f){
    var _V_ = merge(t1, t2, f, comparator[1]);
    return caml_call1(Base_Import[124], _V_);
   }
   function merge_skewed$1(comparator, t1, t2, combine){
    var
     _S_ = comparator[1],
     _T_ = length$1(t2),
     _U_ = merge_skewed(t1, t2, length$1(t1), _T_, combine, _S_);
    return caml_call1(Base_Import[124], _U_);
   }
   function min_elt$1(t){return min_elt(t);}
   function min_elt_exn$1(t){return min_elt_exn(t);}
   function max_elt$1(t){return max_elt(t);}
   function max_elt_exn$1(t){return max_elt_exn(t);}
   function for_all$1(t, f){return for_all(t, f);}
   function for_alli$1(t, f){return for_alli(t, f);}
   function exists$1(t, f){return exists(t, f);}
   function existsi$1(t, f){return existsi(t, f);}
   function count$1(t, f){return count(t, f);}
   function counti$1(t, f){return counti(t, f);}
   function split$1(comparator, t, k){return split(t, k, comparator[1]);}
   function append$1(comparator, lower_part, upper_part){
    return append(lower_part, upper_part, comparator[1]);
   }
   function subrange$0(comparator, t, lower_bound, upper_bound){
    var ret = split_range(t, lower_bound, upper_bound, comparator[1])[2];
    return ret;
   }
   function fold_range_inclusive$1(comparator, t, min, max, init, f){
    return fold_range_inclusive(t, min, max, init, f, comparator[1]);
   }
   function range_to_alist$1(comparator, t, min, max){
    return range_to_alist(t, min, max, comparator[1]);
   }
   function closest_key$1(comparator, t, dir, key){
    return closest_key(t, dir, key, comparator[1]);
   }
   function nth$2(t, n){return nth$0(t, n);}
   function nth_exn$0(t, n){
    var _R_ = nth$2(t, n);
    return caml_call4(Base_Option[28], 0, 0, 0, _R_);
   }
   function rank$1(comparator, t, key){return rank(t, key, comparator[1]);}
   function sexp_of_t$3(sexp_of_k, sexp_of_v, param, t){return sexp_of_t$1(sexp_of_k, sexp_of_v, t);
   }
   function t_of_sexp_direct$0(comparator, k_of_sexp, v_of_sexp, sexp){
    var _Q_ = t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator);
    return caml_call1(Base_Import[124], _Q_);
   }
   function to_sequence$1
   (comparator, order, keys_greater_or_equal_to, keys_less_or_equal_to, t){
    return to_sequence
            (comparator,
             order,
             keys_greater_or_equal_to,
             keys_less_or_equal_to,
             t);
   }
   function binary_search$1(param, t, compare, how, v){return binary_search(t, compare, how, v);
   }
   function binary_search_segmented$1(param, t, segment_of, how){return binary_search_segmented(t, segment_of, how);
   }
   function binary_search_subrange$0
   (comparator, t, compare, lower_bound, upper_bound){
    var
     match =
       binary_search_two_sided_bounds(t, compare, lower_bound, upper_bound);
    if(! match) return 0;
    var
     match$0 = match[1],
     upper_bound$0 = match$0[2],
     lower_bound$0 = match$0[1];
    return subrange$0(comparator, t, lower_bound$0, upper_bound$0);
   }
   function map_keys$0(comparator, t, f){
    var dup = map_keys(t, f, comparator);
    if(17724 > dup[1]) return dup;
    var t$0 = dup[2][1];
    return [0, 17724, t$0];
   }
   function map_keys_exn$0(comparator, t, f){
    var _P_ = map_keys_exn(t, f, comparator);
    return caml_call1(Base_Import[124], _P_);
   }
   function add_exn$2(t, comparator, key, data){
    var match = max_key(t);
    if(match){
     var prev_key = match[1];
     if(0 <= caml_call2(comparator[1], prev_key, key))
      return caml_call1(Base_Error[30], _y_);
    }
    return add_unchecked(t, key, data);
   }
   function to_tree$1(t){return to_tree_unchecked(t);}
   var Build_increasing = [0, empty, add_exn$2, to_tree$1];
   function empty$1(comparator){
    return [0, comparator, empty_without_value_restrictio, 0];
   }
   function singleton$0(comparator, k, v){return [0, comparator, [0, k, v], 1];
   }
   function of_tree0(comparator, param){
    var length = param[2], tree = param[1];
    return [0, comparator, tree, length];
   }
   function of_tree$2(comparator, tree){
    return of_tree0(comparator, [0, tree, length(tree)]);
   }
   function of_sorted_array_unchecked$1(comparator, array){
    return of_tree0
            (comparator, of_sorted_array_unchecked(array, comparator[1]));
   }
   function of_sorted_array$1(comparator, array){
    function _N_(tree){return of_tree0(comparator, tree);}
    var _O_ = of_sorted_array(array, comparator[1]);
    return caml_call2(Base_Or_error[43], _O_, _N_);
   }
   function of_alist$1(comparator, alist){
    var z = caml_call2(of_alist, alist, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_alist_or_error$1(comparator, alist){
    function _L_(tree){return of_tree0(comparator, tree);}
    var _M_ = caml_call2(of_alist_or_error, alist, comparator);
    return caml_call2(Base_Result[30], _M_, _L_);
   }
   function of_alist_exn$1(comparator, alist){
    return of_tree0(comparator, caml_call2(of_alist_exn, alist, comparator));
   }
   function of_alist_multi$1(comparator, alist){
    return of_tree0(comparator, of_alist_multi(alist, comparator[1]));
   }
   function of_alist_fold$1(comparator, alist, init, f){
    return of_tree0
            (comparator,
             caml_call4(of_alist_fold, alist, init, f, comparator[1]));
   }
   function of_alist_reduce$1(comparator, alist, f){
    return of_tree0
            (comparator, caml_call3(of_alist_reduce, alist, f, comparator[1]));
   }
   function of_iteri$1(comparator, iteri){
    var z = of_iteri(iteri, comparator[1]);
    if(17724 > z[1]) return z;
    var tree_length = z[2];
    return [0, 17724, of_tree0(comparator, tree_length)];
   }
   function of_iteri_exn$1(comparator, iteri){
    return of_tree0(comparator, of_iteri_exn(iteri, comparator));
   }
   function of_increasing_iterator_uncheck$1(comparator, len, f){
    return of_tree0
            (comparator, [0, of_increasing_iterator_uncheck(len, f), len]);
   }
   function of_increasing_sequence$1(comparator, seq){
    function _I_(_K_){return of_tree0(comparator, _K_);}
    var _J_ = of_increasing_sequence(seq, comparator[1]);
    return caml_call2(Base_Or_error[43], _J_, _I_);
   }
   function of_sequence$1(comparator, seq){
    var z = caml_call2(of_sequence, seq, comparator[1]);
    if(17724 > z[1]) return z;
    var match = z[2], length = match[2], tree = match[1];
    return [0, 17724, [0, comparator, tree, length]];
   }
   function of_sequence_or_error$1(comparator, seq){
    function _G_(tree){return of_tree0(comparator, tree);}
    var _H_ = caml_call2(of_sequence_or_error, seq, comparator);
    return caml_call2(Base_Result[30], _H_, _G_);
   }
   function of_sequence_exn$1(comparator, seq){
    return of_tree0(comparator, caml_call2(of_sequence_exn, seq, comparator));
   }
   function of_sequence_multi$1(comparator, seq){
    return of_tree0(comparator, of_sequence_multi(seq, comparator[1]));
   }
   function of_sequence_fold$1(comparator, seq, init, f){
    return of_tree0
            (comparator,
             caml_call4(of_sequence_fold, seq, init, f, comparator[1]));
   }
   function of_sequence_reduce$1(comparator, seq, f){
    return of_tree0
            (comparator,
             caml_call3(of_sequence_reduce, seq, f, comparator[1]));
   }
   function t_of_sexp_direct$1(comparator, k_of_sexp, v_of_sexp, sexp){
    return of_tree0
            (comparator,
             t_of_sexp_direct(k_of_sexp, v_of_sexp, sexp, comparator));
   }
   function map_keys$1(comparator, t, f){
    var dup = map_keys(t[2], f, comparator);
    if(17724 > dup[1]) return dup;
    var pair = dup[2];
    return [0, 17724, of_tree0(comparator, pair)];
   }
   function map_keys_exn$1(comparator, t, f){
    return of_tree0(comparator, map_keys_exn(t[2], f, comparator));
   }
   function Empty_without_value_restrictio(K){
    var empty = [0, K[1], empty_without_value_restrictio, 0];
    return [0, empty];
   }
   function comparator_s(t){var comparator = t[1]; return [0, comparator];}
   function of_tree$3(M){
    return function(tree){return of_tree$0(M[1], tree);};
   }
   function empty$2(m){return empty$1(m[1]);}
   function singleton$1(m, a){
    var _E_ = m[1];
    return function(_F_){return singleton$0(_E_, a, _F_);};
   }
   function of_alist$2(m, a){return of_alist$1(m[1], a);}
   function of_alist_or_error$2(m, a){return of_alist_or_error$1(m[1], a);}
   function of_alist_exn$2(m, a){return of_alist_exn$1(m[1], a);}
   function of_alist_multi$2(m, a){return of_alist_multi$1(m[1], a);}
   function of_alist_fold$2(m, a, init, f){
    return of_alist_fold$1(m[1], a, init, f);
   }
   function of_alist_reduce$2(m, a, f){return of_alist_reduce$1(m[1], a, f);}
   function of_sorted_array_unchecked$2(m, a){
    return of_sorted_array_unchecked$1(m[1], a);
   }
   function of_sorted_array$2(m, a){return of_sorted_array$1(m[1], a);}
   function of_iteri$2(m, iteri){return of_iteri$1(m[1], iteri);}
   function of_iteri_exn$2(m, iteri){return of_iteri_exn$1(m[1], iteri);}
   function of_increasing_iterator_uncheck$2(m, len, f){
    return of_increasing_iterator_uncheck$1(m[1], len, f);
   }
   function of_increasing_sequence$2(m, seq){
    return of_increasing_sequence$1(m[1], seq);
   }
   function of_sequence$2(m, s){return of_sequence$1(m[1], s);}
   function of_sequence_or_error$2(m, s){
    return of_sequence_or_error$1(m[1], s);
   }
   function of_sequence_exn$2(m, s){return of_sequence_exn$1(m[1], s);}
   function of_sequence_multi$2(m, s){return of_sequence_multi$1(m[1], s);}
   function of_sequence_fold$2(m, s, init, f){
    return of_sequence_fold$1(m[1], s, init, f);
   }
   function of_sequence_reduce$2(m, s, f){
    return of_sequence_reduce$1(m[1], s, f);
   }
   function map_keys$2(m, t, f){return map_keys$1(m[1], t, f);}
   function map_keys_exn$2(m, t, f){return map_keys_exn$1(m[1], t, f);}
   function M(K){return [0];}
   function sexp_of_m_t(K){
    return function(sexp_of_v, t){
     function _D_(param){return _z_;}
     return sexp_of_t$2(K[1], sexp_of_v, _D_, t);};
   }
   function m_t_of_sexp(K){
    return function(v_of_sexp, sexp){
     return t_of_sexp_direct$1(K[2], K[1], v_of_sexp, sexp);};
   }
   function m_t_sexp_grammar(K){
    return function(v_grammar){
     return [2, [1, [2, [0, K[1], [0, v_grammar, 0]]]]];};
   }
   function compare_m_t(param, compare_v, t1, t2){return compare_direct(compare_v, t1, t2);
   }
   function equal_m_t(param, equal_v, t1, t2){return equal$2(equal_v, t1, t2);
   }
   function hash_fold_m_t(K){
    return function(hash_fold_v, state){
     var _B_ = K[1];
     return function(_C_){
      return hash_fold_direct(_B_, hash_fold_v, state, _C_);};};
   }
   var comparator$0 = Base_Comparator[2][1];
   function of_tree$4(tree){return [0, comparator$0, tree, length(tree)];}
   var
    include$1 = Empty_without_value_restrictio(Base_Comparator[2]),
    empty$3 = include$1[1];
   function singleton$2(a){
    return function(_A_){return singleton$0(comparator$0, a, _A_);};
   }
   function of_alist$3(a){return of_alist$1(comparator$0, a);}
   function of_alist_or_error$3(a){
    return of_alist_or_error$1(comparator$0, a);
   }
   function of_alist_exn$3(a){return of_alist_exn$1(comparator$0, a);}
   function of_alist_multi$3(a){return of_alist_multi$1(comparator$0, a);}
   function of_alist_fold$3(a, init, f){
    return of_alist_fold$1(comparator$0, a, init, f);
   }
   function of_alist_reduce$3(a, f){
    return of_alist_reduce$1(comparator$0, a, f);
   }
   function of_sorted_array_unchecked$3(a){
    return of_sorted_array_unchecked$1(comparator$0, a);
   }
   function of_sorted_array$3(a){return of_sorted_array$1(comparator$0, a);}
   function of_iteri$3(iteri){return of_iteri$1(comparator$0, iteri);}
   function of_iteri_exn$3(iteri){return of_iteri_exn$1(comparator$0, iteri);}
   function of_increasing_iterator_uncheck$3(len, f){
    return of_increasing_iterator_uncheck$1(comparator$0, len, f);
   }
   function of_increasing_sequence$3(seq){
    return of_increasing_sequence$1(comparator$0, seq);
   }
   function of_sequence$3(s){return of_sequence$1(comparator$0, s);}
   function of_sequence_or_error$3(s){
    return of_sequence_or_error$1(comparator$0, s);
   }
   function of_sequence_exn$3(s){return of_sequence_exn$1(comparator$0, s);}
   function of_sequence_multi$3(s){
    return of_sequence_multi$1(comparator$0, s);
   }
   function of_sequence_fold$3(s, init, f){
    return of_sequence_fold$1(comparator$0, s, init, f);
   }
   function of_sequence_reduce$3(s, f){
    return of_sequence_reduce$1(comparator$0, s, f);
   }
   function map_keys$3(t, f){return map_keys$1(comparator$0, t, f);}
   function map_keys_exn$3(t, f){return map_keys_exn$1(comparator$0, t, f);}
   var
    Base_Map =
      [0,
       Finished_or_unfinished,
       Merge_element,
       invariants$0,
       comparator_s,
       comparator,
       empty$2,
       singleton$1,
       of_alist$2,
       of_alist_or_error$2,
       of_alist_exn$2,
       of_alist_multi$2,
       of_alist_fold$2,
       of_alist_reduce$2,
       of_iteri$2,
       of_iteri_exn$2,
       of_sorted_array$2,
       of_sorted_array_unchecked$2,
       of_increasing_iterator_uncheck$2,
       of_increasing_sequence$2,
       of_sequence$2,
       of_sequence_or_error$2,
       of_sequence_exn$2,
       of_sequence_multi$2,
       of_sequence_fold$2,
       of_sequence_reduce$2,
       is_empty$0,
       length$0,
       set$1,
       add,
       add_exn$0,
       add_multi$0,
       remove_multi$0,
       find_multi$0,
       change$0,
       update$0,
       find$0,
       find_exn$0,
       remove$0,
       mem$0,
       iter_keys$0,
       iter$0,
       iteri$0,
       iteri_until$0,
       iter2$0,
       map$0,
       mapi$0,
       map_keys$2,
       map_keys_exn$2,
       fold$3,
       fold_until$0,
       fold_right$0,
       fold2$1,
       filter_keys$0,
       filter$0,
       filteri$0,
       filter_map$0,
       filter_mapi$0,
       partition_mapi$0,
       partition_map$0,
       partitioni_tf$0,
       partition_tf$0,
       combine_errors$0,
       compare_direct,
       hash_fold_direct,
       equal$2,
       keys$0,
       data$0,
       to_alist$0,
       merge$0,
       merge_skewed$0,
       Symmetric_diff_element,
       symmetric_diff$0,
       fold_symmetric_diff$0,
       min_elt$0,
       min_elt_exn$0,
       max_elt$0,
       max_elt_exn$0,
       for_all$0,
       for_alli$0,
       exists$0,
       existsi$0,
       count$0,
       counti$0,
       split$0,
       append$0,
       subrange,
       fold_range_inclusive$0,
       range_to_alist$0,
       closest_key$0,
       nth$1,
       nth_exn,
       rank$0,
       to_sequence$0,
       binary_search$0,
       binary_search_segmented$0,
       binary_search_subrange,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       compare_m_t,
       equal_m_t,
       hash_fold_m_t,
       [0,
        sexp_of_t$2,
        t_of_sexp_direct$1,
        [0,
         sexp_of_t$3,
         t_of_sexp_direct$0,
         empty$0,
         singleton,
         map_keys$0,
         map_keys_exn$0,
         of_alist$0,
         of_alist_or_error$0,
         of_alist_exn$0,
         of_alist_multi$0,
         of_alist_fold$0,
         of_alist_reduce$0,
         of_sorted_array$0,
         of_sorted_array_unchecked$0,
         of_increasing_iterator_uncheck$0,
         of_increasing_sequence$0,
         of_sequence$0,
         of_sequence_or_error$0,
         of_sequence_exn$0,
         of_sequence_multi$0,
         of_sequence_fold$0,
         of_sequence_reduce$0,
         of_iteri$0,
         of_iteri_exn$0,
         of_tree$1,
         invariants$1,
         is_empty$1,
         length$1,
         add$0,
         add_exn$1,
         set$2,
         add_multi$1,
         remove_multi$1,
         find_multi$1,
         change$1,
         update$1,
         find$1,
         find_exn$1,
         remove$1,
         mem$1,
         iter_keys$1,
         iter$1,
         iteri$1,
         iteri_until$1,
         iter2$1,
         map$1,
         mapi$1,
         fold$4,
         fold_until$1,
         fold_right$1,
         fold2$2,
         filter_keys$1,
         filter$1,
         filteri$1,
         filter_map$1,
         filter_mapi$1,
         partition_mapi$1,
         partition_map$1,
         partitioni_tf$1,
         partition_tf$1,
         combine_errors$1,
         compare_direct$0,
         equal$3,
         keys$1,
         data$1,
         to_alist$1,
         merge$1,
         merge_skewed$1,
         symmetric_diff$1,
         fold_symmetric_diff$1,
         min_elt$1,
         min_elt_exn$1,
         max_elt$1,
         max_elt_exn$1,
         for_all$1,
         for_alli$1,
         exists$1,
         existsi$1,
         count$1,
         counti$1,
         split$1,
         append$1,
         subrange$0,
         fold_range_inclusive$1,
         range_to_alist$1,
         closest_key$1,
         nth$2,
         nth_exn$0,
         rank$1,
         to_tree$0,
         to_sequence$1,
         binary_search$1,
         binary_search_segmented$1,
         binary_search_subrange$0,
         empty_without_value_restrictio,
         Build_increasing],
        invariants$0,
        is_empty$0,
        length$0,
        add,
        add_exn$0,
        set$1,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$0,
        find_exn$0,
        remove$0,
        mem$0,
        iter_keys$0,
        iter$0,
        iteri$0,
        iteri_until$0,
        iter2$0,
        map$0,
        mapi$0,
        fold$3,
        fold_until$0,
        fold_right$0,
        fold2$1,
        filter_keys$0,
        filter$0,
        filteri$0,
        filter_map$0,
        filter_mapi$0,
        partition_mapi$0,
        partition_map$0,
        partitioni_tf$0,
        partition_tf$0,
        combine_errors$0,
        compare_direct,
        equal$2,
        keys$0,
        data$0,
        to_alist$0,
        merge$0,
        merge_skewed$0,
        symmetric_diff$0,
        fold_symmetric_diff$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        for_all$0,
        for_alli$0,
        exists$0,
        existsi$0,
        count$0,
        counti$0,
        split$0,
        append$0,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$1,
        nth_exn,
        rank$0,
        to_tree,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        binary_search_subrange,
        empty$1,
        singleton$0,
        map_keys$1,
        map_keys_exn$1,
        of_alist$1,
        of_alist_or_error$1,
        of_alist_exn$1,
        of_alist_multi$1,
        of_alist_fold$1,
        of_alist_reduce$1,
        of_sorted_array$1,
        of_sorted_array_unchecked$1,
        of_increasing_iterator_uncheck$1,
        of_increasing_sequence$1,
        of_sequence$1,
        of_sequence_or_error$1,
        of_sequence_exn$1,
        of_sequence_multi$1,
        of_sequence_fold$1,
        of_sequence_reduce$1,
        of_iteri$1,
        of_iteri_exn$1,
        of_tree$2,
        comparator,
        hash_fold_direct,
        Empty_without_value_restrictio],
       [0,
        empty$3,
        singleton$2,
        map_keys$3,
        map_keys_exn$3,
        of_alist$3,
        of_alist_or_error$3,
        of_alist_exn$3,
        of_alist_multi$3,
        of_alist_fold$3,
        of_alist_reduce$3,
        of_sorted_array$3,
        of_sorted_array_unchecked$3,
        of_increasing_iterator_uncheck$3,
        of_increasing_sequence$3,
        of_sequence$3,
        of_sequence_or_error$3,
        of_sequence_exn$3,
        of_sequence_multi$3,
        of_sequence_fold$3,
        of_sequence_reduce$3,
        of_iteri$3,
        of_iteri_exn$3,
        of_tree$4,
        invariants$0,
        is_empty$0,
        length$0,
        add,
        add_exn$0,
        set$1,
        add_multi$0,
        remove_multi$0,
        find_multi$0,
        change$0,
        update$0,
        find$0,
        find_exn$0,
        remove$0,
        mem$0,
        iter_keys$0,
        iter$0,
        iteri$0,
        iteri_until$0,
        iter2$0,
        map$0,
        mapi$0,
        fold$3,
        fold_until$0,
        fold_right$0,
        fold2$1,
        filter_keys$0,
        filter$0,
        filteri$0,
        filter_map$0,
        filter_mapi$0,
        partition_mapi$0,
        partition_map$0,
        partitioni_tf$0,
        partition_tf$0,
        combine_errors$0,
        compare_direct,
        equal$2,
        keys$0,
        data$0,
        to_alist$0,
        merge$0,
        merge_skewed$0,
        symmetric_diff$0,
        fold_symmetric_diff$0,
        min_elt$0,
        min_elt_exn$0,
        max_elt$0,
        max_elt_exn$0,
        for_all$0,
        for_alli$0,
        exists$0,
        existsi$0,
        count$0,
        counti$0,
        split$0,
        append$0,
        subrange,
        fold_range_inclusive$0,
        range_to_alist$0,
        closest_key$0,
        nth$1,
        nth_exn,
        rank$0,
        to_tree,
        to_sequence$0,
        binary_search$0,
        binary_search_segmented$0,
        binary_search_subrange],
       of_tree$3,
       to_tree];
   runtime.caml_register_global(67, Base_Map, "Base__Map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue0
//# unitInfo: Requires: Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Queue = global_data.Stdlib__Queue,
    create = Stdlib_Queue[2],
    clear = Stdlib_Queue[11],
    copy = Stdlib_Queue[12],
    is_empty = Stdlib_Queue[13],
    length = Stdlib_Queue[14],
    peek = Stdlib_Queue[8],
    pop = Stdlib_Queue[7],
    push = Stdlib_Queue[4],
    transfer = Stdlib_Queue[17];
   function iter(t, f){return caml_call2(Stdlib_Queue[15], f, t);}
   function fold(t, init, f){return caml_call3(Stdlib_Queue[16], f, init, t);}
   var
    Base_Linked_queue0 =
      [0,
       create,
       clear,
       copy,
       is_empty,
       length,
       peek,
       pop,
       push,
       transfer,
       iter,
       fold];
   runtime.caml_register_global(1, Base_Linked_queue0, "Base__Linked_queue0");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Linked_queue
//# unitInfo: Requires: Base__Array, Base__Import, Base__Indexed_container, Base__Linked_queue0, Base__List, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_List = global_data.Base__List,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_Import = global_data.Base__Import,
    Base_Array = global_data.Base__Array,
    Base_Linked_queue0 = global_data.Base__Linked_queue0,
    Base_Indexed_container = global_data.Base__Indexed_container,
    create = Base_Linked_queue0[1],
    clear = Base_Linked_queue0[2],
    copy = Base_Linked_queue0[3],
    is_empty = Base_Linked_queue0[4],
    length = Base_Linked_queue0[5],
    iter = Base_Linked_queue0[10],
    fold = Base_Linked_queue0[11];
   function enqueue(t, x){return caml_call2(Base_Linked_queue0[8], x, t);}
   function dequeue(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[7], t)];
   }
   var dequeue_exn = Base_Linked_queue0[7];
   function peek(t){
    return caml_call1(is_empty, t)
            ? 0
            : [0, caml_call1(Base_Linked_queue0[6], t)];
   }
   var
    peek_exn = Base_Linked_queue0[6],
    iter$0 = [0, -198771759, iter],
    length$0 = [0, -198771759, length],
    C =
      caml_call1
       (Base_Indexed_container[8],
        [0, fold, iter$0, length$0, -304398144, -304398144]),
    count = C[10],
    exists = C[8],
    find = C[12],
    find_map = C[13],
    fold_result = C[6],
    fold_until = C[7],
    for_all = C[9],
    max_elt = C[17],
    mem = C[1],
    min_elt = C[16],
    sum = C[11],
    to_list = C[14],
    counti = C[22],
    existsi = C[20],
    find_mapi = C[24],
    findi = C[23],
    foldi = C[18],
    for_alli = C[21],
    iteri = C[19];
   function transfer(src, dst){
    return caml_call2(Base_Linked_queue0[9], src, dst);
   }
   function concat_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       function _o_(b){return enqueue(res, b);}
       var _p_ = caml_call1(f, a);
       return caml_call2(Base_List[9], _p_, _o_);
      });
    return res;
   }
   function concat_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       function _m_(b){return enqueue(res, b);}
       var _n_ = caml_call2(f, i, a);
       return caml_call2(Base_List[9], _n_, _m_);
      });
    return res;
   }
   function filter_map(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var match = caml_call1(f, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter_mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var match = caml_call2(f, i, a);
       if(! match) return 0;
       var b = match[1];
       return enqueue(res, b);
      });
    return res;
   }
   function filter(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iter,
      t,
      function(a){
       var _l_ = caml_call1(f, a);
       return _l_ ? enqueue(res, a) : _l_;
      });
    return res;
   }
   function filteri(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri,
      t,
      function(i, a){
       var _k_ = caml_call2(f, i, a);
       return _k_ ? enqueue(res, a) : _k_;
      });
    return res;
   }
   function map(t, f){
    var res = caml_call1(create, 0);
    caml_call2(iter, t, function(a){return enqueue(res, caml_call1(f, a));});
    return res;
   }
   function mapi(t, f){
    var res = caml_call1(create, 0);
    caml_call2
     (iteri, t, function(i, a){return enqueue(res, caml_call2(f, i, a));});
    return res;
   }
   function filter_inplace(q, f){
    var q$0 = filter(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function filteri_inplace(q, f){
    var q$0 = filteri(q, f);
    caml_call1(clear, q);
    return transfer(q$0, q);
   }
   function enqueue_all(t, list){
    function _j_(x){return enqueue(t, x);}
    return caml_call2(Base_List[9], list, _j_);
   }
   function of_list(list){
    var t = caml_call1(create, 0);
    function _i_(x){return enqueue(t, x);}
    caml_call2(Base_List[9], list, _i_);
    return t;
   }
   function of_array(array){
    var t = caml_call1(create, 0);
    function _h_(x){return enqueue(t, x);}
    caml_call2(Base_Array[9], array, _h_);
    return t;
   }
   function init(len, f){
    var
     t = caml_call1(create, 0),
     _f_ = caml_call2(Base_Import[92], len, 1),
     _e_ = 0;
    if(_f_ >= 0){
     var i = _e_;
     for(;;){
      enqueue(t, caml_call1(f, i));
      var _g_ = i + 1 | 0;
      if(_f_ !== i){var i = _g_; continue;}
      break;
     }
    }
    return t;
   }
   function to_array(t){
    var len = caml_call1(length, t);
    if(0 === len) return [0];
    var
     _c_ = caml_call1(peek_exn, t),
     arr = caml_call2(Base_Array[25], len, _c_),
     i = [0, 0];
    caml_call2
     (iter,
      t,
      function(v){
       var _d_ = i[1];
       runtime.caml_check_bound(arr, _d_)[1 + _d_] = v;
       return caml_call1(Base_Import[129], i);
      });
    return arr;
   }
   function t_of_sexp(a_of_sexp, sexp){
    return of_list(caml_call2(Base_Import[175], a_of_sexp, sexp));
   }
   function sexp_of_t(sexp_of_a, t){
    var _b_ = caml_call1(to_list, t);
    return caml_call2(Base_Import[151], sexp_of_a, _b_);
   }
   function t_sexp_grammar(grammar){
    var _a_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _a_);
   }
   function singleton(a){
    var t = caml_call1(create, 0);
    enqueue(t, a);
    return t;
   }
   var
    Base_Linked_queue =
      [0,
       t_of_sexp,
       sexp_of_t,
       t_sexp_grammar,
       mem,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       foldi,
       iteri,
       existsi,
       for_alli,
       counti,
       findi,
       find_mapi,
       singleton,
       of_list,
       of_array,
       init,
       enqueue,
       enqueue_all,
       dequeue,
       dequeue_exn,
       peek,
       peek_exn,
       clear,
       copy,
       map,
       mapi,
       concat_map,
       concat_mapi,
       filter_map,
       filter_mapi,
       filter,
       filteri,
       filter_inplace,
       filteri_inplace,
       create,
       transfer];
   runtime.caml_register_global(6, Base_Linked_queue, "Base__Linked_queue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int64
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int64, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_Lx = "%Lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_bswap = runtime.caml_int64_bswap,
    caml_int64_compare = runtime.caml_int64_compare,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_or = runtime.caml_int64_or,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int64.Hex",
    module_name$0 = "Base.Int64",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    hash_fold_t = Base_Import[203],
    func = Base_Import[217],
    _e_ = [0, [7, 6, 0, 0, 0], cst_Lx],
    _d_ = [0, [7, 6, 0, 0, 0], cst_Lx],
    cst_Int64_ceil_log2_got_invali = "[Int64.ceil_log2] got invalid input",
    cst_Int64_floor_log2_got_inval = "[Int64.floor_log2] got invalid input",
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _b_ = [0, "src/int64.ml", 100, 2],
    _a_ =
      [0,
       [11,
        "Int64.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int64.of_float: argument (%f) is out of range or NaN"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[168],
    sexp_of_t = Base_Import[144],
    t_sexp_grammar = Base_Import[188],
    hashable = [0, hash, Stdlib_Int64[15], sexp_of_t];
   function compare(_C_, _B_){return caml_int64_compare(_C_, _B_);}
   var
    to_string = Stdlib_Int64[14],
    of_string = runtime.caml_int64_of_string,
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    float_lower_bound = caml_call1(Base_Float0[25], 64),
    float_upper_bound = caml_call1(Base_Float0[23], 64),
    float_of_bits = runtime.caml_int64_float_of_bits,
    bits_of_float = runtime.caml_int64_bits_of_float,
    shift_right_logical = caml_int64_shift_right_unsigne,
    shift_right = runtime.caml_int64_shift_right,
    shift_left = runtime.caml_int64_shift_left,
    bit_not = Stdlib_Int64[11],
    bit_xor = runtime.caml_int64_xor,
    bit_or = caml_int64_or,
    bit_and = caml_int64_and,
    min_value = Stdlib_Int64[10],
    max_value = Stdlib_Int64[9],
    abs = Stdlib_Int64[8],
    pred = Stdlib_Int64[7],
    succ = Stdlib_Int64[6],
    pow = Base_Int_math[2][2],
    rem = runtime.caml_int64_mod,
    neg = caml_int64_neg,
    minus_one = Stdlib_Int64[3],
    one = Stdlib_Int64[2],
    zero = Stdlib_Int64[1],
    to_float = runtime.caml_int64_to_float,
    of_float_unchecked = caml_int64_of_float,
    num_bits = 64;
   function of_float(f){
    if
     (caml_call2(Base_Import[107][6], f, float_lower_bound)
      && caml_call2(Base_Import[107][2], f, float_upper_bound))
     return caml_int64_of_float(f);
    var _A_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _a_, _A_, 0);
   }
   function symbol(b, e){return caml_call2(pow, b, e);}
   function bswap16(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 48);
   }
   function bswap32(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 32);
   }
   function bswap48(x){
    return caml_int64_shift_right_unsigne(caml_int64_bswap(x), 16);
   }
   var
    include$0 = caml_call1(Base_Comparable[13], [0, compare, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5];
   function invariant(param){return 0;}
   function between(t, low, high){
    var
     _y_ = caml_lessequal(low, t),
     _z_ = _y_ ? caml_lessequal(t, high) : _y_;
    return _z_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _v_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _w_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _v_],
     _x_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _w_);
    return caml_call1(Base_Or_error[35], _x_);
   }
   function incr(r){r[1] = caml_int64_add(r[1], one); return 0;}
   function decr(r){r[1] = caml_int64_sub(r[1], one); return 0;}
   function of_int64_exn(_u_){return _u_;}
   function to_int64(t){return t;}
   var
    popcount = Base_Popcount[3],
    of_int_exn = caml_int64_of_int32,
    to_int = Base_Int_conversions[11],
    to_int_exn = Base_Int_conversions[12],
    of_int32_exn = caml_int64_of_int32,
    to_int32 = Base_Int_conversions[14],
    to_int32_exn = Base_Int_conversions[15],
    of_nativeint = Base_Int_conversions[28],
    to_nativeint = Base_Int_conversions[17],
    to_nativeint_exn = Base_Int_conversions[18],
    raise_s = Base_Error[30];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   function ceil_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int64[7], x),
     x$1 = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 1)),
     x$2 = caml_int64_or(x$1, caml_int64_shift_right_unsigne(x$1, 2)),
     x$3 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 4)),
     x$4 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 8)),
     x$5 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 16)),
     x$6 = caml_int64_or(x$5, caml_int64_shift_right_unsigne(x$5, 32));
    return caml_call1(Stdlib_Int64[6], x$6);
   }
   function floor_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var
     x$0 = caml_int64_or(x, caml_int64_shift_right_unsigne(x, 1)),
     x$1 = caml_int64_or(x$0, caml_int64_shift_right_unsigne(x$0, 2)),
     x$2 = caml_int64_or(x$1, caml_int64_shift_right_unsigne(x$1, 4)),
     x$3 = caml_int64_or(x$2, caml_int64_shift_right_unsigne(x$2, 8)),
     x$4 = caml_int64_or(x$3, caml_int64_shift_right_unsigne(x$3, 16)),
     x$5 = caml_int64_or(x$4, caml_int64_shift_right_unsigne(x$4, 32));
    return caml_int64_sub(x$5, caml_int64_shift_right_unsigne(x$5, 1));
   }
   function is_pow2(x){
    if(caml_lessequal(x, Stdlib_Int64[1])) non_positive_argument(0);
    var _t_ = Stdlib_Int64[1];
    return caml_equal(caml_int64_and(x, caml_call1(Stdlib_Int64[7], x)), _t_);
   }
   function floor_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _q_ = [0, [0, cst, caml_call1(Base_Import[144], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int64_floor_log2_got_inval, _q_));
    }
    var
     _r_ = runtime.Base_int_math_int64_clz(i),
     _s_ = caml_call2(Base_Import[92], num_bits, 1);
    return caml_call2(Base_Import[92], _s_, _r_);
   }
   function ceil_log2(i){
    if(caml_lessequal(i, Stdlib_Int64[1])){
     var _o_ = [0, [0, cst$0, caml_call1(Base_Import[144], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int64_ceil_log2_got_invali, _o_));
    }
    if(caml_call2(Stdlib_Int64[17], i, Stdlib_Int64[2])) return 0;
    var _p_ = runtime.Base_int_math_int64_clz(caml_call1(Stdlib_Int64[7], i));
    return caml_call2(Base_Import[92], num_bits, _p_);
   }
   var
    include$1 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare$0 = Base_Import[230],
    hash_fold_t$0 = Base_Import[203],
    func$0 = Base_Import[217];
   function hash$0(x){return caml_call1(func$0, x);}
   var symbol$0 = caml_lessthan;
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    function _m_(_n_){return _n_;}
    return caml_call3(Stdlib_Scanf[4], s, _e_, _m_);
   }
   var
    include$2 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$0,
         neg,
         module_name]),
    Hex = include$2[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         caml_int64_add,
         caml_int64_sub,
         runtime.caml_int64_mul,
         runtime.caml_int64_div,
         caml_int64_neg,
         runtime.caml_greaterequal,
         caml_lessequal,
         caml_equal,
         caml_greaterthan,
         caml_lessthan,
         runtime.caml_notequal,
         abs,
         caml_int64_neg,
         zero,
         of_int_exn,
         rem]),
    symbol$1 = include$3[1],
    symbol$2 = include$3[2],
    symbol$3 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    include$4 = Base_Import[102],
    ascending = include$4[1],
    descending = include$4[2],
    max = include$4[3],
    min = include$4[4],
    _f_ = [0, symbol, bit_not, abs, zero, symbol$1, symbol$2, symbol$3];
   function _g_(_l_){return runtime.Base_int_math_int64_ctz(_l_);}
   function _h_(_k_){return runtime.Base_int_math_int64_clz(_k_);}
   var
    Base_Int64 =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       caml_equal,
       function(_j_, _i_){return caml_int64_compare(_j_, _i_);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       one,
       minus_one,
       rem,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       _h_,
       _g_,
       _f_,
       symbol,
       bit_not,
       abs,
       zero,
       symbol$1,
       symbol$2,
       symbol$3,
       to_int,
       to_int32,
       of_nativeint,
       to_nativeint,
       bits_of_float,
       float_of_bits,
       bswap16,
       bswap32,
       bswap48];
   runtime.caml_register_global(29, Base_Int64, "Base__Int64");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63_emul
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Float0, Base__Import, Base__Int64, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Stdlib__Int64, Stdlib__MoreLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_int63_emul_ml = "src/int63_emul.ml",
    caml_equal = runtime.caml_equal,
    caml_greaterequal = runtime.caml_greaterequal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int64_add = runtime.caml_int64_add,
    caml_int64_and = runtime.caml_int64_and,
    caml_int64_mul = runtime.caml_int64_mul,
    caml_int64_neg = runtime.caml_int64_neg,
    caml_int64_of_float = runtime.caml_int64_of_float,
    caml_int64_of_string = runtime.caml_int64_of_string,
    caml_int64_shift_right = runtime.caml_int64_shift_right,
    caml_int64_shift_right_unsigne = runtime.caml_int64_shift_right_unsigned,
    caml_int64_sub = runtime.caml_int64_sub,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_notequal = runtime.caml_notequal,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    mask = runtime.caml_int64_create_lo_mi_hi(16777214, 16777215, 65535),
    module_name = "Base.Int63.Hex",
    module_name$0 = "Base.Int63",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Int64 = global_data.Base__Int64,
    Base_String = global_data.Base__String,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Base_Popcount = global_data.Base__Popcount,
    Base_Comparator = global_data.Base__Comparator,
    Base_Int_math = global_data.Base__Int_math,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    compare = Base_Import[230],
    hash_fold_t = Base_Import[203],
    sexp_of_t = Base_Import[144],
    t_sexp_grammar = Base_Import[188],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    cst_0x = "0x",
    _l_ = [0, [7, 6, 0, 0, 0], "%Lx"],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _k_ = [0, cst_src_int63_emul_ml, 317, 2],
    _i_ =
      [0,
       [11,
        "Int63.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int63.of_float: argument (%f) is out of range or NaN"],
    _h_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    _g_ =
      [0,
       [11, "Int63.of_string: invalid input ", [3, 0, 0]],
       "Int63.of_string: invalid input %S"],
    _e_ = [0, cst_src_int63_emul_ml, 114, 20],
    _d_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _c_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _b_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _a_ = runtime.caml_int64_create_lo_mi_hi(2, 0, 0),
    _f_ = runtime.caml_int64_create_lo_mi_hi(1, 0, 0);
   function wrap_exn(x){
    caml_call1(Base_Int_conversions[20], x);
    return caml_int64_mul(x, _a_);
   }
   function wrap_modulo(x){return caml_int64_mul(x, _c_);}
   function unwrap(x){return caml_int64_shift_right(x, 1);}
   function m(x){return caml_int64_and(x, mask);}
   function invariant(t){
    if(caml_equal(m(t), t)) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   var
    symbol = caml_int64_add,
    symbol$0 = caml_int64_sub,
    symbol$1 = caml_int64_neg;
   function abs(x){return caml_call1(Stdlib_Int64[8], x);}
   var one = wrap_exn(_f_);
   function succ(a){return caml_int64_add(a, one);}
   function pred(a){return caml_int64_sub(a, one);}
   var min_value = m(Stdlib_Int64[10]), max_value = m(Stdlib_Int64[9]);
   function bit_not(x){return m(caml_call1(Stdlib_Int64[11], x));}
   var
    bit_and = caml_int64_and,
    bit_xor = runtime.caml_int64_xor,
    bit_or = runtime.caml_int64_or,
    shift_left = runtime.caml_int64_shift_left;
   function shift_right(x, i){return m(caml_int64_shift_right(x, i));}
   function shift_right_logical(x, i){
    return m(caml_int64_shift_right_unsigne(x, i));
   }
   var f = Base_Int_math[2][3];
   function pow(a, b){
    return caml_int64_mul
            (caml_call2
              (f, caml_int64_shift_right(a, 1), caml_int64_shift_right(b, 1)),
             _d_);
   }
   function symbol$2(a, b){
    return caml_int64_mul(a, caml_int64_shift_right(b, 1));
   }
   function symbol$3(a, b){return wrap_modulo(runtime.caml_int64_div(a, b));}
   var rem = runtime.caml_int64_mod;
   function popcount(x){return caml_call1(Base_Popcount[3], x);}
   function to_int64(t){return caml_int64_shift_right(t, 1);}
   function of_int64(t){
    return caml_call1(Base_Int_conversions[21], t)
            ? [0, caml_int64_mul(t, _b_)]
            : 0;
   }
   function of_int64_exn(t){return wrap_exn(t);}
   function of_int64_trunc(t){return wrap_modulo(t);}
   function t_of_sexp(x){return wrap_exn(caml_call1(Base_Import[168], x));}
   function sexp_of_t$0(x){
    return caml_call1(Base_Import[144], caml_int64_shift_right(x, 1));
   }
   function compare$0(x, y){return caml_call2(compare, x, y);}
   function is_pow2(x){
    return caml_call1(Base_Int64[67], caml_int64_shift_right(x, 1));
   }
   function clz(x){return caml_call1(Base_Int64[68], x);}
   function ctz(x){
    return caml_call1(Base_Int64[69], caml_int64_shift_right(x, 1));
   }
   function floor_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[64], caml_int64_shift_right(x, 1)));
   }
   function ceil_pow2(x){
    return wrap_exn(caml_call1(Base_Int64[64], caml_int64_shift_right(x, 1)));
   }
   function floor_log2(x){
    return caml_call1(Base_Int64[66], caml_int64_shift_right(x, 1));
   }
   function ceil_log2(x){
    return caml_call1(Base_Int64[65], caml_int64_shift_right(x, 1));
   }
   function hash(x){return caml_call1(Stdlib_MoreLabels[1][28], x);}
   var hashable = [0, hash, compare$0, sexp_of_t$0];
   function invalid_str(x){return caml_call3(Base_Printf[6], _g_, x, 0);}
   function to_string(x){
    return caml_call1(Stdlib_Int64[14], caml_int64_shift_right(x, 1));
   }
   function of_string(str){
    try{
     var len = caml_ml_string_length(str);
     if(0 < len){
      var switcher = caml_string_get(str, 0) - 43 | 0, switch$0 = 0;
      if(2 < switcher >>> 0)
       switch$0 = 1;
      else
       switch(switcher){
         case 0:
          var sign = 4003188, pos = 1; break;
         case 1:
          switch$0 = 1; break;
         default: var sign = 3901488, pos = 1;
       }
      if(switch$0) var sign = 4003188, pos = 0;
     }
     else
      var sign = 4003188, pos = 0;
     if(caml_call2(Base_Import[90], pos, 2) < len)
      var
       c1 = caml_string_get(str, pos),
       c2 = caml_string_get(str, caml_call2(Base_Import[90], pos, 1)),
       match =
         48 === c1
          ? 9 < c2 - 48 >>> 0 ? [0, sign, 0] : [0, sign, 1]
          : [0, sign, 1];
     else
      var match = [0, sign, 1];
     var signedness = match[2];
     if(signedness)
      var _w_ = of_int64_exn(caml_int64_of_string(str));
     else{
      if(4003188 <= sign)
       var pos_str = str;
      else
       var
        _x_ = caml_call2(Base_Import[92], caml_ml_string_length(str), 1),
        pos_str = caml_call3(Base_String[2], str, 1, _x_);
      var int64 = caml_int64_of_string(pos_str);
      if(caml_lessthan(int64, _h_)) invalid_str(str);
      var
       int63 = wrap_modulo(int64),
       int63$0 = 4003188 <= sign ? int63 : caml_int64_neg(int63),
       _w_ = int63$0;
     }
     return _w_;
    }
    catch(_y_){return invalid_str(str);}
   }
   function bswap16(t){
    return wrap_modulo
            (caml_call1(Base_Int64[84], caml_int64_shift_right(t, 1)));
   }
   function bswap32(t){
    return wrap_modulo
            (caml_call1(Base_Int64[85], caml_int64_shift_right(t, 1)));
   }
   function bswap48(t){
    return wrap_modulo
            (caml_call1(Base_Int64[86], caml_int64_shift_right(t, 1)));
   }
   var
    float_lower_bound = caml_call1(Base_Float0[25], 63),
    float_upper_bound = caml_call1(Base_Float0[23], 63),
    minus_one = wrap_exn(Stdlib_Int64[3]),
    one$0 = wrap_exn(Stdlib_Int64[2]),
    zero = wrap_exn(Stdlib_Int64[1]),
    num_bits = 63;
   function to_float(x){
    return runtime.caml_int64_to_float(caml_int64_shift_right(x, 1));
   }
   function of_float_unchecked(x){return wrap_modulo(caml_int64_of_float(x));}
   function of_float(t){
    if
     (caml_call2(Base_Import[107][6], t, float_lower_bound)
      && caml_call2(Base_Import[107][2], t, float_upper_bound))
     return wrap_modulo(caml_int64_of_float(t));
    var _v_ = caml_call1(Base_Float0[27], t);
    return caml_call3(Base_Printf[7], _i_, _v_, 0);
   }
   var
    _j_ = caml_call1(Base_Comparable[13], [0, compare$0, sexp_of_t$0, zero]),
    is_positive = _j_[1],
    is_non_negative = _j_[2],
    is_negative = _j_[3],
    is_non_positive = _j_[4],
    sign = _j_[5];
   function between(t, low, high){
    var
     _t_ = caml_lessequal(low, t),
     _u_ = _t_ ? caml_lessequal(t, high) : _t_;
    return _u_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _q_ = [0, [0, cst_max, sexp_of_t$0(max)], 0],
     _r_ = [0, [0, cst_min, sexp_of_t$0(min)], _q_],
     _s_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _r_);
    return caml_call1(Base_Or_error[35], _s_);
   }
   function symbol$4(b, e){return pow(b, e);}
   function incr(r){r[1] = caml_int64_add(r[1], one$0); return 0;}
   function decr(r){r[1] = caml_int64_sub(r[1], one$0); return 0;}
   function of_int(x){
    return wrap_exn(caml_call1(Base_Int_conversions[4], x));
   }
   function of_int_exn(x){return of_int(x);}
   function to_int(x){
    return caml_call1(Base_Int_conversions[11], caml_int64_shift_right(x, 1));
   }
   function to_int_exn(x){
    return caml_call1(Base_Int_conversions[12], caml_int64_shift_right(x, 1));
   }
   function to_int_trunc(x){
    return caml_call1(Base_Int_conversions[13], caml_int64_shift_right(x, 1));
   }
   function of_int32(x){
    return wrap_exn(caml_call1(Base_Int_conversions[9], x));
   }
   function of_int32_exn(x){return of_int32(x);}
   function to_int32(x){
    return caml_call1(Base_Int_conversions[14], caml_int64_shift_right(x, 1));
   }
   function to_int32_exn(x){
    return caml_call1(Base_Int_conversions[15], caml_int64_shift_right(x, 1));
   }
   function to_int32_trunc(x){
    return caml_call1(Base_Int_conversions[16], caml_int64_shift_right(x, 1));
   }
   function of_nativeint(x){
    return of_int64(caml_call1(Base_Int_conversions[28], x));
   }
   function of_nativeint_exn(x){
    return wrap_exn(caml_call1(Base_Int_conversions[28], x));
   }
   function of_nativeint_trunc(x){
    return of_int64_trunc(caml_call1(Base_Int_conversions[28], x));
   }
   function to_nativeint(x){
    return caml_call1(Base_Int_conversions[17], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_exn(x){
    return caml_call1(Base_Int_conversions[18], caml_int64_shift_right(x, 1));
   }
   function to_nativeint_trunc(x){
    return caml_call1(Base_Int_conversions[19], caml_int64_shift_right(x, 1));
   }
   var
    include$0 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$0[1],
    sexp_of_t$1 = include$0[2];
   function hash$0(x){return hash(x);}
   var symbol$5 = caml_lessthan;
   function to_string$0(i){
    return caml_call2
            (Base_Printf[2], _l_, caml_int64_shift_right_unsigne(i, 1));
   }
   function of_string$0(s){
    return of_string(caml_call2(Base_Import[111], cst_0x, s));
   }
   var
    include$1 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare$0,
         hash_fold_t,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$5,
         symbol$1,
         module_name]),
    Hex = include$1[1];
   function to_string$1(x){return to_string(x);}
   var
    pp =
      caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string$1])[1],
    symbol$6 = caml_notequal,
    symbol$7 = caml_lessthan,
    symbol$8 = caml_greaterthan,
    symbol$9 = caml_equal,
    symbol$10 = caml_lessequal,
    symbol$11 = caml_greaterequal,
    include$2 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol,
         symbol$0,
         symbol$2,
         symbol$3,
         symbol$1,
         symbol$11,
         symbol$10,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         abs,
         symbol$1,
         zero,
         of_int_exn,
         rem]),
    symbol$12 = include$2[1],
    symbol$13 = include$2[2],
    symbol$14 = include$2[3],
    round = include$2[4],
    round_towards_zero = include$2[5],
    round_down = include$2[6],
    round_up = include$2[7],
    round_nearest = include$2[8],
    Repr = [0],
    include$3 = Base_Import[102],
    ascending = include$3[1],
    descending = include$3[2],
    max = include$3[3],
    min = include$3[4],
    repr = 1,
    _m_ = [0, wrap_exn, unwrap],
    _n_ =
      [0,
       symbol,
       symbol$0,
       symbol$2,
       symbol$3,
       symbol$1,
       symbol$4,
       symbol$11,
       symbol$10,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$6,
       abs,
       symbol$1,
       zero,
       symbol$12,
       symbol$13,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       shift_right_logical],
    Base_Int63_emul =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       to_string,
       caml_greaterequal,
       caml_lessequal,
       caml_equal,
       caml_greaterthan,
       caml_lessthan,
       caml_notequal,
       caml_equal,
       function(_p_, _o_){return runtime.caml_int64_compare(_p_, _o_);},
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       zero,
       one$0,
       minus_one,
       symbol,
       symbol$0,
       symbol$2,
       symbol$4,
       symbol$1,
       symbol$1,
       symbol$13,
       symbol$12,
       symbol$3,
       rem,
       symbol$14,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32_exn,
       to_int32_exn,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint_exn,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       clz,
       ctz,
       _n_,
       of_int,
       to_int,
       to_int_trunc,
       of_int32,
       to_int32,
       to_int32_trunc,
       of_int64,
       of_int64_trunc,
       of_nativeint,
       to_nativeint,
       of_nativeint_trunc,
       to_nativeint_trunc,
       bswap16,
       bswap32,
       bswap48,
       _m_,
       Repr,
       repr];
   runtime.caml_register_global(34, Base_Int63_emul, "Base__Int63_emul");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Bool
//# unitInfo: Requires: Assert_failure, Base__Comparator, Base__Import, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_bool_ml = "src/bool.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    all = [0, 0, [0, 1, 0]],
    module_name = "Base.Bool",
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Printf = global_data.Base__Printf,
    Base_Comparator = global_data.Base__Comparator,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    invalid_argf = Base_Printf[7],
    compare = Base_Import[225],
    hash_fold_t = Base_Import[207],
    func = Base_Import[221],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _b_ = [0, cst_src_bool_ml, 56, 2],
    _a_ =
      [0,
       [11, "Bool.of_string: expected true or false but got ", [2, 0, 0]],
       "Bool.of_string: expected true or false but got %s"],
    _c_ = [0, cst_src_bool_ml, 83, 9];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[161],
    sexp_of_t = Base_Import[137],
    t_sexp_grammar = Base_Import[181],
    hashable = [0, hash, compare, sexp_of_t];
   function of_string(s){
    return caml_string_notequal(s, "false")
            ? caml_string_notequal
               (s, "true")
              ? caml_call3(invalid_argf, _a_, s, 0)
              : 1
            : 0;
   }
   var
    to_string = Base_Import[84][29],
    include = caml_call1(Base_Comparator[5], [0, compare, sexp_of_t]),
    comparator = include[1],
    include$0 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$0[1];
   function invariant(param){return 0;}
   function between(t, low, high){
    var _k_ = caml_call2(Base_Import[104][2], low, t);
    return _k_ ? caml_call2(Base_Import[104][2], t, high) : _k_;
   }
   function clamp_unchecked(t, min, max){
    return caml_call2(Base_Import[104][1], t, min)
            ? min
            : caml_call2(Base_Import[104][2], t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[104][2], min, max))
     return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_call2(Base_Import[104][5], min, max))
     return [0, clamp_unchecked(t, min, max)];
    var
     _h_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _i_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _h_],
     _j_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _i_);
    return caml_call1(Base_Or_error[35], _j_);
   }
   function to_int(x){return caml_call1(Base_Import[85], x);}
   function symbol(a, b){
    var _f_ = to_int(b), _g_ = to_int(a);
    return caml_call2(Base_Import[117], _g_, _f_);
   }
   function symbol$0(a, b){
    var _d_ = to_int(b), _e_ = to_int(a);
    return caml_call2(Base_Import[115], _e_, _d_);
   }
   if(1 === to_int(1) && 0 === to_int(0)){
    var
     include$1 = Base_Import[104],
     symbol$1 = include$1[1],
     symbol$2 = include$1[2],
     symbol$3 = include$1[3],
     symbol$4 = include$1[4],
     symbol$5 = include$1[5],
     symbol$6 = include$1[6],
     ascending = include$1[7],
     descending = include$1[8],
     compare$0 = include$1[9],
     equal = include$1[10],
     max = include$1[11],
     min = include$1[12],
     Base_Bool =
       [0,
        all,
        t_sexp_grammar,
        hash_fold_t,
        hash,
        t_of_sexp,
        sexp_of_t,
        of_string,
        to_string,
        symbol$6,
        symbol$2,
        symbol$4,
        symbol$5,
        symbol$1,
        symbol$3,
        equal,
        compare$0,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        pp,
        hashable,
        invariant,
        to_int,
        [0, symbol$0, symbol]];
    runtime.caml_register_global(17, Base_Bool, "Base__Bool");
    return;
   }
   throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
  }
  (globalThis));

//# unitInfo: Provides: Base__Int32
//# unitInfo: Requires: Assert_failure, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int_conversions, Base__Int_math, Base__Or_error, Base__Popcount, Base__Pretty_printer, Base__Printf, Base__Sexp, Stdlib__Int32, Stdlib__Scanf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    cst_lx = "%lx",
    cst_argument_must_be_strictly_ = "argument must be strictly positive",
    caml_equal = runtime.caml_equal,
    caml_greaterthan = runtime.caml_greaterthan,
    caml_int32_bswap = runtime.caml_int32_bswap,
    caml_lessequal = runtime.caml_lessequal,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    module_name = "Base.Int32.Hex",
    module_name$0 = "Base.Int32",
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Base_Printf = global_data.Base__Printf,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Base_Import = global_data.Base__Import,
    Base_Sexp = global_data.Base__Sexp,
    Base_Int_math = global_data.Base__Int_math,
    Base_Or_error = global_data.Base__Or_error,
    Assert_failure = global_data.Assert_failure,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Comparable = global_data.Base__Comparable,
    Base_Popcount = global_data.Base__Popcount,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Base_Error = global_data.Base__Error,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    hash_fold_t = Base_Import[204],
    func = Base_Import[218],
    _e_ = [0, [5, 6, 0, 0, 0], cst_lx],
    _d_ = [0, [5, 6, 0, 0, 0], cst_lx],
    cst_Int32_ceil_log2_got_invali = "[Int32.ceil_log2] got invalid input",
    cst_Int32_floor_log2_got_inval = "[Int32.floor_log2] got invalid input",
    _c_ =
      [0,
       [11, cst_argument_must_be_strictly_, 0],
       cst_argument_must_be_strictly_],
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _b_ = [0, "src/int32.ml", 97, 4],
    _a_ =
      [0,
       [11,
        "Int32.of_float: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Int32.of_float: argument (%f) is out of range or NaN"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[167],
    sexp_of_t = Base_Import[143],
    t_sexp_grammar = Base_Import[187],
    hashable = [0, hash, Stdlib_Int32[15], sexp_of_t];
   function ascending(x, y){return caml_call2(Stdlib_Int32[15], x, y);}
   var
    to_string = Stdlib_Int32[14],
    of_string = runtime.caml_int_of_string,
    include = caml_call1(Base_Comparator[5], [0, ascending, sexp_of_t]),
    comparator = include[1],
    float_lower_bound = caml_call1(Base_Float0[25], 32),
    float_upper_bound = caml_call1(Base_Float0[23], 32),
    float_of_bits = runtime.caml_int32_float_of_bits,
    bits_of_float = runtime.caml_int32_bits_of_float,
    num_bits = 32;
   function shift_right_logical(_S_, _R_){return _S_ >>> _R_ | 0;}
   function shift_right(_Q_, _P_){return _Q_ >> _P_;}
   function shift_left(_O_, _N_){return _O_ << _N_;}
   var bit_not = Stdlib_Int32[11];
   function bit_xor(_M_, _L_){return _M_ ^ _L_;}
   function bit_or(_K_, _J_){return _K_ | _J_;}
   function bit_and(_I_, _H_){return _I_ & _H_;}
   var
    min_value = Stdlib_Int32[10],
    max_value = Stdlib_Int32[9],
    abs = Stdlib_Int32[8],
    pred = Stdlib_Int32[7],
    succ = Stdlib_Int32[6],
    rem = runtime.caml_mod;
   function symbol(_G_){return - _G_ | 0;}
   var
    minus_one = Stdlib_Int32[3],
    one = Stdlib_Int32[2],
    zero = Stdlib_Int32[1];
   function to_float(_F_){return _F_;}
   function of_float_unchecked(_E_){return _E_ | 0;}
   function of_float(f){
    if
     (caml_call2(Base_Import[107][6], f, float_lower_bound)
      && caml_call2(Base_Import[107][2], f, float_upper_bound))
     return f | 0;
    var _D_ = caml_call1(Base_Float0[27], f);
    return caml_call3(Base_Printf[7], _a_, _D_, 0);
   }
   var
    include$0 =
      caml_call1(Base_Comparable[13], [0, ascending, sexp_of_t, zero]),
    is_positive = include$0[1],
    is_non_negative = include$0[2],
    is_negative = include$0[3],
    is_non_positive = include$0[4],
    sign = include$0[5],
    symbol$0 = runtime.caml_greaterequal,
    symbol$1 = caml_lessequal,
    symbol$2 = caml_equal,
    symbol$3 = caml_greaterthan,
    symbol$4 = caml_lessthan,
    symbol$5 = runtime.caml_notequal;
   function descending(x, y){return ascending(y, x);}
   function min(x, y){return caml_lessthan(x, y) ? x : y;}
   function max(x, y){return caml_greaterthan(x, y) ? x : y;}
   var equal = caml_equal;
   function between(t, low, high){
    var _C_ = caml_lessequal(low, t);
    return _C_ ? caml_lessequal(t, high) : _C_;
   }
   function clamp_unchecked(t, min, max){
    return caml_lessthan(t, min) ? min : caml_lessequal(t, max) ? t : max;
   }
   function clamp_exn(t, min, max){
    if(caml_lessequal(min, max)) return clamp_unchecked(t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   }
   function clamp(t, min, max){
    if(! caml_greaterthan(min, max)) return [0, clamp_unchecked(t, min, max)];
    var
     _z_ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _A_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], _z_],
     _B_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _A_);
    return caml_call1(Base_Or_error[35], _B_);
   }
   function invariant(param){return 0;}
   var symbol$6 = runtime.caml_div, symbol$7 = runtime.caml_mul;
   function symbol$8(_y_, _x_){return _y_ - _x_ | 0;}
   function symbol$9(_w_, _v_){return _w_ + _v_ | 0;}
   function incr(r){r[1] = r[1] + one | 0; return 0;}
   function decr(r){r[1] = r[1] - one | 0; return 0;}
   function of_int32(t){return t;}
   function to_int32(t){return t;}
   var
    popcount = Base_Popcount[2],
    of_int = Base_Int_conversions[1],
    of_int_exn = Base_Int_conversions[2],
    of_int_trunc = Base_Int_conversions[3],
    to_int = Base_Int_conversions[6],
    to_int_exn = Base_Int_conversions[7],
    to_int_trunc = Base_Int_conversions[8],
    of_int64 = Base_Int_conversions[14],
    of_int64_exn = Base_Int_conversions[15],
    of_int64_trunc = Base_Int_conversions[16],
    to_int64 = Base_Int_conversions[9],
    of_nativeint = Base_Int_conversions[25],
    of_nativeint_exn = Base_Int_conversions[26],
    of_nativeint_trunc = Base_Int_conversions[27],
    to_nativeint = Base_Int_conversions[10];
   function pow(b, e){
    var _t_ = caml_call1(to_int_exn, e), _u_ = caml_call1(to_int_exn, b);
    return caml_call1(of_int_exn, caml_call2(Base_Int_math[2][1], _u_, _t_));
   }
   function symbol$10(b, e){return pow(b, e);}
   function bswap16(x){return caml_int32_bswap(x) >>> 16 | 0;}
   var raise_s = Base_Error[30];
   function non_positive_argument(param){
    return caml_call2(Base_Printf[7], _c_, 0);
   }
   function ceil_pow2(x){
    if(caml_call2(Base_Import[101][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x$0 = caml_call1(Stdlib_Int32[7], x),
     x$1 = x$0 | x$0 >>> 1 | 0,
     x$2 = x$1 | x$1 >>> 2 | 0,
     x$3 = x$2 | x$2 >>> 4 | 0,
     x$4 = x$3 | x$3 >>> 8 | 0,
     x$5 = x$4 | x$4 >>> 16 | 0;
    return caml_call1(Stdlib_Int32[6], x$5);
   }
   function floor_pow2(x){
    if(caml_call2(Base_Import[101][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var
     x$0 = x | x >>> 1 | 0,
     x$1 = x$0 | x$0 >>> 2 | 0,
     x$2 = x$1 | x$1 >>> 4 | 0,
     x$3 = x$2 | x$2 >>> 8 | 0,
     x$4 = x$3 | x$3 >>> 16 | 0;
    return x$4 - (x$4 >>> 1 | 0) | 0;
   }
   function is_pow2(x){
    if(caml_call2(Base_Import[101][2], x, Stdlib_Int32[1]))
     non_positive_argument(0);
    var _r_ = Stdlib_Int32[1], _s_ = x & caml_call1(Stdlib_Int32[7], x);
    return caml_call2(Base_Import[101][4], _s_, _r_);
   }
   function floor_log2(i){
    if(caml_call2(Base_Import[101][2], i, Stdlib_Int32[1])){
     var _o_ = [0, [0, cst, caml_call1(Base_Import[143], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int32_floor_log2_got_inval, _o_));
    }
    var
     _p_ = runtime.Base_int_math_int32_clz(i),
     _q_ = caml_call2(Base_Import[92], num_bits, 1);
    return caml_call2(Base_Import[92], _q_, _p_);
   }
   function ceil_log2(i){
    if(caml_call2(Base_Import[101][2], i, Stdlib_Int32[1])){
     var _m_ = [0, [0, cst$0, caml_call1(Base_Import[143], i)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int32_ceil_log2_got_invali, _m_));
    }
    if(caml_call2(Stdlib_Int32[17], i, Stdlib_Int32[2])) return 0;
    var _n_ = runtime.Base_int_math_int32_clz(caml_call1(Stdlib_Int32[7], i));
    return caml_call2(Base_Import[92], num_bits, _n_);
   }
   var
    include$1 = caml_call1(Base_Int_conversions[33], [0, to_string]),
    to_string_hum = include$1[1],
    sexp_of_t$0 = include$1[2],
    compare = Base_Import[229],
    hash_fold_t$0 = Base_Import[204],
    func$0 = Base_Import[218];
   function hash$0(x){return caml_call1(func$0, x);}
   function to_string$0(i){return caml_call2(Base_Printf[2], _d_, i);}
   function of_string$0(s){
    function _k_(_l_){return _l_;}
    return caml_call3(Stdlib_Scanf[4], s, _e_, _k_);
   }
   var
    include$2 =
      caml_call1
       (Base_Int_conversions[34],
        [0,
         compare,
         hash_fold_t$0,
         hash$0,
         to_string$0,
         of_string$0,
         zero,
         symbol$4,
         symbol,
         module_name]),
    Hex = include$2[1],
    pp = caml_call1(Base_Pretty_printer[2], [0, module_name$0, to_string])[1],
    include$3 =
      caml_call1
       (Base_Int_math[1],
        [0,
         of_float,
         to_float,
         of_string,
         to_string,
         symbol$9,
         symbol$8,
         symbol$7,
         symbol$6,
         symbol,
         symbol$0,
         symbol$1,
         symbol$2,
         symbol$3,
         symbol$4,
         symbol$5,
         abs,
         symbol,
         zero,
         of_int_exn,
         rem]),
    symbol$11 = include$3[1],
    symbol$12 = include$3[2],
    symbol$13 = include$3[3],
    round = include$3[4],
    round_towards_zero = include$3[5],
    round_down = include$3[6],
    round_up = include$3[7],
    round_nearest = include$3[8],
    _f_ = caml_int32_bswap,
    _g_ =
      [0,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$6,
       symbol,
       symbol$10,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       abs,
       symbol,
       zero,
       symbol$11,
       symbol$12,
       symbol$13,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       shift_right_logical];
   function _h_(_j_){return runtime.Base_int_math_int32_ctz(_j_);}
   var
    Base_Int32 =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       of_int_exn,
       to_int_exn,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$0,
       of_string,
       to_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       ascending,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       sign,
       invariant,
       Hex,
       to_string_hum,
       zero,
       one,
       minus_one,
       symbol$9,
       symbol$8,
       symbol$7,
       symbol$10,
       symbol,
       symbol,
       symbol$12,
       symbol$11,
       symbol$6,
       rem,
       symbol$13,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       shift_left,
       shift_right,
       round,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       abs,
       succ,
       pred,
       pow,
       bit_and,
       bit_or,
       bit_xor,
       bit_not,
       popcount,
       shift_left,
       shift_right,
       decr,
       incr,
       of_int32,
       to_int32,
       of_int64_exn,
       to_int64,
       of_nativeint_exn,
       to_nativeint,
       of_float_unchecked,
       num_bits,
       max_value,
       min_value,
       shift_right_logical,
       shift_right_logical,
       ceil_pow2,
       floor_pow2,
       ceil_log2,
       floor_log2,
       is_pow2,
       function(_i_){return runtime.Base_int_math_int32_clz(_i_);},
       _h_,
       _g_,
       of_int,
       to_int,
       of_int32,
       to_int32,
       of_nativeint,
       to_nativeint,
       of_int64,
       of_int_trunc,
       to_int_trunc,
       of_nativeint_trunc,
       of_int64_trunc,
       bits_of_float,
       float_of_bits,
       bswap16,
       _f_];
   runtime.caml_register_global(29, Base_Int32, "Base__Int32");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Int63
//# unitInfo: Requires: Assert_failure, Base__Bool, Base__Error, Base__Import, Base__Int, Base__Int63_emul, Base__Int64, Base__Random, Base__Sexp, Base__Word_size
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_product$1 = "product",
    cst_t$3 = "t",
    cst_u$3 = "u",
    caml_div = runtime.caml_div,
    caml_int64_of_int32 = runtime.caml_int64_of_int32,
    caml_int64_to_int32 = runtime.caml_int64_to_int32,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_mul = runtime.caml_mul;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst = "",
    Base_Word_size = global_data.Base__Word_size,
    Base_Int = global_data.Base__Int,
    Base_Sexp = global_data.Base__Sexp,
    Base_Random = global_data.Base__Random,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Int64 = global_data.Base__Int64,
    Base_Error = global_data.Base__Error,
    Base_Int63_emul = global_data.Base__Int63_emul,
    Assert_failure = global_data.Assert_failure,
    raise_s = Base_Error[30],
    cst_Int_floor_log2_got_invalid = "[Int.floor_log2] got invalid input",
    cst_neg_overflow = "neg overflow",
    cst_abs_overflow = "abs overflow",
    cst_product$0 = cst_product$1,
    cst_u$2 = cst_u$3,
    cst_t$2 = cst_t$3,
    cst_overflow$2 = "( / ) overflow",
    cst_product = cst_product$1,
    cst_u$1 = cst_u$3,
    cst_t$1 = cst_t$3,
    cst_overflow$1 = "( * ) overflow",
    cst_diff = "diff",
    cst_u$0 = cst_u$3,
    cst_t$0 = cst_t$3,
    cst_overflow$0 = "( - ) overflow",
    cst_sum = "sum",
    cst_u = cst_u$3,
    cst_t = cst_t$3,
    cst_overflow = "( + ) overflow",
    _b_ = [0, "src/int63.ml", 155, 9],
    repr = Base_Word_size[3] ? 0 : 1,
    t_sexp_grammar = Base_Int[1],
    of_float = Base_Int[2],
    to_float = Base_Int[3],
    of_int_exn = Base_Int[4],
    to_int_exn = Base_Int[5],
    hash_fold_t = Base_Int[6],
    hash = Base_Int[7],
    t_of_sexp = Base_Int[8],
    sexp_of_t = Base_Int[9],
    of_string = Base_Int[10],
    to_string = Base_Int[11],
    equal = Base_Int[12],
    compare = Base_Int[13],
    min = Base_Int[14],
    max = Base_Int[15],
    ascending = Base_Int[16],
    descending = Base_Int[17],
    between = Base_Int[18],
    clamp_exn = Base_Int[19],
    clamp = Base_Int[20],
    comparator = Base_Int[21],
    pp = Base_Int[22],
    hashable = Base_Int[23],
    is_positive = Base_Int[24],
    is_non_negative = Base_Int[25],
    is_negative = Base_Int[26],
    is_non_positive = Base_Int[27],
    sign = Base_Int[28],
    invariant = Base_Int[29],
    Hex = Base_Int[30],
    to_string_hum = Base_Int[31],
    one = Base_Int[32],
    minus_one = Base_Int[33],
    rem = Base_Int[34],
    round = Base_Int[35],
    round_towards_zero = Base_Int[36],
    round_down = Base_Int[37],
    round_up = Base_Int[38],
    round_nearest = Base_Int[39],
    succ = Base_Int[40],
    pred = Base_Int[41],
    pow = Base_Int[42],
    bit_and = Base_Int[43],
    bit_or = Base_Int[44],
    bit_xor = Base_Int[45],
    bit_not = Base_Int[46],
    popcount = Base_Int[47],
    shift_left = Base_Int[48],
    shift_right = Base_Int[49],
    decr = Base_Int[50],
    incr = Base_Int[51],
    of_int32_exn = Base_Int[52],
    to_int32_exn = Base_Int[53],
    of_int64_exn = Base_Int[54],
    to_int64 = Base_Int[55],
    of_nativeint_exn = Base_Int[56],
    to_nativeint_exn = Base_Int[57],
    of_float_unchecked = Base_Int[58],
    num_bits = Base_Int[59],
    max_value = Base_Int[60],
    min_value = Base_Int[61],
    shift_right_logical = Base_Int[62],
    ceil_pow2 = Base_Int[63],
    floor_pow2 = Base_Int[64],
    ceil_log2 = Base_Int[65],
    floor_log2 = Base_Int[66],
    is_pow2 = Base_Int[67],
    clz = Base_Int[68],
    ctz = Base_Int[69],
    O = Base_Int[70],
    symbol = Base_Int[71],
    lnot = Base_Int[72],
    abs = Base_Int[73],
    zero = Base_Int[74],
    symbol$0 = Base_Int[75],
    symbol$1 = Base_Int[76],
    symbol$2 = Base_Int[77],
    of_int = Base_Int[79],
    to_int32 = Base_Int[82],
    of_int64 = Base_Int[83],
    of_nativeint = Base_Int[84],
    _a_ = Base_Int[85];
   function to_int(x){return [0, x];}
   function to_int_trunc(x){return x;}
   function to_nativeint_trunc(x){return caml_call1(_a_, x);}
   function to_nativeint(x){return [0, caml_call1(_a_, x)];}
   var repr$0 = 0;
   function bswap32(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[85], caml_int64_of_int32(t)));
   }
   function bswap48(t){
    return caml_int64_to_int32
            (caml_call1(Base_Int64[86], caml_int64_of_int32(t)));
   }
   if(repr)
    var
     include =
       [0,
        Base_Int63_emul[1],
        Base_Int63_emul[2],
        Base_Int63_emul[3],
        Base_Int63_emul[4],
        Base_Int63_emul[5],
        Base_Int63_emul[6],
        Base_Int63_emul[7],
        Base_Int63_emul[8],
        Base_Int63_emul[9],
        Base_Int63_emul[10],
        Base_Int63_emul[11],
        Base_Int63_emul[12],
        Base_Int63_emul[13],
        Base_Int63_emul[14],
        Base_Int63_emul[15],
        Base_Int63_emul[16],
        Base_Int63_emul[17],
        Base_Int63_emul[18],
        Base_Int63_emul[19],
        Base_Int63_emul[20],
        Base_Int63_emul[21],
        Base_Int63_emul[22],
        Base_Int63_emul[23],
        Base_Int63_emul[24],
        Base_Int63_emul[25],
        Base_Int63_emul[26],
        Base_Int63_emul[27],
        Base_Int63_emul[28],
        Base_Int63_emul[29],
        Base_Int63_emul[30],
        Base_Int63_emul[31],
        Base_Int63_emul[32],
        Base_Int63_emul[33],
        Base_Int63_emul[34],
        Base_Int63_emul[35],
        Base_Int63_emul[36],
        Base_Int63_emul[37],
        Base_Int63_emul[38],
        Base_Int63_emul[39],
        Base_Int63_emul[40],
        Base_Int63_emul[41],
        Base_Int63_emul[42],
        Base_Int63_emul[43],
        Base_Int63_emul[44],
        Base_Int63_emul[45],
        Base_Int63_emul[46],
        Base_Int63_emul[47],
        Base_Int63_emul[48],
        Base_Int63_emul[49],
        Base_Int63_emul[50],
        Base_Int63_emul[51],
        Base_Int63_emul[52],
        Base_Int63_emul[53],
        Base_Int63_emul[54],
        Base_Int63_emul[55],
        Base_Int63_emul[56],
        Base_Int63_emul[57],
        Base_Int63_emul[58],
        Base_Int63_emul[59],
        Base_Int63_emul[60],
        Base_Int63_emul[61],
        Base_Int63_emul[62],
        Base_Int63_emul[63],
        Base_Int63_emul[64],
        Base_Int63_emul[65],
        Base_Int63_emul[66],
        Base_Int63_emul[67],
        Base_Int63_emul[68],
        Base_Int63_emul[69],
        Base_Int63_emul[70],
        Base_Int63_emul[71],
        Base_Int63_emul[72],
        Base_Int63_emul[73],
        Base_Int63_emul[74],
        Base_Int63_emul[75],
        Base_Int63_emul[76],
        Base_Int63_emul[77],
        Base_Int63_emul[78],
        Base_Int63_emul[79],
        Base_Int63_emul[80],
        Base_Int63_emul[81],
        Base_Int63_emul[83],
        Base_Int63_emul[84],
        Base_Int63_emul[85],
        Base_Int63_emul[86],
        Base_Int63_emul[87],
        Base_Int63_emul[88],
        Base_Int63_emul[89],
        Base_Int63_emul[90],
        Base_Int63_emul[91],
        Base_Int63_emul[92],
        Base_Int63_emul[93],
        Base_Int63_emul[94],
        Base_Int63_emul[95],
        Base_Int63_emul[96],
        Base_Int63_emul[97],
        Base_Int63_emul[98],
        Base_Int63_emul[99],
        Base_Int63_emul[100],
        Base_Int63_emul[101],
        Base_Int63_emul[102],
        Base_Int63_emul[103],
        Base_Int63_emul[104],
        Base_Int63_emul[105],
        Base_Int63_emul[106],
        Base_Int63_emul[107],
        Base_Int63_emul[82],
        Base_Int63_emul[113],
        Base_Int63_emul[108],
        Base_Int63_emul[109],
        Base_Int63_emul[110]];
   else
    var
     _c_ = runtime.caml_bswap16,
     _d_ = function(_bo_){return _bo_;},
     _e_ = caml_int64_to_int32,
     _f_ = function(_bn_){return _bn_;},
     _g_ = function(_bm_, _bl_){return _bm_ >>> _bl_ | 0;},
     _h_ = function(_bk_, _bj_){return _bk_ >> _bj_;},
     _i_ = function(_bi_, _bh_){return _bi_ << _bh_;},
     _j_ = O[2],
     _k_ = function(_bg_, _bf_){return _bg_ ^ _bf_;},
     _l_ = function(_be_, _bd_){return _be_ | _bd_;},
     _m_ = function(_bc_, _bb_){return _bc_ & _bb_;},
     _n_ = O[7],
     _o_ = O[6],
     _p_ = O[5],
     _q_ = O[4],
     _r_ = function(_ba_){return - _ba_ | 0;},
     _s_ = O[3],
     _t_ = function(_a$_, _a__){return _a$_ !== _a__ ? 1 : 0;},
     _u_ = function(_a9_, _a8_){return _a9_ < _a8_ ? 1 : 0;},
     _v_ = function(_a7_, _a6_){return _a6_ < _a7_ ? 1 : 0;},
     _w_ = function(_a5_, _a4_){return _a5_ === _a4_ ? 1 : 0;},
     _x_ = function(_a3_, _a2_){return _a3_ <= _a2_ ? 1 : 0;},
     _y_ = function(_a1_, _a0_){return _a0_ <= _a1_ ? 1 : 0;},
     _z_ = O[1],
     _A_ = function(_aZ_){return - _aZ_ | 0;},
     _B_ = caml_div,
     _C_ = caml_mul,
     _D_ = function(_aY_, _aX_){return _aY_ - _aX_ | 0;},
     _E_ =
       [0,
        function(_aW_, _aV_){return _aW_ + _aV_ | 0;},
        _D_,
        _C_,
        _B_,
        _A_,
        _z_,
        _y_,
        _x_,
        _w_,
        _v_,
        _u_,
        _t_,
        _s_,
        _r_,
        _q_,
        _p_,
        _o_,
        _n_,
        _m_,
        _l_,
        _k_,
        _j_,
        _i_,
        _h_,
        _g_],
     _F_ = function(_aU_, _aT_){return _aU_ >>> _aT_ | 0;},
     _G_ = function(_aS_, _aR_){return _aS_ >> _aR_;},
     _H_ = function(_aQ_, _aP_){return _aQ_ << _aP_;},
     _I_ = function(_aO_, _aN_){return _aO_ ^ _aN_;},
     _J_ = function(_aM_, _aL_){return _aM_ | _aL_;},
     _K_ = function(_aK_, _aJ_){return _aK_ & _aJ_;},
     _L_ = caml_div,
     _M_ = function(_aI_){return - _aI_ | 0;},
     _N_ = function(_aH_){return - _aH_ | 0;},
     _O_ = caml_mul,
     _P_ = function(_aG_, _aF_){return _aG_ - _aF_ | 0;},
     _Q_ = function(_aE_, _aD_){return _aE_ + _aD_ | 0;},
     _R_ = function(_aC_, _aB_){return _aC_ !== _aB_ ? 1 : 0;},
     _S_ = function(_aA_, _az_){return _aA_ < _az_ ? 1 : 0;},
     _T_ = function(_ay_, _ax_){return _ax_ < _ay_ ? 1 : 0;},
     _U_ = function(_aw_, _av_){return _aw_ === _av_ ? 1 : 0;},
     _V_ = function(_au_, _at_){return _au_ <= _at_ ? 1 : 0;},
     include =
       [0,
        t_sexp_grammar,
        of_float,
        to_float,
        of_int_exn,
        to_int_exn,
        hash_fold_t,
        hash,
        t_of_sexp,
        sexp_of_t,
        of_string,
        to_string,
        function(_as_, _ar_){return _ar_ <= _as_ ? 1 : 0;},
        _V_,
        _U_,
        _T_,
        _S_,
        _R_,
        equal,
        compare,
        min,
        max,
        ascending,
        descending,
        between,
        clamp_exn,
        clamp,
        comparator,
        pp,
        hashable,
        is_positive,
        is_non_negative,
        is_negative,
        is_non_positive,
        sign,
        invariant,
        Hex,
        to_string_hum,
        zero,
        one,
        minus_one,
        _Q_,
        _P_,
        _O_,
        symbol,
        _N_,
        _M_,
        symbol$1,
        symbol$0,
        _L_,
        rem,
        symbol$2,
        _K_,
        _J_,
        _I_,
        lnot,
        _H_,
        _G_,
        round,
        round_towards_zero,
        round_down,
        round_up,
        round_nearest,
        abs,
        succ,
        pred,
        pow,
        bit_and,
        bit_or,
        bit_xor,
        bit_not,
        popcount,
        shift_left,
        shift_right,
        decr,
        incr,
        of_int32_exn,
        to_int32_exn,
        of_int64_exn,
        to_int64,
        of_nativeint_exn,
        to_nativeint_exn,
        num_bits,
        max_value,
        min_value,
        _F_,
        shift_right_logical,
        ceil_pow2,
        floor_pow2,
        ceil_log2,
        floor_log2,
        is_pow2,
        clz,
        ctz,
        _E_,
        of_int,
        to_int,
        to_int_trunc,
        of_int32_exn,
        to_int32,
        _f_,
        of_int64,
        _e_,
        of_nativeint,
        to_nativeint,
        _d_,
        to_nativeint_trunc,
        of_float_unchecked,
        repr$0,
        _c_,
        bswap32,
        bswap48];
   var
    t_sexp_grammar$0 = include[1],
    of_float$0 = include[2],
    to_float$0 = include[3],
    of_int_exn$0 = include[4],
    to_int_exn$0 = include[5],
    hash_fold_t$0 = include[6],
    hash$0 = include[7],
    t_of_sexp$0 = include[8],
    sexp_of_t$0 = include[9],
    of_string$0 = include[10],
    to_string$0 = include[11],
    symbol$3 = include[12],
    symbol$4 = include[13],
    symbol$5 = include[14],
    symbol$6 = include[15],
    symbol$7 = include[16],
    symbol$8 = include[17],
    equal$0 = include[18],
    compare$0 = include[19],
    min$0 = include[20],
    max$0 = include[21],
    ascending$0 = include[22],
    descending$0 = include[23],
    between$0 = include[24],
    clamp_exn$0 = include[25],
    clamp$0 = include[26],
    comparator$0 = include[27],
    pp$0 = include[28],
    hashable$0 = include[29],
    is_positive$0 = include[30],
    is_non_negative$0 = include[31],
    is_negative$0 = include[32],
    is_non_positive$0 = include[33],
    sign$0 = include[34],
    invariant$0 = include[35],
    Hex$0 = include[36],
    to_string_hum$0 = include[37],
    zero$0 = include[38],
    one$0 = include[39],
    minus_one$0 = include[40],
    symbol$9 = include[41],
    symbol$10 = include[42],
    symbol$11 = include[43],
    symbol$12 = include[44],
    neg = include[45],
    symbol$13 = include[46],
    symbol$14 = include[47],
    symbol$15 = include[48],
    symbol$16 = include[49],
    rem$0 = include[50],
    symbol$17 = include[51],
    land = include[52],
    lor = include[53],
    lxor = include[54],
    lnot$0 = include[55],
    lsl = include[56],
    asr = include[57],
    round$0 = include[58],
    round_towards_zero$0 = include[59],
    round_down$0 = include[60],
    round_up$0 = include[61],
    round_nearest$0 = include[62],
    abs$0 = include[63],
    succ$0 = include[64],
    pred$0 = include[65],
    pow$0 = include[66],
    bit_and$0 = include[67],
    bit_or$0 = include[68],
    bit_xor$0 = include[69],
    bit_not$0 = include[70],
    popcount$0 = include[71],
    shift_left$0 = include[72],
    shift_right$0 = include[73],
    decr$0 = include[74],
    incr$0 = include[75],
    of_int32_exn$0 = include[76],
    to_int32_exn$0 = include[77],
    of_int64_exn$0 = include[78],
    to_int64$0 = include[79],
    of_nativeint_exn$0 = include[80],
    to_nativeint_exn$0 = include[81],
    num_bits$0 = include[82],
    max_value$0 = include[83],
    min_value$0 = include[84],
    lsr = include[85],
    shift_right_logical$0 = include[86],
    ceil_pow2$0 = include[87],
    floor_pow2$0 = include[88],
    ceil_log2$0 = include[89],
    is_pow2$0 = include[91],
    clz$0 = include[92],
    ctz$0 = include[93],
    O$0 = include[94],
    of_int$0 = include[95],
    to_int$0 = include[96],
    to_int_trunc$0 = include[97],
    of_int32 = include[98],
    to_int32$0 = include[99],
    to_int32_trunc = include[100],
    of_int64$0 = include[101],
    of_int64_trunc = include[102],
    of_nativeint$0 = include[103],
    to_nativeint$0 = include[104],
    of_nativeint_trunc = include[105],
    to_nativeint_trunc$0 = include[106],
    of_float_unchecked$0 = include[107],
    repr$1 = include[108],
    bswap16 = include[109],
    bswap32$0 = include[110],
    bswap48$0 = include[111];
   function symbol$18(t, u){
    var
     sum = caml_call2(symbol$9, t, u),
     _an_ = caml_call2(bit_xor$0, t, caml_call1(bit_not$0, sum));
    if
     (caml_call2
       (symbol$7,
        caml_call2(bit_or$0, caml_call2(bit_xor$0, t, u), _an_),
        zero$0))
     return sum;
    var
     _ao_ = [0, [0, cst_sum, caml_call1(sexp_of_t$0, sum)], 0],
     _ap_ = [0, [0, cst_u, caml_call1(sexp_of_t$0, u)], _ao_],
     _aq_ = [0, [0, cst_t, caml_call1(sexp_of_t$0, t)], _ap_];
    return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow, _aq_));
   }
   function symbol$19(t, u){
    var
     diff = caml_call2(symbol$10, t, u),
     pos_diff = caml_call2(symbol$6, t, u);
    if(caml_call2(symbol$8, t, u)){
     var _aj_ = caml_call1(is_positive$0, diff);
     if(caml_call2(Base_Bool[14], pos_diff, _aj_)){
      var
       _ak_ = [0, [0, cst_diff, caml_call1(sexp_of_t$0, diff)], 0],
       _al_ = [0, [0, cst_u$0, caml_call1(sexp_of_t$0, u)], _ak_],
       _am_ = [0, [0, cst_t$0, caml_call1(sexp_of_t$0, t)], _al_];
      return caml_call1
              (raise_s, caml_call2(Base_Sexp[9], cst_overflow$0, _am_));
     }
    }
    return diff;
   }
   var negative_one = caml_call1(of_int$0, -1);
   function div_would_overflow(t, u){
    var _ai_ = caml_call2(symbol$5, t, min_value$0);
    return _ai_ ? caml_call2(symbol$5, u, negative_one) : _ai_;
   }
   function symbol$20(t, u){
    var product = caml_call2(symbol$11, t, u);
    if(caml_call2(symbol$8, u, zero$0)){
     var switch$0 = 0;
     if
      (!
       div_would_overflow(product, u)
       && ! caml_call2(symbol$8, caml_call2(symbol$16, product, u), t))
      switch$0 = 1;
     if(! switch$0){
      var
       _af_ = [0, [0, cst_product, caml_call1(sexp_of_t$0, product)], 0],
       _ag_ = [0, [0, cst_u$1, caml_call1(sexp_of_t$0, u)], _af_],
       _ah_ = [0, [0, cst_t$1, caml_call1(sexp_of_t$0, t)], _ag_];
      return caml_call1
              (raise_s, caml_call2(Base_Sexp[9], cst_overflow$1, _ah_));
     }
    }
    return product;
   }
   function symbol$21(t, u){
    if(! div_would_overflow(t, u)) return caml_call2(symbol$16, t, u);
    var
     _ac_ =
       [0,
        [0,
         cst_product$0,
         caml_call1(sexp_of_t$0, caml_call2(symbol$16, t, u))],
        0],
     _ad_ = [0, [0, cst_u$2, caml_call1(sexp_of_t$0, u)], _ac_],
     _ae_ = [0, [0, cst_t$2, caml_call1(sexp_of_t$0, t)], _ad_];
    return caml_call1(raise_s, caml_call2(Base_Sexp[9], cst_overflow$2, _ae_));
   }
   function abs$1(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[123], cst_abs_overflow)
            : caml_call1(abs$0, t);
   }
   function neg$0(t){
    return caml_call2(symbol$5, t, min_value$0)
            ? caml_call1(Base_Import[123], cst_neg_overflow)
            : caml_call1(neg, t);
   }
   if(63 !== num_bits$0)
    throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
   function random_of_int(opt, bound){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var _ab_ = caml_call1(to_int_exn$0, bound);
    return caml_call1(of_int$0, caml_call2(Base_Random[18][6], state, _ab_));
   }
   function random_of_int64(opt, bound){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var _aa_ = caml_call1(to_int64$0, bound);
    return caml_call1
            (of_int64_exn$0, caml_call2(Base_Random[18][9], state, _aa_));
   }
   var random_of_int$0 = Base_Word_size[3] ? random_of_int : random_of_int64;
   function random_incl_of_int(opt, lo, hi){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var
     ___ = caml_call1(to_int_exn$0, hi),
     _$_ = caml_call1(to_int_exn$0, lo);
    return caml_call1
            (of_int$0, caml_call3(Base_Random[18][11], state, _$_, ___));
   }
   function random_incl_of_int64(opt, lo, hi){
    if(opt)
     var sth = opt[1], state = sth;
    else
     var state = Base_Random[18][1];
    var _Y_ = caml_call1(to_int64$0, hi), _Z_ = caml_call1(to_int64$0, lo);
    return caml_call1
            (of_int64_exn$0, caml_call3(Base_Random[18][14], state, _Z_, _Y_));
   }
   var
    random_incl =
      Base_Word_size[3] ? random_incl_of_int : random_incl_of_int64;
   function floor_log2$0(t){
    if(Base_Word_size[3]){
     var _W_ = caml_call1(to_int_exn$0, t);
     return caml_call1(Base_Int[66], _W_);
    }
    if(caml_call2(symbol$4, t, zero$0)){
     var _X_ = [0, [0, cst, caml_call1(sexp_of_t$0, t)], 0];
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Int_floor_log2_got_invalid, _X_));
    }
    var floor_log2 = [0, num_bits$0 - 2 | 0];
    for(;;){
     if
      (!
       caml_call2
        (equal$0,
         zero$0,
         caml_call2
          (bit_and$0, t, caml_call2(shift_left$0, one$0, floor_log2[1]))))
      return floor_log2[1];
     floor_log2[1] = floor_log2[1] - 1 | 0;
    }
   }
   var
    Base_Int63 =
      [0,
       t_sexp_grammar$0,
       of_float$0,
       to_float$0,
       of_int_exn$0,
       to_int_exn$0,
       hash_fold_t$0,
       hash$0,
       t_of_sexp$0,
       sexp_of_t$0,
       of_string$0,
       to_string$0,
       symbol$3,
       symbol$4,
       symbol$5,
       symbol$6,
       symbol$7,
       symbol$8,
       equal$0,
       compare$0,
       min$0,
       max$0,
       ascending$0,
       descending$0,
       between$0,
       clamp_exn$0,
       clamp$0,
       comparator$0,
       pp$0,
       hashable$0,
       is_positive$0,
       is_non_negative$0,
       is_negative$0,
       is_non_positive$0,
       sign$0,
       invariant$0,
       Hex$0,
       to_string_hum$0,
       zero$0,
       one$0,
       minus_one$0,
       symbol$9,
       symbol$10,
       symbol$11,
       symbol$12,
       neg,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       rem$0,
       symbol$17,
       land,
       lor,
       lxor,
       lnot$0,
       lsl,
       asr,
       round$0,
       round_towards_zero$0,
       round_down$0,
       round_up$0,
       round_nearest$0,
       abs$0,
       succ$0,
       pred$0,
       pow$0,
       bit_and$0,
       bit_or$0,
       bit_xor$0,
       bit_not$0,
       popcount$0,
       shift_left$0,
       shift_right$0,
       decr$0,
       incr$0,
       of_int32_exn$0,
       to_int32_exn$0,
       of_int64_exn$0,
       to_int64$0,
       of_nativeint_exn$0,
       to_nativeint_exn$0,
       of_float_unchecked$0,
       num_bits$0,
       max_value$0,
       min_value$0,
       lsr,
       shift_right_logical$0,
       ceil_pow2$0,
       floor_pow2$0,
       ceil_log2$0,
       is_pow2$0,
       clz$0,
       ctz$0,
       O$0,
       [0, symbol$18, symbol$19, symbol$20, symbol$21, abs$1, neg$0],
       of_int$0,
       to_int$0,
       of_int32,
       to_int32$0,
       of_int64$0,
       of_nativeint$0,
       to_nativeint$0,
       to_int_trunc$0,
       to_int32_trunc,
       of_int64_trunc,
       of_nativeint_trunc,
       to_nativeint_trunc$0,
       bswap16,
       bswap32$0,
       bswap48$0,
       random_of_int$0,
       random_incl,
       floor_log2$0,
       [0, Base_Int63_emul[112], repr$1]];
   runtime.caml_register_global(31, Base_Int63, "Base__Int63");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl_intf
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    Key = [0],
    Merge_into_action = [0],
    Base_Hashtbl_intf = [0, Key, Merge_into_action];
   runtime.caml_register_global(0, Base_Hashtbl_intf, "Base__Hashtbl_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Avltree
//# unitInfo: Requires: Assert_failure, Base__Error, Base__Import, Base__Sexp
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_avltree_ml = "src/avltree.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Sexp = global_data.Base__Sexp,
    Assert_failure = global_data.Assert_failure,
    Base_Import = global_data.Base__Import,
    Base_Error = global_data.Base__Error,
    raise_s = Base_Error[30],
    cst_Avltree_choose_exn_of_empt = "[Avltree.choose_exn] of empty hashtbl",
    _l_ = [0, cst_src_avltree_ml, 417, 15],
    _m_ = [0, cst_src_avltree_ml, 436, 18],
    _k_ = [0, cst_src_avltree_ml, 205, 9],
    _j_ = [0, cst_src_avltree_ml, 193, 9],
    _g_ = [0, cst_src_avltree_ml, 129, 30],
    _f_ = [0, cst_src_avltree_ml, 110, 26],
    _i_ = [0, cst_src_avltree_ml, 163, 30],
    _h_ = [0, cst_src_avltree_ml, 145, 26],
    _e_ = [0, cst_src_avltree_ml, 87, 22],
    _d_ = [0, cst_src_avltree_ml, 66, 6],
    _c_ = [0, cst_src_avltree_ml, 67, 6],
    _b_ = [0, cst_src_avltree_ml, 56, 6],
    _a_ = [0, cst_src_avltree_ml, 50, 6];
   function max(x, y){return y < x ? x : y;}
   var empty = 0;
   function is_empty(param){return typeof param === "number" ? 1 : 0;}
   function height(param){
    if(typeof param === "number") return 0;
    if(0 !== param[0]) return 1;
    var height = param[4];
    return height;
   }
   function invariant(t, compare){
    function inv(param){
     if(typeof param !== "number" && 0 === param[0]){
      var
       left = param[1],
       key = param[2],
       h = param[4],
       right = param[5],
       hr = height(right),
       hl = height(left);
      inv(left);
      inv(right);
      var switch$0 = 0;
      if(typeof left === "number")
       switch$0 = 1;
      else
       var left_key = 0 === left[0] ? left[2] : left[1];
      if(! switch$0 && 0 <= caml_call2(compare, left_key, key))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
      var switch$1 = 0;
      if(typeof right === "number")
       switch$1 = 1;
      else
       var right_key = 0 === right[0] ? right[2] : right[1];
      if(! switch$1 && 0 >= caml_call2(compare, right_key, key))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
      var _D_ = max(hl, hr);
      if(h !== caml_call2(Base_Import[90], _D_, 1))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      var _E_ = caml_call2(Base_Import[92], hl, hr);
      if(2 < caml_call1(Base_Import[122], _E_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
      return 0;
     }
     return 0;
    }
    return inv(t);
   }
   function update_height(x){
    if(typeof x !== "number" && 0 === x[0]){
     var
      left = x[1],
      old_height = x[4],
      right = x[5],
      _z_ = height(right),
      _A_ = max(height(left), _z_),
      new_height = caml_call2(Base_Import[90], _A_, 1),
      _B_ = new_height !== old_height ? 1 : 0,
      _C_ = _B_ ? (x[4] = new_height, 0) : _B_;
     return _C_;
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
   }
   function balance(root_node){
    if(typeof root_node !== "number" && 0 === root_node[0]){
     var
      left_node = root_node[1],
      right_node = root_node[5],
      hl = height(left_node),
      hr = height(right_node);
     if(caml_call2(Base_Import[90], hr, 2) < hl){
      if(typeof left_node !== "number" && 0 === left_node[0]){
       var
        left_node_left = left_node[1],
        left_node_right = left_node[5],
        _x_ = height(left_node_right);
       if(_x_ <= height(left_node_left)){
        root_node[1] = left_node_right;
        left_node[5] = root_node;
        update_height(root_node);
        update_height(left_node);
        return left_node;
       }
       if(typeof left_node_right !== "number" && 0 === left_node_right[0]){
        var lr_left = left_node_right[1], lr_right = left_node_right[5];
        left_node[5] = lr_left;
        root_node[1] = lr_right;
        left_node_right[5] = root_node;
        left_node_right[1] = left_node;
        update_height(left_node);
        update_height(root_node);
        update_height(left_node_right);
        return left_node_right;
       }
       throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
     }
     if(caml_call2(Base_Import[90], hl, 2) >= hr){update_height(root_node); return root_node;
     }
     if(typeof right_node !== "number" && 0 === right_node[0]){
      var
       right_node_left = right_node[1],
       right_node_right = right_node[5],
       _y_ = height(right_node_left);
      if(_y_ <= height(right_node_right)){
       root_node[5] = right_node_left;
       right_node[1] = root_node;
       update_height(root_node);
       update_height(right_node);
       return right_node;
      }
      if(typeof right_node_left !== "number" && 0 === right_node_left[0]){
       var rl_left = right_node_left[1], rl_right = right_node_left[5];
       right_node[1] = rl_right;
       root_node[5] = rl_left;
       right_node_left[1] = root_node;
       right_node_left[5] = right_node;
       update_height(right_node);
       update_height(root_node);
       update_height(right_node_left);
       return right_node_left;
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
    }
    return root_node;
   }
   function set_left(node, tree){
    var tree$0 = balance(tree);
    if(typeof node !== "number" && 0 === node[0]){
     var left = node[1];
     if(! caml_call2(Base_Import[127], left, tree$0)) node[1] = tree$0;
     return update_height(node);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
   }
   function set_right(node, tree){
    var tree$0 = balance(tree);
    if(typeof node !== "number" && 0 === node[0]){
     var right = node[5];
     if(! caml_call2(Base_Import[127], right, tree$0)) node[5] = tree$0;
     return update_height(node);
    }
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   function add(t, replace, added, compare, k, v){
    if(typeof t === "number"){added[1] = 1; return [1, k, v];}
    if(0 !== t[0]){
     var k$1 = t[1], c$0 = caml_call2(compare, k$1, k);
     if(0 !== c$0){
      added[1] = 1;
      return 0 <= c$0 ? [0, 0, k, v, 2, t] : [0, t, k, v, 2, 0];
     }
     added[1] = 0;
     if(replace) t[2] = v;
     return t;
    }
    var
     left = t[1],
     k$0 = t[2],
     right = t[5],
     c = caml_call2(compare, k, k$0);
    if(0 === c){
     added[1] = 0;
     if(replace) t[3] = v;
    }
    else if(0 <= c)
     set_right(t, add(right, replace, added, compare, k, v));
    else
     set_left(t, add(left, replace, added, compare, k, v));
    return t;
   }
   function add$0(t, replace, compare, added, key, data){
    var t$0 = add(t, replace, added, compare, key, data);
    return added[1] ? balance(t$0) : t$0;
   }
   function first(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var l = t$0[1];
      if(typeof l !== "number"){var t$0 = l; continue;}
      var v = t$0[3], k = t$0[2];
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function last(t){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var _v_ = t$0[2], _w_ = t$0[3];
      if(typeof t$0[5] !== "number"){var r = t$0[5], t$0 = r; continue;}
      var v = _w_, k = _v_;
     }
     else
      var k$0 = t$0[1], v$0 = t$0[2], v = v$0, k = k$0;
     return [0, [0, k, v]];
    }
   }
   function findi_and_call_impl
   (t,
    compare,
    k,
    arg1,
    arg2,
    call_if_found,
    call_if_not_found,
    if_found,
    if_not_found){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number")
      return caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     if(0 !== t$0[0]){
      var k$1 = t$0[1], v$0 = t$0[2];
      return 0 === caml_call2(compare, k, k$1)
              ? caml_call5(call_if_found, if_found, k$1, v$0, arg1, arg2)
              : caml_call4(call_if_not_found, if_not_found, k, arg1, arg2);
     }
     var
      left = t$0[1],
      k$0 = t$0[2],
      v = t$0[3],
      right = t$0[5],
      c = caml_call2(compare, k, k$0);
     if(0 === c)
      return caml_call5(call_if_found, if_found, k$0, v, arg1, arg2);
     var right$0 = 0 <= c ? right : left, t$0 = right$0;
    }
   }
   function call_if_found(if_found, param, data, _u_, _t_){return caml_call1(if_found, data);
   }
   function call_if_not_found(if_not_found, key, param, _s_){return caml_call1(if_not_found, key);
   }
   function find_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found,
             call_if_not_found,
             if_found,
             if_not_found);
   }
   function call_if_found$0(if_found, key, data, param, _r_){return caml_call2(if_found, key, data);
   }
   function call_if_not_found$0(if_not_found, key, param, _q_){return caml_call1(if_not_found, key);
   }
   function findi_and_call(t, compare, k, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             0,
             0,
             call_if_found$0,
             call_if_not_found$0,
             if_found,
             if_not_found);
   }
   function call_if_found$1(if_found, param, data, arg, _p_){return caml_call2(if_found, data, arg);
   }
   function call_if_not_found$1(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function find_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$1,
             call_if_not_found$1,
             if_found,
             if_not_found);
   }
   function call_if_found$2(if_found, key, data, arg, param){return caml_call3(if_found, key, data, arg);
   }
   function call_if_not_found$2(if_not_found, key, arg, param){return caml_call2(if_not_found, key, arg);
   }
   function findi_and_call1(t, compare, k, a, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             0,
             call_if_found$2,
             call_if_not_found$2,
             if_found,
             if_not_found);
   }
   function call_if_found$3(if_found, param, data, arg1, arg2){return caml_call3(if_found, data, arg1, arg2);
   }
   function call_if_not_found$3(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function find_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$3,
             call_if_not_found$3,
             if_found,
             if_not_found);
   }
   function call_if_found$4(if_found, key, data, arg1, arg2){return caml_call4(if_found, key, data, arg1, arg2);
   }
   function call_if_not_found$4(if_not_found, key, arg1, arg2){return caml_call3(if_not_found, key, arg1, arg2);
   }
   function findi_and_call2(t, compare, k, a, b, if_found, if_not_found){
    return findi_and_call_impl
            (t,
             compare,
             k,
             a,
             b,
             call_if_found$4,
             call_if_not_found$4,
             if_found,
             if_not_found);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, compare, k){
    return find_and_call(t, compare, k, if_found, if_not_found);
   }
   function if_found$0(param){return 1;}
   function if_not_found$0(param){return 0;}
   function mem(t, compare, k){
    return find_and_call(t, compare, k, if_found$0, if_not_found$0);
   }
   function remove_min_elt(tree){
    if(typeof tree === "number")
     throw caml_maybe_attach_backtrace([0, Assert_failure, _l_], 1);
    if(0 !== tree[0]) return 0;
    var left = tree[1];
    if(typeof left === "number"){var right = tree[5]; return right;}
    if(0 === left[0]){set_left(tree, remove_min_elt(left)); return tree;}
    var k = tree[2], v = tree[3];
    return typeof tree[5] === "number" ? [1, k, v] : (set_left(tree, 0), tree);
   }
   function remove(t, removed, compare, k$0){
    if(typeof t === "number"){removed[1] = 0; return 0;}
    if(0 !== t[0]){
     var k$2 = t[1];
     return 0 === caml_call2(compare, k$0, k$2)
             ? (removed[1] = 1, 0)
             : (removed[1] = 0, t);
    }
    var
     left$0 = t[1],
     k$1 = t[2],
     right = t[5],
     c = caml_call2(compare, k$0, k$1);
    if(0 !== c)
     return 0 <= c
             ? (set_right(t, remove(right, removed, compare, k$0)), t)
             : (set_left(t, remove(left$0, removed, compare, k$0)), t);
    removed[1] = 1;
    if(typeof left$0 === "number") return right;
    if(typeof right === "number") return left$0;
    var tree = right;
    for(;;){
     if(typeof tree === "number")
      var tree$0 = 0;
     else if(0 === tree[0]){
      var left = tree[1];
      if(typeof left !== "number"){var tree = left; continue;}
      var tree$0 = tree;
     }
     else
      var tree$0 = tree;
     if(typeof tree$0 === "number")
      throw caml_maybe_attach_backtrace([0, Assert_failure, _m_], 1);
     if(0 === tree$0[0]){
      set_right(tree$0, remove_min_elt(right));
      set_left(tree$0, left$0);
      return tree$0;
     }
     var
      k = tree$0[1],
      v = tree$0[2],
      t2 = balance(remove_min_elt(right)),
      _n_ = height(t2),
      _o_ = max(height(left$0), _n_);
     return [0, left$0, k, v, caml_call2(Base_Import[90], _o_, 1), t2];
    }
   }
   function remove$0(t, removed, compare, k){
    return balance(remove(t, removed, compare, k));
   }
   function fold(t, init, f){
    var t$0 = t, init$0 = init;
    for(;;){
     if(typeof t$0 === "number") return init$0;
     if(0 !== t$0[0]){
      var key$4 = t$0[1], data$4 = t$0[2];
      return caml_call3(f, key$4, data$4, init$0);
     }
     var left = t$0[1], switch$0 = 0;
     if(typeof left === "number"){
      var key = t$0[2], data = t$0[3], match = t$0[5];
      if(typeof match !== "number" && 0 !== match[0]){
       var rkey = match[1], rdata = match[2];
       return caml_call3(f, rkey, rdata, caml_call3(f, key, data, init$0));
      }
     }
     else if(0 === left[0]){
      var key$1 = t$0[2], data$1 = t$0[3], match$0 = t$0[5];
      if(typeof match$0 !== "number" && 0 !== match$0[0]){
       var rkey$0 = match$0[1], rdata$0 = match$0[2];
       return caml_call3
               (f,
                rkey$0,
                rdata$0,
                caml_call3(f, key$1, data$1, fold(left, init$0, f)));
      }
      switch$0 = 1;
     }
     else{
      var
       lkey$0 = left[1],
       ldata$0 = left[2],
       key$3 = t$0[2],
       data$3 = t$0[3],
       match$1 = t$0[5];
      if(typeof match$1 === "number")
       return caml_call3
               (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0));
      if(0 !== match$1[0]){
       var rkey$1 = match$1[1], rdata$1 = match$1[2];
       return caml_call3
               (f,
                rkey$1,
                rdata$1,
                caml_call3
                 (f, key$3, data$3, caml_call3(f, lkey$0, ldata$0, init$0)));
      }
      switch$0 = 1;
     }
     if(switch$0 && typeof left !== "number" && 1 === left[0]){
      var
       lkey = left[1],
       ldata = left[2],
       key$2 = t$0[2],
       data$2 = t$0[3],
       right$0 = t$0[5],
       init$2 =
         caml_call3(f, key$2, data$2, caml_call3(f, lkey, ldata, init$0)),
       t$0 = right$0,
       init$0 = init$2;
      continue;
     }
     var
      key$0 = t$0[2],
      data$0 = t$0[3],
      right = t$0[5],
      init$1 = caml_call3(f, key$0, data$0, fold(left, init$0, f)),
      t$0 = right,
      init$0 = init$1;
    }
   }
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var left = t$0[1], key = t$0[2], data = t$0[3], right = t$0[5];
      iter(left, f);
      caml_call2(f, key, data);
      var t$0 = right;
      continue;
     }
     var key$0 = t$0[1], data$0 = t$0[2];
     return caml_call2(f, key$0, data$0);
    }
   }
   function mapi_inplace(t, f){
    var t$0 = t;
    for(;;){
     if(typeof t$0 === "number") return 0;
     if(0 === t$0[0]){
      var left = t$0[1], key = t$0[2], value = t$0[3], right = t$0[5];
      mapi_inplace(left, f);
      t$0[3] = caml_call2(f, key, value);
      var t$0 = right;
      continue;
     }
     var key$0 = t$0[1], value$0 = t$0[2];
     t$0[2] = caml_call2(f, key$0, value$0);
     return 0;
    }
   }
   function choose_exn(param){
    if(typeof param === "number")
     return caml_call1
             (raise_s,
              caml_call2(Base_Sexp[9], cst_Avltree_choose_exn_of_empt, 0));
    if(0 === param[0])
     var value = param[3], key = param[2];
    else
     var key$0 = param[1], value$0 = param[2], value = value$0, key = key$0;
    return [0, key, value];
   }
   var
    Base_Avltree =
      [0,
       empty,
       is_empty,
       invariant,
       add$0,
       first,
       last,
       find,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       mem,
       remove$0,
       fold,
       iter,
       mapi_inplace,
       choose_exn];
   runtime.caml_register_global(18, Base_Avltree, "Base__Avltree");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hashtbl
//# unitInfo: Requires: Assert_failure, Base__Array, Base__Avltree, Base__Error, Base__Hashable, Base__Hashtbl_intf, Base__Import, Base__Int, Base__List, Base__Option, Base__Or_error, Base__Sexp, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_hashtbl_ml = "src/hashtbl.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Avltree = global_data.Base__Avltree,
    Base_Import = global_data.Base__Import,
    Base_Hashable = global_data.Base__Hashable,
    Base_Array = global_data.Base__Array,
    Base_List = global_data.Base__List,
    Base_Or_error = global_data.Base__Or_error,
    Base_Sexp = global_data.Base__Sexp,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Assert_failure = global_data.Assert_failure,
    Base_Error = global_data.Base__Error,
    Base_Option = global_data.Base__Option,
    Base_Int = global_data.Base__Int,
    Base_With_return = global_data.Base__With_return,
    with_return = Base_With_return[1],
    hash_param = Base_Hashable[5],
    hash = Base_Hashable[6],
    raise_s = Base_Error[30],
    cst_Hashtbl_merge_different_ha =
      "Hashtbl.merge: different 'hashable' values",
    cst_keys = "keys",
    cst_Hashtbl_create_with_key_du = "Hashtbl.create_with_key: duplicate keys",
    cst_Hashtbl_t_of_sexp_duplicat = "Hashtbl.t_of_sexp: duplicate key",
    _c_ = [0, cst_src_hashtbl_ml, 575, 4],
    cst_Hashtbl_of_alist_exn_dupli = "Hashtbl.of_alist_exn: duplicate key",
    _b_ = [0, "Hashtbl.find_exn: not found"],
    _a_ = [0, cst_src_hashtbl_ml, 323, 2],
    cst_Hashtbl_choose_exn_of_empt = "[Hashtbl.choose_exn] of empty hashtbl",
    cst_Hashtbl_add_exn_got_key_al = "Hashtbl.add_exn got key already present",
    cst_Hashtbl_mutation_not_allow =
      "Hashtbl: mutation not allowed during iteration";
   function sexp_of_key(t){return t[5][3];}
   function compare_key(t){return t[5][2];}
   function ensure_mutation_allowed(t){
    var _aO_ = 1 - t[6];
    return _aO_
            ? caml_call1(Base_Import[123], cst_Hashtbl_mutation_not_allow)
            : _aO_;
   }
   function without_mutating(t, f){
    if(! t[6]) return caml_call1(f, 0);
    t[6] = 0;
    try{var x = caml_call1(f, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[6] = 1;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[6] = 1;
    return x;
   }
   var max_table_length = caml_call1(Base_Int[64], Base_Array[24]);
   function create(opt, _aM_, hashable, param){
    if(opt)
     var sth = opt[1], growth_allowed = sth;
    else
     var growth_allowed = 1;
    if(_aM_) var sth$0 = _aM_[1], size = sth$0; else var size = 0;
    var
     _aN_ = caml_call2(Base_Int[15], 1, size),
     size$0 = caml_call2(Base_Int[14], _aN_, max_table_length),
     size$1 = caml_call1(Base_Int[63], size$0);
    return [0,
            caml_call2(Base_Array[25], size$1, Base_Avltree[1]),
            0,
            [0, 0],
            growth_allowed,
            hashable,
            1];
   }
   function slot(t, key){
    var
     hash = caml_call1(t[5][1], key),
     _aL_ = caml_call2(Base_Import[92], t[1].length - 1, 1);
    return caml_call2(Base_Import[115], hash, _aL_);
   }
   function add_worker(t, replace, key, data){
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     added = t[3];
    added[1] = 0;
    var
     _aI_ = compare_key(t),
     new_root =
       caml_call6(Base_Avltree[4], root, replace, _aI_, added, key, data);
    if(added[1]) t[2] = caml_call2(Base_Import[90], t[2], 1);
    var
     _aJ_ = 1 - caml_call2(Base_Import[127], new_root, root),
     _aK_ = _aJ_ ? (caml_check_bound(t[1], i)[1 + i] = new_root, 0) : _aJ_;
    return _aK_;
   }
   function maybe_resize_table(t){
    var
     len = t[1].length - 1,
     should_grow = len < t[2] ? 1 : 0,
     _az_ = should_grow ? t[4] : should_grow;
    if(_az_){
     var
      _aA_ = caml_call2(Base_Import[87], len, 2),
      new_array_length = caml_call2(Base_Int[14], _aA_, max_table_length),
      _aB_ = len < new_array_length ? 1 : 0;
     if(_aB_){
      var
       new_table =
         caml_call2(Base_Array[25], new_array_length, Base_Avltree[1]),
       old_table = t[1];
      t[1] = new_table;
      t[2] = 0;
      var
       f = function(key, data){return add_worker(t, 1, key, data);},
       _aD_ = caml_call2(Base_Import[92], old_table.length - 1, 1),
       _aC_ = 0;
      if(_aD_ >= 0){
       var i = _aC_;
       for(;;){
        var _aG_ = caml_check_bound(old_table, i)[1 + i];
        caml_call2(Base_Avltree[17], _aG_, f);
        var _aH_ = i + 1 | 0;
        if(_aD_ !== i){var i = _aH_; continue;}
        break;
       }
      }
      var _aE_ = 0;
     }
     else
      var _aE_ = _aB_;
     var _aF_ = _aE_;
    }
    else
     var _aF_ = _az_;
    return _aF_;
   }
   function set(t, key, data){
    ensure_mutation_allowed(t);
    add_worker(t, 1, key, data);
    return maybe_resize_table(t);
   }
   function add(t, key, data){
    ensure_mutation_allowed(t);
    add_worker(t, 0, key, data);
    return t[3][1] ? (maybe_resize_table(t), 17724) : -1024851605;
   }
   function add_exn(t, key, data){
    if(17724 <= add(t, key, data)) return 0;
    var
     sexp_of_key$0 = sexp_of_key(t),
     error =
       caml_call5
        (Base_Error[17],
         0,
         0,
         cst_Hashtbl_add_exn_got_key_al,
         key,
         sexp_of_key$0);
    return caml_call1(Base_Error[29], error);
   }
   function clear(t){
    ensure_mutation_allowed(t);
    var _aw_ = caml_call2(Base_Import[92], t[1].length - 1, 1), _av_ = 0;
    if(_aw_ >= 0){
     var i = _av_;
     for(;;){
      var _ax_ = Base_Avltree[1];
      caml_check_bound(t[1], i)[1 + i] = _ax_;
      var _ay_ = i + 1 | 0;
      if(_aw_ !== i){var i = _ay_; continue;}
      break;
     }
    }
    t[2] = 0;
    return 0;
   }
   function find_and_call(t, key, if_found, if_not_found){
    var _at_ = slot(t, key), tree = caml_check_bound(t[1], _at_)[1 + _at_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _au_ = compare_key(t);
     return caml_call5
             (Base_Avltree[8], tree, _au_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call1(if_found, v)
            : caml_call1(if_not_found, key);
   }
   function find_and_call1(t, key, a, if_found, if_not_found){
    var _ar_ = slot(t, key), tree = caml_check_bound(t[1], _ar_)[1 + _ar_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _as_ = compare_key(t);
     return caml_call6
             (Base_Avltree[9], tree, _as_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function find_and_call2(t, key, a, b, if_found, if_not_found){
    var _ap_ = slot(t, key), tree = caml_check_bound(t[1], _ap_)[1 + _ap_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var _aq_ = compare_key(t);
     return caml_call7
             (Base_Avltree[10], tree, _aq_, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function findi_and_call(t, key, if_found, if_not_found){
    var _an_ = slot(t, key), tree = caml_check_bound(t[1], _an_)[1 + _an_];
    if(typeof tree === "number") return caml_call1(if_not_found, key);
    if(0 === tree[0]){
     var _ao_ = compare_key(t);
     return caml_call5
             (Base_Avltree[11], tree, _ao_, key, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call2(if_found, k, v)
            : caml_call1(if_not_found, key);
   }
   function findi_and_call1(t, key, a, if_found, if_not_found){
    var _al_ = slot(t, key), tree = caml_check_bound(t[1], _al_)[1 + _al_];
    if(typeof tree === "number") return caml_call2(if_not_found, key, a);
    if(0 === tree[0]){
     var _am_ = compare_key(t);
     return caml_call6
             (Base_Avltree[12], tree, _am_, key, a, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call3(if_found, k, v, a)
            : caml_call2(if_not_found, key, a);
   }
   function findi_and_call2(t, key, a, b, if_found, if_not_found){
    var _aj_ = slot(t, key), tree = caml_check_bound(t[1], _aj_)[1 + _aj_];
    if(typeof tree === "number") return caml_call3(if_not_found, key, a, b);
    if(0 === tree[0]){
     var _ak_ = compare_key(t);
     return caml_call7
             (Base_Avltree[13], tree, _ak_, key, a, b, if_found, if_not_found);
    }
    var k = tree[1], v = tree[2];
    return 0 === caml_call2(compare_key(t), k, key)
            ? caml_call4(if_found, k, v, a, b)
            : caml_call3(if_not_found, key, a, b);
   }
   function if_found(v){return [0, v];}
   function if_not_found(param){return 0;}
   function find(t, key){
    return find_and_call(t, key, if_found, if_not_found);
   }
   function mem(t, key){
    var _ah_ = slot(t, key), tree = caml_check_bound(t[1], _ah_)[1 + _ah_];
    if(typeof tree === "number") return 0;
    if(0 === tree[0]){
     var _ai_ = compare_key(t);
     return caml_call3(Base_Avltree[14], tree, _ai_, key);
    }
    var k = tree[1];
    return 0 === caml_call2(compare_key(t), k, key) ? 1 : 0;
   }
   function remove(t, key){
    ensure_mutation_allowed(t);
    var
     i = slot(t, key),
     root = caml_check_bound(t[1], i)[1 + i],
     added_or_removed = t[3];
    added_or_removed[1] = 0;
    var
     _ae_ = compare_key(t),
     new_root =
       caml_call4(Base_Avltree[15], root, added_or_removed, _ae_, key);
    if(1 - caml_call2(Base_Import[127], root, new_root))
     caml_check_bound(t[1], i)[1 + i] = new_root;
    var
     _af_ = added_or_removed[1],
     _ag_ = _af_ ? (t[2] = caml_call2(Base_Import[92], t[2], 1), 0) : _af_;
    return _ag_;
   }
   function length(t){return t[2];}
   function is_empty(t){return 0 === t[2] ? 1 : 0;}
   function fold(t, init, f){
    if(0 === t[2]) return init;
    var n = t[1].length - 1, acc = [0, init], m = t[6];
    try{
     t[6] = 0;
     var _ac_ = caml_call2(Base_Import[92], n, 1), _ab_ = 0;
     if(_ac_ >= 0){
      var i = _ab_;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         acc[1] = caml_call3(Base_Avltree[16], bucket, acc[1], f);
        else{
         var key = bucket[1], data = bucket[2];
         acc[1] = caml_call3(f, key, data, acc[1]);
        }
       var _ad_ = i + 1 | 0;
       if(_ac_ !== i){var i = _ad_; continue;}
       break;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[6] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[6] = m;
    return acc[1];
   }
   function iteri(t, f){
    if(0 === t[2]) return 0;
    var n = t[1].length - 1, m = t[6];
    try{
     t[6] = 0;
     var _$_ = caml_call2(Base_Import[92], n, 1), ___ = 0;
     if(_$_ >= 0){
      var i = ___;
      for(;;){
       var bucket = t[1][1 + i];
       if(typeof bucket !== "number")
        if(0 === bucket[0])
         caml_call2(Base_Avltree[17], bucket, f);
        else{var key = bucket[1], data = bucket[2]; caml_call2(f, key, data);}
       var _aa_ = i + 1 | 0;
       if(_$_ !== i){var i = _aa_; continue;}
       break;
      }
     }
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     t[6] = m;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    t[6] = m;
    return 0;
   }
   function iter(t, f){
    return iteri(t, function(param, data){return caml_call1(f, data);});
   }
   function iter_keys(t, f){
    return iteri(t, function(key, param){return caml_call1(f, key);});
   }
   function choose_nonempty(table, i){
    var i$0 = i;
    for(;;){
     var avltree = caml_check_bound(table, i$0)[1 + i$0];
     if(! caml_call1(Base_Avltree[2], avltree))
      return caml_call1(Base_Avltree[19], avltree);
     var i$1 = caml_call2(Base_Import[90], i$0, 1), i$0 = i$1;
    }
   }
   function choose_exn(t){
    if(0 === t[2])
     caml_call1
      (raise_s, caml_call2(Base_Sexp[9], cst_Hashtbl_choose_exn_of_empt, 0));
    return choose_nonempty(t[1], 0);
   }
   function choose(t){return is_empty(t) ? 0 : [0, choose_nonempty(t[1], 0)];}
   function invariant(invariant_key, invariant_data, t){
    var _W_ = caml_call2(Base_Import[92], t[1].length - 1, 1), _V_ = 0;
    if(_W_ >= 0){
     var i = _V_;
     for(;;){
      var _X_ = compare_key(t), _Y_ = caml_check_bound(t[1], i)[1 + i];
      caml_call2(Base_Avltree[3], _Y_, _X_);
      var _Z_ = i + 1 | 0;
      if(_W_ !== i){var i = _Z_; continue;}
      break;
     }
    }
    var
     real_len =
       fold
        (t,
         0,
         function(key, data, i){
          caml_call1(invariant_key, key);
          caml_call1(invariant_data, data);
          return caml_call2(Base_Import[90], i, 1);
         });
    if(real_len === t[2]) return 0;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
   }
   function if_found$0(v, param){return v;}
   function if_not_found$0(k, t){
    var _U_ = [1, [0, _b_, [0, caml_call1(t[5][3], k), 0]]];
    throw caml_maybe_attach_backtrace([0, Base_Import[251], _U_], 1);
   }
   function find_exn(t, key){
    return find_and_call1(t, key, t, if_found$0, if_not_found$0);
   }
   function existsi(t, f){
    return caml_call1
            (with_return,
             function(r){
              iteri
               (t,
                function(key, data){
                 var _T_ = caml_call2(f, key, data);
                 return _T_ ? caml_call1(r, 1) : _T_;
                });
              return 0;
             });
   }
   function exists(t, f){
    return existsi(t, function(param, data){return caml_call1(f, data);});
   }
   function for_alli(t, f){
    return 1
           -
            existsi
             (t, function(key, data){return 1 - caml_call2(f, key, data);});
   }
   function for_all(t, f){
    return 1
           -
            existsi(t, function(param, data){return 1 - caml_call1(f, data);});
   }
   function counti(t, f){
    return fold
            (t,
             0,
             function(key, data, acc){
              return caml_call2(f, key, data)
                      ? caml_call2(Base_Import[90], acc, 1)
                      : acc;
             });
   }
   function count(t, f){
    return fold
            (t,
             0,
             function(param, data, acc){
              return caml_call1(f, data)
                      ? caml_call2(Base_Import[90], acc, 1)
                      : acc;
             });
   }
   function mapi(t, f){
    var new_t = create([0, t[4]], [0, t[2]], t[5], 0);
    iteri
     (t,
      function(key, data){return set(new_t, key, caml_call2(f, key, data));});
    return new_t;
   }
   function map(t, f){
    return mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function copy(t){return map(t, function(_S_){return _S_;});}
   function filter_mapi(t, f){
    var new_t = create([0, t[4]], [0, t[2]], t[5], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(! match) return 0;
       var new_data = match[1];
       return set(new_t, key, new_data);
      });
    return new_t;
   }
   function filter_map(t, f){
    return filter_mapi(t, function(param, data){return caml_call1(f, data);});
   }
   function filteri(t, f){
    return filter_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : 0;
             });
   }
   function filter(t, f){
    return filteri(t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys(t, f){
    return filteri(t, function(key, param){return caml_call1(f, key);});
   }
   function partition_mapi(t, f){
    var
     t0 = create([0, t[4]], [0, t[2]], t[5], 0),
     t1 = create([0, t[4]], [0, t[2]], t[5], 0);
    iteri
     (t,
      function(key, data){
       var match = caml_call2(f, key, data);
       if(0 === match[0]){
        var new_data = match[1];
        return set(t0, key, new_data);
       }
       var new_data$0 = match[1];
       return set(t1, key, new_data$0);
      });
    return [0, t0, t1];
   }
   function partition_map(t, f){
    return partition_mapi
            (t, function(param, data){return caml_call1(f, data);});
   }
   function partitioni_tf(t, f){
    return partition_mapi
            (t,
             function(key, data){
              return caml_call2(f, key, data) ? [0, data] : [1, data];
             });
   }
   function partition_tf(t, f){
    return partitioni_tf
            (t, function(param, data){return caml_call1(f, data);});
   }
   function find_or_add(t, id, default$0){
    function _Q_(key, t, default$0){
     var default$1 = caml_call1(default$0, 0);
     set(t, key, default$1);
     return default$1;
    }
    return find_and_call2
            (t,
             id,
             t,
             default$0,
             function(data, param, _R_){return data;},
             _Q_);
   }
   function findi_or_add(t, id, default$0){
    function _O_(key, t, default$0){
     var default$1 = caml_call1(default$0, key);
     set(t, key, default$1);
     return default$1;
    }
    return find_and_call2
            (t,
             id,
             t,
             default$0,
             function(data, param, _P_){return data;},
             _O_);
   }
   function find_and_remove(t, id){
    var result = find(t, id);
    if(caml_call1(Base_Option[50], result)) remove(t, id);
    return result;
   }
   function change(t, id, f){
    var match = caml_call1(f, find(t, id));
    if(! match) return remove(t, id);
    var data = match[1];
    return set(t, id, data);
   }
   function update_and_return(t, id, f){
    var data = caml_call1(f, find(t, id));
    set(t, id, data);
    return data;
   }
   function update(t, id, f){update_and_return(t, id, f); return 0;}
   function incr_by(remove_if_zero, t, key, by){
    return remove_if_zero
            ? change
              (t,
               key,
               function(opt){
                var
                 _N_ = caml_call2(Base_Option[27], opt, 0),
                 n = caml_call2(Base_Import[90], by, _N_);
                return 0 === n ? 0 : [0, n];
               })
            : update
              (t,
               key,
               function(param){
                if(! param) return by;
                var i = param[1];
                return caml_call2(Base_Import[90], by, i);
               });
   }
   function incr(opt, _M_, t, key){
    if(opt) var sth = opt[1], by = sth; else var by = 1;
    if(_M_)
     var sth$0 = _M_[1], remove_if_zero = sth$0;
    else
     var remove_if_zero = 0;
    return incr_by(remove_if_zero, t, key, by);
   }
   function decr(opt, _L_, t, key){
    if(opt) var sth = opt[1], by = sth; else var by = 1;
    if(_L_)
     var sth$0 = _L_[1], remove_if_zero = sth$0;
    else
     var remove_if_zero = 0;
    return incr_by(remove_if_zero, t, key, caml_call1(Base_Import[112], by));
   }
   function add_multi(t, key, data){
    return update
            (t,
             key,
             function(param){
              if(! param) return [0, data, 0];
              var l = param[1];
              return [0, data, l];
             });
   }
   function remove_multi(t, key){
    var match = find(t, key);
    if(! match) return 0;
    var _K_ = match[1];
    if(_K_ && _K_[2]){var tl = _K_[2]; return set(t, key, tl);}
    return remove(t, key);
   }
   function find_multi(t, key){
    var match = find(t, key);
    if(! match) return 0;
    var l = match[1];
    return l;
   }
   function create_mapped
   (growth_allowed, size, hashable, get_key, get_data, rows){
    if(size)
     var s = size[1], size$0 = s;
    else
     var size$0 = caml_call1(Base_List[7], rows);
    var
     res = create(growth_allowed, [0, size$0], hashable, 0),
     dupes = [0, 0];
    function _J_(r){
     var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
     return mem(res, key)
             ? (dupes[1] = [0, key, dupes[1]], 0)
             : set(res, key, data);
    }
    caml_call2(Base_List[9], rows, _J_);
    var keys = dupes[1];
    return keys
            ? [0, 175765640, caml_call2(Base_List[114], keys, hashable[2])]
            : [0, 17724, res];
   }
   function of_alist(growth_allowed, size, hashable, lst){
    var
     match =
       create_mapped
        (growth_allowed,
         size,
         hashable,
         Base_Import[124],
         Base_Import[126],
         lst);
    if(175765640 <= match[1]){
     var k = match[2];
     return [0, -1048878709, caml_call1(Base_List[67], k)];
    }
    var t = match[2];
    return [0, 17724, t];
   }
   function of_alist_report_all_dups(growth_allowed, size, hashable, lst){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             Base_Import[124],
             Base_Import[126],
             lst);
   }
   function of_alist_or_error(growth_allowed, size, hashable, lst){
    var match = of_alist(growth_allowed, size, hashable, lst);
    if(17724 <= match[1]){var v = match[2]; return [0, v];}
    var key = match[2], sexp_of_key = hashable[3];
    return caml_call5
            (Base_Or_error[34],
             0,
             0,
             cst_Hashtbl_of_alist_exn_dupli,
             key,
             sexp_of_key);
   }
   function of_alist_exn(growth_allowed, size, hashable, lst){
    var match = of_alist_or_error(growth_allowed, size, hashable, lst);
    if(0 === match[0]){var v = match[1]; return v;}
    var e = match[1];
    return caml_call1(Base_Error[29], e);
   }
   function of_alist_multi(growth_allowed, size$0, hashable, rows){
    var get_data = Base_Import[126], get_key = Base_Import[124];
    if(size$0)
     var s = size$0[1], size = s;
    else
     var size = caml_call1(Base_List[7], rows);
    var res = create(growth_allowed, [0, size], hashable, 0);
    function _I_(r){
     var key = caml_call1(get_key, r), data = caml_call1(get_data, r);
     return add_multi(res, key, data);
    }
    caml_call2(Base_List[9], rows, _I_);
    return res;
   }
   function to_alist(t){
    return fold
            (t,
             0,
             function(key, data, list){return [0, [0, key, data], list];});
   }
   function sexp_of_t(sexp_of_key, sexp_of_data, t){
    var
     _D_ = to_alist(t),
     _E_ = Base_List[62],
     _F_ =
       caml_call2
        (_E_,
         _D_,
         function(param, _H_){
          var k2 = _H_[1], k1 = param[1];
          return caml_call2(t[5][2], k1, k2);
         }),
     _G_ = caml_call2(Base_Import[149], sexp_of_key, sexp_of_data);
    return caml_call1(caml_call1(Base_Import[151], _G_), _F_);
   }
   function t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp){
    var
     _t_ = caml_call2(Base_Import[173], k_of_sexp, d_of_sexp),
     alist = caml_call2(Base_Import[175], _t_, sexp),
     match =
       of_alist(0, [0, caml_call1(Base_List[7], alist)], hashable, alist);
    if(17724 <= match[1]){var v = match[2]; return v;}
    var k = match[2];
    function _u_(_C_){return _C_;}
    function _v_(_B_){return _B_;}
    var
     _w_ = caml_call2(Base_Import[173], _v_, _u_),
     alist_sexps = caml_call2(Base_Import[175], _w_, sexp),
     found_first_k = [0, 0];
    function _x_(param, _y_){
     var
      k2_sexp = _y_[1],
      k2 = param[1],
      _z_ = 0 === caml_call2(hashable[2], k, k2) ? 1 : 0;
     if(_z_){
      if(found_first_k[1])
       return caml_call2
               (Base_Import[158], cst_Hashtbl_t_of_sexp_duplicat, k2_sexp);
      found_first_k[1] = 1;
      var _A_ = 0;
     }
     else
      var _A_ = _z_;
     return _A_;
    }
    caml_call3(Base_List[42], alist, alist_sexps, _x_);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
   }
   function t_sexp_grammar(k_grammar, v_grammar){
    var _s_ = caml_call2(Base_List[129][3], k_grammar, v_grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _s_);
   }
   function keys(t){
    return fold(t, 0, function(key, param, acc){return [0, key, acc];});
   }
   function data(t){
    return fold(t, 0, function(param, data, list){return [0, data, list];});
   }
   function group
   (growth_allowed, size, hashable, get_key, get_data, combine, rows){
    var groups = create(growth_allowed, size, hashable, 0);
    function _r_(row){
     var
      key = caml_call1(get_key, row),
      data = caml_call1(get_data, row),
      match = find(groups, key);
     if(match)
      var old = match[1], data$0 = caml_call2(combine, old, data);
     else
      var data$0 = data;
     return set(groups, key, data$0);
    }
    caml_call2(Base_List[9], rows, _r_);
    return groups;
   }
   function create_with_key(growth_allowed, size, hashable, get_key, rows){
    return create_mapped
            (growth_allowed,
             size,
             hashable,
             get_key,
             function(_q_){return _q_;},
             rows);
   }
   function create_with_key_or_error
   (growth_allowed, size, hashable, get_key, rows){
    var
     match = create_with_key(growth_allowed, size, hashable, get_key, rows);
    if(175765640 <= match[1]){
     var
      keys = match[2],
      sexp_of_key = hashable[3],
      _o_ =
        [0, [0, cst_keys, caml_call2(Base_Import[151], sexp_of_key, keys)], 0],
      _p_ = caml_call2(Base_Sexp[9], cst_Hashtbl_create_with_key_du, _o_);
     return caml_call1(Base_Or_error[35], _p_);
    }
    var t = match[2];
    return [0, t];
   }
   function create_with_key_exn(growth_allowed, size, hashable, get_key, rows){
    var
     _n_ =
       create_with_key_or_error(growth_allowed, size, hashable, get_key, rows);
    return caml_call1(Base_Or_error[31], _n_);
   }
   function maybe_set(t, key, f, d){
    var match = caml_call2(f, key, d);
    if(! match) return 0;
    var v = match[1];
    return set(t, key, v);
   }
   function merge(t_left, t_right, f){
    if(1 - caml_call2(Base_Hashable[1], t_left[5], t_right[5]))
     caml_call1(Base_Import[125], cst_Hashtbl_merge_different_ha);
    var new_t = create([0, t_left[4]], [0, t_left[2]], t_left[5], 0);
    without_mutating
     (t_left,
      function(param){
       return without_mutating
               (t_right,
                function(param){
                 iteri
                  (t_left,
                   function(key, left){
                    var match = find(t_right, key);
                    if(! match)
                     return maybe_set(new_t, key, f, [0, 847852583, left]);
                    var right = match[1];
                    return maybe_set
                            (new_t, key, f, [0, 737457313, [0, left, right]]);
                   });
                 return iteri
                         (t_right,
                          function(key, right){
                           return find(t_left, key)
                                   ? 0
                                   : maybe_set(new_t, key, f, [0, -57574468, right]);
                          });
                });
      });
    return new_t;
   }
   function merge_into(src, dst, f){
    return iteri
            (src,
             function(key, data){
              var
               dst_data = find(dst, key),
               action =
                 without_mutating
                  (dst,
                   function(param){return caml_call3(f, key, data, dst_data);});
              if(! action) return remove(dst, key);
              var data$0 = action[1];
              if(! dst_data) return set(dst, key, data$0);
              var
               dst_data$0 = dst_data[1],
               _m_ = 1 - caml_call2(Base_Import[127], dst_data$0, data$0);
              return _m_ ? set(dst, key, data$0) : _m_;
             });
   }
   function filteri_inplace(t, f){
    var
     to_remove =
       fold
        (t,
         0,
         function(key, data, ac){
          return caml_call2(f, key, data) ? ac : [0, key, ac];
         });
    function _l_(key){return remove(t, key);}
    return caml_call2(Base_List[9], to_remove, _l_);
   }
   function filter_inplace(t, f){
    return filteri_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function filter_keys_inplace(t, f){
    return filteri_inplace
            (t, function(key, param){return caml_call1(f, key);});
   }
   function filter_mapi_inplace(t, f){
    var
     map_results =
       fold
        (t,
         0,
         function(key, data, ac){
          return [0, [0, key, caml_call2(f, key, data)], ac];
         });
    function _k_(param){
     var result = param[2], key = param[1];
     if(! result) return remove(t, key);
     var data = result[1];
     return set(t, key, data);
    }
    return caml_call2(Base_List[9], map_results, _k_);
   }
   function filter_map_inplace(t, f){
    return filter_mapi_inplace
            (t, function(param, data){return caml_call1(f, data);});
   }
   function mapi_inplace(t, f){
    ensure_mutation_allowed(t);
    return without_mutating
            (t,
             function(param){
              var _h_ = Base_Avltree[18];
              function _i_(_j_){return caml_call2(_h_, _j_, f);}
              return caml_call2(Base_Array[9], t[1], _i_);
             });
   }
   function map_inplace(t, f){
    return mapi_inplace(t, function(param, data){return caml_call1(f, data);});
   }
   function similar(equal, t$0, t){
    var _f_ = t$0[2] === t[2] ? 1 : 0;
    return _f_
            ? caml_call1
              (with_return,
               function(r){
                without_mutating
                 (t,
                  function(param){
                   return iteri
                           (t$0,
                            function(key, data){
                             var match = find(t, key);
                             if(! match) return caml_call1(r, 0);
                             var
                              data$0 = match[1],
                              _g_ = 1 - caml_call2(equal, data, data$0);
                             return _g_ ? caml_call1(r, 0) : _g_;
                            });
                  });
                return 1;
               })
            : _f_;
   }
   function Creators(Key){
    var hashable = Key[1];
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, hashable, 0);
    }
    function of_alist$0(growth_allowed, size, l){
     return of_alist(growth_allowed, size, hashable, l);
    }
    function of_alist_report_all_dups$0(growth_allowed, size, l){
     return of_alist_report_all_dups(growth_allowed, size, hashable, l);
    }
    function of_alist_or_error$0(growth_allowed, size, l){
     return of_alist_or_error(growth_allowed, size, hashable, l);
    }
    function of_alist_exn$0(growth_allowed, size, l){
     return of_alist_exn(growth_allowed, size, hashable, l);
    }
    function t_of_sexp$0(k_of_sexp, d_of_sexp, sexp){
     return t_of_sexp(hashable, k_of_sexp, d_of_sexp, sexp);
    }
    function of_alist_multi$0(growth_allowed, size, l){
     return of_alist_multi(growth_allowed, size, hashable, l);
    }
    function create_mapped$0(growth_allowed, size, get_key, get_data, l){
     return create_mapped
             (growth_allowed, size, hashable, get_key, get_data, l);
    }
    function create_with_key$0(growth_allowed, size, get_key, l){
     return create_with_key(growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_or_error$0(growth_allowed, size, get_key, l){
     return create_with_key_or_error
             (growth_allowed, size, hashable, get_key, l);
    }
    function create_with_key_exn$0(growth_allowed, size, get_key, l){
     return create_with_key_exn(growth_allowed, size, hashable, get_key, l);
    }
    function group$0(growth_allowed, size, get_key, get_data, combine, l){
     return group
             (growth_allowed, size, hashable, get_key, get_data, combine, l);
    }
    return [0,
            t_of_sexp$0,
            create$0,
            of_alist$0,
            of_alist_report_all_dups$0,
            of_alist_or_error$0,
            of_alist_exn$0,
            of_alist_multi$0,
            create_mapped$0,
            create_with_key$0,
            create_with_key_or_error$0,
            create_with_key_exn$0,
            group$0];
   }
   var
    hashable = Base_Hashable[2],
    _d_ = Creators([0, hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_alist$0 = _d_[3],
    of_alist_report_all_dups$0 = _d_[4],
    of_alist_or_error$0 = _d_[5],
    of_alist_exn$0 = _d_[6],
    of_alist_multi$0 = _d_[7],
    create_mapped$0 = _d_[8],
    create_with_key$0 = _d_[9],
    create_with_key_or_error$0 = _d_[10],
    create_with_key_exn$0 = _d_[11],
    group$0 = _d_[12];
   function hashable$0(t){return t[5];}
   var Private = [0, hashable$0];
   function create$1(growth_allowed, size, m){
    return create(growth_allowed, size, caml_call1(Base_Hashable[3], m), 0);
   }
   function of_alist$1(growth_allowed, size, m, l){
    return of_alist(growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_report_all_dups$1(growth_allowed, size, m, l){
    return of_alist_report_all_dups
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_or_error$1(growth_allowed, size, m, l){
    return of_alist_or_error
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_exn$1(growth_allowed, size, m, l){
    return of_alist_exn
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function of_alist_multi$1(growth_allowed, size, m, l){
    return of_alist_multi
            (growth_allowed, size, caml_call1(Base_Hashable[3], m), l);
   }
   function create_mapped$1(growth_allowed, size, m, get_key, get_data, l){
    return create_mapped
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             l);
   }
   function create_with_key$1(growth_allowed, size, m, get_key, l){
    return create_with_key
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_or_error$1(growth_allowed, size, m, get_key, l){
    return create_with_key_or_error
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function create_with_key_exn$1(growth_allowed, size, m, get_key, l){
    return create_with_key_exn
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             l);
   }
   function group$1(growth_allowed, size, m, get_key, get_data, combine, l){
    return group
            (growth_allowed,
             size,
             caml_call1(Base_Hashable[3], m),
             get_key,
             get_data,
             combine,
             l);
   }
   function hashable_s(t){return caml_call1(Base_Hashable[4], t[5]);}
   function M(K){return [0];}
   function sexp_of_m_t(K){
    return function(sexp_of_v, t){return sexp_of_t(K[1], sexp_of_v, t);};
   }
   function m_t_of_sexp(K){
    return function(v_of_sexp, sexp){
     var _e_ = K[1];
     return t_of_sexp
             (caml_call1(Base_Hashable[3], [0, K[2], K[3], K[4]]),
              _e_,
              v_of_sexp,
              sexp);};
   }
   function m_t_sexp_grammar(K){
    return function(v_grammar){return t_sexp_grammar(K[1], v_grammar);};
   }
   function equal_m_t(param, equal_v, t1, t2){return similar(equal_v, t1, t2);
   }
   var
    Base_Hashtbl =
      [0,
       hash,
       hash_param,
       sexp_of_t,
       create$1,
       of_alist$1,
       of_alist_report_all_dups$1,
       of_alist_or_error$1,
       of_alist_exn$1,
       of_alist_multi$1,
       create_mapped$1,
       create_with_key$1,
       create_with_key_or_error$1,
       create_with_key_exn$1,
       group$1,
       sexp_of_key,
       clear,
       copy,
       fold,
       iter_keys,
       iter,
       iteri,
       existsi,
       exists,
       for_alli,
       for_all,
       counti,
       count,
       length,
       is_empty,
       mem,
       remove,
       choose,
       choose_exn,
       set,
       add,
       add_exn,
       change,
       update,
       update_and_return,
       map,
       mapi,
       filter_map,
       filter_mapi,
       filter_keys,
       filter,
       filteri,
       partition_map,
       partition_mapi,
       partition_tf,
       partitioni_tf,
       find_or_add,
       findi_or_add,
       find,
       find_exn,
       find_and_call,
       find_and_call1,
       find_and_call2,
       findi_and_call,
       findi_and_call1,
       findi_and_call2,
       find_and_remove,
       merge,
       merge_into,
       keys,
       data,
       filter_keys_inplace,
       filter_inplace,
       filteri_inplace,
       map_inplace,
       mapi_inplace,
       filter_map_inplace,
       filter_mapi_inplace,
       similar,
       similar,
       to_alist,
       incr,
       decr,
       add_multi,
       remove_multi,
       find_multi,
       hashable_s,
       invariant,
       Creators,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        hashable,
        invariant,
        create$0,
        of_alist$0,
        of_alist_report_all_dups$0,
        of_alist_or_error$0,
        of_alist_exn$0,
        of_alist_multi$0,
        create_mapped$0,
        create_with_key$0,
        create_with_key_or_error$0,
        create_with_key_exn$0,
        group$0,
        sexp_of_key,
        clear,
        copy,
        fold,
        iter_keys,
        iter,
        iteri,
        existsi,
        exists,
        for_alli,
        for_all,
        counti,
        count,
        length,
        is_empty,
        mem,
        remove,
        choose,
        choose_exn,
        set,
        add,
        add_exn,
        change,
        update,
        update_and_return,
        map,
        mapi,
        filter_map,
        filter_mapi,
        filter_keys,
        filter,
        filteri,
        partition_map,
        partition_mapi,
        partition_tf,
        partitioni_tf,
        find_or_add,
        findi_or_add,
        find,
        find_exn,
        find_and_call,
        find_and_call1,
        find_and_call2,
        findi_and_call,
        findi_and_call1,
        findi_and_call2,
        find_and_remove,
        merge,
        merge_into,
        keys,
        data,
        filter_keys_inplace,
        filter_inplace,
        filteri_inplace,
        map_inplace,
        mapi_inplace,
        filter_map_inplace,
        filter_mapi_inplace,
        similar,
        similar,
        to_alist,
        incr,
        decr,
        add_multi,
        remove_multi,
        find_multi],
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(24, Base_Hashtbl, "Base__Hashtbl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Hash_set_intf = [0];
   runtime.caml_register_global(0, Base_Hash_set_intf, "Base__Hash_set_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Hash_set
//# unitInfo: Requires: Base__Array, Base__Container, Base__Hash_set_intf, Base__Hashable, Base__Hashtbl, Base__Import, Base__List, Base__Or_error, Base__With_return, Sexplib0__Sexp_grammar
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Import = global_data.Base__Import,
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Base_List = global_data.Base__List,
    Base_Hashable = global_data.Base__Hashable,
    Base_Hashtbl = global_data.Base__Hashtbl,
    Base_Array = global_data.Base__Array,
    Base_Container = global_data.Base__Container,
    Base_Or_error = global_data.Base__Or_error,
    Base_With_return = global_data.Base__With_return,
    hashable_s = Base_Hashtbl[81],
    hashable = Base_Hashtbl[90][1],
    poly_hashable = Base_Hashtbl[84][4],
    with_return = Base_With_return[1],
    clear = Base_Hashtbl[16],
    length = Base_Hashtbl[28],
    mem = Base_Hashtbl[30],
    cst_Hash_set_t_of_sexp_got_a_d =
      "Hash_set.t_of_sexp got a duplicate element",
    cst_Hash_set_t_of_sexp_require = "Hash_set.t_of_sexp requires a list",
    _c_ = [0, 0],
    _b_ = [0, 0],
    cst_element_not_in_set = "element not in set",
    cst_element_already_exists = "element already exists",
    _a_ = [0, 0];
   function is_empty(t){return caml_call1(Base_Hashtbl[29], t);}
   function find_map(t, f){
    return caml_call1
            (with_return,
             function(r){
              function _E_(elt){
               var o = caml_call1(f, elt);
               return o ? caml_call1(r, o) : 0;
              }
              caml_call2(Base_Hashtbl[19], t, _E_);
              return 0;
             });
   }
   function find(t, f){
    return find_map(t, function(a){return caml_call1(f, a) ? [0, a] : 0;});
   }
   function add(t, k){return caml_call3(Base_Hashtbl[34], t, k, 0);}
   function strict_add(t, k){
    return caml_call2(mem, t, k)
            ? caml_call1(Base_Or_error[36], cst_element_already_exists)
            : (caml_call3(Base_Hashtbl[34], t, k, 0), _a_);
   }
   function strict_add_exn(t, k){
    var _D_ = strict_add(t, k);
    return caml_call1(Base_Or_error[31], _D_);
   }
   var remove = Base_Hashtbl[31];
   function strict_remove(t, k){
    if(caml_call2(mem, t, k)){caml_call2(remove, t, k); return _b_;}
    var _C_ = caml_call1(Base_Hashtbl[15], t);
    return caml_call5(Base_Or_error[34], 0, 0, cst_element_not_in_set, k, _C_);
   }
   function strict_remove_exn(t, k){
    var _B_ = strict_remove(t, k);
    return caml_call1(Base_Or_error[31], _B_);
   }
   function fold(t, init, f){
    function _A_(key, param, acc){return caml_call2(f, acc, key);}
    return caml_call3(Base_Hashtbl[18], t, init, _A_);
   }
   function iter(t, f){return caml_call2(Base_Hashtbl[19], t, f);}
   function count(t, f){return caml_call3(Base_Container[2], fold, t, f);}
   function sum(m, t, f){return caml_call4(Base_Container[7], fold, m, t, f);}
   function min_elt(t, compare){
    return caml_call3(Base_Container[3], fold, t, compare);
   }
   function max_elt(t, compare){
    return caml_call3(Base_Container[4], fold, t, compare);
   }
   function fold_result(t, init, f){
    return caml_call4(Base_Container[8], fold, init, f, t);
   }
   function fold_until(t, init, f){
    var _y_ = caml_call3(Base_Container[9], fold, init, f);
    return function(_z_){return caml_call2(_y_, _z_, t);};
   }
   var to_list = Base_Hashtbl[64];
   function sexp_of_t(sexp_of_e, t){
    var
     _w_ = caml_call1(to_list, t),
     func = Base_List[62],
     _x_ = caml_call2(func, _w_, caml_call1(hashable, t)[2]);
    return caml_call2(Base_Import[151], sexp_of_e, _x_);
   }
   function to_array(t){
    var
     len = caml_call1(length, t),
     index = [0, caml_call2(Base_Import[92], len, 1)];
    return fold
            (t,
             [0],
             function(acc, key){
              if(0 === acc.length - 1)
               return caml_call2(Base_Array[25], len, key);
              index[1] = caml_call2(Base_Import[92], index[1], 1);
              var _v_ = index[1];
              runtime.caml_check_bound(acc, _v_)[1 + _v_] = key;
              return acc;
             });
   }
   function exists(t, f){
    function _u_(key, param){return caml_call1(f, key);}
    return caml_call2(Base_Hashtbl[22], t, _u_);
   }
   function for_all(t, f){
    function _t_(key, param){return 1 - caml_call1(f, key);}
    return 1 - caml_call2(Base_Hashtbl[22], t, _t_);
   }
   function equal(t1, t2){
    function _r_(param, _s_){return 1;}
    return caml_call3(Base_Hashtbl[73], _r_, t1, t2);
   }
   function copy(t){return caml_call1(Base_Hashtbl[17], t);}
   function filter(t, f){
    function _q_(key, param){return caml_call1(f, key);}
    return caml_call2(Base_Hashtbl[46], t, _q_);
   }
   function union(t1, t2){
    function _o_(param, _p_){return _c_;}
    return caml_call3(Base_Hashtbl[62], t1, t2, _o_);
   }
   function diff(t1, t2){
    return filter
            (t1,
             function(key){return 1 - caml_call2(Base_Hashtbl[30], t2, key);});
   }
   function inter(t1, t2){
    var _m_ = caml_call1(length, t2);
    if(_m_ < caml_call1(length, t1))
     var larger = t1, smaller = t2;
    else
     var larger = t2, smaller = t1;
    function _n_(key, param){
     return caml_call2(Base_Hashtbl[30], larger, key);
    }
    return caml_call2(Base_Hashtbl[46], smaller, _n_);
   }
   function filter_inplace(t, f){
    var
     to_remove =
       fold(t, 0, function(ac, x){return caml_call1(f, x) ? ac : [0, x, ac];});
    function _l_(x){return caml_call2(remove, t, x);}
    return caml_call2(Base_List[9], to_remove, _l_);
   }
   function of_hashtbl_keys(hashtbl){
    function _j_(_k_){return 0;}
    return caml_call2(Base_Hashtbl[40], hashtbl, _j_);
   }
   function to_hashtbl(t, f){
    function _i_(key, param){return caml_call1(f, key);}
    return caml_call2(Base_Hashtbl[41], t, _i_);
   }
   function create(growth_allowed, size, m){
    return caml_call3(Base_Hashtbl[4], growth_allowed, size, m);
   }
   function of_list(growth_allowed, size, m, l){
    if(size)
     var x = size[1], size$0 = x;
    else
     var size$0 = caml_call1(Base_List[7], l);
    var t = caml_call3(Base_Hashtbl[4], growth_allowed, [0, size$0], m);
    function _h_(k){return add(t, k);}
    caml_call2(Base_List[9], l, _h_);
    return t;
   }
   function t_of_sexp(m, e_of_sexp, sexp){
    if(0 === sexp[0])
     return caml_call2(Base_Import[158], cst_Hash_set_t_of_sexp_require, sexp);
    var list = sexp[1], t = create(0, [0, caml_call1(Base_List[7], list)], m);
    function _g_(sexp){
     var e = caml_call1(e_of_sexp, sexp);
     return 0 === strict_add(t, e)[0]
             ? 0
             : caml_call2
               (Base_Import[158], cst_Hash_set_t_of_sexp_got_a_d, sexp);
    }
    caml_call2(Base_List[9], list, _g_);
    return t;
   }
   function Creators(Elt){
    function create$0(growth_allowed, size, param){
     return create(growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]));
    }
    function of_list$0(growth_allowed, size, l){
     return of_list
             (growth_allowed, size, caml_call1(Base_Hashable[4], Elt[1]), l);
    }
    function t_of_sexp$0(e_of_sexp, sexp){
     return t_of_sexp(caml_call1(Base_Hashable[4], Elt[1]), e_of_sexp, sexp);
    }
    return [0, t_of_sexp$0, create$0, of_list$0];
   }
   var
    _d_ = Creators([0, poly_hashable]),
    t_of_sexp$0 = _d_[1],
    create$0 = _d_[2],
    of_list$0 = _d_[3];
   function t_sexp_grammar(grammar){
    var _f_ = caml_call1(Base_List[5], grammar);
    return caml_call1(Sexplib0_Sexp_grammar[1], _f_);
   }
   function M(Elt){return [0];}
   function sexp_of_m_t(Elt){
    return function(t){return sexp_of_t(Elt[1], t);};
   }
   function m_t_of_sexp(Elt){
    return function(sexp){
     return t_of_sexp([0, Elt[2], Elt[3], Elt[4]], Elt[1], sexp);};
   }
   function m_t_sexp_grammar(Elt){
    var _e_ = caml_call1(Base_Import[194], Elt[1]);
    return caml_call1(Sexplib0_Sexp_grammar[1], _e_);
   }
   function equal_m_t(param, t1, t2){return equal(t1, t2);}
   var
    hashable$0 = Base_Hashtbl[90][1],
    Private = [0, hashable$0],
    Base_Hash_set =
      [0,
       sexp_of_t,
       create,
       of_list,
       length,
       is_empty,
       iter,
       fold,
       fold_result,
       fold_until,
       exists,
       for_all,
       count,
       sum,
       find,
       find_map,
       to_list,
       to_array,
       min_elt,
       max_elt,
       mem,
       copy,
       add,
       strict_add,
       strict_add_exn,
       remove,
       strict_remove,
       strict_remove_exn,
       clear,
       equal,
       filter,
       filter_inplace,
       inter,
       union,
       diff,
       of_hashtbl_keys,
       to_hashtbl,
       hashable_s,
       [0,
        t_of_sexp$0,
        sexp_of_t,
        t_sexp_grammar,
        create$0,
        of_list$0,
        length,
        is_empty,
        iter,
        fold,
        fold_result,
        fold_until,
        exists,
        for_all,
        count,
        sum,
        find,
        find_map,
        to_list,
        to_array,
        min_elt,
        max_elt,
        mem,
        copy,
        add,
        strict_add,
        strict_add_exn,
        remove,
        strict_remove,
        strict_remove_exn,
        clear,
        equal,
        filter,
        filter_inplace,
        inter,
        union,
        diff,
        of_hashtbl_keys,
        to_hashtbl],
       Creators,
       M,
       sexp_of_m_t,
       m_t_of_sexp,
       m_t_sexp_grammar,
       equal_m_t,
       Private];
   runtime.caml_register_global(16, Base_Hash_set, "Base__Hash_set");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Float
//# unitInfo: Requires: Assert_failure, Base__Bytes0, Base__Char, Base__Comparable, Base__Comparator, Base__Error, Base__Float0, Base__Import, Base__Int, Base__Int63, Base__Int64, Base__Int_conversions, Base__Or_error, Base__Pretty_printer, Base__Printf, Base__Sexp, Base__String, Base__Word_size, Sexplib0__Sexp_conv_error, Stdlib__Int64
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$4 = "",
    cst_out_of_range_0 = " out of range [0, ",
    cst_s_1e = "%s%.1e",
    cst_is_too_large = ") is too large",
    cst_is_too_small_or_NaN = ") is too small or NaN",
    cst$5 = ".",
    cst_Float_int63_round_down_exn = "Float.int63_round_down_exn: argument (",
    cst_Float_int63_round_nearest_ =
      "Float.int63_round_nearest_portable_alloc_exn: argument (",
    cst_Float_int63_round_up_exn_a = "Float.int63_round_up_exn: argument (",
    cst_Float_iround_down_exn_argu = "Float.iround_down_exn: argument (",
    cst_Float_iround_nearest_exn_a = "Float.iround_nearest_exn: argument (",
    cst_Float_iround_nearest_exn_a$0 =
      "Float.iround_nearest_exn: argument (%f) is too large",
    cst_Float_iround_up_exn_argume = "Float.iround_up_exn: argument (",
    cst_Infinite = "Infinite",
    cst_Nan = "Nan",
    cst_Normal = "Normal",
    cst_Subnormal = "Subnormal",
    cst_Zero = "Zero",
    cst_infinite = "infinite",
    cst_nan$1 = "nan",
    cst_normal = "normal",
    cst_src_float_ml = "src/float.ml",
    cst_subnormal = "subnormal",
    cst_zero = "zero",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_format_float = runtime.caml_format_float,
    caml_int64_bits_of_float = runtime.caml_int64_bits_of_float,
    caml_int64_or = runtime.caml_int64_or,
    caml_log10_float = runtime.caml_log10_float,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$3 = cst$4,
    cst$2 = cst$4,
    cst$1 = "-",
    cst$0 = cst$5,
    cst = cst$5,
    all = [0, 0, [0, 1, [0, 2, [0, 3, [0, 4, 0]]]]],
    error_source_006 = "float.ml.Class.t",
    t_sexp_grammar$0 =
      [3,
       [0,
        2,
        [0,
         [1, [0, cst_Infinite, 0]],
         [0,
          [1, [0, cst_Nan, 0]],
          [0,
           [1, [0, cst_Normal, 0]],
           [0, [1, [0, cst_Subnormal, 0]], [0, [1, [0, cst_Zero, 0]], 0]]]]]]],
    module_name = "Base.Float",
    Base_Import = global_data.Base__Import,
    Base_Printf = global_data.Base__Printf,
    Base_Or_error = global_data.Base__Or_error,
    Base_Int = global_data.Base__Int,
    Base_Int63 = global_data.Base__Int63,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Base_Int64 = global_data.Base__Int64,
    Base_Sexp = global_data.Base__Sexp,
    Base_Error = global_data.Base__Error,
    Assert_failure = global_data.Assert_failure,
    Base_String = global_data.Base__String,
    Base_Bytes0 = global_data.Base__Bytes0,
    Base_Char = global_data.Base__Char,
    Base_Int_conversions = global_data.Base__Int_conversions,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_Float0 = global_data.Base__Float0,
    Base_Comparator = global_data.Base__Comparator,
    Base_Word_size = global_data.Base__Word_size,
    Base_Comparable = global_data.Base__Comparable,
    Base_Pretty_printer = global_data.Base__Pretty_printer,
    round_up = Base_Float0[1],
    round_down = Base_Float0[2],
    mod_float = Base_Float0[3],
    modf = Base_Float0[4],
    float_of_string = Base_Float0[5],
    nan = Base_Float0[6],
    max_value = Base_Float0[7],
    neg_infinity = Base_Float0[8],
    max_finite_value = Base_Float0[9],
    epsilon_float = Base_Float0[10],
    classify_float = Base_Float0[11],
    abs_float = Base_Float0[12],
    is_integer = Base_Float0[13],
    symbol = Base_Float0[14],
    symbol$0 = Base_Float0[15],
    frexp = Base_Float0[16],
    ldexp = Base_Float0[17],
    is_nan = Base_Float0[18],
    to_int64_preserve_order = Base_Float0[19],
    to_int64_preserve_order_exn = Base_Float0[20],
    of_int64_preserve_order = Base_Float0[21],
    one_ulp = Base_Float0[22],
    upper_bound_for_int = Base_Float0[23],
    lower_bound_for_int = Base_Float0[25],
    clamp_unchecked = Base_Float0[26],
    box = Base_Float0[27],
    compare = Base_Float0[36],
    raise_s = Base_Error[30],
    hash_fold_t = Base_Import[209],
    func = Base_Import[223],
    _R_ = [0, [8, [0, 0, 4], 0, [0, 8], 0], "%.8G"],
    _P_ =
      [0,
       [11,
        "exponent ",
        [4, 0, 0, 0, [11, cst_out_of_range_0, [4, 0, 0, 0, [12, 93, 0]]]]],
       "exponent %d out of range [0, %d]"],
    _Q_ =
      [0,
       [11,
        "mantissa ",
        [2, 0, [11, cst_out_of_range_0, [2, 0, [12, 93, 0]]]]],
       "mantissa %s out of range [0, %s]"],
    cst_Float_sign_exn_of_NAN = "Float.sign_exn of NAN",
    cst_max = "max",
    cst_min = "min",
    cst_clamp_requires_min_max = "clamp requires [min <= max]",
    _L_ = [0, cst_src_float_ml, 859, 2],
    _K_ =
      [0,
       [11,
        "Float.round_significant: invalid argument significant_digits:",
        [4, 0, 0, 0, 0]],
       "Float.round_significant: invalid argument significant_digits:%d"],
    _J_ = [0, [8, [0, 0, 3], 0, 1, 0], "%.*g"],
    _I_ = [0, "p"],
    cst_t = "t",
    cst_g = "g",
    cst_m = "m",
    cst_k = "k",
    _F_ = [0, cst_src_float_ml, 697, 8],
    _E_ = [0, cst_src_float_ml, 700, 8],
    _A_ = [0, cst_src_float_ml, 707, 8],
    _B_ = [0, cst_src_float_ml, 708, 8],
    _C_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [12, 32, 0]]]], "%s%d%s "],
    _D_ = [0, [2, 0, [4, 0, 0, 0, [2, 0, [4, 0, 0, 0, 0]]]], "%s%d%s%d"],
    _z_ = [0, cst_src_float_ml, 684, 8],
    cst_0 = ".0",
    _G_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    _H_ = [0, [2, 0, [8, [0, 0, 1], 0, [0, 1], 0]], cst_s_1e],
    cst_inf$1 = "-inf  ",
    cst_inf$2 = "inf  ",
    cst_nan$0 = "nan  ",
    cst_sexp = "sexp",
    cst_sexp_of_float_produced_str = "[sexp_of_float] produced strange sexp",
    _w_ =
      [0,
       [11, "to_string_hum: invalid argument ~decimals=", [4, 0, 0, 0, 0]],
       "to_string_hum: invalid argument ~decimals=%d"],
    _x_ = [0, [8, [0, 1, 0], 0, 1, 0], "%+.*f"],
    _y_ = [0, [8, [0, 0, 0], 0, 1, 0], "%.*f"],
    cst_inf = "inf",
    cst_inf$0 = "-inf",
    cst_nan = cst_nan$1,
    _r_ = [0, cst_Infinite],
    _s_ = [0, cst_Nan],
    _t_ = [0, cst_Normal],
    _u_ = [0, cst_Subnormal],
    _v_ = [0, cst_Zero],
    _p_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too large"],
    _q_ =
      [0,
       [11,
        cst_Float_int63_round_nearest_,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_nearest_portable_alloc_exn: argument (%f) is too small or NaN"],
    _n_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too large"],
    _o_ =
      [0,
       [11,
        cst_Float_int63_round_down_exn,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_down_exn: argument (%f) is too small or NaN"],
    _l_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too large"],
    _m_ =
      [0,
       [11,
        cst_Float_int63_round_up_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.int63_round_up_exn: argument (%f) is too small or NaN"],
    _j_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _k_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small or NaN"],
    _h_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       cst_Float_iround_nearest_exn_a$0],
    _i_ =
      [0,
       [11,
        cst_Float_iround_nearest_exn_a,
        [8, [0, 0, 0], 0, 0, [11, ") is too small", 0]]],
       "Float.iround_nearest_exn: argument (%f) is too small"],
    _f_ =
      [0,
       [11,
        "Float.iround_towards_zero_exn: argument (",
        [8, [0, 0, 0], 0, 0, [11, ") is out of range or NaN", 0]]],
       "Float.iround_towards_zero_exn: argument (%f) is out of range or NaN"],
    _d_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_down_exn: argument (%f) is too large"],
    _e_ =
      [0,
       [11,
        cst_Float_iround_down_exn_argu,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_down_exn: argument (%f) is too small or NaN"],
    _b_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_large, 0]]],
       "Float.iround_up_exn: argument (%f) is too large"],
    _c_ =
      [0,
       [11,
        cst_Float_iround_up_exn_argume,
        [8, [0, 0, 0], 0, 0, [11, cst_is_too_small_or_NaN, 0]]],
       "Float.iround_up_exn: argument (%f) is too small or NaN"],
    _a_ = [0, [11, "Float.of_string ", [2, 0, 0]], "Float.of_string %s"];
   function hash(x){return caml_call1(func, x);}
   var
    t_of_sexp = Base_Import[166],
    sexp_of_t = Base_Import[142],
    t_sexp_grammar = Base_Import[186],
    hashable = [0, hash, compare, sexp_of_t],
    compare$0 = Base_Import[107][9],
    include = caml_call1(Base_Comparator[5], [0, compare$0, sexp_of_t]),
    comparator = include[1];
   function invariant(param){return 0;}
   function to_float(x){return x;}
   function of_float(x){return x;}
   function of_string(s){
    try{var _aX_ = caml_call1(float_of_string, s); return _aX_;}
    catch(_aY_){return caml_call3(Base_Printf[7], _a_, s, 0);}
   }
   function to_string(x){
    var
     y = caml_format_float("%.15g", x),
     _aW_ = caml_call1(float_of_string, y),
     y$0 =
       caml_call2(Base_Import[107][4], _aW_, x)
        ? y
        : caml_format_float("%.17g", x),
     l = runtime.caml_ml_string_length(y$0),
     i = 0;
    for(;;){
     if(l <= i) return caml_call2(Base_Import[111], y$0, cst);
     var match = runtime.caml_string_get(y$0, i), switch$0 = 0;
     if(48 <= match){
      if(58 > match) switch$0 = 1;
     }
     else if(45 === match) switch$0 = 1;
     if(! switch$0) return y$0;
     var i$0 = caml_call2(Base_Import[90], i, 1), i = i$0;
    }
   }
   var
    min_positive_subnormal_value = caml_call2(symbol, 2., -1074.),
    min_positive_normal_value = caml_call2(symbol, 2., -1022.),
    of_int = Base_Int[3],
    to_int = Base_Int[2],
    zero = 0.,
    one = 1.,
    minus_one = -1.,
    pi = 3.141592653589793,
    sqrt_pi = 1.772453850905516,
    sqrt_2pi = 2.5066282746310007,
    euler = 0.5772156649015329;
   function of_int63(i){return caml_call1(Base_Int63[3], i);}
   var
    of_int64 = runtime.caml_int64_to_float,
    to_int64 = runtime.caml_int64_of_float,
    iround_lbound = caml_call1(lower_bound_for_int, Base_Int[59]),
    iround_ubound = caml_call1(upper_bound_for_int, Base_Int[59]);
   function iround_up(t){
    if(! caml_call2(Base_Import[107][5], t, 0.))
     return caml_call2(Base_Import[107][6], t, iround_lbound)
             ? [0, caml_call1(Base_Int[58], t)]
             : 0;
    var t$0 = caml_call1(round_up, t);
    return caml_call2(Base_Import[107][2], t$0, iround_ubound)
            ? [0, caml_call1(Base_Int[58], t$0)]
            : 0;
   }
   function iround_up_exn(t){
    if(caml_call2(Base_Import[107][5], t, 0.)){
     var t$0 = caml_call1(round_up, t);
     if(caml_call2(Base_Import[107][2], t$0, iround_ubound))
      return caml_call1(Base_Int[58], t$0);
     var _aU_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _b_, _aU_, 0);
    }
    if(caml_call2(Base_Import[107][6], t, iround_lbound))
     return caml_call1(Base_Int[58], t);
    var _aV_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _c_, _aV_, 0);
   }
   function iround_down(t){
    if(caml_call2(Base_Import[107][6], t, 0.))
     return caml_call2(Base_Import[107][2], t, iround_ubound)
             ? [0, caml_call1(Base_Int[58], t)]
             : 0;
    var t$0 = caml_call1(round_down, t);
    return caml_call2(Base_Import[107][6], t$0, iround_lbound)
            ? [0, caml_call1(Base_Int[58], t$0)]
            : 0;
   }
   function iround_down_exn(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     if(caml_call2(Base_Import[107][2], t, iround_ubound))
      return caml_call1(Base_Int[58], t);
     var _aS_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _d_, _aS_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(caml_call2(Base_Import[107][6], t$0, iround_lbound))
     return caml_call1(Base_Int[58], t$0);
    var _aT_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _e_, _aT_, 0);
   }
   function iround_towards_zero(t){
    if
     (caml_call2(Base_Import[107][6], t, iround_lbound)
      && caml_call2(Base_Import[107][2], t, iround_ubound))
     return [0, caml_call1(Base_Int[58], t)];
    return 0;
   }
   function iround_towards_zero_exn(t){
    if
     (caml_call2(Base_Import[107][6], t, iround_lbound)
      && caml_call2(Base_Import[107][2], t, iround_ubound))
     return caml_call1(Base_Int[58], t);
    var _aR_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _f_, _aR_, 0);
   }
   var
    _g_ = caml_call2(symbol, 2., 52.),
    round_nearest_lb = caml_call1(Base_Import[113], _g_),
    round_nearest_ub = caml_call2(symbol, 2., 52.),
    one_ulp_less_than_half = caml_call2(one_ulp, 759637122, 0.5);
   function add_half_for_round_nearest(t){
    var
     _aQ_ =
       caml_call2(Base_Import[107][4], t, one_ulp_less_than_half)
        ? one_ulp_less_than_half
        : 0.5;
    return caml_call2(Base_Import[91], t, _aQ_);
   }
   function iround_nearest_32(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     var t$0 = add_half_for_round_nearest(t);
     return caml_call2(Base_Import[107][2], t$0, iround_ubound)
             ? [0, caml_call1(Base_Int[58], t$0)]
             : 0;
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[91], t, 0.5));
    return caml_call2(Base_Import[107][6], t$1, iround_lbound)
            ? [0, caml_call1(Base_Int[58], t$1)]
            : 0;
   }
   function iround_nearest_64(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     if(! caml_call2(Base_Import[107][1], t, round_nearest_ub))
      return caml_call2(Base_Import[107][2], t, iround_ubound)
              ? [0, caml_call1(Base_Int[58], t)]
              : 0;
     var _aO_ = add_half_for_round_nearest(t);
     return [0, caml_call1(Base_Int[58], _aO_)];
    }
    if(! caml_call2(Base_Import[107][5], t, round_nearest_lb))
     return caml_call2(Base_Import[107][6], t, iround_lbound)
             ? [0, caml_call1(Base_Int[58], t)]
             : 0;
    var _aP_ = caml_call1(round_down, caml_call2(Base_Import[91], t, 0.5));
    return [0, caml_call1(Base_Int[58], _aP_)];
   }
   var
    iround_nearest_64$0 =
      Base_Word_size[3] ? iround_nearest_64 : iround_nearest_32;
   function iround_nearest_exn_32(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     var t$0 = add_half_for_round_nearest(t);
     if(caml_call2(Base_Import[107][2], t$0, iround_ubound))
      return caml_call1(Base_Int[58], t$0);
     var _aM_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _h_, _aM_, 0);
    }
    var t$1 = caml_call1(round_down, caml_call2(Base_Import[91], t, 0.5));
    if(caml_call2(Base_Import[107][6], t$1, iround_lbound))
     return caml_call1(Base_Int[58], t$1);
    var _aN_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _i_, _aN_, 0);
   }
   function iround_nearest_exn_64(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     if(caml_call2(Base_Import[107][1], t, round_nearest_ub)){
      var _aI_ = add_half_for_round_nearest(t);
      return caml_call1(Base_Int[58], _aI_);
     }
     if(caml_call2(Base_Import[107][2], t, iround_ubound))
      return caml_call1(Base_Int[58], t);
     var _aJ_ = caml_call1(box, t);
     return caml_call3(Base_Printf[7], _j_, _aJ_, 0);
    }
    if(caml_call2(Base_Import[107][5], t, round_nearest_lb)){
     var _aK_ = caml_call1(round_down, caml_call2(Base_Import[91], t, 0.5));
     return caml_call1(Base_Int[58], _aK_);
    }
    if(caml_call2(Base_Import[107][6], t, iround_lbound))
     return caml_call1(Base_Int[58], t);
    var _aL_ = caml_call1(box, t);
    return caml_call3(Base_Printf[7], _k_, _aL_, 0);
   }
   var
    iround_nearest_exn =
      Base_Word_size[3] ? iround_nearest_exn_64 : iround_nearest_exn_32;
   function iround_exn(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    return 857423934 <= dir
            ? 1003109192
              <= dir
              ? iround_towards_zero_exn(t)
              : iround_nearest_exn(t)
            : 759637122 <= dir ? iround_down_exn(t) : iround_up_exn(t);
   }
   function iround(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    try{var _aG_ = [0, iround_exn([0, dir], t)]; return _aG_;}
    catch(_aH_){return 0;}
   }
   function is_inf(t){
    var _aF_ = caml_call2(Base_Import[95], 1., t);
    return caml_call2(Base_Import[107][4], _aF_, 0.);
   }
   function is_finite(t){
    var _aE_ = caml_call2(Base_Import[93], t, t);
    return caml_call2(Base_Import[107][4], _aE_, 0.);
   }
   function min_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1
               (is_nan, x)
              ? y
              : caml_call2(Base_Import[107][1], x, y) ? x : y;
   }
   function max_inan(x, y){
    return caml_call1(is_nan, y)
            ? x
            : caml_call1
               (is_nan, x)
              ? y
              : caml_call2(Base_Import[107][5], x, y) ? x : y;
   }
   var
    add = Base_Import[91],
    sub = Base_Import[93],
    neg = Base_Import[113],
    scale = Base_Import[89];
   function square(x){return caml_call2(Base_Import[89], x, x);}
   function fractional(t){return caml_call1(Base_Import[124], t);}
   function integral(t){return caml_call1(Base_Import[126], t);}
   function round_towards_zero(t){
    return caml_call2(Base_Import[107][6], t, 0.)
            ? caml_call1(round_down, t)
            : caml_call1(round_up, t);
   }
   function round_nearest_inline(t){
    if
     (caml_call2(Base_Import[107][5], t, round_nearest_lb)
      && caml_call2(Base_Import[107][1], t, round_nearest_ub))
     return caml_call1(round_down, add_half_for_round_nearest(t));
    return caml_call2(Base_Import[91], t, 0.);
   }
   function round_nearest(t){return round_nearest_inline(t);}
   function round_nearest_half_to_even(t){
    if
     (!
      caml_call2(Base_Import[107][2], t, round_nearest_lb)
      && ! caml_call2(Base_Import[107][6], t, round_nearest_ub)){
     var
      floor = caml_call1(round_down, t),
      ceil_or_succ = caml_call2(Base_Import[91], floor, 1.),
      diff_floor = caml_call2(Base_Import[93], t, floor),
      diff_ceil = caml_call2(Base_Import[93], ceil_or_succ, t);
     if(caml_call2(Base_Import[107][1], diff_floor, diff_ceil)) return floor;
     if(caml_call2(Base_Import[107][5], diff_floor, diff_ceil))
      return ceil_or_succ;
     var _aD_ = caml_call2(mod_float, floor, 2.);
     return caml_call2(Base_Import[107][4], _aD_, 0.) ? floor : ceil_or_succ;
    }
    return caml_call2(Base_Import[91], t, 0.);
   }
   var
    int63_round_lbound = caml_call1(lower_bound_for_int, Base_Int63[83]),
    int63_round_ubound = caml_call1(upper_bound_for_int, Base_Int63[83]);
   function int63_round_up_exn(t){
    if(caml_call2(Base_Import[107][5], t, 0.)){
     var t$0 = caml_call1(round_up, t);
     if(caml_call2(Base_Import[107][2], t$0, int63_round_ubound))
      return caml_call1(Base_Int63[82], t$0);
     var _aB_ = caml_call1(Base_Float0[27], t);
     return caml_call3(Base_Printf[7], _l_, _aB_, 0);
    }
    if(caml_call2(Base_Import[107][6], t, int63_round_lbound))
     return caml_call1(Base_Int63[82], t);
    var _aC_ = caml_call1(Base_Float0[27], t);
    return caml_call3(Base_Printf[7], _m_, _aC_, 0);
   }
   function int63_round_down_exn(t){
    if(caml_call2(Base_Import[107][6], t, 0.)){
     if(caml_call2(Base_Import[107][2], t, int63_round_ubound))
      return caml_call1(Base_Int63[82], t);
     var _az_ = caml_call1(Base_Float0[27], t);
     return caml_call3(Base_Printf[7], _n_, _az_, 0);
    }
    var t$0 = caml_call1(round_down, t);
    if(caml_call2(Base_Import[107][6], t$0, int63_round_lbound))
     return caml_call1(Base_Int63[82], t$0);
    var _aA_ = caml_call1(Base_Float0[27], t);
    return caml_call3(Base_Printf[7], _o_, _aA_, 0);
   }
   function int63_round_nearest_portable_a(t0){
    var t = round_nearest_inline(t0);
    if(caml_call2(Base_Import[107][5], t, 0.)){
     if(caml_call2(Base_Import[107][2], t, int63_round_ubound))
      return caml_call1(Base_Int63[82], t);
     var _ax_ = caml_call1(box, t0);
     return caml_call3(Base_Printf[7], _p_, _ax_, 0);
    }
    if(caml_call2(Base_Import[107][6], t, int63_round_lbound))
     return caml_call1(Base_Int63[82], t);
    var _ay_ = caml_call1(box, t0);
    return caml_call3(Base_Printf[7], _q_, _ay_, 0);
   }
   function int63_round_nearest_arch64_noa(f){
    var _aw_ = iround_nearest_exn(f);
    return caml_call1(Base_Int63[96], _aw_);
   }
   var
    int63_round_nearest_exn =
      Base_Word_size[3]
       ? int63_round_nearest_arch64_noa
       : int63_round_nearest_portable_a;
   function round(opt, t){
    if(opt) var sth = opt[1], dir = sth; else var dir = 857423934;
    return 857423934 <= dir
            ? 1003109192 <= dir ? round_towards_zero(t) : round_nearest(t)
            : 759637122
              <= dir
              ? caml_call1(round_down, t)
              : caml_call1(round_up, t);
   }
   var compare$1 = runtime.caml_int_compare;
   function t_of_sexp$0(sexp_007){
    if(0 === sexp_007[0]){
     var
      _aq_ = sexp_007[1],
      _ar_ = caml_string_compare(_aq_, cst_infinite),
      switch$0 = 0;
     if(0 <= _ar_)
      if(0 < _ar_)
       if(caml_string_notequal(_aq_, cst_nan$1))
        if(caml_string_notequal(_aq_, cst_normal))
         if(caml_string_notequal(_aq_, cst_subnormal)){
          if(! caml_string_notequal(_aq_, cst_zero)) switch$0 = 5;
         }
         else
          switch$0 = 4;
        else
         switch$0 = 3;
       else
        switch$0 = 2;
      else
       switch$0 = 1;
     else if(caml_string_notequal(_aq_, cst_Infinite))
      if(caml_string_notequal(_aq_, cst_Nan))
       if(caml_string_notequal(_aq_, cst_Normal))
        if(caml_string_notequal(_aq_, cst_Subnormal)){
         if(! caml_string_notequal(_aq_, cst_Zero)) switch$0 = 5;
        }
        else
         switch$0 = 4;
       else
        switch$0 = 3;
      else
       switch$0 = 2;
     else
      switch$0 = 1;
     switch(switch$0){
       case 1:
        return 0;
       case 2:
        return 1;
       case 3:
        return 2;
       case 4:
        return 3;
       case 5:
        return 4;
     }
    }
    else{
     var _as_ = sexp_007[1];
     if(! _as_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_006, sexp_007);
     var _at_ = _as_[1];
     if(0 !== _at_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_006, sexp_007);
     var
      _au_ = _at_[1],
      _av_ = caml_string_compare(_au_, cst_infinite),
      switch$1 = 0;
     if(0 <= _av_){
      if(0 < _av_)
       if(caml_string_notequal(_au_, cst_nan$1))
        if(caml_string_notequal(_au_, cst_normal))
         if(caml_string_notequal(_au_, cst_subnormal))
          if(caml_string_notequal(_au_, cst_zero))
           switch$1 = 5;
          else
           switch$1 = 4;
         else
          switch$1 = 3;
        else
         switch$1 = 2;
       else
        switch$1 = 1;
     }
     else if(caml_string_notequal(_au_, cst_Infinite))
      if(caml_string_notequal(_au_, cst_Nan))
       if(caml_string_notequal(_au_, cst_Normal))
        if(caml_string_notequal(_au_, cst_Subnormal))
         if(caml_string_notequal(_au_, cst_Zero))
          switch$1 = 5;
         else
          switch$1 = 4;
        else
         switch$1 = 3;
       else
        switch$1 = 2;
      else
       switch$1 = 1;
     switch(switch$1){
       case 0:
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
       case 1:
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
       case 2:
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
       case 3:
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
       case 4:
        return caml_call2
                (Sexplib0_Sexp_conv_error[3], error_source_006, sexp_007);
     }
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_006, sexp_007);
   }
   function sexp_of_t$0(param){
    switch(param){
      case 0:
       return _r_;
      case 1:
       return _s_;
      case 2:
       return _t_;
      case 3:
       return _u_;
      default: return _v_;
    }
   }
   function to_string$0(t){
    var _ap_ = sexp_of_t$0(t);
    return caml_call1(Base_Import[162], _ap_);
   }
   function of_string$0(s){
    return t_of_sexp$0(caml_call1(Base_Import[138], s));
   }
   function classify(t){
    switch(caml_call1(classify_float, t)){
      case 0:
       return 2;
      case 1:
       return 3;
      case 2:
       return 4;
      case 3:
       return 0;
      default: return 1;
    }
   }
   function insert_underscores(opt, _am_, string){
    if(opt) var sth = opt[1], delimiter = sth; else var delimiter = 95;
    if(_am_) var sth$0 = _am_[1], strip_zero = sth$0; else var strip_zero = 0;
    var match = caml_call2(Base_String[84], string, 46);
    if(! match)
     return caml_call2(Base_Int_conversions[37], string, delimiter);
    var
     match$0 = match[1],
     right = match$0[2],
     left = match$0[1],
     left$0 = caml_call2(Base_Int_conversions[37], left, delimiter);
    if(strip_zero)
     var
      _an_ = [0, function(c){return caml_call2(Base_Char[11], c, 48);}],
      right$0 = caml_call2(Base_String[92], _an_, right);
    else
     var right$0 = right;
    if(! caml_string_notequal(right$0, cst$4)) return left$0;
    var _ao_ = caml_call2(Base_Import[111], cst$0, right$0);
    return caml_call2(Base_Import[111], left$0, _ao_);
   }
   function to_string_hum(delimiter, opt, strip_zero, _al_, f){
    if(opt) var sth = opt[1], decimals = sth; else var decimals = 3;
    if(_al_)
     var sth$0 = _al_[1], explicit_plus = sth$0;
    else
     var explicit_plus = 0;
    if(decimals < 0) caml_call3(Base_Printf[7], _w_, decimals, 0);
    var match = classify(f);
    if(1 === match) return cst_nan;
    if(! match)
     return caml_call2(Base_Import[107][5], f, 0.) ? cst_inf : cst_inf$0;
    var
     s =
       explicit_plus
        ? caml_call3(Base_Printf[2], _x_, decimals, f)
        : caml_call3(Base_Printf[2], _y_, decimals, f);
    return insert_underscores(delimiter, strip_zero, s);
   }
   function sexp_of_t$1(t){
    var sexp = caml_call1(sexp_of_t, t);
    if(1009018843 <= Base_Sexp[18][1]) return sexp;
    if(0 === sexp[0]){
     var string = sexp[1];
     return caml_call4(Base_String[56], 0, 0, string, 69)
             ? sexp
             : [0, insert_underscores(0, 0, string)];
    }
    var _ak_ = [0, [0, cst_sexp, caml_call1(Base_Sexp[4], sexp)], 0];
    return caml_call1
            (raise_s,
             caml_call2(Base_Sexp[9], cst_sexp_of_float_produced_str, _ak_));
   }
   function to_padded_compact_string_custo
   (t, opt, kilo, mega, giga, tera, peta, param){
    if(opt) var sth = opt[1], prefix = sth; else var prefix = cst$2;
    var match = classify(t);
    if(1 === match) return cst_nan$0;
    if(! match)
     return caml_call2(Base_Import[107][1], t, 0.) ? cst_inf$1 : cst_inf$2;
    function go(t){
     function conv(mag, numerator, denominator){
      var switch$0 = 0;
      if
       (caml_call2(Base_Import[107][4], denominator, 100.)
        && caml_call2(Base_Import[107][6], numerator, 999.95))
       switch$0 = 1;
      if(! switch$0){
       var switch$1 = 0;
       if(caml_call2(Base_Import[107][6], denominator, 100000.)){
        var
         _aj_ =
           round_nearest(caml_call2(Base_Import[89], denominator, 9.9995));
        if(caml_call2(Base_Import[107][6], numerator, _aj_)) switch$1 = 1;
       }
       if(! switch$1)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _F_], 1);
      }
      var
       _ai_ = round_nearest(caml_call2(Base_Import[89], denominator, 9999.5));
      if(! caml_call2(Base_Import[107][1], numerator, _ai_))
       throw caml_maybe_attach_backtrace([0, Assert_failure, _E_], 1);
      var
       k =
         caml_call1
          (round_down, caml_call2(Base_Import[95], numerator, denominator)),
       lower = caml_call2(Base_Import[89], denominator, k),
       _ah_ = caml_call2(Base_Import[91], k, 1.),
       higher = caml_call2(Base_Import[89], denominator, _ah_),
       diff_right = caml_call2(Base_Import[93], higher, numerator),
       diff_left = caml_call2(Base_Import[93], numerator, lower),
       k$0 = iround_nearest_exn(k),
       k$1 =
         caml_call2(Base_Import[107][1], diff_right, diff_left)
          ? caml_call2(Base_Import[90], k$0, 1)
          : caml_call2
             (Base_Import[107][5], diff_right, diff_left)
            ? k$0
            : 0
              === caml_call2(Base_Import[121], k$0, 2)
              ? k$0
              : caml_call2(Base_Import[90], k$0, 1),
       d = caml_call2(Base_Import[121], k$1, 10),
       i = caml_call2(Base_Import[94], k$1, 10);
      if(0 <= i && 1000 > i){
       if(0 <= d && 10 > d)
        return 0 === d
                ? caml_call4(Base_Printf[2], _C_, prefix, i, mag)
                : caml_call5(Base_Printf[2], _D_, prefix, i, mag, d);
       throw caml_maybe_attach_backtrace([0, Assert_failure, _B_], 1);
      }
      throw caml_maybe_attach_backtrace([0, Assert_failure, _A_], 1);
     }
     if(! caml_call2(Base_Import[107][1], t, 999.95)){
      if(caml_call2(Base_Import[107][1], t, 999950.))
       return conv(kilo, t, 100.);
      if(caml_call2(Base_Import[107][1], t, 999950000.))
       return conv(mega, t, 100000.);
      if(caml_call2(Base_Import[107][1], t, 999950000000.))
       return conv(giga, t, 100000000.);
      if(caml_call2(Base_Import[107][1], t, 999950000000000.))
       return conv(tera, t, 100000000000.);
      if(! peta) return caml_call3(Base_Printf[2], _H_, prefix, t);
      var peta$0 = peta[1];
      return caml_call2(Base_Import[107][1], t, 999950000000000000.)
              ? conv(peta$0, t, 100000000000000.)
              : caml_call3(Base_Printf[2], _G_, prefix, t);
     }
     if
      (caml_call2(Base_Import[107][2], 0., t)
       && caml_call2(Base_Import[107][1], t, 999.95)){
      var
       x = caml_call2(Base_Import[111], prefix, caml_format_float("%.1f", t));
      if(! caml_call2(Base_String[80], x, cst_0)) return x;
      var
       x$0 = caml_call1(Base_Bytes0[15], x),
       n = runtime.caml_ml_bytes_length(x$0);
      caml_bytes_set(x$0, caml_call2(Base_Import[92], n, 1), 32);
      caml_bytes_set(x$0, caml_call2(Base_Import[92], n, 2), 32);
      return caml_call1(Base_Bytes0[16], x$0);
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
    }
    if(caml_call2(Base_Import[107][6], t, 0.)) return go(t);
    var _ag_ = go(caml_call1(Base_Import[113], t));
    return caml_call2(Base_Import[111], cst$1, _ag_);
   }
   function to_padded_compact_string(t){
    return to_padded_compact_string_custo
            (t, 0, cst_k, cst_m, cst_g, cst_t, _I_, 0);
   }
   function int_pow(x, n){
    if(0 === n) return 1.;
    var
     x$0 = [0, caml_call2(Base_Import[91], x, -0.)],
     n$0 = [0, n],
     accum = [0, 1.];
    if(n$0[1] < 0){
     x$0[1] = caml_call2(Base_Import[95], 1., x$0[1]);
     n$0[1] = caml_call1(Base_Import[112], n$0[1]);
     if(n$0[1] < 0){accum[1] = x$0[1]; caml_call1(Base_Import[128], n$0);}
    }
    for(;;){
     if(1 >= n$0[1]) return caml_call2(Base_Import[89], x$0[1], accum[1]);
     if(0 !== caml_call2(Base_Import[115], n$0[1], 1))
      accum[1] = caml_call2(Base_Import[89], x$0[1], accum[1]);
     x$0[1] = caml_call2(Base_Import[89], x$0[1], x$0[1]);
     n$0[1] = caml_call2(Base_Import[119], n$0[1], 1);
    }
   }
   function round_gen(x, how){
    if(caml_call2(Base_Import[107][4], x, 0.)) return 0.;
    if(! is_finite(x)) return x;
    if(555917426 <= how[1])
     var
      sd = how[2],
      _ac_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      dd = caml_call2(Base_Import[92], sd, _ac_),
      dd$0 = dd,
      sd$0 = sd;
    else
     var
      dd$1 = how[2],
      _af_ =
        caml_call1
         (to_int,
          caml_call1(round_up, caml_log10_float(caml_call1(abs_float, x)))),
      sd$1 = caml_call2(Base_Import[90], dd$1, _af_),
      dd$0 = dd$1,
      sd$0 = sd$1;
    if(0 > sd$0) return 0.;
    if(17 <= sd$0) return x;
    var abs_dd = caml_call1(Base_Int[73], dd$0);
    if(22 >= abs_dd && 16 > sd$0){
     var order = int_pow(10., abs_dd);
     if(0 <= dd$0){
      var
       _ad_ =
         round_nearest_half_to_even(caml_call2(Base_Import[89], x, order));
      return caml_call2(Base_Import[95], _ad_, order);
     }
     var
      _ae_ = round_nearest_half_to_even(caml_call2(Base_Import[95], x, order));
     return caml_call2(Base_Import[89], _ae_, order);
    }
    return of_string(caml_call3(Base_Printf[2], _J_, sd$0, x));
   }
   function round_significant(x, significant_digits){
    return 0 < significant_digits
            ? round_gen(x, [0, 555917426, significant_digits])
            : caml_call3(Base_Printf[7], _K_, significant_digits, 0);
   }
   function round_decimal(x, decimal_digits){
    return round_gen(x, [0, -352548012, decimal_digits]);
   }
   function between(t, low, high){
    var _ab_ = caml_call2(Base_Import[107][2], low, t);
    return _ab_ ? caml_call2(Base_Import[107][2], t, high) : _ab_;
   }
   function clamp_exn(t, min, max){
    if(caml_call2(Base_Import[107][2], min, max))
     return caml_call3(clamp_unchecked, t, min, max);
    throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
   }
   function clamp(t, min, max){
    if(caml_call2(Base_Import[107][2], min, max))
     return [0, caml_call3(clamp_unchecked, t, min, max)];
    var
     ___ = [0, [0, cst_max, caml_call1(sexp_of_t, max)], 0],
     _$_ = [0, [0, cst_min, caml_call1(sexp_of_t, min)], ___],
     _aa_ = caml_call2(Base_Sexp[9], cst_clamp_requires_min_max, _$_);
    return caml_call1(Base_Or_error[35], _aa_);
   }
   var
    symbol$1 = Base_Import[91],
    symbol$2 = Base_Import[93],
    symbol$3 = Base_Import[89],
    symbol$4 = Base_Import[95],
    symbol$5 = Base_Import[113];
   function sign_exn(t){
    if(caml_call2(Base_Import[107][5], t, 0.)) return 2;
    if(caml_call2(Base_Import[107][1], t, 0.)) return 0;
    if(caml_call2(Base_Import[107][4], t, 0.)) return 1;
    var
     _Y_ = [0, [0, cst$3, sexp_of_t$1(t)], 0],
     _Z_ = caml_call2(Base_Sexp[9], cst_Float_sign_exn_of_NAN, _Y_);
    return caml_call1(Base_Error[30], _Z_);
   }
   function sign_or_nan(t){
    return caml_call2(Base_Import[107][5], t, 0.)
            ? 2
            : caml_call2
               (Base_Import[107][1], t, 0.)
              ? 0
              : caml_call2(Base_Import[107][4], t, 0.) ? 1 : 3;
   }
   function ieee_negative(t){
    var bits = caml_int64_bits_of_float(t);
    return runtime.caml_lessthan(bits, Stdlib_Int64[1]);
   }
   var
    _M_ = Base_Int64[32],
    exponent_mask64 =
      runtime.caml_int64_sub
       (caml_call2(Base_Int64[48], Base_Int64[32], 11), _M_),
    exponent_mask = caml_call1(Base_Int64[5], exponent_mask64),
    _N_ = Base_Int63[39],
    _O_ = caml_call2(Base_Int63[72], Base_Int63[39], 52),
    mantissa_mask = caml_call2(Base_Int63[42], _O_, _N_),
    mantissa_mask64 = caml_call1(Base_Int63[79], mantissa_mask),
    mantissa_bits = 52;
   function ieee_exponent(t){
    var
     bits = caml_int64_bits_of_float(t),
     _X_ = caml_call2(Base_Int64[62], bits, mantissa_bits);
    return runtime.caml_int64_to_int32
            (caml_call2(Base_Int64[43], _X_, exponent_mask64));
   }
   function ieee_mantissa(t){
    var bits = caml_int64_bits_of_float(t);
    return caml_call1
            (Base_Int63[78], runtime.caml_int64_and(bits, mantissa_mask64));
   }
   function create_ieee_exn(negative, exponent, mantissa){
    if(caml_call2(Base_Int[43], exponent, exponent_mask) !== exponent)
     return caml_call4(Base_Printf[6], _P_, exponent, exponent_mask, 0);
    var _U_ = caml_call2(Base_Int63[67], mantissa, mantissa_mask);
    if(caml_call2(Base_Int63[17], _U_, mantissa)){
     var
      _V_ = caml_call1(Base_Int63[11], mantissa_mask),
      _W_ = caml_call1(Base_Int63[11], mantissa);
     return caml_call4(Base_Printf[6], _Q_, _W_, _V_, 0);
    }
    var
     sign_bits = negative ? Stdlib_Int64[10] : Stdlib_Int64[1],
     expt_bits =
       runtime.caml_int64_shift_left
        (runtime.caml_int64_of_int32(exponent), 52),
     mant_bits = caml_call1(Base_Int63[79], mantissa),
     bits = caml_int64_or(sign_bits, caml_int64_or(expt_bits, mant_bits));
    return runtime.caml_int64_float_of_bits(bits);
   }
   function create_ieee(negative, exponent, mantissa){
    function _T_(param){return create_ieee_exn(negative, exponent, mantissa);}
    return caml_call2(Base_Or_error[28], 0, _T_);
   }
   function to_string$1(x){return caml_call2(Base_Printf[2], _R_, x);}
   function sexp_of_t$2(x){return [0, to_string$1(x)];}
   function of_string$1(x){return of_string(x);}
   var
    include$0 =
      caml_call1(Base_Comparable[13], [0, compare$0, sexp_of_t, zero]),
    sign = include$0[5];
   function is_positive(t){return caml_call2(Base_Import[107][5], t, 0.);}
   function is_non_negative(t){return caml_call2(Base_Import[107][6], t, 0.);}
   function is_negative(t){return caml_call2(Base_Import[107][1], t, 0.);}
   function is_non_positive(t){return caml_call2(Base_Import[107][2], t, 0.);}
   var
    include$1 =
      caml_call1(Base_Pretty_printer[2], [0, module_name, to_string]),
    pp = include$1[1],
    _S_ = Base_Import[107],
    symbol$6 = _S_[3],
    symbol$7 = _S_[1],
    symbol$8 = _S_[5],
    symbol$9 = _S_[4],
    symbol$10 = _S_[2],
    symbol$11 = _S_[6];
   function of_float$0(x){return x;}
   var
    specialized_hash = Base_Import[223],
    Private =
      [0,
       box,
       clamp_unchecked,
       lower_bound_for_int,
       upper_bound_for_int,
       specialized_hash,
       one_ulp_less_than_half,
       int63_round_nearest_portable_a,
       int63_round_nearest_arch64_noa,
       iround_nearest_exn_64],
    include$2 = Base_Import[107],
    symbol$12 = include$2[1],
    symbol$13 = include$2[2],
    symbol$14 = include$2[3],
    symbol$15 = include$2[4],
    symbol$16 = include$2[5],
    symbol$17 = include$2[6],
    ascending = include$2[7],
    descending = include$2[8],
    compare$2 = include$2[9],
    equal = include$2[10];
   function min(x, y){
    if(! caml_call2(symbol$12, x, y) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   function max(x, y){
    if(! caml_call2(symbol$16, x, y) && ! caml_call1(is_nan, x)) return y;
    return x;
   }
   var
    Base_Float =
      [0,
       t_sexp_grammar,
       of_float,
       to_float,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t$1,
       of_string,
       symbol$17,
       symbol$13,
       symbol$15,
       symbol$16,
       symbol$12,
       symbol$14,
       equal,
       compare$2,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator,
       pp,
       hashable,
       is_positive,
       is_non_negative,
       is_negative,
       is_non_positive,
       invariant,
       nan,
       max_value,
       neg_infinity,
       max_value,
       neg_infinity,
       zero,
       one,
       minus_one,
       pi,
       sqrt_pi,
       sqrt_2pi,
       euler,
       epsilon_float,
       max_finite_value,
       min_positive_subnormal_value,
       min_positive_normal_value,
       to_int64_preserve_order,
       to_int64_preserve_order_exn,
       of_int64_preserve_order,
       one_ulp,
       of_int,
       to_int,
       of_int63,
       of_int64,
       to_int64,
       round,
       iround,
       iround_exn,
       round_towards_zero,
       round_down,
       round_up,
       round_nearest,
       round_nearest_half_to_even,
       iround_towards_zero,
       iround_down,
       iround_up,
       iround_nearest_64$0,
       iround_towards_zero_exn,
       iround_down_exn,
       iround_up_exn,
       iround_nearest_exn,
       int63_round_down_exn,
       int63_round_up_exn,
       int63_round_nearest_exn,
       iround_lbound,
       iround_ubound,
       int63_round_lbound,
       int63_round_ubound,
       round_significant,
       round_decimal,
       is_nan,
       is_inf,
       is_finite,
       is_integer,
       min_inan,
       max_inan,
       symbol$1,
       symbol$2,
       symbol$4,
       symbol$0,
       symbol$3,
       symbol,
       symbol$5,
       [0, fractional, integral],
       modf,
       mod_float,
       add,
       sub,
       neg,
       scale,
       abs_float,
       [0,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$4,
        symbol$0,
        symbol,
        symbol$5,
        symbol$11,
        symbol$10,
        symbol$9,
        symbol$8,
        symbol$7,
        symbol$6,
        abs_float,
        neg,
        zero,
        of_int,
        of_float$0],
       [0, symbol$1, symbol$2, symbol$3, symbol$4, symbol$0, symbol, symbol$5],
       to_string,
       to_string_hum,
       to_padded_compact_string,
       to_padded_compact_string_custo,
       int_pow,
       square,
       ldexp,
       frexp,
       [0,
        compare$1,
        all,
        t_of_sexp$0,
        sexp_of_t$0,
        t_sexp_grammar$0,
        of_string$0,
        to_string$0],
       classify,
       sign,
       sign_exn,
       sign_or_nan,
       create_ieee,
       create_ieee_exn,
       ieee_negative,
       ieee_exponent,
       ieee_mantissa,
       [0, t_of_sexp, sexp_of_t$2, t_sexp_grammar, of_string$1, to_string$1],
       Private];
   runtime.caml_register_global(191, Base_Float, "Base__Float");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Fieldslib
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Fieldslib = [0];
   runtime.caml_register_global(0, Base_Fieldslib, "Base__Fieldslib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer_intf
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base_Buffer_intf = [0];
   runtime.caml_register_global(0, Base_Buffer_intf, "Base__Buffer_intf");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Buffer
//# unitInfo: Requires: Base__Blit, Base__Buffer_intf, Base__Bytes, Base__Import, Stdlib__Buffer
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Base_Bytes = global_data.Base__Bytes,
    Base_Import = global_data.Base__Import,
    Base_Blit = global_data.Base__Blit,
    create = Stdlib_Buffer[1],
    contents = Stdlib_Buffer[2],
    to_bytes = Stdlib_Buffer[3],
    nth = Stdlib_Buffer[6],
    length = Stdlib_Buffer[7],
    clear = Stdlib_Buffer[8],
    reset = Stdlib_Buffer[9],
    add_char = Stdlib_Buffer[12],
    add_string = Stdlib_Buffer[16],
    add_bytes = Stdlib_Buffer[17],
    add_buffer = Stdlib_Buffer[21],
    _a_ = Stdlib_Buffer[18],
    _b_ = Stdlib_Buffer[19];
   function add_substring(t, s, pos, len){
    return caml_call4(_a_, t, s, pos, len);
   }
   function add_subbytes(t, s, pos, len){
    return caml_call4(_b_, t, s, pos, len);
   }
   function sexp_of_t(t){
    var _c_ = caml_call1(contents, t);
    return caml_call1(Base_Import[138], _c_);
   }
   function create$0(len){return caml_call1(Base_Bytes[31], len);}
   var length$0 = runtime.caml_ml_bytes_length;
   function unsafe_blit(src, src_pos, dst, dst_pos, len){
    return caml_call5(Stdlib_Buffer[5], src, src_pos, dst, dst_pos, len);
   }
   var
    To_bytes =
      caml_call1
       (caml_call1(Base_Blit[2], [0, length]),
        [0, length$0, create$0, unsafe_blit]),
    blit = To_bytes[1],
    blito = To_bytes[2],
    unsafe_blit$0 = To_bytes[3],
    sub = To_bytes[4],
    subo = To_bytes[5],
    To_string = caml_call1(caml_call1(Base_Blit[3], [0]), To_bytes),
    Base_Buffer =
      [0,
       sexp_of_t,
       create,
       contents,
       to_bytes,
       blit,
       blito,
       unsafe_blit$0,
       sub,
       subo,
       To_string,
       nth,
       length,
       clear,
       reset,
       add_char,
       add_string,
       add_substring,
       add_bytes,
       add_subbytes,
       add_buffer];
   runtime.caml_register_global(4, Base_Buffer, "Base__Buffer");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base__Backtrace
//# unitInfo: Requires: Base__Exn, Base__Int, Base__List, Base__String, Base__Sys0, Stdlib__Printexc
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    elided_message = "<backtrace elided in test>",
    Base_Exn = global_data.Base__Exn,
    Base_Sys0 = global_data.Base__Sys0,
    Base_String = global_data.Base__String,
    Base_List = global_data.Base__List,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Base_Int = global_data.Base__Int,
    elide = [0, 0],
    cst_b = "b",
    cst_OCAMLRUNPARAM = "OCAMLRUNPARAM";
   function get(opt, param){
    if(opt)
     var sth = opt[1], at_most_num_frames = sth;
    else
     var at_most_num_frames = Base_Int[60];
    return runtime.caml_get_current_callstack(at_most_num_frames);
   }
   function to_string(t){
    return elide[1] ? elided_message : caml_call1(Stdlib_Printexc[14], t);
   }
   function to_string_list(t){
    var _i_ = to_string(t);
    return caml_call1(Base_String[88], _i_);
   }
   function sexp_of_t(t){
    function _g_(x){return [0, x];}
    var _h_ = to_string_list(t);
    return [1, caml_call2(Base_List[76], _h_, _g_)];
   }
   var set_recording = Stdlib_Printexc[7], am_recording = Stdlib_Printexc[8];
   function most_recent(param){return caml_call1(Stdlib_Printexc[12], 0);}
   function most_recent_for_exn(exn){
    return caml_call1(Base_Exn[18], exn) ? [0, most_recent(0)] : 0;
   }
   function with_recording(b, f){
    var saved = caml_call1(am_recording, 0);
    caml_call1(set_recording, b);
    function _f_(param){return caml_call1(set_recording, saved);}
    return caml_call2(Base_Exn[13], f, _f_);
   }
   function initialize_module(param){
    var match = caml_call1(Base_Sys0[20], cst_OCAMLRUNPARAM);
    if(match)
     var
      x = match[1],
      _a_ = Base_String[81],
      _b_ = function(_e_){return caml_call2(_a_, _e_, cst_b);},
      _c_ = caml_call2(Base_String[86], x, 44),
      ocamlrunparam_mentions_backtra = caml_call2(Base_List[13], _c_, _b_);
    else
     var ocamlrunparam_mentions_backtra = 0;
    var _d_ = 1 - ocamlrunparam_mentions_backtra;
    return _d_ ? caml_call1(set_recording, 1) : _d_;
   }
   var
    Base_Backtrace =
      [0,
       sexp_of_t,
       get,
       to_string,
       to_string_list,
       elide,
       [0,
        am_recording,
        set_recording,
        with_recording,
        most_recent,
        most_recent_for_exn],
       initialize_module];
   runtime.caml_register_global(9, Base_Backtrace, "Base__Backtrace");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base
//# unitInfo: Requires: Base__Array, Base__Backtrace, Base__Bool, Base__Bytes, Base__Char, Base__Container_intf, Base__Error, Base__Exn, Base__Float, Base__Import, Base__Int, Base__Int32, Base__Int64, Base__List, Base__Nativeint, Base__Option, Base__Ref, Base__Sexp_with_comparable, Base__String, Base__T, Base__Unit, Shadow_stdlib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Base_Ref = global_data.Base__Ref,
    Base_Option = global_data.Base__Option,
    Base_List = global_data.Base__List,
    Base_Array = global_data.Base__Array,
    Shadow_stdlib = global_data.Shadow_stdlib,
    Base_Sexp_with_comparable = global_data.Base__Sexp_with_comparable,
    Base_Import = global_data.Base__Import,
    Base_Bool = global_data.Base__Bool,
    Base_Char = global_data.Base__Char,
    Base_Exn = global_data.Base__Exn,
    Base_Float = global_data.Base__Float,
    Base_Int = global_data.Base__Int,
    Base_Int32 = global_data.Base__Int32,
    Base_Int64 = global_data.Base__Int64,
    Base_Nativeint = global_data.Base__Nativeint,
    Base_String = global_data.Base__String,
    Base_Bytes = global_data.Base__Bytes,
    Base_Unit = global_data.Base__Unit,
    Base_Error = global_data.Base__Error,
    Base_Container_intf = global_data.Base__Container_intf,
    Base_Backtrace = global_data.Base__Backtrace,
    do_at_exit = Shadow_stdlib[91],
    unsafe_really_input = Shadow_stdlib[90],
    valid_float_lexem = Shadow_stdlib[89],
    at_exit = Shadow_stdlib[88],
    exit = Shadow_stdlib[87],
    symbol = Shadow_stdlib[86],
    string_of_format = Shadow_stdlib[85],
    set_binary_mode_in = Shadow_stdlib[84],
    close_in_noerr = Shadow_stdlib[83],
    close_in = Shadow_stdlib[82],
    in_channel_length = Shadow_stdlib[81],
    pos_in = Shadow_stdlib[80],
    seek_in = Shadow_stdlib[79],
    input_value = Shadow_stdlib[78],
    input_binary_int = Shadow_stdlib[77],
    input_byte = Shadow_stdlib[76],
    really_input_string = Shadow_stdlib[75],
    really_input = Shadow_stdlib[74],
    input = Shadow_stdlib[73],
    input_line = Shadow_stdlib[72],
    input_char = Shadow_stdlib[71],
    open_in_gen = Shadow_stdlib[70],
    open_in_bin = Shadow_stdlib[69],
    open_in = Shadow_stdlib[68],
    set_binary_mode_out = Shadow_stdlib[67],
    close_out_noerr = Shadow_stdlib[66],
    close_out = Shadow_stdlib[65],
    out_channel_length = Shadow_stdlib[64],
    pos_out = Shadow_stdlib[63],
    seek_out = Shadow_stdlib[62],
    output_value = Shadow_stdlib[61],
    output_binary_int = Shadow_stdlib[60],
    output_byte = Shadow_stdlib[59],
    output_substring = Shadow_stdlib[58],
    output = Shadow_stdlib[57],
    output_bytes = Shadow_stdlib[56],
    output_string = Shadow_stdlib[55],
    output_char = Shadow_stdlib[54],
    flush_all = Shadow_stdlib[53],
    flush = Shadow_stdlib[52],
    open_out_gen = Shadow_stdlib[51],
    open_out_bin = Shadow_stdlib[50],
    open_out = Shadow_stdlib[49],
    read_float = Shadow_stdlib[48],
    read_float_opt = Shadow_stdlib[47],
    read_int = Shadow_stdlib[46],
    read_int_opt = Shadow_stdlib[45],
    read_line = Shadow_stdlib[44],
    prerr_newline = Shadow_stdlib[43],
    prerr_endline = Shadow_stdlib[42],
    prerr_float = Shadow_stdlib[41],
    prerr_int = Shadow_stdlib[40],
    prerr_bytes = Shadow_stdlib[39],
    prerr_string = Shadow_stdlib[38],
    prerr_char = Shadow_stdlib[37],
    print_newline = Shadow_stdlib[36],
    print_endline = Shadow_stdlib[35],
    print_float = Shadow_stdlib[34],
    print_int = Shadow_stdlib[33],
    print_bytes = Shadow_stdlib[32],
    print_string = Shadow_stdlib[31],
    print_char = Shadow_stdlib[30],
    stderr = Shadow_stdlib[29],
    stdout = Shadow_stdlib[28],
    stdin = Shadow_stdlib[27],
    float_of_string_opt = Shadow_stdlib[25],
    string_of_float = Shadow_stdlib[24],
    int_of_string_opt = Shadow_stdlib[23],
    string_of_int = Shadow_stdlib[22],
    bool_of_string = Shadow_stdlib[21],
    bool_of_string_opt = Shadow_stdlib[20],
    string_of_bool = Shadow_stdlib[19],
    char_of_int = Shadow_stdlib[18],
    epsilon_float = Shadow_stdlib[16],
    min_float = Shadow_stdlib[15],
    max_float = Shadow_stdlib[14],
    nan = Shadow_stdlib[13],
    neg_infinity = Shadow_stdlib[12],
    infinity = Shadow_stdlib[11],
    min_int = Shadow_stdlib[9],
    max_int = Shadow_stdlib[8],
    Not_found = Shadow_stdlib[4],
    Exit = Shadow_stdlib[3],
    hash_fold_t = Base_Sexp_with_comparable[1],
    hash = Base_Sexp_with_comparable[2],
    t_of_sexp = Base_Sexp_with_comparable[3],
    sexp_of_t = Base_Sexp_with_comparable[4],
    Not_found_s = Base_Sexp_with_comparable[5],
    Of_sexp_error = Base_Sexp_with_comparable[6],
    message = Base_Sexp_with_comparable[7],
    default_indent = Base_Sexp_with_comparable[8],
    pp_hum = Base_Sexp_with_comparable[9],
    pp_hum_indent = Base_Sexp_with_comparable[10],
    pp_mach = Base_Sexp_with_comparable[11],
    pp = Base_Sexp_with_comparable[12],
    to_string_hum = Base_Sexp_with_comparable[13],
    to_string_mach = Base_Sexp_with_comparable[14],
    to_string = Base_Sexp_with_comparable[15],
    of_float_style = Base_Sexp_with_comparable[16],
    of_int_style = Base_Sexp_with_comparable[17],
    t_sexp_grammar = Base_Sexp_with_comparable[18],
    invariant = Base_Sexp_with_comparable[19],
    of_string = Base_Sexp_with_comparable[20],
    symbol$0 = Base_Sexp_with_comparable[21],
    symbol$1 = Base_Sexp_with_comparable[22],
    symbol$2 = Base_Sexp_with_comparable[23],
    symbol$3 = Base_Sexp_with_comparable[24],
    symbol$4 = Base_Sexp_with_comparable[25],
    symbol$5 = Base_Sexp_with_comparable[26],
    equal = Base_Sexp_with_comparable[27],
    compare = Base_Sexp_with_comparable[28],
    min = Base_Sexp_with_comparable[29],
    max = Base_Sexp_with_comparable[30],
    ascending = Base_Sexp_with_comparable[31],
    descending = Base_Sexp_with_comparable[32],
    between = Base_Sexp_with_comparable[33],
    clamp_exn = Base_Sexp_with_comparable[34],
    clamp = Base_Sexp_with_comparable[35],
    comparator = Base_Sexp_with_comparable[36],
    Sexp =
      [0,
       hash_fold_t,
       hash,
       t_of_sexp,
       sexp_of_t,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp,
       to_string_hum,
       to_string_mach,
       to_string,
       of_float_style,
       of_int_style,
       t_sexp_grammar,
       invariant,
       of_string,
       symbol$0,
       symbol$1,
       symbol$2,
       symbol$3,
       symbol$4,
       symbol$5,
       equal,
       compare,
       min,
       max,
       ascending,
       descending,
       between,
       clamp_exn,
       clamp,
       comparator],
    am_testing = Base_Import[131],
    Exported_for_specific_uses = [0, am_testing],
    compare_array = Base_Array[1],
    equal_array = Base_Array[100],
    array_of_sexp = Base_Array[2],
    sexp_of_array = Base_Array[3];
   function array_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Array[4], a_sexp_grammar);
   }
   var
    compare_bool = Base_Bool[16],
    equal_bool = Base_Bool[15],
    hash_fold_bool = Base_Bool[3],
    func = Base_Bool[4];
   function hash_bool(x){return caml_call1(func, x);}
   var
    bool_of_sexp = Base_Bool[5],
    sexp_of_bool = Base_Bool[6],
    bool_sexp_grammar = Base_Bool[2],
    compare_char = Base_Char[16],
    equal_char = Base_Char[15],
    hash_fold_char = Base_Char[3],
    func$0 = Base_Char[4];
   function hash_char(x){return caml_call1(func$0, x);}
   var
    char_of_sexp = Base_Char[5],
    sexp_of_char = Base_Char[6],
    char_sexp_grammar = Base_Char[2],
    sexp_of_exn = Base_Exn[1],
    compare_float = Base_Float[16],
    equal_float = Base_Float[15],
    hash_fold_float = Base_Float[4],
    func$1 = Base_Float[5];
   function hash_float(x){return caml_call1(func$1, x);}
   var
    float_of_sexp = Base_Float[6],
    sexp_of_float = Base_Float[7],
    float_sexp_grammar = Base_Float[1],
    compare_int = Base_Int[13],
    equal_int = Base_Int[12],
    hash_fold_int = Base_Int[6],
    func$2 = Base_Int[7];
   function hash_int(x){return caml_call1(func$2, x);}
   var
    int_of_sexp = Base_Int[8],
    sexp_of_int = Base_Int[9],
    int_sexp_grammar = Base_Int[1],
    compare_int32 = Base_Int32[19],
    equal_int32 = Base_Int32[18],
    hash_fold_int32 = Base_Int32[6],
    func$3 = Base_Int32[7];
   function hash_int32(x){return caml_call1(func$3, x);}
   var
    int32_of_sexp = Base_Int32[8],
    sexp_of_int32 = Base_Int32[9],
    int32_sexp_grammar = Base_Int32[1],
    compare_int64 = Base_Int64[13],
    equal_int64 = Base_Int64[12],
    hash_fold_int64 = Base_Int64[6],
    func$4 = Base_Int64[7];
   function hash_int64(x){return caml_call1(func$4, x);}
   var
    int64_of_sexp = Base_Int64[8],
    sexp_of_int64 = Base_Int64[9],
    int64_sexp_grammar = Base_Int64[1],
    compare_list = Base_List[1],
    equal_list = Base_List[147],
    hash_fold_list = Base_List[2],
    list_of_sexp = Base_List[3],
    sexp_of_list = Base_List[4];
   function list_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_List[5], a_sexp_grammar);
   }
   var
    compare_nativeint = Base_Nativeint[19],
    equal_nativeint = Base_Nativeint[18],
    hash_fold_nativeint = Base_Nativeint[6],
    func$5 = Base_Nativeint[7];
   function hash_nativeint(x){return caml_call1(func$5, x);}
   var
    nativeint_of_sexp = Base_Nativeint[8],
    sexp_of_nativeint = Base_Nativeint[9],
    nativeint_sexp_grammar = Base_Nativeint[1],
    compare_option = Base_Option[1],
    equal_option = Base_Option[4],
    hash_fold_option = Base_Option[2],
    option_of_sexp = Base_Option[6],
    sexp_of_option = Base_Option[7];
   function option_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Option[3], a_sexp_grammar);
   }
   var
    compare_ref = Base_Ref[1],
    equal_ref = Base_Ref[2],
    ref_of_sexp = Base_Ref[3],
    sexp_of_ref = Base_Ref[4];
   function ref_sexp_grammar(a_sexp_grammar){
    return caml_call1(Base_Ref[5], a_sexp_grammar);
   }
   var
    compare_string = Base_String[37],
    equal_string = Base_String[121],
    hash_fold_string = Base_String[26];
   function hash_string(x){return runtime.Base_hash_string(x);}
   var
    string_of_sexp = Base_String[27],
    sexp_of_string = Base_String[28],
    string_sexp_grammar = Base_String[1],
    compare_bytes = Base_Bytes[16],
    equal_bytes = Base_Bytes[15],
    bytes_of_sexp = Base_Bytes[1],
    sexp_of_bytes = Base_Bytes[2],
    bytes_sexp_grammar = Base_Bytes[3],
    compare_unit = Base_Unit[16],
    equal_unit = Base_Unit[15],
    hash_fold_unit = Base_Unit[3],
    func$6 = Base_Unit[4];
   function hash_unit(x){return caml_call1(func$6, x);}
   var
    unit_of_sexp = Base_Unit[5],
    sexp_of_unit = Base_Unit[6],
    unit_sexp_grammar = Base_Unit[2],
    symbol$6 = Base_List[148][1],
    _a_ = Base_Int[70],
    symbol$7 = _a_[1],
    lnot = _a_[2],
    abs = _a_[3],
    zero = _a_[4],
    symbol$8 = _a_[5],
    symbol$9 = _a_[6],
    symbol$10 = _a_[7],
    _b_ = Base_Import[96],
    ascending$0 = _b_[1],
    descending$0 = _b_[2],
    max$0 = _b_[3],
    min$0 = _b_[4],
    include = Base_Float[104],
    symbol$11 = include[1],
    symbol$12 = include[2],
    symbol$13 = include[3],
    symbol$14 = include[4],
    symbol$15 = include[5],
    symbol$16 = include[6],
    symbol$17 = include[7],
    symbol$18 = Base_String[53],
    fst = Base_Import[124],
    snd = Base_Import[126],
    failwith = Base_Import[123],
    invalid_arg = Base_Import[125],
    raise_s = Base_Error[30],
    phys_equal = Base_Import[127],
    Export =
      [0,
       compare_array,
       equal_array,
       array_of_sexp,
       sexp_of_array,
       array_sexp_grammar,
       compare_bool,
       equal_bool,
       hash_fold_bool,
       hash_bool,
       bool_of_sexp,
       sexp_of_bool,
       bool_sexp_grammar,
       compare_char,
       equal_char,
       hash_fold_char,
       hash_char,
       char_of_sexp,
       sexp_of_char,
       char_sexp_grammar,
       sexp_of_exn,
       compare_float,
       equal_float,
       hash_fold_float,
       hash_float,
       float_of_sexp,
       sexp_of_float,
       float_sexp_grammar,
       compare_int,
       equal_int,
       hash_fold_int,
       hash_int,
       int_of_sexp,
       sexp_of_int,
       int_sexp_grammar,
       compare_int32,
       equal_int32,
       hash_fold_int32,
       hash_int32,
       int32_of_sexp,
       sexp_of_int32,
       int32_sexp_grammar,
       compare_int64,
       equal_int64,
       hash_fold_int64,
       hash_int64,
       int64_of_sexp,
       sexp_of_int64,
       int64_sexp_grammar,
       compare_list,
       equal_list,
       hash_fold_list,
       list_of_sexp,
       sexp_of_list,
       list_sexp_grammar,
       compare_nativeint,
       equal_nativeint,
       hash_fold_nativeint,
       hash_nativeint,
       nativeint_of_sexp,
       sexp_of_nativeint,
       nativeint_sexp_grammar,
       compare_option,
       equal_option,
       hash_fold_option,
       option_of_sexp,
       sexp_of_option,
       option_sexp_grammar,
       compare_ref,
       equal_ref,
       ref_of_sexp,
       sexp_of_ref,
       ref_sexp_grammar,
       compare_string,
       equal_string,
       hash_fold_string,
       hash_string,
       string_of_sexp,
       sexp_of_string,
       string_sexp_grammar,
       compare_bytes,
       equal_bytes,
       bytes_of_sexp,
       sexp_of_bytes,
       bytes_sexp_grammar,
       compare_unit,
       equal_unit,
       hash_fold_unit,
       hash_unit,
       unit_of_sexp,
       sexp_of_unit,
       unit_sexp_grammar,
       symbol$6,
       symbol$7,
       lnot,
       abs,
       zero,
       symbol$8,
       symbol$9,
       symbol$10,
       ascending$0,
       descending$0,
       max$0,
       min$0,
       symbol$11,
       symbol$12,
       symbol$13,
       symbol$14,
       symbol$15,
       symbol$16,
       symbol$17,
       symbol$18,
       fst,
       snd,
       failwith,
       invalid_arg,
       raise_s,
       phys_equal],
    compare_array$0 = Export[1],
    equal_array$0 = Export[2],
    array_of_sexp$0 = Export[3],
    sexp_of_array$0 = Export[4],
    array_sexp_grammar$0 = Export[5],
    compare_bool$0 = Export[6],
    equal_bool$0 = Export[7],
    hash_fold_bool$0 = Export[8],
    hash_bool$0 = Export[9],
    bool_of_sexp$0 = Export[10],
    sexp_of_bool$0 = Export[11],
    bool_sexp_grammar$0 = Export[12],
    compare_char$0 = Export[13],
    equal_char$0 = Export[14],
    hash_fold_char$0 = Export[15],
    hash_char$0 = Export[16],
    char_of_sexp$0 = Export[17],
    sexp_of_char$0 = Export[18],
    char_sexp_grammar$0 = Export[19],
    sexp_of_exn$0 = Export[20],
    compare_float$0 = Export[21],
    equal_float$0 = Export[22],
    hash_fold_float$0 = Export[23],
    hash_float$0 = Export[24],
    float_of_sexp$0 = Export[25],
    sexp_of_float$0 = Export[26],
    float_sexp_grammar$0 = Export[27],
    compare_int$0 = Export[28],
    equal_int$0 = Export[29],
    hash_fold_int$0 = Export[30],
    hash_int$0 = Export[31],
    int_of_sexp$0 = Export[32],
    sexp_of_int$0 = Export[33],
    int_sexp_grammar$0 = Export[34],
    compare_int32$0 = Export[35],
    equal_int32$0 = Export[36],
    hash_fold_int32$0 = Export[37],
    hash_int32$0 = Export[38],
    int32_of_sexp$0 = Export[39],
    sexp_of_int32$0 = Export[40],
    int32_sexp_grammar$0 = Export[41],
    compare_int64$0 = Export[42],
    equal_int64$0 = Export[43],
    hash_fold_int64$0 = Export[44],
    hash_int64$0 = Export[45],
    int64_of_sexp$0 = Export[46],
    sexp_of_int64$0 = Export[47],
    int64_sexp_grammar$0 = Export[48],
    compare_list$0 = Export[49],
    equal_list$0 = Export[50],
    hash_fold_list$0 = Export[51],
    list_of_sexp$0 = Export[52],
    sexp_of_list$0 = Export[53],
    list_sexp_grammar$0 = Export[54],
    compare_nativeint$0 = Export[55],
    equal_nativeint$0 = Export[56],
    hash_fold_nativeint$0 = Export[57],
    hash_nativeint$0 = Export[58],
    nativeint_of_sexp$0 = Export[59],
    sexp_of_nativeint$0 = Export[60],
    nativeint_sexp_grammar$0 = Export[61],
    compare_option$0 = Export[62],
    equal_option$0 = Export[63],
    hash_fold_option$0 = Export[64],
    option_of_sexp$0 = Export[65],
    sexp_of_option$0 = Export[66],
    option_sexp_grammar$0 = Export[67],
    compare_ref$0 = Export[68],
    equal_ref$0 = Export[69],
    ref_of_sexp$0 = Export[70],
    sexp_of_ref$0 = Export[71],
    ref_sexp_grammar$0 = Export[72],
    compare_string$0 = Export[73],
    equal_string$0 = Export[74],
    hash_fold_string$0 = Export[75],
    hash_string$0 = Export[76],
    string_of_sexp$0 = Export[77],
    sexp_of_string$0 = Export[78],
    string_sexp_grammar$0 = Export[79],
    compare_bytes$0 = Export[80],
    equal_bytes$0 = Export[81],
    bytes_of_sexp$0 = Export[82],
    sexp_of_bytes$0 = Export[83],
    bytes_sexp_grammar$0 = Export[84],
    compare_unit$0 = Export[85],
    equal_unit$0 = Export[86],
    hash_fold_unit$0 = Export[87],
    hash_unit$0 = Export[88],
    unit_of_sexp$0 = Export[89],
    sexp_of_unit$0 = Export[90],
    unit_sexp_grammar$0 = Export[91],
    symbol$19 = Export[92],
    symbol$20 = Export[93],
    lnot$0 = Export[94],
    abs$0 = Export[95],
    zero$0 = Export[96],
    symbol$21 = Export[97],
    symbol$22 = Export[98],
    symbol$23 = Export[99],
    ascending$1 = Export[100],
    descending$1 = Export[101],
    max$1 = Export[102],
    min$1 = Export[103],
    symbol$24 = Export[104],
    symbol$25 = Export[105],
    symbol$26 = Export[106],
    symbol$27 = Export[107],
    symbol$28 = Export[108],
    symbol$29 = Export[109],
    symbol$30 = Export[110],
    symbol$31 = Export[111],
    fst$0 = Export[112],
    snd$0 = Export[113],
    failwith$0 = Export[114],
    invalid_arg$0 = Export[115],
    raise_s$0 = Export[116],
    phys_equal$0 = Export[117],
    include$0 = Base_Container_intf[1],
    Continue_or_stop = include$0[1],
    Not_found_s$0 = Base_Import[251];
   caml_call1(Base_Backtrace[7], 0);
   var
    Base =
      [0,
       Exit,
       Not_found,
       max_int,
       min_int,
       infinity,
       neg_infinity,
       nan,
       max_float,
       min_float,
       epsilon_float,
       char_of_int,
       string_of_bool,
       bool_of_string_opt,
       bool_of_string,
       string_of_int,
       int_of_string_opt,
       string_of_float,
       float_of_string_opt,
       stdin,
       stdout,
       stderr,
       print_char,
       print_string,
       print_bytes,
       print_int,
       print_float,
       print_endline,
       print_newline,
       prerr_char,
       prerr_string,
       prerr_bytes,
       prerr_int,
       prerr_float,
       prerr_endline,
       prerr_newline,
       read_line,
       read_int_opt,
       read_int,
       read_float_opt,
       read_float,
       open_out,
       open_out_bin,
       open_out_gen,
       flush,
       flush_all,
       output_char,
       output_string,
       output_bytes,
       output,
       output_substring,
       output_byte,
       output_binary_int,
       output_value,
       seek_out,
       pos_out,
       out_channel_length,
       close_out,
       close_out_noerr,
       set_binary_mode_out,
       open_in,
       open_in_bin,
       open_in_gen,
       input_char,
       input_line,
       input,
       really_input,
       really_input_string,
       input_byte,
       input_binary_int,
       input_value,
       seek_in,
       pos_in,
       in_channel_length,
       close_in,
       close_in_noerr,
       set_binary_mode_in,
       string_of_format,
       symbol,
       exit,
       at_exit,
       valid_float_lexem,
       unsafe_really_input,
       do_at_exit,
       Sexp,
       Exported_for_specific_uses,
       Export,
       compare_array$0,
       equal_array$0,
       array_of_sexp$0,
       sexp_of_array$0,
       array_sexp_grammar$0,
       compare_bool$0,
       equal_bool$0,
       hash_fold_bool$0,
       hash_bool$0,
       bool_of_sexp$0,
       sexp_of_bool$0,
       bool_sexp_grammar$0,
       compare_char$0,
       equal_char$0,
       hash_fold_char$0,
       hash_char$0,
       char_of_sexp$0,
       sexp_of_char$0,
       char_sexp_grammar$0,
       sexp_of_exn$0,
       compare_float$0,
       equal_float$0,
       hash_fold_float$0,
       hash_float$0,
       float_of_sexp$0,
       sexp_of_float$0,
       float_sexp_grammar$0,
       compare_int$0,
       equal_int$0,
       hash_fold_int$0,
       hash_int$0,
       int_of_sexp$0,
       sexp_of_int$0,
       int_sexp_grammar$0,
       compare_int32$0,
       equal_int32$0,
       hash_fold_int32$0,
       hash_int32$0,
       int32_of_sexp$0,
       sexp_of_int32$0,
       int32_sexp_grammar$0,
       compare_int64$0,
       equal_int64$0,
       hash_fold_int64$0,
       hash_int64$0,
       int64_of_sexp$0,
       sexp_of_int64$0,
       int64_sexp_grammar$0,
       compare_list$0,
       equal_list$0,
       hash_fold_list$0,
       list_of_sexp$0,
       sexp_of_list$0,
       list_sexp_grammar$0,
       compare_nativeint$0,
       equal_nativeint$0,
       hash_fold_nativeint$0,
       hash_nativeint$0,
       nativeint_of_sexp$0,
       sexp_of_nativeint$0,
       nativeint_sexp_grammar$0,
       compare_option$0,
       equal_option$0,
       hash_fold_option$0,
       option_of_sexp$0,
       sexp_of_option$0,
       option_sexp_grammar$0,
       compare_ref$0,
       equal_ref$0,
       ref_of_sexp$0,
       sexp_of_ref$0,
       ref_sexp_grammar$0,
       compare_string$0,
       equal_string$0,
       hash_fold_string$0,
       hash_string$0,
       string_of_sexp$0,
       sexp_of_string$0,
       string_sexp_grammar$0,
       compare_bytes$0,
       equal_bytes$0,
       bytes_of_sexp$0,
       sexp_of_bytes$0,
       bytes_sexp_grammar$0,
       compare_unit$0,
       equal_unit$0,
       hash_fold_unit$0,
       hash_unit$0,
       unit_of_sexp$0,
       sexp_of_unit$0,
       unit_sexp_grammar$0,
       symbol$19,
       symbol$20,
       lnot$0,
       abs$0,
       zero$0,
       symbol$21,
       symbol$22,
       symbol$23,
       ascending$1,
       descending$1,
       max$1,
       min$1,
       symbol$24,
       symbol$25,
       symbol$26,
       symbol$27,
       symbol$28,
       symbol$29,
       symbol$30,
       symbol$31,
       fst$0,
       snd$0,
       failwith$0,
       invalid_arg$0,
       raise_s$0,
       phys_equal$0,
       Continue_or_stop,
       Not_found_s$0];
   runtime.caml_register_global(21, Base, "Base");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJkZXNjZW5kaW5nIiwieCIsInkiLCJtYXgiLCJtaW4iLCJkb19hdF9leGl0IiwidW5zYWZlX3JlYWxseV9pbnB1dCIsInZhbGlkX2Zsb2F0X2xleGVtIiwiYXRfZXhpdCIsImV4aXQiLCJzeW1ib2wiLCJzdHJpbmdfb2ZfZm9ybWF0Iiwic2V0X2JpbmFyeV9tb2RlX2luIiwiY2xvc2VfaW5fbm9lcnIiLCJjbG9zZV9pbiIsImluX2NoYW5uZWxfbGVuZ3RoIiwicG9zX2luIiwic2Vla19pbiIsImlucHV0X3ZhbHVlIiwiaW5wdXRfYmluYXJ5X2ludCIsImlucHV0X2J5dGUiLCJyZWFsbHlfaW5wdXRfc3RyaW5nIiwicmVhbGx5X2lucHV0IiwiaW5wdXQiLCJpbnB1dF9saW5lIiwiaW5wdXRfY2hhciIsIm9wZW5faW5fZ2VuIiwib3Blbl9pbl9iaW4iLCJvcGVuX2luIiwic2V0X2JpbmFyeV9tb2RlX291dCIsImNsb3NlX291dF9ub2VyciIsImNsb3NlX291dCIsIm91dF9jaGFubmVsX2xlbmd0aCIsInBvc19vdXQiLCJzZWVrX291dCIsIm91dHB1dF92YWx1ZSIsIm91dHB1dF9iaW5hcnlfaW50Iiwib3V0cHV0X2J5dGUiLCJvdXRwdXRfc3Vic3RyaW5nIiwib3V0cHV0Iiwib3V0cHV0X2J5dGVzIiwib3V0cHV0X3N0cmluZyIsIm91dHB1dF9jaGFyIiwiZmx1c2hfYWxsIiwiZmx1c2giLCJvcGVuX291dF9nZW4iLCJvcGVuX291dF9iaW4iLCJvcGVuX291dCIsInJlYWRfZmxvYXQiLCJyZWFkX2Zsb2F0X29wdCIsInJlYWRfaW50IiwicmVhZF9pbnRfb3B0IiwicmVhZF9saW5lIiwicHJlcnJfbmV3bGluZSIsInByZXJyX2VuZGxpbmUiLCJwcmVycl9mbG9hdCIsInByZXJyX2ludCIsInByZXJyX2J5dGVzIiwicHJlcnJfc3RyaW5nIiwicHJlcnJfY2hhciIsInByaW50X25ld2xpbmUiLCJwcmludF9lbmRsaW5lIiwicHJpbnRfZmxvYXQiLCJwcmludF9pbnQiLCJwcmludF9ieXRlcyIsInByaW50X3N0cmluZyIsInByaW50X2NoYXIiLCJzdGRlcnIiLCJzdGRvdXQiLCJzdGRpbiIsImZsb2F0X29mX3N0cmluZ19vcHQiLCJzdHJpbmdfb2ZfZmxvYXQiLCJpbnRfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9pbnQiLCJib29sX29mX3N0cmluZyIsImJvb2xfb2Zfc3RyaW5nX29wdCIsInN0cmluZ19vZl9ib29sIiwiY2hhcl9vZl9pbnQiLCJlcHNpbG9uX2Zsb2F0IiwibWluX2Zsb2F0IiwibWF4X2Zsb2F0IiwibmFuIiwibmVnX2luZmluaXR5IiwiaW5maW5pdHkiLCJtaW5faW50IiwibWF4X2ludCIsImJvb2xfdG9faW50Iiwic3ltYm9sJDMiLCJzeW1ib2wkNCIsInN5bWJvbCQ1Iiwic3ltYm9sJDYiLCJzeW1ib2wkNyIsInN5bWJvbCQ4Iiwic3ltYm9sJDkiLCJzeW1ib2wkMTAiLCJzeW1ib2wkMTEiLCJzeW1ib2wkMTIiLCJhc2NlbmRpbmciLCJtYXgkMCIsIm1pbiQwIiwiYXNjZW5kaW5nJDAiLCJkZXNjZW5kaW5nJDAiLCJtYXgkMSIsIm1pbiQxIiwic3ltYm9sJDEzIiwic3ltYm9sJDE0Iiwic3ltYm9sJDE1Iiwic3ltYm9sJDE2Iiwic3ltYm9sJDE3Iiwic3ltYm9sJDE4IiwiYXNjZW5kaW5nJDEiLCJkZXNjZW5kaW5nJDEiLCJjb21wYXJlIiwiZXF1YWwiLCJtYXgkMiIsIm1pbiQyIiwiYXNjZW5kaW5nJDIiLCJkZXNjZW5kaW5nJDIiLCJtYXgkMyIsIm1pbiQzIiwic3ltYm9sJDE5Iiwic3ltYm9sJDIwIiwic3ltYm9sJDIxIiwic3ltYm9sJDIyIiwic3ltYm9sJDIzIiwic3ltYm9sJDI0IiwiYXNjZW5kaW5nJDMiLCJkZXNjZW5kaW5nJDMiLCJjb21wYXJlJDAiLCJlcXVhbCQwIiwibWF4JDQiLCJtaW4kNCIsInN5bWJvbCQyNSIsInN5bWJvbCQyNiIsInN5bWJvbCQyNyIsInN5bWJvbCQyOCIsInN5bWJvbCQyOSIsInN5bWJvbCQzMCIsImFzY2VuZGluZyQ0IiwiZGVzY2VuZGluZyQ0IiwiY29tcGFyZSQxIiwiZXF1YWwkMSIsIm1heCQ1IiwibWluJDUiLCJzeW1ib2wkMzEiLCJzeW1ib2wkMzIiLCJzeW1ib2wkMzMiLCJzeW1ib2wkMzQiLCJzeW1ib2wkMzUiLCJzeW1ib2wkMzYiLCJhc2NlbmRpbmckNSIsImRlc2NlbmRpbmckNSIsImNvbXBhcmUkMiIsImVxdWFsJDIiLCJtYXgkNiIsIm1pbiQ2IiwiaSIsInN5bWJvbCQzNyIsInN5bWJvbCQzOCIsInN5bWJvbCQzOSIsInN5bWJvbCQ0MCIsInN5bWJvbCQ0MSIsInN5bWJvbCQ0MiIsImFzY2VuZGluZyQ2IiwiZGVzY2VuZGluZyQ2IiwiY29tcGFyZSQzIiwiZXF1YWwkMyIsIm1heCQ3IiwibWluJDciLCJzeW1ib2wkNDMiLCJzeW1ib2wkNDQiLCJzeW1ib2wkNDUiLCJzeW1ib2wkNDYiLCJzeW1ib2wkNDciLCJzeW1ib2wkNDgiLCJhc2NlbmRpbmckNyIsImRlc2NlbmRpbmckNyIsImNvbXBhcmUkNCIsImVxdWFsJDQiLCJtYXgkOCIsIm1pbiQ4Iiwic3ltYm9sJDQ5Iiwic3ltYm9sJDUwIiwic3ltYm9sJDUxIiwic3ltYm9sJDUyIiwic3ltYm9sJDUzIiwic3ltYm9sJDU0IiwiYXNjZW5kaW5nJDgiLCJkZXNjZW5kaW5nJDgiLCJjb21wYXJlJDUiLCJlcXVhbCQ1IiwibWF4JDkiLCJtaW4kOSIsInN5bWJvbCQ1NSIsInN5bWJvbCQ1NiIsInN5bWJvbCQ1NyIsInN5bWJvbCQ1OCIsInN5bWJvbCQ1OSIsInN5bWJvbCQ2MCIsImFzY2VuZGluZyQ5IiwiZGVzY2VuZGluZyQ5IiwiY29tcGFyZSQ2IiwiZXF1YWwkNiIsIm1heCQxMCIsIm1pbiQxMCIsInN5bWJvbCQ2MSIsInN5bWJvbCQ2MiIsInN5bWJvbCQ2MyIsInN5bWJvbCQ2NCIsImFzciIsImxhbmQiLCJsbm90JDAiLCJsb3IiLCJsc2wiLCJsc3IiLCJseG9yIiwibW9kIiwiYWJzJDAiLCJmYWlsd2l0aCQwIiwiZnN0IiwiaW52YWxpZF9hcmckMCIsInNuZCIsInBoeXNfZXF1YWwiLCJkZWNyIiwiaW5jciIsImZsb2F0X29mX3N0cmluZyIsImFtX3Rlc3RpbmciLCJmYWlsd2l0aGYiLCJmbXQiLCJzIiwiaW52YWxpZF9hcmdmIiwiYmFja2VuZF90eXBlIiwiaW50ZXJhY3RpdmUiLCJvc190eXBlIiwidW5peCIsIndpbjMyIiwiY3lnd2luIiwid29yZF9zaXplX2luX2JpdHMiLCJpbnRfc2l6ZV9pbl9iaXRzIiwiYmlnX2VuZGlhbiIsIm1heF9zdHJpbmdfbGVuZ3RoIiwibWF4X2FycmF5X2xlbmd0aCIsInJ1bnRpbWVfdmFyaWFudCIsInJ1bnRpbWVfcGFyYW1ldGVycyIsImFyZ3YiLCJnZXRfYXJndiIsIm9jYW1sX3ZlcnNpb24iLCJlbmFibGVfcnVudGltZV93YXJuaW5ncyIsInJ1bnRpbWVfd2FybmluZ3NfZW5hYmxlZCIsImdldGVudl9leG4iLCJ2YXIkMCIsImdldGVudiIsIm1heF9sZW5ndGgiLCJjcmVhdGUiLCJsZW4iLCJjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCIsImFwcGVuZCIsImJsaXQiLCJjb25jYXQiLCJjb3B5IiwiZmlsbCIsImluaXQiLCJtYWtlX21hdHJpeCIsIm9mX2xpc3QiLCJzdWIiLCJ0b19saXN0IiwiZm9sZCIsInQiLCJmIiwiZm9sZF9yaWdodCIsIml0ZXIiLCJpdGVyaSIsIm1hcCIsIm1hcGkiLCJzdGFibGVfc29ydCIsInN3YXAiLCJqIiwiZWx0X2kiLCJlbHRfaiIsImVzY2FwZWQiLCJsb3dlcmNhc2UiLCJ0b19pbnQiLCJ1bnNhZmVfb2ZfaW50IiwidXBwZXJjYXNlIiwiaW50X2lzX29rIiwibWluX3ZhbHVlIiwibWF4X3ZhbHVlIiwib2ZfaW50Iiwib2ZfaW50X2V4biIsInQxIiwidDIiLCJ0b19zdHJpbmciLCJvZl9zdHJpbmciLCJ0b19mbG9hdCIsIm9mX2Zsb2F0Iiwic3VjYyIsImhkX2V4biIsImxlbmd0aCIsInJldl9hcHBlbmQiLCJ0bF9leG4iLCJ1bnppcCIsImV4aXN0cyIsImV4aXN0czJfb2siLCJsMSIsImwyIiwiZm9sZDJfb2siLCJmb3JfYWxsIiwiZm9yX2FsbDJfb2siLCJpdGVyMl9vayIsIm5vbnRhaWxfbWFwIiwibm9udGFpbF9tYXBpIiwicGFydGl0aW9uIiwicmV2X21hcCIsInJldl9tYXAyX29rIiwic29ydCIsImwiLCJyZXYiLCJyZXMiLCJyZXN0IiwiYSIsImIiLCJoYXNoX2ZvbGRfdW5pdCIsImhhc2hfZm9sZF9pbnQiLCJoYXNoX2ZvbGRfaW50NjQiLCJoYXNoX2ZvbGRfZmxvYXQiLCJoYXNoX2ZvbGRfc3RyaW5nIiwiYXNfaW50IiwiaGFzaF9mb2xkX2ludDMyIiwiaGFzaF9mb2xkX2NoYXIiLCJoYXNoX2ZvbGRfYm9vbCIsImhhc2hfZm9sZF9uYXRpdmVpbnQiLCJoYXNoX2ZvbGRfb3B0aW9uIiwiaGFzaF9mb2xkX2VsZW0iLCJoYXNoX2ZvbGRfbGlzdCIsInMkMSIsImxpc3QkMSIsInMkMiIsImxpc3QiLCJsaXN0JDAiLCJzJDAiLCJoYXNoX2ZvbGRfbGF6eV90IiwiaGFzaF9mb2xkX3JlZl9mcm96ZW4iLCJoYXNoX2ZvbGRfYXJyYXlfZnJvemVuIiwiYXJyYXkiLCJlIiwiaSQwIiwiaGFzaF9uYXRpdmVpbnQiLCJoYXNoX2ludDY0IiwiaGFzaF9pbnQzMiIsImhhc2hfY2hhciIsImhhc2hfaW50IiwiaGFzaF9ib29sIiwiaGFzaF9zdHJpbmciLCJoYXNoX2Zsb2F0IiwiaGFzaF91bml0Iiwic2VlZCIsIm9mX2ZvbGQiLCJoYXNoX2ZvbGRfdCIsInJ1biIsImZvbGRlciIsIm9wdCIsInN0aCIsImNvbXBhcmVfc3RhdGUiLCJzdGF0ZV90b19zdHJpbmciLCJzdGF0ZSIsInQkMCIsInQkMSIsInQkMiIsInQkMyIsInQkNCIsInQkNSIsImNvbXBhcmVfYWJzdHJhY3QiLCJ0eXBlX25hbWUiLCJlcXVhbF9hYnN0cmFjdCIsImNvbXBhcmVfYm9vbCIsImNvbXBhcmVfY2hhciIsImNvbXBhcmVfZmxvYXQiLCJjb21wYXJlX2ludCIsImNvbXBhcmVfaW50MzIiLCJjb21wYXJlX2ludDY0IiwiY29tcGFyZV9uYXRpdmVpbnQiLCJjb21wYXJlX3N0cmluZyIsImNvbXBhcmVfdW5pdCIsImNvbXBhcmVfYXJyYXkiLCJjb21wYXJlX2VsdCIsImxlbl9hIiwibGVuX2IiLCJyZXQiLCJyIiwiY29tcGFyZV9saXN0IiwiYSQwIiwiYiQwIiwieXMiLCJ4cyIsImNvbXBhcmVfb3B0aW9uIiwiY29tcGFyZV9yZWYiLCJlcXVhbF9ib29sIiwiZXF1YWxfY2hhciIsImVxdWFsX2ludCIsImVxdWFsX2ludDMyIiwiZXF1YWxfaW50NjQiLCJlcXVhbF9uYXRpdmVpbnQiLCJlcXVhbF9zdHJpbmciLCJlcXVhbF91bml0IiwiZXF1YWxfZmxvYXQiLCJlcXVhbF9hcnJheSIsImVxdWFsX2VsdCIsImVxdWFsX2xpc3QiLCJlcXVhbF9vcHRpb24iLCJlcXVhbF9yZWYiLCJhXzAwMSIsImJfMDAyIiwiYV8wMDMiLCJiXzAwNCIsImFfMDA1IiwiYl8wMDYiLCJoYXNoIiwiaHN2IiwiYXJnIiwiYTAiLCJoc3YkMCIsImEwJDAiLCJoc3YkMSIsInRfc2V4cF9ncmFtbWFyIiwiaW52YXJpYW50Iiwic2V4cF9vZl90IiwibnVtX2JpdHMiLCJ3b3JkX3NpemUiLCJhbGwiLCJyZWdpc3RlciIsInAiLCJwcCIsIm1vZHVsZV9uYW1lIiwiZm9ybWF0dGVyIiwiYXJnMV8wMDIiLCJhcmcwXzAwMSIsInJlczBfMDAzIiwicmVzMV8wMDQiLCJhcmcxXzAwNiIsImFyZzBfMDA1IiwicmVzMF8wMDciLCJyZXMxXzAwOCIsImNyZWF0ZV9zIiwic2V4cCIsInJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIiwiYmFja3RyYWNlIiwicmVyYWlzZSIsImV4biIsInN0ciIsImV4biQwIiwiYnQiLCJyZXJhaXNlZiIsImV4YyIsImZvcm1hdCIsInRvX3N0cmluZ19tYWNoIiwic2V4cF9vZl90JDAiLCJwcm90ZWN0eCIsImZpbmFsbHkkMCIsImZpbmFsX2V4biQwIiwiZmluYWxfZXhuIiwicHJvdGVjdCIsImRvZXNfcmFpc2UiLCJwcGYiLCJwcmludF93aXRoX2JhY2t0cmFjZSIsInJhd19iYWNrdHJhY2UiLCJoYW5kbGVfdW5jYXVnaHRfYXV4IiwiZXhjJDAiLCJoYW5kbGVfdW5jYXVnaHRfYW5kX2V4aXQiLCJoYW5kbGVfdW5jYXVnaHQiLCJtdXN0X2V4aXQiLCJleGl0JDAiLCJyZXJhaXNlX3VuY2F1Z2h0IiwiZnVuYyIsInJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIiwiaW5pdGlhbGl6ZV9tb2R1bGUiLCJjbGVhcl9iYWNrdHJhY2UiLCJ3aXRoX3JldHVybiIsImlzX2FsaXZlIiwicmV0dXJuJDAiLCJ3aXRoX3JldHVybl9vcHRpb24iLCJwcmVwZW5kIiwicGFyYW0iLCJzeW1ib2xfYmluZCIsInN5bWJvbF9tYXAiLCJiaW5kIiwiam9pbiIsImlnbm9yZV9tIiwiYWxsX3VuaXQiLCJtYXBfdmlhX2JpbmQiLCJtYSIsInN5bWJvbF9iaW5kJDAiLCJzeW1ib2xfbWFwJDAiLCJzeW1ib2xfYmluZCQxIiwic3ltYm9sX21hcCQxIiwiYm90aCIsImxvb3AiLCJ2cyIsInRzIiwidiIsImJpbmQkMCIsInJldHVybiQxIiwibWFwJDAiLCJ0b19tb25hZCIsIm9mX21vbmFkIiwiZGVyaXZlZF9tYXAiLCJtYXAyIiwidGEiLCJ0YiIsIm1hcDMiLCJ0YyIsInN5bWJvbCQwIiwidSIsInN5bWJvbCQxIiwidGYiLCJmYWIiLCJjIiwiYXBwbHkiLCJtZiIsIm14IiwidHgiLCJjdXN0b21fbWFwIiwiYXBwbHkkMCIsImJsaXRfc3RyaW5nIiwibWFrZSIsInVuc2FmZV9ibGl0IiwidW5zYWZlX3RvX3N0cmluZyIsInVuc2FmZV9vZl9zdHJpbmdfcHJvbWlzZV9ub19tdSIsImNvbXBhcmF0b3IiLCJlcnJvcl9zb3VyY2VfMDExIiwiY21wX2YiLCJjbXBfcyIsImhhc2hfZm9sZF9mIiwiaGFzaF9mb2xkX3MiLCJ0X29mX3NleHAiLCJvZl9mXzAwNyIsIm9mX3NfMDA4Iiwic2V4cF8wMTMiLCJ0YWdfMDE0Iiwic2V4cF9hcmdzXzAyMCIsImFyZzBfMDIxIiwicmVzMF8wMjIiLCJzZXhwX2FyZ3NfMDE1IiwiYXJnMF8wMTYiLCJyZXMwXzAxNyIsIm9mX2ZfMDI1Iiwib2Zfc18wMjYiLCJhcmcwXzAyNyIsInJlczBfMDI4IiwiYXJnMF8wMjkiLCJyZXMwXzAzMCIsImZfc2V4cF9ncmFtbWFyIiwic19zZXhwX2dyYW1tYXIiLCJvcGFxdWVfaWRlbnRpdHkiLCJuYW1lIiwiZ2V0IiwiZnNldCIsInNldHRlciIsInVwZGF0ZXIiLCJmaWVsZCIsImNhcGl0YWxpemUiLCJ1bmNhcGl0YWxpemUiLCJzZXAiLCJuIiwibiQwIiwibiQxIiwiaHN2JDIiLCJwb3NfY251bV8wMTAiLCJwb3NfYm9sXzAwOCIsInBvc19sbnVtXzAwNiIsInBvc19mbmFtZV8wMDQiLCJhcmdfMDExIiwiYm5kc18wMDMiLCJhcmdfMDA5IiwiYm5kc18wMDMkMCIsImFyZ18wMDciLCJibmRzXzAwMyQxIiwiYXJnXzAwNSIsImJuZHNfMDAzJDIiLCJoYXNoX2ZvbGRfdCQwIiwiaGFzaCQwIiwibWFrZV9sb2NhdGlvbl9zdHJpbmciLCJwb3NfZm5hbWUiLCJwb3NfbG51bSIsInBvc19jbnVtIiwicG9zX2JvbCIsImlzX2VtcHR5IiwicGFydGl0aW9uX21hcCIsImZzdCQwIiwieSQwIiwic25kJDAiLCJlcnJvcl9zb3VyY2VfMDA1Iiwib2ZfYV8wMDEiLCJvZl9iXzAwMiIsInNleHBfMDA3IiwidGFnXzAwOCIsInNleHBfYXJnc18wMDkiLCJhcmcwXzAxMCIsInJlczBfMDExIiwic2V4cF9hcmdzXzAxNCIsImFyZzBfMDE1IiwicmVzMF8wMTYiLCJvZl9hXzAxOSIsIm9mX2JfMDIwIiwiYXJnMF8wMjMiLCJyZXMwXzAyNCIsImFfc2V4cF9ncmFtbWFyIiwiYl9zZXhwX2dyYW1tYXIiLCJjbXBfYSIsImNtcF9iIiwiYV8wMjciLCJiXzAyOCIsImFfMDI5IiwiYl8wMzAiLCJhXzAzMSIsImJfMDMyIiwiYV8wMzMiLCJiXzAzNCIsImFfMDM1IiwiYl8wMzYiLCJhXzAzNyIsImJfMDM4IiwiaGFzaF9mb2xkX2EiLCJoYXNoX2ZvbGRfYiIsIngkMCIsImNoZWNrX29rIiwiY2hlY2tfZXJyb3IiLCJvayIsImVycm9yIiwiZmFpbCIsImZhaWxmIiwibWFwX2Vycm9yIiwiYmluZCQxIiwibWFwJDEiLCJyZXR1cm4kMiIsImlzX29rIiwiaXNfZXJyb3IiLCJvZl9vcHRpb24iLCJpdGVyX2Vycm9yIiwidG9fZWl0aGVyIiwib2ZfZWl0aGVyIiwib2tfaWZfdHJ1ZSIsImJvb2wiLCJ0cnlfd2l0aCIsIm9rX2V4biIsIm9rX29yX2ZhaWx3aXRoIiwiY29tYmluZSIsImVyciIsIm9rMSIsIm9rMiIsImVycjEiLCJlcnIyIiwiY29tYmluZV9lcnJvcnMiLCJlcnJzIiwiY29tYmluZV9lcnJvcnNfdW5pdCIsImNvdW50Iiwic3VtIiwiTSIsImZvbGRfcmVzdWx0IiwiYWNjIiwiaXRlbSIsImZvbGRfdW50aWwiLCJmaW5pc2giLCJtaW5fZWx0IiwiZWx0IiwibWF4X2VsdCIsImZpbmRfbWFwIiwiZmluZCIsInRvX2FycmF5IiwiaXRlciQwIiwiaXRlciQxIiwibGVuZ3RoJDAiLCJsZW5ndGgkMSIsImlzX2VtcHR5JDAiLCJzdW0kMCIsIm0iLCJjb3VudCQwIiwiZXhpc3RzJDAiLCJmb3JfYWxsJDAiLCJmaW5kX21hcCQwIiwiZmluZCQwIiwidG9fbGlzdCQwIiwidG9fYXJyYXkkMCIsIm1pbl9lbHQkMCIsIm1heF9lbHQkMCIsImZvbGRfcmVzdWx0JDAiLCJmb2xkX3VudGlsJDAiLCJmb2xkJDAiLCJtZW0iLCJjb21wYXJlX2EiLCJlcXVhbF9hIiwic2V4cF9vZl9hIiwic2xvd19jaGVja19wb3NfbGVuX2V4biIsInBvcyIsInRvdGFsX2xlbmd0aCIsImNoZWNrX3Bvc19sZW5fZXhuIiwic3RvcCIsImdldF9wb3NfbGVuX2V4biIsImxlbiQwIiwib2Zfc3RhdGUiLCJhc3NpZ24iLCJ0MSQwIiwidDIkMCIsIm1ha2VfZGVmYXVsdCIsImRlZmF1bHQkMCIsImdldF9zdGF0ZSIsImZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyIsImFsbG93X2luX3Rlc3RzIiwiYml0cyIsImludCQwIiwiaW50MzIiLCJpbnQ2NCIsIm5hdGl2ZWludCIsImNoYXIkMCIsImFzY2lpIiwibWFrZV9zZWxmX2luaXQiLCJpbnRfb25fNjRiaXRzIiwiYm91bmQiLCJpbnRfb25fMzJiaXRzIiwiaW50JDEiLCJiaXRzJDAiLCJmdWxsX3JhbmdlX2ludDY0IiwiYml0cyQxIiwiZnVsbF9yYW5nZV9pbnQzMiIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzMyYml0cyIsImZ1bGxfcmFuZ2VfaW50X29uXzY0Yml0cyQwIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fNjRiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnRfb25fMzJiaXRzIiwiZnVsbF9yYW5nZV9uYXRpdmVpbnQiLCJyYWlzZV9jcm9zc2VkX2JvdW5kcyIsImxvd2VyX2JvdW5kIiwidXBwZXJfYm91bmQiLCJzdHJpbmdfb2ZfYm91bmQiLCJpbnRfaW5jbCIsImxvIiwiaGkiLCJkaWZmIiwiaW50MzJfaW5jbCIsIm5hdGl2ZWludF9pbmNsIiwiaW50NjRfaW5jbCIsImZsb2F0JDAiLCJyMSIsInIyIiwicmVzdWx0IiwiZmxvYXRfcmFuZ2UiLCJkZWZhdWx0JDEiLCJiaXRzJDIiLCJpbnQkMiIsImludDMyJDAiLCJuYXRpdmVpbnQkMCIsImludDY0JDAiLCJmbG9hdCQxIiwiaW50X2luY2wkMCIsImludDMyX2luY2wkMCIsIm5hdGl2ZWludF9pbmNsJDAiLCJpbnQ2NF9pbmNsJDAiLCJmbG9hdF9yYW5nZSQwIiwiYm9vbCQwIiwiY2hhciQxIiwiYXNjaWkkMCIsImZ1bGxfaW5pdCIsInNlbGZfaW5pdCIsInNldF9zdGF0ZSIsInBlcm11dGUiLCJyYW5kb21fc3RhdGUiLCJzdGgkMCIsIm51bV9zd2FwcyIsInRoaXNfaSIsInJhbmRvbV9pIiwiY29uc3QkMCIsIm5vbiIsImZvcmV2ZXIiLCJlJDAiLCJjb21wb3NlIiwiZyIsImZsaXAiLCJhcHBseV9uX3RpbWVzIiwieCQxIiwic2V4cF8wMDYiLCJlcnJvcl9zb3VyY2VfMDIyIiwiZm9sZF9sZWZ0IiwiYV8wMDYiLCJiXzAwNyIsImFfMDA4IiwiYl8wMDkiLCJvZl9hXzAxMCIsImFyZzBfMDExIiwicmVzMF8wMTIiLCJyYW5nZSIsInN0cmlkZSIsInN0YXJ0X2kiLCJzdG9wX2kiLCJzdGFydCIsIm5leHRfaSIsIm9yZGVyIiwicmFpc2Vfc3RyaWRlX2Nhbm5vdF9yZXR1cm5fc2FtIiwiaW5pdGlhbF9zdHJpZGVfb3JkZXIiLCJzdGFydF9pJDAiLCJhY2N1bSIsImlfdG9fc3RvcF9vcmRlciIsIm5leHRfaSQwIiwiYWNjdW0kMCIsInJhbmdlJDAiLCJzdGgkMSIsImhkIiwidGwiLCJudGgiLCJudGhfZXhuIiwidW5vcmRlcmVkX2FwcGVuZCIsIm9mX2xpc3RzIiwic2hhcmVkX2xlbmd0aCIsInNoYXJlZF9sZW5ndGgkMCIsImNoZWNrX2xlbmd0aDJfZXhuIiwidGFpbF9vZl9iIiwidGFpbF9vZl9hIiwiY2hlY2tfbGVuZ3RoMiIsIm9mX2xpc3RzJDAiLCJsMyIsImMkMCIsImNoZWNrX2xlbmd0aDNfZXhuIiwidGFpbF9vZl9jIiwibjEiLCJuMiIsIm4zIiwiY2hlY2tfbGVuZ3RoMyIsIml0ZXIyIiwiaXRlcjJfZXhuIiwicmV2X21hcDIiLCJyZXZfbWFwMl9leG4iLCJmb2xkMiIsImZvbGQyX2V4biIsImZvcl9hbGwyIiwiZm9yX2FsbDJfZXhuIiwiZXhpc3RzMiIsImV4aXN0czJfZXhuIiwiYnMiLCJyZXZfZmlsdGVyIiwiYWNjdSIsImZpbHRlciIsIm5vdF9mb3VuZCIsImZpbmRfbWFwX2V4biIsIm5vdF9mb3VuZCQwIiwiZmluZF9leG4iLCJmaW5kaSIsIm5vdF9mb3VuZCQxIiwiZmluZGlfZXhuIiwiZmluZF9tYXBpIiwibm90X2ZvdW5kJDIiLCJmaW5kX21hcGlfZXhuIiwiZm9yX2FsbGkiLCJleGlzdHNpIiwibWF4X25vbl90YWlsY2FsbCIsImNvdW50X2FwcGVuZCIsIngxIiwieDIiLCJ4MyIsIng0IiwieDUiLCJjb3VudF9tYXAiLCJjdHIiLCJ4MSQwIiwiZjEkMyIsIngyJDAiLCJmMSQyIiwiZjIkMiIsIngzJDAiLCJmMSQxIiwiZjIkMSIsImYzJDEiLCJ4NCQwIiwiZjEkMCIsImYyJDAiLCJmMyQwIiwiZjQkMCIsIng1JDAiLCJmMSIsImYyIiwiZjMiLCJmNCIsImY1IiwiYnMkMCIsInhzJDAiLCJ4OCIsIng3IiwieDYiLCJ4MCIsInkwJDAiLCJ5MSQwIiwieTIkMCIsInkzJDAiLCJ5NCQwIiwieTUkMCIsInk2JDAiLCJ5NyQwIiwieTgkMCIsInk4IiwieTciLCJ5NiIsInk1IiwieTQiLCJ5MyIsInkyIiwieTEiLCJ5MCIsImZvbGRpbmdfbWFwIiwibmV3X2FjYyIsImZvbGRfbWFwIiwibWFwMl9vayIsIm1hcDJfZXhuIiwicmV2X21hcDNfb2siLCJsMSQwIiwibDIkMCIsImwzJDAiLCJhYyIsImwzJDEiLCJsMiQxIiwibDEkMSIsImFjJDAiLCJyZXZfbWFwMyIsInJldl9tYXAzX2V4biIsIm1hcDNfb2siLCJtYXAzX2V4biIsInJldl9tYXBfYXBwZW5kIiwiaCIsImxpc3QkMiIsInVuemlwMyIsInoiLCJ6aXBfZXhuIiwiemlwIiwicmV2X21hcGkiLCJmb2xkaW5nX21hcGkiLCJmb2xkX21hcGkiLCJmb2xkaSIsImZpbHRlcmkiLCJyZWR1Y2UiLCJyZWR1Y2VfZXhuIiwicmVkdWNlX2JhbGFuY2VkIiwic3RlcF9hY2N1bSIsIm51bSIsIm51bSQwIiwiYWNjJDAiLCJhY2MkMSIsIm51bSQxIiwicmVkdWNlX2JhbGFuY2VkX2V4biIsImdyb3VwaSIsImJyZWFrJDAiLCJncm91cHMiLCJjdXJyZW50X2dyb3VwIiwiZ3JvdXAiLCJzb3J0X2FuZF9ncm91cCIsImNvbmNhdF9tYXAiLCJjb25jYXRfbWFwaSIsImNvbnQiLCJtZXJnZSIsImgyIiwiaDEiLCJtYXAyJDAiLCJtYXAzJDAiLCJzeW1ib2wkMiIsImxhc3RfZXhuIiwibGFzdCIsImlzX3ByZWZpeCIsInByZWZpeCIsInByZWZpeCQwIiwicHJlZml4JDEiLCJoZCQwIiwiZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUiLCJhMSIsImExJDAiLCJhMiIsInJlbW92ZV9jb25zZWN1dGl2ZV9kdXBsaWNhdGVzIiwid2hpY2hfdG9fa2VlcCIsInRsJDAiLCJ0b19rZWVwJDIiLCJ0b19rZWVwIiwidG9fa2VlcCQwIiwidG9fa2VlcCQxIiwiZGVkdXBfYW5kX3NvcnQiLCJzb3J0ZWQiLCJmaW5kX2FfZHVwIiwibCQwIiwiaGQyIiwiaGQxIiwiY29udGFpbnNfZHVwIiwibHN0IiwiZmluZF9hbGxfZHVwcyIsInNvcnRlZCQyIiwicHJldiQxIiwic29ydGVkJDAiLCJwcmV2IiwiYWxyZWFkeV9yZWNvcmRlZCIsInNvcnRlZCQxIiwicHJldiQwIiwiYWxsX2VxdWFsIiwiY291bnRpIiwiaWR4IiwicmV2X2ZpbHRlcl9tYXAiLCJmaWx0ZXJfbWFwIiwicmV2X2ZpbHRlcl9tYXBpIiwiaSQxIiwiZmlsdGVyX21hcGkiLCJmaWx0ZXJfb3B0IiwicGFydGl0aW9uM19tYXAiLCJ0cmQiLCJ0cmQkMCIsInkkMSIsInBhcnRpdGlvbl90ZiIsImYkMCIsInBhcnRpdGlvbl9yZXN1bHQiLCJ0X29mX3NleHAkMCIsIm9mX2FfMDE0Iiwib2ZfYl8wMTUiLCJ4XzAyMyIsInNleHBfMDIxIiwiYXJnMV8wMTgiLCJhcmcwXzAxNyIsInJlczBfMDE5IiwicmVzMV8wMjAiLCJzZXhwX29mX3QkMSIsIm9mX2FfMDI0Iiwib2ZfYl8wMjUiLCJ4XzAzMCIsImFyZzFfMDI3IiwiYXJnMF8wMjYiLCJyZXMxXzAyOSIsInRfc2V4cF9ncmFtbWFyJDAiLCJwYWlyX29mX2dyb3VwIiwiayIsImdyb3VwJDAiLCJhbGlzdCIsInNvcnRfYW5kX2dyb3VwJDAiLCJrZXkiLCJrZXkkMCIsIm5vdF9mb3VuZCQzIiwiZmluZF9leG4kMCIsInZhbHVlIiwibWVtJDAiLCJyZW1vdmUiLCJhZGQiLCJpbnZlcnNlIiwibWFwJDIiLCJlbCIsInNwbGl0X24iLCJ0X29yaWciLCJ0YWtlIiwiZHJvcCIsImNodW5rc19vZiIsImwkMSIsInN1Ymxpc3QiLCJzcGxpdF93aGlsZSIsInRha2Vfd2hpbGUiLCJkcm9wX3doaWxlIiwiZHJvcF9sYXN0IiwiZHJvcF9sYXN0X2V4biIsImNhcnRlc2lhbl9wcm9kdWN0IiwibGlzdDEiLCJsaXN0MiIsImNvbmNhdF9ub19vcmRlciIsImNvbnMiLCJpc19zb3J0ZWQiLCJpc19zb3J0ZWRfc3RyaWN0bHkiLCJhcnIiLCJyYW5kb21fZWxlbWVudF9leG4iLCJyYW5kb21fZWxlbWVudCIsImNtcCIsInQyJDEiLCJ0MSQxIiwidHJhbnNwb3NlIiwicm93cyQwIiwicm93cyIsImNvbHVtbnMiLCJkb19yZXYiLCJjb2x1bW5fYWNjIiwidHJpbW1lZF9yb3dzIiwiZm91bmRfZW1wdHkiLCJjb2x1bW4iLCJkb19yZXYkMCIsImNvbHVtbnMkMCIsInRyaW1tZWQiLCJjb2x1bW5fYWNjJDAiLCJhcmcwXzAzMSIsInJlczBfMDMyIiwidHJhbnNwb3NlX2V4biIsImludGVyc3BlcnNlIiwiaXNfc3VmZml4Iiwic3VmZml4IiwibGlzdF9sZW4iLCJzdWZmaXhfbGVuIiwicmVzMF8wMDIiLCJhcmcwXzAwMyIsInJlczBfMDA0IiwicmVzMF8wMDYiLCJhcmcwXzAwNyIsInJlczBfMDA4IiwiYXJnMl8wMTEiLCJhcmcxXzAxMCIsImFyZzBfMDA5IiwicmVzMV8wMTMiLCJyZXMyXzAxNCIsImFyZzFfMDE2IiwicmVzMV8wMTgiLCJhcmcyXzAyMSIsImFyZzFfMDIwIiwiYXJnMF8wMTkiLCJyZXMxXzAyMyIsInJlczJfMDI0IiwiYXJnMV8wMjYiLCJhcmcwXzAyNSIsInJlczBfMDI3IiwicmVzMV8wMjgiLCJhcmcxXzAzMCIsInJlczBfMDMxIiwicmVzMV8wMzIiLCJ0b19zdHJpbmdzX2h1bSIsInN0cmluZyIsInNleHAkMCIsInNleHAkMSIsInRhZyIsInRhZyQwIiwic2V4cCQyIiwidGFnJDEiLCJib2R5IiwidHJ1bmNfYWZ0ZXIiLCJ0cyQwIiwidHMkMSIsImFjJDEiLCJ0b19zZXhwc19odW0iLCJoZXJlIiwiaGVyZSQwIiwidG9fc2V4cF9odW0iLCJzZXhwcyIsInRvX21lc3NhZ2UiLCJpbmZvIiwib2ZfbWVzc2FnZSIsInRvX3N0cmluZ19odW0iLCJtZXNzYWdlIiwidG9fc3RyaW5nX2h1bV9kZXByZWNhdGVkIiwib2ZfbGF6eSIsIm9mX2xhenlfc2V4cCIsIm9mX2xhenlfdCIsImxhenlfdCIsImNyZWF0ZWYiLCJvZl90aHVuayIsInN0cmljdCIsInNleHBfb2ZfeCIsInRhZ19zX2xhenkiLCJ0YWdfcyIsInRhZ19hcmciLCJ0b19leG4iLCJvZl9leG4iLCJiYWNrdHJhY2UkMCIsImJhY2t0cmFjZSQxIiwiYmFja3RyYWNlJDIiLCJyYWlzZSIsInJhaXNlX3MiLCJ0b19pbmZvIiwib2ZfaW5mbyIsImNoZWNrX2ZpZWxkIiwiYV8wMDciLCJiXzAwOCIsIm9mX2FfMDEzIiwieF8wMTUiLCJvZl9hXzAxNiIsInhfMDE3IiwiaW52YXJpYW50X2EiLCJlMSIsImUyIiwidHJ5X3dpdGhfam9pbiIsIm9mX2V4bl9yZXN1bHQiLCJlcnJvcl9zIiwiZXJyb3Jfc3RyaW5nIiwiZXJyb3JmIiwidW5pbXBsZW1lbnRlZCIsImZpbHRlcl9va19hdF9sZWFzdF9vbmUiLCJmaW5kX29rIiwiZmluZF9tYXBfb2siLCJlcnJvcl9zb3VyY2VfMDAzIiwic2V4cF8wMDQiLCJnZXEiLCJsZXEiLCJiZXR3ZWVuIiwibG93IiwiaGlnaCIsImNsYW1wX3VuY2hlY2tlZCIsImNsYW1wX2V4biIsImNsYW1wIiwibGV4aWNvZ3JhcGhpYyIsImNtcHMiLCJjbXBzJDAiLCJsaWZ0IiwicmV2ZXJzZSIsImlzX3Bvc2l0aXZlIiwiaXNfbm9uX25lZ2F0aXZlIiwiaXNfbmVnYXRpdmUiLCJpc19ub25fcG9zaXRpdmUiLCJzaWduIiwiaGFzaF9wYXJhbSIsInBvbHkiLCJvZl9rZXkiLCJLZXkiLCJ0b19rZXkiLCJoYXNoX3BhcmFtJDAiLCJwb2x5JDAiLCJvZl9rZXkkMCIsInRvX2tleSQwIiwiaGFzaGFibGUiLCJnZXRfcG9zX2xlbiIsImZpbmRfZmlyc3Rfc2F0aXNmeWluZyIsInByZWQiLCJwb3MkMCIsImhpJDAiLCJsbyQxIiwibWlkIiwibG8kMiIsImxvJDAiLCJmaW5kX2xhc3Rfc2F0aXNmeWluZyIsImJpbmFyeV9zZWFyY2giLCJob3ciLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCIsInNlZ21lbnRfb2YiLCJpc19sZWZ0IiwiaXNfcmlnaHQiLCJhbGwkMCIsInNyYyIsInNyY19wb3MiLCJkc3QiLCJkc3RfcG9zIiwiYmxpdG8iLCJzcmNfbGVuIiwic3VibyIsImNyZWF0ZV9saWtlIiwidW5zYWZlX2JsaXQkMCIsImlzX25vbmUiLCJpc19zb21lIiwidmFsdWVfbWFwIiwibyIsImNhbGwiLCJ2YWx1ZV9leG4iLCJlcnJvciQwIiwibSQwIiwibSQxIiwidmFsdWVfb3JfdGh1bmsiLCJzb21lIiwiZmlyc3Rfc29tZSIsInNvbWVfaWYiLCJjb25kIiwiYV9vZl9zZXhwIiwiYl9vZl9zZXhwIiwic2V4cF9vZl9iIiwiY19vZl9zZXhwIiwic2V4cF9vZl9jIiwiaXNfZmlyc3QiLCJpc19zZWNvbmQiLCJmaXJzdCIsInNlY29uZCIsImVxMSIsImVxMiIsIm90aGVyIiwiZWl0aGVyIiwib3RoZXJfbG9vcCIsInJldHVybl9sb29wIiwiY29tYmluZV9hbGwiLCJvdGhlcl9sb29wJDAiLCJyZXR1cm5fbG9vcCQwIiwiY29tYmluZV9hbGxfdW5pdCIsInRvX29wdGlvbiIsImVpdGhlciQwIiwiY29tYmluZSQwIiwiaXRlcmkkMCIsIml0ZXJpJDEiLCJmb2xkaSQwIiwiZm9sZGkkMSIsImNvdW50aSQwIiwiZXhpc3RzaSQwIiwiZm9yX2FsbGkkMCIsImZpbmRfbWFwaSQwIiwiZmluZGkkMCIsImVycm9yX3NvdXJjZV8wMjUiLCJvZl9zXzAwMiIsIm5leHRfc3RlcCIsImRlbGF5ZWRfZm9sZF9zdGVwIiwibmV4dCIsInVuZm9sZF9zdGVwIiwidW5mb2xkIiwidW5mb2xkX3dpdGgiLCJzZWVkJDAiLCJzZWVkJDEiLCJ1bmZvbGRfd2l0aF9hbmRfZmluaXNoIiwicnVubmluZ19zdGVwIiwiaW5uZXJfZmluaXNoZWQiLCJmaW5pc2hpbmdfc3RlcCIsInN0YXRlJDAiLCJzdGF0ZSQxIiwic3RhdGUkMiIsImlubmVyX3N0YXRlIiwic3RhdGUkMyIsImlubmVyX3N0YXRlJDAiLCJpbm5lcl9zdGF0ZSQxIiwic3RhdGUkNCIsInN0YXRlJDUiLCJzZWVkJDIiLCJ2JDAiLCJ0b19saXN0X3JldiIsInN0YXJ0X3YiLCJzdG9wX3YiLCJzdGVwIiwidF9sYXp5IiwibCQyIiwic29tZV9iIiwiZW1wdHkiLCJuZXh0JDAiLCJzJDMiLCJhXzAxMSIsImJfMDEyIiwiYV8wMTMiLCJiXzAxNCIsImFfMDE1IiwiYl8wMTYiLCJhXzAxOSIsImFfMDE3IiwiYl8wMjAiLCJiXzAxOCIsImEwJDEiLCJoc3YkMyIsIm9mX2FfMDIxIiwib2ZfYl8wMjIiLCJzZXhwXzAyNyIsInRhZ18wMjgiLCJzZXhwX2FyZ3NfMDM0IiwiYXJnMF8wMzUiLCJyZXMwXzAzNiIsInNleHBfYXJnc18wMjkiLCJhcmcwXzAzMCIsInNleHBfYXJnc18wMzkiLCJhcmcxXzA0MSIsImFyZzBfMDQwIiwicmVzMF8wNDIiLCJyZXMxXzA0MyIsIm9mX2FfMDQ2Iiwib2ZfYl8wNDciLCJhcmcwXzA0OCIsInJlczBfMDQ5IiwiYXJnMF8wNTAiLCJyZXMwXzA1MSIsImFyZzFfMDUzIiwiYXJnMF8wNTIiLCJyZXMwXzA1NCIsInJlczFfMDU1IiwibWVyZ2Vfd2l0aF9kdXBsaWNhdGVzIiwibmV4dDIiLCJzMiIsIm5leHQxIiwiczEiLCJzMiQwIiwiczIkMSIsInMxJDAiLCJzMiQyIiwiczEkMSIsInMyJDMiLCJjb21wYXJpc29uIiwibWVyZ2VfZGVkdXBlZF9hbmRfc29ydGVkIiwibWVyZ2Vfc29ydGVkIiwidGxfZWFnZXJseV9leG4iLCJsaWZ0X2lkZW50aXR5IiwiY2h1bmtzX2V4biIsInppcF9mdWxsIiwiYm91bmRlZF9sZW5ndGgiLCJhdF9tb3N0IiwibGVuZ3RoX2lzX2JvdW5kZWRfYnkiLCJjdXIiLCJjdXIkMCIsImxhc3RfZWx0IiwibGFzdF9lbHQkMCIsInNoaWZ0X3JpZ2h0Iiwic2hpZnRfcmlnaHRfd2l0aF9saXN0IiwicyQ1IiwiYSQxIiwicyQ0IiwicmVwZWF0IiwiY3ljbGVfbGlzdF9leG4iLCJzYSIsInNiIiwic2luZ2xldG9uIiwiZGVsYXllZF9mb2xkIiwib3B0aW9uIiwiZm9sZF9tIiwiaXRlcl9tIiwiZm9yY2VfZWFnZXJseSIsIm1lbW9pemUiLCJkcm9wX2VhZ2VybHkiLCJkcm9wX3doaWxlX29wdGlvbiIsInYyIiwidjEiLCJyb3VuZF9yb2JpbiIsImRvbmVfc3RhY2siLCJ0b2RvX3N0YWNrIiwidG9kb19zdGFjayQwIiwiaW50ZXJsZWF2ZSIsImludGVybGVhdmVkX2NhcnRlc2lhbl9wcm9kdWN0Iiwib2Zfc2VxIiwic2VxIiwidG9fc2VxIiwieWllbGQkMCIsIm9mX3NlcXVlbmNlIiwic2VxdWVuY2UiLCJ0aHVuayIsInNldCIsInN3YXAkMCIsInRtcCIsImxlZnQiLCJyaWdodCIsImZpbmFsX3BvcyIsImlfbmV4dCIsImhlYXBpZnkiLCJyb290Iiwicm9vdCQwIiwicmVsYXRpdmVfcm9vdCIsImxlZnRfY2hpbGQiLCJyaWdodF9jaGlsZCIsImxhcmdlc3QiLCJsYXJnZXN0JDAiLCJzb3J0JDAiLCJmaXZlX2VsZW1lbnRfc29ydCIsIm0xIiwibTIiLCJtMyIsIm00IiwibTUiLCJjb21wYXJlX2FuZF9zd2FwIiwiaW50cm9fc29ydCIsIm1heF9kZXB0aCIsIm1heF9kZXB0aCQwIiwibGVmdCQwIiwibWF4X2RlcHRoJDEiLCJzaXh0aCIsIm0yX3ZhbCIsIm0zX3ZhbCIsIm00X3ZhbCIsIm1pZGRsZV9zb3J0ZWQiLCJwaXZvdDIiLCJwaXZvdDEiLCJwJDEiLCJyJDIiLCJsZWZ0JDEiLCJwdiIsInAkMCIsInIkMCIsInIkMSIsInNvcnQkMSIsInNvcnQkMiIsImVsdF9pX21pbnVzXzEiLCJtZXJnZWQiLCJhMV9pbmRleCIsImEyX2luZGV4IiwidXNlX2ExIiwiY29weV9tYXRyaXgiLCJyZXZfaW5wbGFjZSIsIm9mX2xpc3RfcmV2Iiwib2ZfbGlzdF9tYXAiLCJvZl9saXN0X21hcGkiLCJvZl9saXN0X3Jldl9tYXAiLCJvZl9saXN0X3Jldl9tYXBpIiwibWFwX2lucGxhY2UiLCJmaW5kaV9pbnRlcm5hbCIsImlmX2ZvdW5kIiwiaWZfbm90X2ZvdW5kIiwiZm91bmQiLCJ2YWx1ZV9mb3VuZCIsInJlczEiLCJyZXMyIiwic29ydGVkX2NvcHkiLCJwYXJ0aXRpb25pX3RmIiwidHJ1ZXMiLCJmYWxzZXMiLCJ0b19zZXF1ZW5jZV9tdXRhYmxlIiwidG9fc2VxdWVuY2UiLCJpMSIsImkyIiwidHQiLCJ3aWR0aCIsImRlcHRoIiwiZCIsInciLCJ0dCQwIiwiZ2V0JDAiLCJ6ZXJvX29iaiIsImNyZWF0ZV96ZXJvIiwidW5zYWZlX2dldCIsInVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSIsIm9iaiIsInNldF93aXRoX2NhbWxfbW9kaWZ5IiwidW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVuIiwib2xkX29iaiIsInVuc2FmZV9zZXQiLCJ1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGUiLCJ1bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV8iLCJ1bnNhZmVfc2V0X2ludCIsInVuc2FmZV9jbGVhcl9pZl9wb2ludGVyIiwidW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIiwiY3JlYXRlX29ial9hcnJheSIsIm9mX2FycmF5IiwiZ3JhbW1hciIsImNlaWwiLCJmbG9vciIsIm1vZF9mbG9hdCIsIm1vZGYiLCJtYXhfZmluaXRlX3ZhbHVlIiwiY2xhc3NpZnlfZmxvYXQiLCJhYnNfZmxvYXQiLCJpc19pbnRlZ2VyIiwiZnJleHAiLCJsZGV4cCIsImlzX25hbiIsInRvX2ludDY0X3ByZXNlcnZlX29yZGVyIiwidG9faW50NjRfcHJlc2VydmVfb3JkZXJfZXhuIiwib2ZfaW50NjRfcHJlc2VydmVfb3JkZXIiLCJvbmVfdWxwIiwiZGlyIiwidXBwZXJfYm91bmRfZm9yX2ludCIsImV4cCIsImlzX3hfbWludXNfb25lX2V4YWN0IiwibG93ZXJfYm91bmRfZm9yX2ludCIsIm1pbl9pbnRfYXNfZmxvYXQiLCJib3giLCJpc19sb3dlcmNhc2UiLCJpc191cHBlcmNhc2UiLCJpc19wcmludCIsImlzX3doaXRlc3BhY2UiLCJpc19kaWdpdCIsImlzX2FscGhhIiwiaXNfYWxwaGFudW0iLCJnZXRfZGlnaXRfdW5zYWZlIiwiZ2V0X2RpZ2l0X2V4biIsImdldF9kaWdpdCIsImlzX2hleF9kaWdpdCIsImlzX2hleF9kaWdpdF9sb3dlciIsImlzX2hleF9kaWdpdF91cHBlciIsImdldF9oZXhfZGlnaXRfZXhuIiwiZ2V0X2hleF9kaWdpdCIsInRfb2Zfc2V4cCQxIiwiYzEiLCJjMiIsImhhc2hfZm9sZF90JDEiLCJoYXNoJDEiLCJ0cl9jcmVhdGVfbWFwIiwidGFyZ2V0IiwicmVwbGFjZW1lbnQiLCJ0cl9tYXAiLCJpJDMiLCJpJDIiLCJpbmRleCQwIiwibGFzdF9yZXBsYWNlbWVudCIsImluZGV4IiwiZmlyc3RfdGFyZ2V0Iiwic3RhZ2UiLCJ1bnN0YWdlIiwiY29udGFpbnMiLCJwb3MkMSIsImVuZCIsImluZGV4X2Zyb21fZXhuX2ludGVybmFsIiwiaW5kZXhfZXhuX2ludGVybmFsIiwiaW5kZXhfZXhuIiwiaW5kZXhfZnJvbV9leG4iLCJyaW5kZXhfZnJvbV9leG5faW50ZXJuYWwiLCJyaW5kZXhfZXhuX2ludGVybmFsIiwicmluZGV4X2V4biIsInJpbmRleF9mcm9tX2V4biIsInJpbmRleCIsImluZGV4X2Zyb20iLCJyaW5kZXhfZnJvbSIsImNhc2Vfc2Vuc2l0aXZlIiwicGF0dGVybiIsImttcF9pbnRlcm5hbF9sb29wIiwibWF0Y2hlZF9jaGFycyIsIm5leHRfdGV4dF9jaGFyIiwia21wX2FycmF5IiwiY2hhcl9lcXVhbCIsIm1hdGNoZWRfY2hhcnMkMCIsImdldF9jaGFyX2VxdWFsIiwiaW5kZXhfaW50ZXJuYWwiLCJ0ZXh0IiwibWF0Y2hlcyIsImluJDAiLCJpbmRleF9leG4kMCIsImluZGV4X2FsbCIsIm1heV9vdmVybGFwIiwicmVwbGFjZV9maXJzdCIsIndpdGgkMCIsImxlbl9zIiwibGVuX3QiLCJsZW5fd2l0aCIsInJlcGxhY2VfYWxsIiwibnVtX21hdGNoZXMiLCJuZXh0X2RzdF9wb3MiLCJuZXh0X3NyY19wb3MiLCJzcGxpdF9vbiIsInBhdHRlcm5fbGVuIiwiYV8wMDIiLCJiXzAwMyIsImttcF9hcnJheV8wMTEiLCJjYXNlX3NlbnNpdGl2ZV8wMDkiLCJwYXR0ZXJuXzAwNyIsImFyZ18wMTIiLCJibmRzXzAwNiIsImFyZ18wMTAiLCJibmRzXzAwNiQwIiwiYXJnXzAwOCIsImJuZHNfMDA2JDEiLCJyZXByZXNlbnRhdGlvbiIsInN1YnN0cl9pbmRleF9nZW4iLCJzdWJzdHJfaW5kZXhfZXhuX2dlbiIsInN1YnN0cl9pbmRleF9hbGxfZ2VuIiwic3Vic3RyX3JlcGxhY2VfZmlyc3RfZ2VuIiwic3Vic3RyX3JlcGxhY2VfYWxsX2dlbiIsImlzX3N1YnN0cmluZ19nZW4iLCJzdWJzdHJpbmciLCJzdWJzdHJfaW5kZXgiLCJzdWJzdHJfaW5kZXhfZXhuIiwic3Vic3RyX2luZGV4X2FsbCIsInN1YnN0cl9yZXBsYWNlX2ZpcnN0Iiwic3Vic3RyX3JlcGxhY2VfYWxsIiwiaXNfc3Vic3RyaW5nIiwiaXNfc3Vic3RyaW5nX2F0X2dlbiIsInN0cl9wb3MkMSIsInN0cl9sZW4iLCJzdWJfbGVuIiwic3RyX3BvcyIsInN1Yl9wb3MiLCJzdWJfcG9zJDAiLCJzdHJfcG9zJDAiLCJpc19zdWZmaXhfZ2VuIiwic3RyaW5nX2xlbiIsImlzX3ByZWZpeF9nZW4iLCJwcmVmaXhfbGVuIiwic2V4cF9vZl90JDIiLCJzdHJpbmcxIiwic3RyaW5nMiIsImxlbjIiLCJsZW4xIiwic3Vic3RyX2luZGV4JDAiLCJzdWJzdHJfaW5kZXhfZXhuJDAiLCJzdWJzdHJfaW5kZXhfYWxsJDAiLCJzdWJzdHJfcmVwbGFjZV9maXJzdCQwIiwic3Vic3RyX3JlcGxhY2VfYWxsJDAiLCJpc19zdWJzdHJpbmckMCIsImlzX3N1YnN0cmluZ19hdCIsImxzcGxpdDJfZXhuIiwibGluZSIsImRlbGltIiwibm90X2ZvdW5kJDQiLCJyc3BsaXQyX2V4biIsImxzcGxpdDIiLCJvbiIsInJzcGxpdDIiLCJjaGFyX2xpc3RfbWVtIiwic3BsaXRfZ2VuIiwiaXNfZGVsaW0iLCJsYXN0X3BvcyIsImxhc3RfcG9zJDEiLCJsYXN0X3BvcyQwIiwicG9zMSIsInN1Yl9zdHIiLCJzcGxpdCIsInNwbGl0X29uX2NoYXJzIiwiY2hhcnMiLCJiYWNrX3VwX2F0X25ld2xpbmUiLCJlb2wiLCJzcGxpdF9saW5lcyIsImlzX3N1ZmZpeCQwIiwiaXNfcHJlZml4JDAiLCJpc19zdWJzdHJpbmdfYXQkMCIsIndyYXBfc3ViX24iLCJvbl9lcnJvciIsImRyb3BfcHJlZml4IiwiZHJvcF9zdWZmaXgiLCJsZmluZGkiLCJyZmluZGkiLCJsYXN0X25vbl9kcm9wIiwicnN0cmlwIiwiZmlyc3Rfbm9uX2Ryb3AiLCJsc3RyaXAiLCJzdHJpcCIsInRyIiwidHJfbXVsdGkiLCJjb25jYXRfYXJyYXkiLCJhciIsIm91dCIsIm91dF9wb3MiLCJvdXQkMCIsImNob3BfcHJlZml4IiwiY2hvcF9wcmVmaXhfaWZfZXhpc3RzIiwiY2hvcF9wcmVmaXhfZXhuIiwiY2hvcF9zdWZmaXgiLCJjaG9wX3N1ZmZpeF9pZl9leGlzdHMiLCJjaG9wX3N1ZmZpeF9leG4iLCJzaG9ydGVyIiwic2hvcnRlc3QiLCJwb3NfZnJvbV9sZWZ0IiwicG9zX2Zyb21fcmlnaHQiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AiLCJnZXRfcG9zIiwibWF4X2xlbiIsImxlbl9zb19mYXIiLCJsZW5fc29fZmFyJDAiLCJsZW5fc29fZmFyJDEiLCJjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoX2xvb3AiLCJmaXJzdCQwIiwibWF4X2xlbiQwIiwibWF4X2xlbiQxIiwiY29tbW9uX2dlbmVyaWNfbGVuZ3RoIiwiY29tbW9uX2dlbmVyaWMyIiwiY29tbW9uX2dlbmVyaWMiLCJjb21tb25fcHJlZml4IiwiY29tbW9uX3N1ZmZpeCIsImNvbW1vbl9wcmVmaXgyIiwiY29tbW9uX3N1ZmZpeDIiLCJjb21tb25fcHJlZml4X2xlbmd0aCIsImNvbW1vbl9zdWZmaXhfbGVuZ3RoIiwiY29tbW9uX3ByZWZpeDJfbGVuZ3RoIiwiY29tbW9uX3N1ZmZpeDJfbGVuZ3RoIiwib2ZfY2hhciIsIm9mX2NoYXJfbGlzdCIsImJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aCIsImVzY2FwZXdvcnRoeV9tYXAiLCJlc2NhcGVfY2hhciIsImVzY2FwZXdvcnRoeV9tYXAkMCIsInZhbHMiLCJjX3RvIiwiY19mcm9tIiwiayQwIiwiZXNjYXBlX2dlbiIsImVzY2FwZXdvcnRoeSIsInRvX2VzY2FwZV9sZW4iLCJ0b19lc2NhcGUiLCJsYXN0X2lkeCIsImxhc3RfZHN0X3BvcyIsImxhc3RfaWR4JDAiLCJsYXN0X2RzdF9wb3MkMCIsInRvX2VzY2FwZSQwIiwiZXNjYXBlZF9jaGFyIiwibGFzdF9pZHgkMSIsImxhc3RfZHN0X3BvcyQxIiwiZXNjYXBlX2dlbl9leG4iLCJlc2NhcGUiLCJ1bmVzY2FwZV9nZW4iLCJzdGF0dXMiLCJ0b191bmVzY2FwZSIsInRvX3VuZXNjYXBlJDAiLCJzdGF0dXMkMCIsInVuZXNjYXBlX2dlbl9leG4iLCJ1bmVzY2FwZSIsInByZWNlZGluZ19lc2NhcGVfY2hhcnMiLCJjbnQiLCJjbnQkMCIsInVwZGF0ZV9lc2NhcGVfc3RhdHVzIiwiZXNjYXBlX3N0YXR1cyIsIm9kZCIsImNoZWNrX2JvdW5kIiwiZnVuY3Rpb25fbmFtZSIsImlzX2NoYXJfZXNjYXBpbmciLCJpc19jaGFyX2VzY2FwZWQiLCJpc19jaGFyX2xpdGVyYWwiLCJpbmRleF9mcm9tJDAiLCJzdGF0dXMkMSIsImluZGV4X2Zyb21fZXhuJDAiLCJpbmRleCQxIiwiaW5kZXhfZXhuJDEiLCJyaW5kZXhfZnJvbSQwIiwiZXNjYXBlX2NoYXJzIiwicmluZGV4X2Zyb21fZXhuJDAiLCJyaW5kZXgkMCIsInJpbmRleF9leG4kMCIsInNwbGl0X2dlbiQwIiwic3BsaXQkMCIsInNwbGl0X29uX2NoYXJzJDAiLCJzcGxpdF9hdCIsImxzcGxpdDIkMCIsInJzcGxpdDIkMCIsImxzcGxpdDJfZXhuJDAiLCJyc3BsaXQyX2V4biQwIiwibGFzdF9ub25fZHJvcF9saXRlcmFsIiwiZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCIsInJzdHJpcF9saXRlcmFsIiwibHN0cmlwX2xpdGVyYWwiLCJzdHJpcF9saXRlcmFsIiwiYmV0d2VlbiQwIiwiY2xhbXBfZXhuJDAiLCJjbGFtcCQwIiwiY3JlYXRlJDAiLCJjcmVhdGUkMSIsInVuc2FmZV9ibGl0JDEiLCJtYXBpJDAiLCJvY2FtbF9sZXhfdGFibGVzIiwicGFyc2VfaGV4IiwibGV4YnVmIiwib2NhbWxfbGV4X3N0YXRlIiwib2NhbWxfbGV4X3N0YXRlJDAiLCJjb252ZXJ0X2ZhaWx1cmUiLCJudW1fYml0c19pbnQiLCJudW1fYml0c19uYXRpdmVpbnQiLCJudW1fYml0c19pbnQzMiIsIm51bV9iaXRzX2ludDY0IiwibWluX2ludDMyIiwibWF4X2ludDMyIiwibWluX2ludDY0IiwibWF4X2ludDY0IiwibWluX25hdGl2ZWludCIsIm1heF9uYXRpdmVpbnQiLCJpbnQ2NF90b19zdHJpbmciLCJuYXRpdmVpbnRfdG9fc3RyaW5nIiwiaW50MzJfdG9faW50X3RydW5jIiwiaW50X3RvX2ludDMyX3RydW5jIiwiaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIiLCJpbnRfdG9faW50MzIiLCJpbnQzMl90b19pbnQiLCJpbnRfdG9faW50MzJfZXhuIiwiaW50MzJfdG9faW50X2V4biIsImludF90b19pbnQ2NCIsImludDY0X3RvX2ludF90cnVuYyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IiwiaW50NjRfdG9faW50IiwiaW50NjRfdG9faW50X2V4biIsImludF90b19uYXRpdmVpbnQiLCJuYXRpdmVpbnRfdG9faW50X3RydW5jIiwibmF0aXZlaW50X3RvX2ludCIsIm5hdGl2ZWludF90b19pbnRfZXhuIiwiaW50MzJfdG9faW50NjQiLCJpbnQ2NF90b19pbnQzMl90cnVuYyIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MyIsImludDY0X3RvX2ludDMyIiwiaW50NjRfdG9faW50MzJfZXhuIiwiaW50MzJfdG9fbmF0aXZlaW50IiwibmF0aXZlaW50X3RvX2ludDMyX3RydW5jIiwibmF0aXZlaW50X3RvX2ludDMyIiwibmF0aXZlaW50X3RvX2ludDMyX2V4biIsImludDY0X3RvX25hdGl2ZWludF90cnVuYyIsIm5hdGl2ZWludF90b19pbnQ2NCIsImludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aSIsImludDY0X3RvX25hdGl2ZWludCIsImludDY0X3RvX25hdGl2ZWludF9leG4iLCJpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYiLCJpbnQ2NF9maXRfb25faW50NjNfZXhuIiwiaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSIsImRlbGltaXRlciIsImNoYXJzX3Blcl9kZWxpbWl0ZXIiLCJpbnB1dF9sZW5ndGgiLCJoYXNfc2lnbiIsIm51bV9kaWdpdHMiLCJudW1fZGVsaW1pdGVycyIsIm91dHB1dF9sZW5ndGgiLCJpbnB1dF9wb3MiLCJvdXRwdXRfcG9zIiwibnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciIsImZpcnN0X2RpZ2l0X3BvcyIsImluc2VydF9kZWxpbWl0ZXIiLCJpbnNlcnRfdW5kZXJzY29yZXMiLCJzZXhwX29mX2ludF9zdHlsZSIsImRlbGltaXRlciQwIiwibWFrZV9zdWZmaXgiLCJ0b19zdHJpbmckMCIsImludmFsaWQiLCJvZl9zdHJpbmdfd2l0aF9kZWxpbWl0ZXIiLCJsZXgiLCJib2R5JDAiLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50NjNfb25faW4iLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50NjRfdmFsdWUiLCJpbnQzMl9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMiLCJvdmVyZmxvd19ib3VuZF9tYXhfaW50X3ZhbHVlIiwib3ZlcmZsb3dfYm91bmRfbWF4X2ludDMyX3ZhbHVlIiwiaW50X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsImludDYzX29uX2ludDY0X3Bvc2l0aXZlX292ZXJmbCIsImludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyIsImludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcyIsIm5lZ2F0aXZlX2V4cG9uZW50Iiwib3ZlcmZsb3ciLCJpbnRfcG93IiwiYmFzZSIsImV4cG9uZW50IiwiaW50NjRfcG93IiwiaW50NjNfcG93X29uX2ludDY0IiwicnZhbCIsIm9uZSIsInJvdW5kX2Rvd24iLCJtb2R1bHVzIiwicm91bmRfdXAiLCJyZW1haW5kZXIiLCJyb3VuZF90b3dhcmRzX3plcm8iLCJ0b19tdWx0aXBsZV9vZiIsInJvdW5kX25lYXJlc3QiLCJtb2R1bHVzX21pbnVzX3JlbWFpbmRlciIsInJvdW5kIiwiaDAxIiwibWFzayIsImludDY0X3BvcGNvdW50IiwieCQyIiwiaW50MzJfcG9wY291bnQiLCJuYXRpdmVpbnRfcG9wY291bnQiLCJtb2R1bGVfbmFtZSQwIiwib2Zfc3RyaW5nJDAiLCJmbG9hdF9sb3dlcl9ib3VuZCIsImZsb2F0X3VwcGVyX2JvdW5kIiwib2ZfZmxvYXRfdW5jaGVja2VkIiwiZnVuYyQwIiwiemVybyIsIm1pbnVzX29uZSIsIm5lZyIsIm9mX3N0cmluZyQxIiwib2ZfaW50MzIiLCJvZl9pbnQzMl9leG4iLCJ0b19pbnQzMiIsInRvX2ludDMyX2V4biIsIm9mX2ludDY0Iiwib2ZfaW50NjRfZXhuIiwidG9faW50NjQiLCJvZl9uYXRpdmVpbnQiLCJvZl9uYXRpdmVpbnRfZXhuIiwidG9fbmF0aXZlaW50IiwibWF4X3ZhbHVlXzMwX2JpdHMiLCJhYnMiLCJyZW0iLCJzaGlmdF9yaWdodF9sb2dpY2FsIiwic2hpZnRfbGVmdCIsImJpdF9ub3QiLCJiaXRfb3IiLCJiaXRfYW5kIiwiYml0X3hvciIsInBvdyIsIm5vbl9wb3NpdGl2ZV9hcmd1bWVudCIsImNlaWxfcG93MiIsIngkMyIsIngkNCIsIngkNSIsIngkNiIsImZsb29yX3BvdzIiLCJpc19wb3cyIiwiZmxvb3JfbG9nMiIsImNlaWxfbG9nMiIsInBvcGNvdW50IiwibG5vdCIsInN1Y2NfZXhuIiwibXNnIiwicHJlZF9leG4iLCJvZl9zY2FsYXIiLCJvZl9zY2FsYXJfZXhuIiwidG9fc2NhbGFyIiwidG9fY2hhciIsInRvX2NoYXJfZXhuIiwidXRmOF9ieXRlX2xlbmd0aCIsInVjaGFyIiwiY29kZXBvaW50Iiwic29tZV90IiwicmVmbCIsInN5bSIsInRyYW5zIiwiY29udiIsImRldHVwbGUyIiwidHVwbGUyIiwid2l0bmVzcyIsInZfMDA1IiwidG9fc2V4cCIsInVpZCIsInNhbWVfd2l0bmVzcyIsInNhbWUiLCJzYW1lX3dpdG5lc3NfZXhuIiwibm9uZV9zdWJzdGl0dXRlIiwibm9uZSIsInZhbHVlX3Vuc2FmZSIsIm9mX3NleHBhYmxlIiwidG9fc2V4cGFibGUiLCJ4XzAwMyIsIm9mX2FfMDA0IiwieF8wMDUiLCJpbml0X3NvbWUiLCJnZXRfc29tZV9leG4iLCJpc19ub25lJDAiLCJpc19zb21lJDAiLCJzZXRfc29tZSIsInNldF9ub25lIiwidW5zYWZlX2dldF9zb21lX2V4biIsInVuc2FmZV9nZXRfc29tZV9hc3N1bWluZ19zb21lIiwidW5zYWZlX2lzX3NvbWUiLCJ1bnNhZmVfc2V0X3NvbWUiLCJ1bnNhZmVfc2V0X25vbmUiLCJjbGVhciIsImVsZW0iLCJtYXBfc29tZSIsIm9mX2FycmF5X3NvbWUiLCJjYXBhY2l0eSIsImVsdHMiLCJsZW5ndGhfMDAzIiwiZWx0c18wMDUiLCJhcmdfMDA2IiwiYm5kc18wMDIiLCJhcmdfMDA0IiwiYm5kc18wMDIkMCIsInJlc2l6ZSIsInNpemUiLCJzZXRfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkiLCJuZXdfY2FwYWNpdHkkMCIsInB1c2giLCJwb3Bfbm9uZW1wdHkiLCJwb3BfZXJyb3IiLCJwb3AiLCJwb3BfZXhuIiwidG9wX25vbmVtcHR5IiwidG9wX2Vycm9yIiwidG9wIiwidG9wX2V4biIsInVudGlsX2VtcHR5IiwiaGFzaF9vdmVycmlkZSIsIm9mX3BvcyIsIm9mX3NpZ24iLCJ0b19zaWduX2V4biIsInRvX2ludF9leG4iLCJlcnJvcl9zb3VyY2VfMDA2IiwiZXJyb3Jfc291cmNlXzAyNyIsImludGVydmFsX2NvbXBhcmlzb25fc2V4cF9ncmFtbSIsImFsbF9vZl9hIiwiZW51bWVyYXRlXzAwMiIsImVudW1lcmF0ZV8wMDEiLCJhY2MkMiIsIm9mX2FfMDAzIiwic2V4cF8wMDgiLCJ0YWdfMDA5Iiwic2V4cF9hcmdzXzAxMCIsImFyZzBfMDIwIiwicmVzMF8wMjEiLCJhcmcwXzAyMiIsInJlczBfMDIzIiwiaW50ZXJ2YWxfY29tcGFyaXNvbl9vZl9zZXhwIiwic2V4cF8wMjgiLCJzZXhwX29mX2ludGVydmFsX2NvbXBhcmlzb24iLCJjb21wYXJlX2ludGVydmFsX2NvbXBhcmlzb24iLCJoYXNoX2ZvbGRfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImhhc2hfaW50ZXJ2YWxfY29tcGFyaXNvbiIsImluY2wiLCJleGNsIiwiaXNfbG93ZXJfYm91bmQiLCJpc191cHBlcl9ib3VuZCIsImJvdW5kc19jcm9zc2VkIiwibG93ZXIiLCJ1cHBlciIsImxvd2VyJDAiLCJ1cHBlciQwIiwiY29tcGFyZV90b19pbnRlcnZhbF9leG4iLCJpbnRlcnZhbF9jb250YWluc19leG4iLCJlcnJvcl9zb3VyY2VfMDU3IiwicmlnaHRfMDA0IiwibGVmdF8wMDMiLCJyaWdodF8wMDgiLCJsZWZ0XzAwNyIsIm9mX2FfMDA5Iiwidl8wMTAiLCJjbXBfayIsImNtcF92IiwidF8wMTQiLCJ0XzAxMyIsInRfMDE2IiwidF8wMTUiLCJyaWdodF8wMTgiLCJsZWZ0XzAxNyIsInJpZ2h0XzAyMiIsImxlZnRfMDIxIiwidF8wMjQiLCJ0XzAyMyIsInRfMDI2IiwidF8wMjUiLCJyaWdodF8wMjAiLCJsZWZ0XzAxOSIsInRfMDMwIiwidF8wMjkiLCJ0XzAzMiIsInRfMDMxIiwicmlnaHRfMDM0IiwibGVmdF8wMzMiLCJyaWdodF8wMzgiLCJsZWZ0XzAzNyIsInRfMDQwIiwidF8wMzkiLCJ0XzA0MiIsInRfMDQxIiwicmlnaHRfMDM2IiwibGVmdF8wMzUiLCJvZl9rXzA0MyIsIm9mX3ZfMDQ0Iiwic2V4cF8wNzEiLCJhcmcxXzA2OCIsImFyZzBfMDY3IiwicmVzMF8wNjkiLCJhdG9tXzA0NyIsInNleHBfYXJnc18wNTAiLCJhdG9tXzA0NyQwIiwiYXJnMF8wNTgiLCJyZXMwXzA1OSIsImFyZzBfMDYxIiwicmVzMF8wNjIiLCJhcmcwXzA2NCIsInJlczBfMDY1IiwicmVzMV8wNzAiLCJvZl9rXzA3MiIsIm9mX3ZfMDczIiwiYXJnMV8wODIiLCJhcmcwXzA4MSIsInJlczBfMDgzIiwidl8wNzQiLCJyZXMxXzA4NCIsInZfMDc2IiwiYXJnMV8wNzgiLCJhcmcwXzA3NyIsInJlczBfMDc5IiwicmVzMV8wODAiLCJ2XzA3NSIsImtfc2V4cF9ncmFtbWFyIiwidl9zZXhwX2dyYW1tYXIiLCJjbXBfbGVmdCIsImNtcF9yaWdodCIsImFfMDg1IiwiYl8wODYiLCJyaWdodF8wOTIiLCJsZWZ0XzA5MSIsInRfMDk0IiwidF8wOTMiLCJ0XzA5NiIsInRfMDk1IiwicmlnaHRfMDg4IiwibGVmdF8wODciLCJyaWdodF8wOTAiLCJsZWZ0XzA4OSIsImFfMDk3IiwiYl8wOTgiLCJyaWdodF8xMDQiLCJsZWZ0XzEwMyIsInRfMTA2IiwidF8xMDUiLCJ0XzEwOCIsInRfMTA3IiwicmlnaHRfMTAwIiwibGVmdF8wOTkiLCJyaWdodF8xMDIiLCJsZWZ0XzEwMSIsIm9mX2xlZnRfMTA5Iiwib2ZfcmlnaHRfMTEwIiwidl8xMTMiLCJhcmcxXzExNSIsImFyZzBfMTE0IiwicmVzMF8xMTYiLCJyZXMxXzExNyIsInZfMTExIiwidl8xMTIiLCJzZXhwX29mX3QkMyIsImhlaWdodCIsImluX3JhbmdlIiwiaGwiLCJociIsImxvd2VyJDEiLCJpbnZhcmlhbnRzIiwiaCQxIiwiaCQwIiwic2wiLCJzciIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayIsImtsIiwiayQxIiwia2wkMCIsImskMiIsImtyIiwibGVmdF9sZW5ndGgiLCJyaWdodF9sZW5ndGgiLCJvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIiwiYXJyYXlfbGVuZ3RoIiwib2Zfc29ydGVkX2FycmF5IiwiaW5jcmVhc2luZyIsImJhbCIsImxyIiwibHYiLCJsbCIsImxyciIsImxydiQwIiwibHJsIiwibHJ2IiwicnIiLCJydiIsInJsIiwicmxyIiwicmx2JDAiLCJybGwiLCJybHYiLCJhdXgiLCJsaCIsImx2JDAiLCJyaCIsInJ2JDAiLCJtaW5fZWx0X2V4biIsImZvbGRfdW50aWxfaGVscGVyIiwidmFsdWUkMCIsIm1heF9lbHRfZXhuIiwicmVtb3ZlX21pbl9lbHQiLCJtYXliZV9lbHQiLCJtYXliZV9lbHQkMCIsImVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3RpbyIsInJlbW92ZV9pbmRleCIsImxfc2l6ZSIsInVuaW9uIiwidjEkMCIsInYyJDAiLCJyMiQwIiwicjEkMCIsInVuaW9uX2xpc3QiLCJ0b190cmVlIiwiaW50ZXIiLCJvdGhlcl9zZXQiLCJlJDEiLCJjb25zX3JpZ2h0Iiwib2Zfc2V0IiwiZW51bSQwIiwidHJlZSIsInN5bW1ldHJpY19kaWZmIiwiZWx0JDAiLCJlbnVtMSIsInRyZWUxIiwiZW51bTIiLCJ0cmVlMiIsImNvbXBhcmVfcmVzdWx0IiwibmV4dF9zdGF0ZSIsImdyZWF0ZXJfb3JfZXF1YWxfdG8iLCJsZXNzX29yX2VxdWFsX3RvIiwiaW5jbHVzaXZlX2JvdW5kIiwic2lkZSIsIm1heWJlIiwidiQxIiwidiQyIiwidiQzIiwidiQ0IiwiZSQyIiwiaW5pdCQwIiwibWVyZ2VfdG9fc2VxdWVuY2UiLCJlMiQyIiwiZTEkMiIsImUyJDAiLCJlMSQwIiwiZTIkMSIsImUxJDEiLCJ0MiQyIiwidDEkMiIsImlzX3N1YnNldCIsImFyZV9kaXNqb2ludCIsImFjY3UkMCIsImFjY3UkMSIsImZpbHQiLCJwYXJ0IiwiZWxlbWVudHNfYXV4IiwiZWxlbWVudHMiLCJjaG9vc2UiLCJjaG9vc2VfZXhuIiwicG9zX3JlZiIsImdyb3VwX2J5IiwiZXF1aXYiLCJzZXQkMCIsImVxdWl2X2NsYXNzZXMiLCJub3RfZXF1aXZfeCIsImVxdWl2X3giLCJlcXVpdl9jbGFzc2VzJDAiLCJzdGFibGVfZGVkdXBfbGlzdCIsImxlZnRvdmVycyIsImFscmVhZHlfc2VlbiIsImFscmVhZHlfc2VlbiQwIiwibGVmdG92ZXJzJDAiLCJ0X29mX3NleHBfZGlyZWN0IiwiZWx0X2xzdCIsImVsX3NleHAiLCJpc19zdWJzZXQkMCIsInN1YnNldCIsInN1cGVyc2V0Iiwic2V4cF9vZl9lbHQiLCJpbnZhbGlkX2VsZW1lbnRzIiwiaW52YWxpZF9lbGVtZW50c19zZXhwIiwibGlrZSIsImludmFyaWFudHMkMCIsImVsZW1lbnRzJDAiLCJtaW5fZWx0X2V4biQwIiwibWF4X2VsdF9leG4kMCIsImNob29zZSQwIiwiY2hvb3NlX2V4biQwIiwiZm9sZF9yaWdodCQwIiwiaXRlcjIkMCIsImZpbHRlciQwIiwiYWRkJDAiLCJyZW1vdmUkMCIsInVuaW9uJDAiLCJpbnRlciQwIiwiZGlmZiQwIiwic3ltbWV0cmljX2RpZmYkMCIsImNvbXBhcmVfZGlyZWN0IiwiaXNfc3Vic2V0JDEiLCJvZiIsImFyZV9kaXNqb2ludCQwIiwidG9fbmFtZWRfdHJlZSIsImlzX3N1YnNldCQyIiwicGFydGl0aW9uX3RmJDAiLCJ0cmVlX2YiLCJ0cmVlX3QiLCJncm91cF9ieSQwIiwibnRoJDAiLCJyZW1vdmVfaW5kZXgkMCIsInRvX3NlcXVlbmNlJDAiLCJiaW5hcnlfc2VhcmNoJDAiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQwIiwibWVyZ2VfdG9fc2VxdWVuY2UkMCIsImhhc2hfZm9sZF9kaXJlY3QiLCJ0X29mX3NleHBfZGlyZWN0JDAiLCJpbnZhcmlhbnRzJDEiLCJpc19lbXB0eSQxIiwiZWxlbWVudHMkMSIsIm1pbl9lbHQkMSIsIm1pbl9lbHRfZXhuJDEiLCJtYXhfZWx0JDEiLCJtYXhfZWx0X2V4biQxIiwiY2hvb3NlJDEiLCJjaG9vc2VfZXhuJDEiLCJ0b19saXN0JDEiLCJ0b19hcnJheSQxIiwiaXRlciQyIiwiZXhpc3RzJDEiLCJmb3JfYWxsJDEiLCJjb3VudCQxIiwic3VtJDEiLCJmaW5kJDEiLCJmaW5kX2V4biQxIiwiZmluZF9tYXAkMSIsImZvbGQkMSIsImZvbGRfdW50aWwkMSIsImZvbGRfcmlnaHQkMSIsImZpbHRlciQxIiwiZmlsdGVyX21hcCQwIiwicGFydGl0aW9uX3RmJDEiLCJpdGVyMiQxIiwibWVtJDEiLCJhZGQkMSIsInJlbW92ZSQxIiwidW5pb24kMSIsImludGVyJDEiLCJkaWZmJDEiLCJzeW1tZXRyaWNfZGlmZiQxIiwiY29tcGFyZV9kaXJlY3QkMCIsImlzX3N1YnNldCQzIiwiYXJlX2Rpc2pvaW50JDEiLCJvZl9saXN0JDAiLCJvZl9zZXF1ZW5jZSQwIiwib2ZfYXJyYXkkMCIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkMCIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQwIiwib2Zfc29ydGVkX2FycmF5JDAiLCJ1bmlvbl9saXN0JDAiLCJzdGFibGVfZGVkdXBfbGlzdCQwIiwiZ3JvdXBfYnkkMSIsInNwbGl0JDEiLCJudGgkMSIsInJlbW92ZV9pbmRleCQxIiwib2ZfdHJlZSIsInRvX3NlcXVlbmNlJDEiLCJiaW5hcnlfc2VhcmNoJDEiLCJiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCQxIiwibWVyZ2VfdG9fc2VxdWVuY2UkMSIsImlzX3N1YnNldCQ0IiwidG9fdHJlZSQwIiwib2ZfdHJlZSQwIiwidF9vZl9zZXhwX2RpcmVjdCQxIiwiZW1wdHkkMCIsInNpbmdsZXRvbiQwIiwidW5pb25fbGlzdCQxIiwib2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCQxIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrJDEiLCJvZl9zb3J0ZWRfYXJyYXkkMSIsIm9mX2xpc3QkMSIsIm9mX3NlcXVlbmNlJDEiLCJvZl9hcnJheSQxIiwic3RhYmxlX2RlZHVwX2xpc3QkMSIsImZpbHRlcl9tYXAkMSIsImNvbXBhcmF0b3JfcyIsImVtcHR5JDEiLCJzaW5nbGV0b24kMSIsInVuaW9uX2xpc3QkMiIsIm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQkMiIsIm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVjayQyIiwib2Zfc29ydGVkX2FycmF5JDIiLCJvZl9saXN0JDIiLCJvZl9zZXF1ZW5jZSQyIiwib2ZfYXJyYXkkMiIsInN0YWJsZV9kZWR1cF9saXN0JDIiLCJmaWx0ZXJfbWFwJDIiLCJzZXhwX29mX21fdCIsIkVsdCIsIm1fdF9vZl9zZXhwIiwibV90X3NleHBfZ3JhbW1hciIsImNvbXBhcmVfbV90IiwiZXF1YWxfbV90IiwiaGFzaF9mb2xkX21fdCIsImhhc2hfbV90IiwiY29tcGFyYXRvciQwIiwiZW1wdHkkMiIsInNpbmdsZXRvbiQyIiwidW5pb25fbGlzdCQzIiwib2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCQzIiwib2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrJDMiLCJvZl9zb3J0ZWRfYXJyYXkkMyIsIm9mX2xpc3QkMyIsIm9mX3NlcXVlbmNlJDMiLCJvZl9hcnJheSQzIiwic3RhYmxlX2RlZHVwX2xpc3QkMyIsIm1hcCQzIiwiZmlsdGVyX21hcCQzIiwib2ZfdHJlZSQxIiwidG9fdHJlZSQxIiwicmVwbGFjZSIsInNldF90ZW1wb3JhcmlseSIsInJlc3RvcmVfdG8iLCJzZXRzIiwic25hcHNob3QiLCJzZXRzX3RlbXBvcmFyaWx5IiwiYW5kX3ZhbHVlcyIsImluY19udW1fbXV0YXRpb25zIiwiZWx0c19pbmRleCIsImNoZWNrX2luZGV4X2V4biIsImVuc3VyZV9ub19tdXRhdGlvbiIsIm51bV9tdXRhdGlvbnMiLCJudW1fbXV0YXRpb25zXzAwMyIsImZyb250XzAwNSIsIm1hc2tfMDA3IiwibGVuZ3RoXzAwOSIsImVsdHNfMDExIiwiYm5kc18wMDIkMSIsImJuZHNfMDAyJDIiLCJibmRzXzAwMiQzIiwibXV0MiIsIm11dDEiLCJmcm9udCIsImNhcGFjaXR5JDAiLCJjYXBhY2l0eSQxIiwiYmxpdF90b19hcnJheSIsImZyb250X2xlbiIsInJlc3RfbGVuIiwiZGVzaXJlZF9jYXBhY2l0eSIsImVucXVldWUiLCJkZXF1ZXVlX25vbmVtcHR5IiwiZGVxdWV1ZV9leG4iLCJkZXF1ZXVlIiwiZnJvbnRfbm9uZW1wdHkiLCJsYXN0X25vbmVtcHR5IiwicGVlayIsInBlZWtfZXhuIiwiYmxpdF90cmFuc2ZlciIsImxlbiQxIiwiZHN0X3N0YXJ0Iiwic3JjX2kiLCJkc3RfaSIsImVucXVldWVfYWxsIiwidF9yZXN1bHQiLCJmaWx0ZXJfaW5wbGFjZSIsImZpbHRlcmlfaW5wbGFjZSIsInVucmVhY2hhYmxlX2NvZGUiLCJ6ZXJvJDAiLCJ6ZXJvJDEiLCJ0b19pbnRfdHJ1bmMiLCJ0b19pbnQzMl90cnVuYyIsIm9mX2ludDY0X3RydW5jIiwibmFtZSQwIiwib2ZfY29udGludWVfb3Jfc3RvcCIsInRvX2NvbnRpbnVlX29yX3N0b3AiLCJsZWZ0X3ZhbHVlIiwicmlnaHRfdmFsdWUiLCJ2YWx1ZXMiLCJsZWZ0X2RlZmF1bHQiLCJyaWdodF9kZWZhdWx0IiwicmlnaHQkMCIsImNvbXBhcmVfa2V5IiwidmwiLCJ2bCQwIiwidnIiLCJrMCIsImsxIiwibGQiLCJscmQiLCJscmQkMCIsInJkIiwicmxkIiwicmxkJDAiLCJyYWlzZV9rZXlfYWxyZWFkeV9wcmVzZW50Iiwic2V4cF9vZl9rZXkiLCJmaW5kX2FuZF9hZGRfb3Jfc2V0IiwiZGF0YSIsImFkZF9vcl9zZXQiLCJkJDAiLCJhZGRfZXhuIiwiYWRkX2V4bl9pbnRlcm5hbCIsInNpbmdsZXRvbl90b190cmVlX2V4biIsImNvbGxhcHNlIiwiZ28iLCJhZGRfdW5jaGVja2VkIiwiZ28kMCIsInRvX3RyZWVfdW5jaGVja2VkIiwibWF4X2tleSIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UiLCJidWlsZGVyIiwicHJldl9rZXkiLCJqb2luJDAiLCJsZCQwIiwibGskMCIsInJrIiwicmQkMCIsInJrJDAiLCJsayIsImNtcCQwIiwibWF5YmUkMCIsInNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSIsImludG8iLCJib3VuZGFyeV9vcHQiLCJpbnNlcnRfaW50byIsInNwbGl0X3JhbmdlIiwibWlkX2FuZF9yaWdodCIsImxiJDEiLCJsYiQyIiwibWlkX2FuZF9yaWdodCQwIiwibGIiLCJsYiQwIiwibWlkJDAiLCJhZGRfbXVsdGkiLCJkYXRhJDAiLCJmaW5kX211bHRpIiwibG93ZXJfcGFydCIsInVwcGVyX3BhcnQiLCJtaW5fdXBwZXIiLCJtYXhfbG93ZXIiLCJ1cHBlcl9wYXJ0X3dpdGhvdXRfbWluIiwiZ28kMSIsImNfbWluIiwiaW5pdCQxIiwiY19tYXgiLCJpbml0JDIiLCJmb2xkX3JhbmdlX2luY2x1c2l2ZSIsInJhbmdlX3RvX2FsaXN0IiwiY29uY2F0X3VuY2hlY2tlZCIsInJlbW92ZV9sb29wIiwiY2hhbmdlIiwiY2hhbmdlX2NvcmUiLCJkJDEiLCJsZW5ndGgkMiIsImxlbmd0aCQzIiwidXBkYXRlIiwidXBkYXRlX2NvcmUiLCJyZW1vdmVfbXVsdGkiLCJub25fZW1wdHlfdGFpbCIsIml0ZXJfa2V5cyIsIml0ZXJpX3VudGlsX2xvb3AiLCJpdGVyaV91bnRpbCIsImZvbGRfdW50aWxfbG9vcCIsImZpbmFsJDEiLCJmaW5hbCQwIiwiZmlsdGVyX2tleXMiLCJwYXJ0aXRpb25fbWFwaSIsInBhaXIyIiwicGFpcjEiLCJjdXJyIiwiazIiLCJuZXh0JDEiLCJkYXRhX2VxdWFsIiwia2V5c19ncmVhdGVyX29yX2VxdWFsX3RvIiwia2V5c19sZXNzX29yX2VxdWFsX3RvIiwiZCQyIiwiY29tcGFyZV9kYXRhIiwiZDIiLCJkMSIsImZvbGQyJDAiLCJmb2xkX3N5bW1ldHJpY19kaWZmIiwiZGVsdGEiLCJhY2MkMyIsImFjYyQ0IiwiYWNjJDUiLCJhY2MkNiIsImFjYyQ3IiwicmlnaHQkMiIsImxlZnQkMiIsInJpZ2h0JDEiLCJrZXlzIiwib2ZfZm9sZGFibGVfZm9sZCIsImZvbGRhYmxlIiwicHJldl9kYXRhIiwib2ZfZm9sZGFibGVfcmVkdWNlIiwibmV3X2RhdGEiLCJvZl9mb2xkYWJsZSIsIm9mX2ZvbGRhYmxlX29yX2Vycm9yIiwib2ZfZm9sZGFibGVfZXhuIiwib2ZfYWxpc3RfZm9sZCIsIm9mX2FsaXN0X3JlZHVjZSIsIm9mX2FsaXN0Iiwib2ZfYWxpc3Rfb3JfZXJyb3IiLCJvZl9hbGlzdF9leG4iLCJvZl9mb2xkYWJsZV9tdWx0aSIsIm9mX2FsaXN0X211bHRpIiwiZm9sZCQyIiwib2Zfc2VxdWVuY2VfZm9sZCIsIm9mX3NlcXVlbmNlX3JlZHVjZSIsIm9mX3NlcXVlbmNlX29yX2Vycm9yIiwib2Zfc2VxdWVuY2VfZXhuIiwib2Zfc2VxdWVuY2VfbXVsdGkiLCJ0b19hbGlzdCIsImtleV9vcmRlciIsIm1lcmdlX2xhcmdlX2ZpcnN0IiwibGVuZ3RoX2xhcmdlIiwidF9sYXJnZSIsInRfc21hbGwiLCJtZXJnZV9za2V3ZWQiLCJsZW5ndGgxIiwibGVuZ3RoMiIsInJlcGFja2FnZSIsIm1hcmtlciIsImNsb3Nlc3Rfa2V5IiwiZm91bmRfbWFya2VyIiwiZm91bmRfa2V5IiwiZm91bmRfdmFsdWUiLCJmb3VuZF92YWx1ZSQwIiwiZm91bmRfa2V5JDAiLCJyYW5rIiwibnVtX3RvX3NlYXJjaCIsInBhaXIiLCJwYWlyJDAiLCJiaW5hcnlfc2VhcmNoX29uZV9zaWRlZF9ib3VuZCIsIm1heWJlX2JvdW5kIiwiaWZfZXhjbHVzaXZlIiwiaWZfaW5jbHVzaXZlIiwiZmluZF9ib3VuZCIsImJvdW5kJDAiLCJiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMiLCJsb3dlcl9ib3VuZCQwIiwidXBwZXJfYm91bmQkMCIsIm9mX2l0ZXJpIiwib2ZfaXRlcmlfZXhuIiwia2V5X29mX3NleHAiLCJ2YWx1ZV9vZl9zZXhwIiwiYWxpc3Rfc2V4cHMiLCJmb3VuZF9maXJzdF9rIiwiazJfc2V4cCIsInNleHBfb2ZfdmFsdWUiLCJlcnJvcl90cmVlIiwib2tzIiwibWFwX2tleXMiLCJtYXBfa2V5c19leG4iLCJsaWtlMiIsImxpa2VfbWF5YmVfbm9fb3AiLCJvbGRfdCIsIm9sZF90cmVlIiwid2l0aF9zYW1lX2xlbmd0aCIsInNldCQxIiwiYWRkX2V4biQwIiwiYWRkX211bHRpJDAiLCJyZW1vdmVfbXVsdGkkMCIsImZpbmRfbXVsdGkkMCIsImNoYW5nZSQwIiwidXBkYXRlJDAiLCJpdGVyX2tleXMkMCIsIml0ZXJpX3VudGlsJDAiLCJmb2xkJDMiLCJmb2xkMiQxIiwiZmlsdGVyX2tleXMkMCIsImZpbHRlcmkkMCIsImZpbHRlcl9tYXBpJDAiLCJwYXJ0aXRpb25fbWFwaSQwIiwicGFydGl0aW9uX21hcCQwIiwicGFydGl0aW9uaV90ZiQwIiwiY29tYmluZV9lcnJvcnMkMCIsImtleXMkMCIsInRvX2FsaXN0JDAiLCJmb2xkX3N5bW1ldHJpY19kaWZmJDAiLCJtZXJnZSQwIiwibWVyZ2Vfc2tld2VkJDAiLCJib3RoX2xlbiIsInN1YnJhbmdlIiwiaF9sIiwiaF9yIiwib3V0ZXJfam9pbmVkX2hlaWdodCIsIm1pZF9sZW5ndGgiLCJhcHBlbmQkMCIsImZvbGRfcmFuZ2VfaW5jbHVzaXZlJDAiLCJyYW5nZV90b19hbGlzdCQwIiwiY2xvc2VzdF9rZXkkMCIsInJhbmskMCIsInNleHBfb2ZfayIsInNleHBfb2ZfdiIsImhhc2hfZm9sZF9rZXkiLCJoYXNoX2ZvbGRfZGF0YSIsImJpbmFyeV9zZWFyY2hfc3VicmFuZ2UiLCJvZl9hbGlzdCQwIiwib2ZfYWxpc3Rfb3JfZXJyb3IkMCIsIm9mX2FsaXN0X2V4biQwIiwib2ZfYWxpc3RfbXVsdGkkMCIsIm9mX2FsaXN0X2ZvbGQkMCIsIm9mX2FsaXN0X3JlZHVjZSQwIiwib2ZfaXRlcmkkMCIsIm9mX2l0ZXJpX2V4biQwIiwicmVxdWlyZWRfYnlfaW50ZiIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMCIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDAiLCJvZl9zZXF1ZW5jZV9leG4kMCIsIm9mX3NlcXVlbmNlX211bHRpJDAiLCJvZl9zZXF1ZW5jZV9mb2xkJDAiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMCIsInNldCQyIiwiYWRkX2V4biQxIiwiYWRkX211bHRpJDEiLCJyZW1vdmVfbXVsdGkkMSIsImZpbmRfbXVsdGkkMSIsImNoYW5nZSQxIiwidXBkYXRlJDEiLCJpdGVyX2tleXMkMSIsIml0ZXJpX3VudGlsJDEiLCJtYXBpJDEiLCJmb2xkJDQiLCJmb2xkMiQyIiwiZmlsdGVyX2tleXMkMSIsImZpbHRlcmkkMSIsImZpbHRlcl9tYXBpJDEiLCJwYXJ0aXRpb25fbWFwaSQxIiwicGFydGl0aW9uX21hcCQxIiwicGFydGl0aW9uaV90ZiQxIiwiY29tYmluZV9lcnJvcnMkMSIsImtleXMkMSIsImRhdGEkMSIsInRvX2FsaXN0JDEiLCJmb2xkX3N5bW1ldHJpY19kaWZmJDEiLCJtZXJnZSQxIiwibWVyZ2Vfc2tld2VkJDEiLCJmb3JfYWxsaSQxIiwiZXhpc3RzaSQxIiwiY291bnRpJDEiLCJhcHBlbmQkMSIsInN1YnJhbmdlJDAiLCJmb2xkX3JhbmdlX2luY2x1c2l2ZSQxIiwicmFuZ2VfdG9fYWxpc3QkMSIsImNsb3Nlc3Rfa2V5JDEiLCJudGgkMiIsIm50aF9leG4kMCIsInJhbmskMSIsImtfb2Zfc2V4cCIsInZfb2Zfc2V4cCIsImJpbmFyeV9zZWFyY2hfc3VicmFuZ2UkMCIsIm1hcF9rZXlzJDAiLCJkdXAiLCJtYXBfa2V5c19leG4kMCIsImFkZF9leG4kMiIsIm9mX3RyZWUwIiwib2ZfdHJlZSQyIiwib2ZfYWxpc3QkMSIsIm9mX2FsaXN0X29yX2Vycm9yJDEiLCJvZl9hbGlzdF9leG4kMSIsIm9mX2FsaXN0X211bHRpJDEiLCJvZl9hbGlzdF9mb2xkJDEiLCJvZl9hbGlzdF9yZWR1Y2UkMSIsIm9mX2l0ZXJpJDEiLCJ0cmVlX2xlbmd0aCIsIm9mX2l0ZXJpX2V4biQxIiwib2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSQxIiwib2Zfc2VxdWVuY2Vfb3JfZXJyb3IkMSIsIm9mX3NlcXVlbmNlX2V4biQxIiwib2Zfc2VxdWVuY2VfbXVsdGkkMSIsIm9mX3NlcXVlbmNlX2ZvbGQkMSIsIm9mX3NlcXVlbmNlX3JlZHVjZSQxIiwibWFwX2tleXMkMSIsIm1hcF9rZXlzX2V4biQxIiwib2ZfdHJlZSQzIiwib2ZfYWxpc3QkMiIsIm9mX2FsaXN0X29yX2Vycm9yJDIiLCJvZl9hbGlzdF9leG4kMiIsIm9mX2FsaXN0X211bHRpJDIiLCJvZl9hbGlzdF9mb2xkJDIiLCJvZl9hbGlzdF9yZWR1Y2UkMiIsIm9mX2l0ZXJpJDIiLCJvZl9pdGVyaV9leG4kMiIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMiIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDIiLCJvZl9zZXF1ZW5jZV9leG4kMiIsIm9mX3NlcXVlbmNlX211bHRpJDIiLCJvZl9zZXF1ZW5jZV9mb2xkJDIiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMiIsIm1hcF9rZXlzJDIiLCJtYXBfa2V5c19leG4kMiIsIksiLCJ2X2dyYW1tYXIiLCJjb21wYXJlX3YiLCJlcXVhbF92IiwiaGFzaF9mb2xkX3YiLCJvZl90cmVlJDQiLCJlbXB0eSQzIiwib2ZfYWxpc3QkMyIsIm9mX2FsaXN0X29yX2Vycm9yJDMiLCJvZl9hbGlzdF9leG4kMyIsIm9mX2FsaXN0X211bHRpJDMiLCJvZl9hbGlzdF9mb2xkJDMiLCJvZl9hbGlzdF9yZWR1Y2UkMyIsIm9mX2l0ZXJpJDMiLCJvZl9pdGVyaV9leG4kMyIsIm9mX2luY3JlYXNpbmdfc2VxdWVuY2UkMyIsIm9mX3NlcXVlbmNlX29yX2Vycm9yJDMiLCJvZl9zZXF1ZW5jZV9leG4kMyIsIm9mX3NlcXVlbmNlX211bHRpJDMiLCJvZl9zZXF1ZW5jZV9mb2xkJDMiLCJvZl9zZXF1ZW5jZV9yZWR1Y2UkMyIsIm1hcF9rZXlzJDMiLCJtYXBfa2V5c19leG4kMyIsInRyYW5zZmVyIiwicSIsInEkMCIsImZsb2F0X29mX2JpdHMiLCJiaXRzX29mX2Zsb2F0IiwiYnN3YXAxNiIsImJzd2FwMzIiLCJic3dhcDQ4IiwidG9fbmF0aXZlaW50X2V4biIsIndyYXBfZXhuIiwid3JhcF9tb2R1bG8iLCJ1bndyYXAiLCJjbHoiLCJjdHoiLCJpbnZhbGlkX3N0ciIsInNpZ25lZG5lc3MiLCJwb3Nfc3RyIiwiaW50NjMiLCJpbnQ2MyQwIiwib25lJDAiLCJvZl9uYXRpdmVpbnRfdHJ1bmMiLCJ0b19uYXRpdmVpbnRfdHJ1bmMiLCJ0b19zdHJpbmckMSIsInJlcHIiLCJvZl9pbnRfdHJ1bmMiLCJyZXByJDAiLCJpbmNsdWRlIiwib2ZfZmxvYXQkMCIsInRvX2Zsb2F0JDAiLCJvZl9pbnRfZXhuJDAiLCJ0b19pbnRfZXhuJDAiLCJwcCQwIiwiaGFzaGFibGUkMCIsImlzX3Bvc2l0aXZlJDAiLCJpc19ub25fbmVnYXRpdmUkMCIsImlzX25lZ2F0aXZlJDAiLCJpc19ub25fcG9zaXRpdmUkMCIsInNpZ24kMCIsImludmFyaWFudCQwIiwidG9fc3RyaW5nX2h1bSQwIiwibWludXNfb25lJDAiLCJyZW0kMCIsInJvdW5kJDAiLCJyb3VuZF90b3dhcmRzX3plcm8kMCIsInJvdW5kX2Rvd24kMCIsInJvdW5kX3VwJDAiLCJyb3VuZF9uZWFyZXN0JDAiLCJzdWNjJDAiLCJwcmVkJDAiLCJwb3ckMCIsImJpdF9hbmQkMCIsImJpdF9vciQwIiwiYml0X3hvciQwIiwiYml0X25vdCQwIiwicG9wY291bnQkMCIsInNoaWZ0X2xlZnQkMCIsInNoaWZ0X3JpZ2h0JDAiLCJkZWNyJDAiLCJpbmNyJDAiLCJvZl9pbnQzMl9leG4kMCIsInRvX2ludDMyX2V4biQwIiwib2ZfaW50NjRfZXhuJDAiLCJ0b19pbnQ2NCQwIiwib2ZfbmF0aXZlaW50X2V4biQwIiwidG9fbmF0aXZlaW50X2V4biQwIiwibnVtX2JpdHMkMCIsIm1heF92YWx1ZSQwIiwibWluX3ZhbHVlJDAiLCJzaGlmdF9yaWdodF9sb2dpY2FsJDAiLCJjZWlsX3BvdzIkMCIsImZsb29yX3BvdzIkMCIsImNlaWxfbG9nMiQwIiwiaXNfcG93MiQwIiwiY2x6JDAiLCJjdHokMCIsIm9mX2ludCQwIiwidG9faW50JDAiLCJ0b19pbnRfdHJ1bmMkMCIsInRvX2ludDMyJDAiLCJvZl9pbnQ2NCQwIiwib2ZfbmF0aXZlaW50JDAiLCJ0b19uYXRpdmVpbnQkMCIsInRvX25hdGl2ZWludF90cnVuYyQwIiwib2ZfZmxvYXRfdW5jaGVja2VkJDAiLCJyZXByJDEiLCJic3dhcDMyJDAiLCJic3dhcDQ4JDAiLCJwb3NfZGlmZiIsIm5lZ2F0aXZlX29uZSIsImRpdl93b3VsZF9vdmVyZmxvdyIsInByb2R1Y3QiLCJhYnMkMSIsIm5lZyQwIiwicmFuZG9tX29mX2ludCIsInJhbmRvbV9vZl9pbnQ2NCIsInJhbmRvbV9vZl9pbnQkMCIsInJhbmRvbV9pbmNsX29mX2ludCIsInJhbmRvbV9pbmNsX29mX2ludDY0IiwicmFuZG9tX2luY2wiLCJmbG9vcl9sb2cyJDAiLCJpbnYiLCJsZWZ0X2tleSIsInJpZ2h0X2tleSIsInVwZGF0ZV9oZWlnaHQiLCJvbGRfaGVpZ2h0IiwibmV3X2hlaWdodCIsImJhbGFuY2UiLCJyb290X25vZGUiLCJsZWZ0X25vZGUiLCJyaWdodF9ub2RlIiwibGVmdF9ub2RlX2xlZnQiLCJsZWZ0X25vZGVfcmlnaHQiLCJscl9sZWZ0IiwibHJfcmlnaHQiLCJyaWdodF9ub2RlX2xlZnQiLCJyaWdodF9ub2RlX3JpZ2h0IiwicmxfbGVmdCIsInJsX3JpZ2h0Iiwic2V0X2xlZnQiLCJub2RlIiwidHJlZSQwIiwic2V0X3JpZ2h0IiwiYWRkZWQiLCJmaW5kaV9hbmRfY2FsbF9pbXBsIiwiYXJnMSIsImFyZzIiLCJjYWxsX2lmX2ZvdW5kIiwiY2FsbF9pZl9ub3RfZm91bmQiLCJmaW5kX2FuZF9jYWxsIiwiY2FsbF9pZl9mb3VuZCQwIiwiY2FsbF9pZl9ub3RfZm91bmQkMCIsImZpbmRpX2FuZF9jYWxsIiwiY2FsbF9pZl9mb3VuZCQxIiwiY2FsbF9pZl9ub3RfZm91bmQkMSIsImZpbmRfYW5kX2NhbGwxIiwiY2FsbF9pZl9mb3VuZCQyIiwiY2FsbF9pZl9ub3RfZm91bmQkMiIsImZpbmRpX2FuZF9jYWxsMSIsImNhbGxfaWZfZm91bmQkMyIsImNhbGxfaWZfbm90X2ZvdW5kJDMiLCJmaW5kX2FuZF9jYWxsMiIsImNhbGxfaWZfZm91bmQkNCIsImNhbGxfaWZfbm90X2ZvdW5kJDQiLCJmaW5kaV9hbmRfY2FsbDIiLCJpZl9mb3VuZCQwIiwiaWZfbm90X2ZvdW5kJDAiLCJyZW1vdmVkIiwia2V5JDQiLCJkYXRhJDQiLCJya2V5IiwicmRhdGEiLCJrZXkkMSIsInJrZXkkMCIsInJkYXRhJDAiLCJsa2V5JDAiLCJsZGF0YSQwIiwia2V5JDMiLCJkYXRhJDMiLCJya2V5JDEiLCJyZGF0YSQxIiwibGtleSIsImxkYXRhIiwia2V5JDIiLCJkYXRhJDIiLCJtYXBpX2lucGxhY2UiLCJlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCIsIndpdGhvdXRfbXV0YXRpbmciLCJtYXhfdGFibGVfbGVuZ3RoIiwiZ3Jvd3RoX2FsbG93ZWQiLCJzaXplJDAiLCJzaXplJDEiLCJzbG90IiwiYWRkX3dvcmtlciIsIm5ld19yb290IiwibWF5YmVfcmVzaXplX3RhYmxlIiwic2hvdWxkX2dyb3ciLCJuZXdfYXJyYXlfbGVuZ3RoIiwibmV3X3RhYmxlIiwib2xkX3RhYmxlIiwic2V4cF9vZl9rZXkkMCIsImFkZGVkX29yX3JlbW92ZWQiLCJidWNrZXQiLCJjaG9vc2Vfbm9uZW1wdHkiLCJ0YWJsZSIsImF2bHRyZWUiLCJpbnZhcmlhbnRfa2V5IiwiaW52YXJpYW50X2RhdGEiLCJyZWFsX2xlbiIsIm5ld190IiwidDAiLCJuZXdfZGF0YSQwIiwiZmluZF9vcl9hZGQiLCJpZCIsImZpbmRpX29yX2FkZCIsImZpbmRfYW5kX3JlbW92ZSIsInVwZGF0ZV9hbmRfcmV0dXJuIiwiaW5jcl9ieSIsInJlbW92ZV9pZl96ZXJvIiwiYnkiLCJjcmVhdGVfbWFwcGVkIiwiZ2V0X2tleSIsImdldF9kYXRhIiwiZHVwZXMiLCJvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMiLCJzZXhwX29mX2RhdGEiLCJkX29mX3NleHAiLCJrX2dyYW1tYXIiLCJyb3ciLCJvbGQiLCJjcmVhdGVfd2l0aF9rZXkiLCJjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IiLCJjcmVhdGVfd2l0aF9rZXlfZXhuIiwibWF5YmVfc2V0IiwidF9sZWZ0IiwidF9yaWdodCIsIm1lcmdlX2ludG8iLCJkc3RfZGF0YSIsImFjdGlvbiIsImRzdF9kYXRhJDAiLCJ0b19yZW1vdmUiLCJmaWx0ZXJfa2V5c19pbnBsYWNlIiwiZmlsdGVyX21hcGlfaW5wbGFjZSIsIm1hcF9yZXN1bHRzIiwiZmlsdGVyX21hcF9pbnBsYWNlIiwic2ltaWxhciIsIm9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyQwIiwiY3JlYXRlX21hcHBlZCQwIiwiY3JlYXRlX3dpdGhfa2V5JDAiLCJjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IkMCIsImNyZWF0ZV93aXRoX2tleV9leG4kMCIsIm9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyQxIiwiY3JlYXRlX21hcHBlZCQxIiwiY3JlYXRlX3dpdGhfa2V5JDEiLCJjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IkMSIsImNyZWF0ZV93aXRoX2tleV9leG4kMSIsImdyb3VwJDEiLCJoYXNoYWJsZV9zIiwicG9seV9oYXNoYWJsZSIsInN0cmljdF9hZGQiLCJzdHJpY3RfYWRkX2V4biIsInN0cmljdF9yZW1vdmUiLCJzdHJpY3RfcmVtb3ZlX2V4biIsInNleHBfb2ZfZSIsImxhcmdlciIsInNtYWxsZXIiLCJvZl9oYXNodGJsX2tleXMiLCJoYXNodGJsIiwidG9faGFzaHRibCIsImVfb2Zfc2V4cCIsIm1pbl9wb3NpdGl2ZV9zdWJub3JtYWxfdmFsdWUiLCJtaW5fcG9zaXRpdmVfbm9ybWFsX3ZhbHVlIiwicGkiLCJzcXJ0X3BpIiwic3FydF8ycGkiLCJldWxlciIsIm9mX2ludDYzIiwiaXJvdW5kX2xib3VuZCIsImlyb3VuZF91Ym91bmQiLCJpcm91bmRfdXAiLCJpcm91bmRfdXBfZXhuIiwiaXJvdW5kX2Rvd24iLCJpcm91bmRfZG93bl9leG4iLCJpcm91bmRfdG93YXJkc196ZXJvIiwiaXJvdW5kX3Rvd2FyZHNfemVyb19leG4iLCJyb3VuZF9uZWFyZXN0X2xiIiwicm91bmRfbmVhcmVzdF91YiIsIm9uZV91bHBfbGVzc190aGFuX2hhbGYiLCJhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCIsImlyb3VuZF9uZWFyZXN0XzMyIiwiaXJvdW5kX25lYXJlc3RfNjQiLCJpcm91bmRfbmVhcmVzdF82NCQwIiwiaXJvdW5kX25lYXJlc3RfZXhuXzMyIiwiaXJvdW5kX25lYXJlc3RfZXhuXzY0IiwiaXJvdW5kX25lYXJlc3RfZXhuIiwiaXJvdW5kX2V4biIsImlyb3VuZCIsImlzX2luZiIsImlzX2Zpbml0ZSIsIm1pbl9pbmFuIiwibWF4X2luYW4iLCJzY2FsZSIsInNxdWFyZSIsImZyYWN0aW9uYWwiLCJpbnRlZ3JhbCIsInJvdW5kX25lYXJlc3RfaW5saW5lIiwicm91bmRfbmVhcmVzdF9oYWxmX3RvX2V2ZW4iLCJjZWlsX29yX3N1Y2MiLCJkaWZmX2Zsb29yIiwiZGlmZl9jZWlsIiwiaW50NjNfcm91bmRfbGJvdW5kIiwiaW50NjNfcm91bmRfdWJvdW5kIiwiaW50NjNfcm91bmRfdXBfZXhuIiwiaW50NjNfcm91bmRfZG93bl9leG4iLCJpbnQ2M19yb3VuZF9uZWFyZXN0X3BvcnRhYmxlX2EiLCJpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2EiLCJpbnQ2M19yb3VuZF9uZWFyZXN0X2V4biIsImNsYXNzaWZ5Iiwic3RyaXBfemVybyIsImRlY2ltYWxzIiwiZXhwbGljaXRfcGx1cyIsInRvX3BhZGRlZF9jb21wYWN0X3N0cmluZ19jdXN0byIsImtpbG8iLCJtZWdhIiwiZ2lnYSIsInRlcmEiLCJwZXRhIiwibWFnIiwibnVtZXJhdG9yIiwiZGVub21pbmF0b3IiLCJoaWdoZXIiLCJkaWZmX3JpZ2h0IiwiZGlmZl9sZWZ0IiwicGV0YSQwIiwidG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nIiwicm91bmRfZ2VuIiwic2QiLCJkZCIsImRkJDAiLCJzZCQwIiwiZGQkMSIsInNkJDEiLCJhYnNfZGQiLCJyb3VuZF9zaWduaWZpY2FudCIsInNpZ25pZmljYW50X2RpZ2l0cyIsInJvdW5kX2RlY2ltYWwiLCJkZWNpbWFsX2RpZ2l0cyIsInNpZ25fZXhuIiwic2lnbl9vcl9uYW4iLCJpZWVlX25lZ2F0aXZlIiwiZXhwb25lbnRfbWFzazY0IiwiZXhwb25lbnRfbWFzayIsIm1hbnRpc3NhX21hc2siLCJtYW50aXNzYV9tYXNrNjQiLCJtYW50aXNzYV9iaXRzIiwiaWVlZV9leHBvbmVudCIsImllZWVfbWFudGlzc2EiLCJjcmVhdGVfaWVlZV9leG4iLCJuZWdhdGl2ZSIsIm1hbnRpc3NhIiwic2lnbl9iaXRzIiwiZXhwdF9iaXRzIiwibWFudF9iaXRzIiwiY3JlYXRlX2llZWUiLCJzcGVjaWFsaXplZF9oYXNoIiwiYWRkX3N1YnN0cmluZyIsImFkZF9zdWJieXRlcyIsImVsaWRlZF9tZXNzYWdlIiwiZWxpZGUiLCJhdF9tb3N0X251bV9mcmFtZXMiLCJ0b19zdHJpbmdfbGlzdCIsInNldF9yZWNvcmRpbmciLCJhbV9yZWNvcmRpbmciLCJtb3N0X3JlY2VudCIsIm1vc3RfcmVjZW50X2Zvcl9leG4iLCJ3aXRoX3JlY29yZGluZyIsInNhdmVkIiwib2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhIiwiYXJyYXlfb2Zfc2V4cCIsInNleHBfb2ZfYXJyYXkiLCJhcnJheV9zZXhwX2dyYW1tYXIiLCJib29sX29mX3NleHAiLCJzZXhwX29mX2Jvb2wiLCJib29sX3NleHBfZ3JhbW1hciIsImNoYXJfb2Zfc2V4cCIsInNleHBfb2ZfY2hhciIsImNoYXJfc2V4cF9ncmFtbWFyIiwic2V4cF9vZl9leG4iLCJmdW5jJDEiLCJmbG9hdF9vZl9zZXhwIiwic2V4cF9vZl9mbG9hdCIsImZsb2F0X3NleHBfZ3JhbW1hciIsImZ1bmMkMiIsImludF9vZl9zZXhwIiwic2V4cF9vZl9pbnQiLCJpbnRfc2V4cF9ncmFtbWFyIiwiZnVuYyQzIiwiaW50MzJfb2Zfc2V4cCIsInNleHBfb2ZfaW50MzIiLCJpbnQzMl9zZXhwX2dyYW1tYXIiLCJmdW5jJDQiLCJpbnQ2NF9vZl9zZXhwIiwic2V4cF9vZl9pbnQ2NCIsImludDY0X3NleHBfZ3JhbW1hciIsImxpc3Rfb2Zfc2V4cCIsInNleHBfb2ZfbGlzdCIsImxpc3Rfc2V4cF9ncmFtbWFyIiwiZnVuYyQ1IiwibmF0aXZlaW50X29mX3NleHAiLCJzZXhwX29mX25hdGl2ZWludCIsIm5hdGl2ZWludF9zZXhwX2dyYW1tYXIiLCJvcHRpb25fb2Zfc2V4cCIsInNleHBfb2Zfb3B0aW9uIiwib3B0aW9uX3NleHBfZ3JhbW1hciIsInJlZl9vZl9zZXhwIiwic2V4cF9vZl9yZWYiLCJyZWZfc2V4cF9ncmFtbWFyIiwic3RyaW5nX29mX3NleHAiLCJzZXhwX29mX3N0cmluZyIsInN0cmluZ19zZXhwX2dyYW1tYXIiLCJjb21wYXJlX2J5dGVzIiwiZXF1YWxfYnl0ZXMiLCJieXRlc19vZl9zZXhwIiwic2V4cF9vZl9ieXRlcyIsImJ5dGVzX3NleHBfZ3JhbW1hciIsImZ1bmMkNiIsInVuaXRfb2Zfc2V4cCIsInNleHBfb2ZfdW5pdCIsInVuaXRfc2V4cF9ncmFtbWFyIiwiZmFpbHdpdGgiLCJpbnZhbGlkX2FyZyIsImNvbXBhcmVfYXJyYXkkMCIsImVxdWFsX2FycmF5JDAiLCJhcnJheV9vZl9zZXhwJDAiLCJzZXhwX29mX2FycmF5JDAiLCJhcnJheV9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfYm9vbCQwIiwiZXF1YWxfYm9vbCQwIiwiaGFzaF9mb2xkX2Jvb2wkMCIsImhhc2hfYm9vbCQwIiwiYm9vbF9vZl9zZXhwJDAiLCJzZXhwX29mX2Jvb2wkMCIsImJvb2xfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX2NoYXIkMCIsImVxdWFsX2NoYXIkMCIsImhhc2hfZm9sZF9jaGFyJDAiLCJoYXNoX2NoYXIkMCIsImNoYXJfb2Zfc2V4cCQwIiwic2V4cF9vZl9jaGFyJDAiLCJjaGFyX3NleHBfZ3JhbW1hciQwIiwic2V4cF9vZl9leG4kMCIsImNvbXBhcmVfZmxvYXQkMCIsImVxdWFsX2Zsb2F0JDAiLCJoYXNoX2ZvbGRfZmxvYXQkMCIsImhhc2hfZmxvYXQkMCIsImZsb2F0X29mX3NleHAkMCIsInNleHBfb2ZfZmxvYXQkMCIsImZsb2F0X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9pbnQkMCIsImVxdWFsX2ludCQwIiwiaGFzaF9mb2xkX2ludCQwIiwiaGFzaF9pbnQkMCIsImludF9vZl9zZXhwJDAiLCJzZXhwX29mX2ludCQwIiwiaW50X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9pbnQzMiQwIiwiZXF1YWxfaW50MzIkMCIsImhhc2hfZm9sZF9pbnQzMiQwIiwiaGFzaF9pbnQzMiQwIiwiaW50MzJfb2Zfc2V4cCQwIiwic2V4cF9vZl9pbnQzMiQwIiwiaW50MzJfc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX2ludDY0JDAiLCJlcXVhbF9pbnQ2NCQwIiwiaGFzaF9mb2xkX2ludDY0JDAiLCJoYXNoX2ludDY0JDAiLCJpbnQ2NF9vZl9zZXhwJDAiLCJzZXhwX29mX2ludDY0JDAiLCJpbnQ2NF9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfbGlzdCQwIiwiZXF1YWxfbGlzdCQwIiwiaGFzaF9mb2xkX2xpc3QkMCIsImxpc3Rfb2Zfc2V4cCQwIiwic2V4cF9vZl9saXN0JDAiLCJsaXN0X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9uYXRpdmVpbnQkMCIsImVxdWFsX25hdGl2ZWludCQwIiwiaGFzaF9mb2xkX25hdGl2ZWludCQwIiwiaGFzaF9uYXRpdmVpbnQkMCIsIm5hdGl2ZWludF9vZl9zZXhwJDAiLCJzZXhwX29mX25hdGl2ZWludCQwIiwibmF0aXZlaW50X3NleHBfZ3JhbW1hciQwIiwiY29tcGFyZV9vcHRpb24kMCIsImVxdWFsX29wdGlvbiQwIiwiaGFzaF9mb2xkX29wdGlvbiQwIiwib3B0aW9uX29mX3NleHAkMCIsInNleHBfb2Zfb3B0aW9uJDAiLCJvcHRpb25fc2V4cF9ncmFtbWFyJDAiLCJjb21wYXJlX3JlZiQwIiwiZXF1YWxfcmVmJDAiLCJyZWZfb2Zfc2V4cCQwIiwic2V4cF9vZl9yZWYkMCIsInJlZl9zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfc3RyaW5nJDAiLCJlcXVhbF9zdHJpbmckMCIsImhhc2hfZm9sZF9zdHJpbmckMCIsImhhc2hfc3RyaW5nJDAiLCJzdHJpbmdfb2Zfc2V4cCQwIiwic2V4cF9vZl9zdHJpbmckMCIsInN0cmluZ19zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfYnl0ZXMkMCIsImVxdWFsX2J5dGVzJDAiLCJieXRlc19vZl9zZXhwJDAiLCJzZXhwX29mX2J5dGVzJDAiLCJieXRlc19zZXhwX2dyYW1tYXIkMCIsImNvbXBhcmVfdW5pdCQwIiwiZXF1YWxfdW5pdCQwIiwiaGFzaF9mb2xkX3VuaXQkMCIsImhhc2hfdW5pdCQwIiwidW5pdF9vZl9zZXhwJDAiLCJzZXhwX29mX3VuaXQkMCIsInVuaXRfc2V4cF9ncmFtbWFyJDAiLCJyYWlzZV9zJDAiLCJwaHlzX2VxdWFsJDAiXSwic291cmNlcyI6WyIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9wb2x5MC5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2ltcG9ydDAubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9wcmludGYubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9zeXMwLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvYXJyYXkwLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvY2hhcjAubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9pbnQwLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvbGlzdDAubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9oYXNoLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvcHB4X2NvbXBhcmVfbGliLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvcHB4X2hhc2hfbGliLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2Uvc2V4cC5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL3dvcmRfc2l6ZS5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL3ByZXR0eV9wcmludGVyLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvZXhuLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2Uvd2l0aF9yZXR1cm4ubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9tb25hZF9pbnRmLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvbW9uYWQubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9hcHBsaWNhdGl2ZS5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2J5dGVzMC5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2NvbXBhcmF0b3IubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9laXRoZXIwLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvZmllbGQubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9zdHJpbmcwLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2Uvc291cmNlX2NvZGVfcG9zaXRpb24wLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvbGlzdDEubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9yZXN1bHQubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9jb250YWluZXJfaW50Zi5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2NvbnRhaW5lci5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2xhenkubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9vcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMC5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL3JhbmRvbV9yZXByLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvcmFuZG9tLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvYXJyYXlfcGVybXV0ZS5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2ZuLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2Uvb3JkZXJpbmcubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9saXN0Lm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvaW5mby5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2Vycm9yLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvaW52YXJpYW50Lm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2Uvb3JfZXJyb3IubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9zaWduMC5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2NvbXBhcmFibGUubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9oYXNoYWJsZV9pbnRmLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvaWRlbnRpZmlhYmxlLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvdW5pdC5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL29yZGVyZWRfY29sbGVjdGlvbl9jb21tb24ubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9iaW5hcnlfc2VhcmNoLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvYmluYXJ5X3NlYXJjaGFibGVfaW50Zi5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2JpbmFyeV9zZWFyY2hhYmxlLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvYmxpdC5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL29wdGlvbi5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL3NleHBhYmxlLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvZWl0aGVyLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvaW5kZXhlZF9jb250YWluZXIubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9zZXF1ZW5jZS5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2FycmF5Lm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2Uvb2JqX2FycmF5Lm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvdW5pZm9ybV9hcnJheS5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2Zsb2F0MC5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2NoYXIubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9wcHhfZW51bWVyYXRlX2xpYi5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2J5dGVzX3RyLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2Uvc3RhZ2VkLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2Uvc3RyaW5nLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvYnl0ZXMubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9oZXhfbGV4ZXIubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9pbnRfY29udmVyc2lvbnMubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9wb3dfb3ZlcmZsb3dfYm91bmRzLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvaW50X21hdGgubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9wb3Bjb3VudC5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL3NpZ24ubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9pbnQubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS91Y2hhci5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL3R5cGVfZXF1YWwubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9vcHRpb25fYXJyYXkubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9zdGFjay5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL3NvdXJjZV9jb2RlX3Bvc2l0aW9uLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2Uvc2lnbl9vcl9uYW4ubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9tYXliZV9ib3VuZC5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL21hcF9pbnRmLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2Uvc2V0X2ludGYubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9zZXQubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9yZWYubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9xdWV1ZS5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL25vdGhpbmcubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9uYXRpdmVpbnQubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9tYXAubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9saW5rZWRfcXVldWUwLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvbGlua2VkX3F1ZXVlLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvaW50NjQubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9pbnQ2M19lbXVsLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvYm9vbC5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2ludDMyLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvaW50NjMubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9oYXNodGJsX2ludGYubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9hdmx0cmVlLm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvaGFzaHRibC5tbCIsIi9ob21lL25hdGhhbi8ub3BhbS9kZWZhdWx0L2xpYi9iYXNlL2hhc2hfc2V0Lm1sIiwiL2hvbWUvbmF0aGFuLy5vcGFtL2RlZmF1bHQvbGliL2Jhc2UvZmxvYXQubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9idWZmZXIubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9iYWNrdHJhY2UubWwiLCIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmFzZS9iYXNlLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7Ozs7Ozs7WUFnQklBLFdBQVdDLEdBQUVDLEdBQUksb0JBQUpBLEdBQUZELEdBQWlCOztJQUM1QkU7SUFDQUM7bUNBRkFKLFlBRUFJLEtBREFEOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dDNEJVOzs7Ozs7SUF2Q1ZFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXVDVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WUF3RlZpRixZQUFhckYsR0FBa0IsT0FBbEJBLEVBQWtDO1lBSy9Dc0YsbUI7T0FDQUM7WUFDQUMsbUI7WUFDQUMsbUI7WUFDQUMsbUI7WUFDQUMsbUI7WUFDQUMsbUI7WUFDQUMsb0I7T0FDQUM7WUFDQUMsb0I7T0FnQkVDO1lBQ0FqRyxXQUFZQyxHQUFTQyxHQUFJLHdCQUFKQSxHQUFURCxHQUF3QjtZQUNwQ2lHLE1BQUtqRyxHQUFTQyxHQUFJLE9BQUpBLEtBQVRELFFBQVNDLEVBQTJCO1lBQ3pD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aXZlcyBmb3IgcG9seW1vcnBoaWMgY29tcGFyZS4gKilcblxuKCpfIFBvbHltb3JwaGljIGNvbXBpbGVyIHByaW1pdGl2ZXMgY2FuJ3QgYmUgYWxpYXNlcyBhcyB0aGlzIGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAgaW5saW5pbmcuIChJZiBhbGlhc2VkIHdpdGhvdXQgYSB0eXBlIGFubm90YXRpb24sIHRoZSBjb21waWxlciB3b3VsZCBpbXBsZW1lbnQgdGhlbVxuICB1c2luZyB0aGUgZ2VuZXJpYyBjb2RlIGRvaW5nIGEgQyBjYWxsLCBhbmQgaXQncyB0aGlzIGNvZGUgdGhhdCB3b3VsZCBiZSBpbmxpbmVkLikgQXMgYVxuICByZXN1bHQgd2UgaGF2ZSB0byBjb3B5IHRoZSBbZXh0ZXJuYWwgLi4uXSBkZWNsYXJhdGlvbiBoZXJlLiAqKVxuZXh0ZXJuYWwgKCA8ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuZXh0ZXJuYWwgKCA8PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG5leHRlcm5hbCAoIDw+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuZXh0ZXJuYWwgKCA+ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZ3JlYXRlcnRoYW5cIlxuZXh0ZXJuYWwgKCA+PSApIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG5leHRlcm5hbCBhc2NlbmRpbmcgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmV4dGVybmFsIGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnQgPSBcIiVjb21wYXJlXCJcbmV4dGVybmFsIGVxdWFsIDogJ2EgLT4gJ2EgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxubGV0IGRlc2NlbmRpbmcgeCB5ID0gY29tcGFyZSB5IHhcbmxldCBtYXggPSBDYW1sLm1heFxubGV0IG1pbiA9IENhbWwubWluXG4iLCIoKiBUaGlzIG1vZHVsZSBpcyBpbmNsdWRlZCBpbiBbSW1wb3J0XS4gIEl0IGlzIGFpbWVkIGF0IG1vZHVsZXMgdGhhdCBkZWZpbmUgdGhlIHN0YW5kYXJkXG4gICBjb21iaW5hdG9ycyBmb3IgW3NleHBfb2ZdLCBbb2Zfc2V4cF0sIFtjb21wYXJlXSBhbmQgW2hhc2hdIGFuZCBhcmUgaW5jbHVkZWQgaW5cbiAgIFtJbXBvcnRdLiAqKVxuXG5pbmNsdWRlIChcbiAgU2hhZG93X3N0ZGxpYiA6XG4gICAgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBTaGFkb3dfc3RkbGliXG4gIGVuZFxuICB3aXRoIHR5cGUgJ2EgcmVmIDo9ICdhIHJlZlxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIGZvcm1hdCA6PSAoJ2EsICdiLCAnYykgZm9ybWF0XG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QpIGZvcm1hdDQgOj0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gIHdpdGggdHlwZSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NiA6PSAoJ2EsICdiLCAnYywgJ2QsICdlLCAnZikgZm9ybWF0NlxuICAoKiBUaGVzZSBtb2R1bGVzIGFyZSByZWRlZmluZWQgaW4gQmFzZSAqKVxuICB3aXRoIG1vZHVsZSBBcnJheSA6PSBTaGFkb3dfc3RkbGliLkFycmF5XG4gIHdpdGggbW9kdWxlIEF0b21pYyA6PSBTaGFkb3dfc3RkbGliLkF0b21pY1xuICB3aXRoIG1vZHVsZSBCb29sIDo9IFNoYWRvd19zdGRsaWIuQm9vbFxuICB3aXRoIG1vZHVsZSBCdWZmZXIgOj0gU2hhZG93X3N0ZGxpYi5CdWZmZXJcbiAgd2l0aCBtb2R1bGUgQnl0ZXMgOj0gU2hhZG93X3N0ZGxpYi5CeXRlc1xuICB3aXRoIG1vZHVsZSBDaGFyIDo9IFNoYWRvd19zdGRsaWIuQ2hhclxuICB3aXRoIG1vZHVsZSBFaXRoZXIgOj0gU2hhZG93X3N0ZGxpYi5FaXRoZXJcbiAgd2l0aCBtb2R1bGUgRmxvYXQgOj0gU2hhZG93X3N0ZGxpYi5GbG9hdFxuICB3aXRoIG1vZHVsZSBIYXNodGJsIDo9IFNoYWRvd19zdGRsaWIuSGFzaHRibFxuICB3aXRoIG1vZHVsZSBJbnQgOj0gU2hhZG93X3N0ZGxpYi5JbnRcbiAgd2l0aCBtb2R1bGUgSW50MzIgOj0gU2hhZG93X3N0ZGxpYi5JbnQzMlxuICB3aXRoIG1vZHVsZSBJbnQ2NCA6PSBTaGFkb3dfc3RkbGliLkludDY0XG4gIHdpdGggbW9kdWxlIExhenkgOj0gU2hhZG93X3N0ZGxpYi5MYXp5XG4gIHdpdGggbW9kdWxlIExpc3QgOj0gU2hhZG93X3N0ZGxpYi5MaXN0XG4gIHdpdGggbW9kdWxlIE1hcCA6PSBTaGFkb3dfc3RkbGliLk1hcFxuICB3aXRoIG1vZHVsZSBOYXRpdmVpbnQgOj0gU2hhZG93X3N0ZGxpYi5OYXRpdmVpbnRcbiAgd2l0aCBtb2R1bGUgT3B0aW9uIDo9IFNoYWRvd19zdGRsaWIuT3B0aW9uXG4gIHdpdGggbW9kdWxlIFByaW50ZiA6PSBTaGFkb3dfc3RkbGliLlByaW50ZlxuICB3aXRoIG1vZHVsZSBRdWV1ZSA6PSBTaGFkb3dfc3RkbGliLlF1ZXVlXG4gIHdpdGggbW9kdWxlIFJhbmRvbSA6PSBTaGFkb3dfc3RkbGliLlJhbmRvbVxuICB3aXRoIG1vZHVsZSBSZXN1bHQgOj0gU2hhZG93X3N0ZGxpYi5SZXN1bHRcbiAgd2l0aCBtb2R1bGUgU2V0IDo9IFNoYWRvd19zdGRsaWIuU2V0XG4gIHdpdGggbW9kdWxlIFN0YWNrIDo9IFNoYWRvd19zdGRsaWIuU3RhY2tcbiAgd2l0aCBtb2R1bGUgU3RyaW5nIDo9IFNoYWRvd19zdGRsaWIuU3RyaW5nXG4gIHdpdGggbW9kdWxlIFN5cyA6PSBTaGFkb3dfc3RkbGliLlN5c1xuICB3aXRoIG1vZHVsZSBVY2hhciA6PSBTaGFkb3dfc3RkbGliLlVjaGFyXG4gIHdpdGggbW9kdWxlIFVuaXQgOj0gU2hhZG93X3N0ZGxpYi5Vbml0KSBbQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG50eXBlICdhIHJlZiA9ICdhIENhbWwucmVmID0geyBtdXRhYmxlIGNvbnRlbnRzIDogJ2EgfVxuXG4oKiBSZXNodWZmbGUgW0NhbWxdIHNvIHRoYXQgd2UgY2hvb3NlIHRoZSBtb2R1bGVzIHVzaW5nIGxhYmVscyB3aGVuIGF2YWlsYWJsZS4gKilcbm1vZHVsZSBDYW1sID0gc3RydWN0XG5cbiAgaW5jbHVkZSBDYW1sXG5cbiAgbW9kdWxlIEFyZyA9IENhbWwuQXJnICgqKiBAY2Fub25pY2FsIENhbWwuQXJnICopXG5cbiAgbW9kdWxlIEFycmF5ID0gQ2FtbC5TdGRMYWJlbHMuQXJyYXkgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGRMYWJlbHMuQXJyYXkgKilcblxuICBtb2R1bGUgQm9vbCA9IENhbWwuQm9vbCAoKiogQGNhbm9uaWNhbCBDYW1sLkJvb2wgKilcblxuICBtb2R1bGUgQnVmZmVyID0gQ2FtbC5CdWZmZXIgKCoqIEBjYW5vbmljYWwgQ2FtbC5CdWZmZXIgKilcblxuICBtb2R1bGUgQnl0ZXMgPSBDYW1sLlN0ZExhYmVscy5CeXRlcyAoKiogQGNhbm9uaWNhbCBDYW1sLlN0ZExhYmVscy5CeXRlcyAqKVxuXG4gIG1vZHVsZSBDaGFyID0gQ2FtbC5DaGFyICgqKiBAY2Fub25pY2FsIENhbWwuQ2hhciAqKVxuXG4gIG1vZHVsZSBFcGhlbWVyb24gPSBDYW1sLkVwaGVtZXJvbiAoKiogQGNhbm9uaWNhbCBDYW1sLkVwaGVtZXJvbiAqKVxuXG4gIG1vZHVsZSBGbG9hdCA9IENhbWwuRmxvYXQgKCoqIEBjYW5vbmljYWwgQ2FtbC5GbG9hdCAqKVxuXG4gIG1vZHVsZSBGb3JtYXQgPSBDYW1sLkZvcm1hdCAoKiogQGNhbm9uaWNhbCBDYW1sLkZvcm1hdCAqKVxuXG4gIG1vZHVsZSBGdW4gPSBDYW1sLkZ1biAoKiogQGNhbm9uaWNhbCBDYW1sLkZ1biAqKVxuXG4gIG1vZHVsZSBHYyA9IENhbWwuR2MgKCoqIEBjYW5vbmljYWwgQ2FtbC5HYyAqKVxuXG4gIG1vZHVsZSBIYXNodGJsID0gQ2FtbC5Nb3JlTGFiZWxzLkhhc2h0YmwgKCoqIEBjYW5vbmljYWwgQ2FtbC5Nb3JlTGFiZWxzLkhhc2h0YmwgKilcblxuICBtb2R1bGUgSW50MzIgPSBDYW1sLkludDMyICgqKiBAY2Fub25pY2FsIENhbWwuSW50MzIgKilcblxuICBtb2R1bGUgSW50ID0gQ2FtbC5JbnQgKCoqIEBjYW5vbmljYWwgQ2FtbC5JbnQgKilcblxuICBtb2R1bGUgSW50NjQgPSBDYW1sLkludDY0ICgqKiBAY2Fub25pY2FsIENhbWwuSW50NjQgKilcblxuICBtb2R1bGUgTGF6eSA9IENhbWwuTGF6eSAoKiogQGNhbm9uaWNhbCBDYW1sLkxhenkgKilcblxuICBtb2R1bGUgTGV4aW5nID0gQ2FtbC5MZXhpbmcgKCoqIEBjYW5vbmljYWwgQ2FtbC5MZXhpbmcgKilcblxuICBtb2R1bGUgTGlzdCA9IENhbWwuU3RkTGFiZWxzLkxpc3QgKCoqIEBjYW5vbmljYWwgQ2FtbC5TdGRMYWJlbHMuTGlzdCAqKVxuXG4gIG1vZHVsZSBNYXAgPSBDYW1sLk1vcmVMYWJlbHMuTWFwICgqKiBAY2Fub25pY2FsIENhbWwuTW9yZUxhYmVscy5NYXAgKilcblxuICBtb2R1bGUgTmF0aXZlaW50ID0gQ2FtbC5OYXRpdmVpbnQgKCoqIEBjYW5vbmljYWwgQ2FtbC5OYXRpdmVpbnQgKilcblxuICBtb2R1bGUgT2JqID0gQ2FtbC5PYmogKCoqIEBjYW5vbmljYWwgQ2FtbC5PYmogKilcblxuICBtb2R1bGUgT3B0aW9uID0gQ2FtbC5PcHRpb24gKCoqIEBjYW5vbmljYWwgQ2FtbC5PcHRpb24gKilcblxuICBtb2R1bGUgUGFyc2luZyA9IENhbWwuUGFyc2luZyAoKiogQGNhbm9uaWNhbCBDYW1sLlBhcnNpbmcgKilcblxuICBtb2R1bGUgUHJpbnRleGMgPSBDYW1sLlByaW50ZXhjICgqKiBAY2Fub25pY2FsIENhbWwuUHJpbnRleGMgKilcblxuICBtb2R1bGUgUHJpbnRmID0gQ2FtbC5QcmludGYgKCoqIEBjYW5vbmljYWwgQ2FtbC5QcmludGYgKilcblxuICBtb2R1bGUgUXVldWUgPSBDYW1sLlF1ZXVlICgqKiBAY2Fub25pY2FsIENhbWwuUXVldWUgKilcblxuICBtb2R1bGUgUmFuZG9tID0gQ2FtbC5SYW5kb20gKCoqIEBjYW5vbmljYWwgQ2FtbC5SYW5kb20gKilcblxuICBtb2R1bGUgUmVzdWx0ID0gQ2FtbC5SZXN1bHQgKCoqIEBjYW5vbmljYWwgQ2FtbC5SZXN1bHQgKilcblxuICBtb2R1bGUgU2NhbmYgPSBDYW1sLlNjYW5mICgqKiBAY2Fub25pY2FsIENhbWwuU2NhbmYgKilcblxuICBtb2R1bGUgU2VxID0gQ2FtbC5TZXEgKCoqIEBjYW5vbmljYWwgQ2FtbC5TZXEgKilcblxuICBtb2R1bGUgU2V0ID0gQ2FtbC5Nb3JlTGFiZWxzLlNldCAoKiogQGNhbm9uaWNhbCBDYW1sLk1vcmVMYWJlbHMuU2V0ICopXG5cbiAgbW9kdWxlIFN0YWNrID0gQ2FtbC5TdGFjayAoKiogQGNhbm9uaWNhbCBDYW1sLlN0YWNrICopXG5cbiAgbW9kdWxlIFN0cmluZyA9IENhbWwuU3RkTGFiZWxzLlN0cmluZyAoKiogQGNhbm9uaWNhbCBDYW1sLlN0ZExhYmVscy5TdHJpbmcgKilcblxuICBtb2R1bGUgU3lzID0gQ2FtbC5TeXMgKCoqIEBjYW5vbmljYWwgQ2FtbC5TeXMgKilcblxuICBtb2R1bGUgVWNoYXIgPSBDYW1sLlVjaGFyICgqKiBAY2Fub25pY2FsIENhbWwuVWNoYXIgKilcblxuICBtb2R1bGUgVW5pdCA9IENhbWwuVW5pdCAoKiogQGNhbm9uaWNhbCBDYW1sLlVuaXQgKilcblxuICBleGNlcHRpb24gTm90X2ZvdW5kID0gQ2FtbC5Ob3RfZm91bmRcbmVuZFxuXG5leHRlcm5hbCAoIHw+ICkgOiAnYSAtPiAoJ2EgLT4gJ2IpIC0+ICdiID0gXCIlcmV2YXBwbHlcIlxuXG4oKiBUaGVzZSBuZWVkIHRvIGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHRvIGdldCB0aGUgbGF6eSBiZWhhdmlvciAqKVxuZXh0ZXJuYWwgKCAmJiApIDogYm9vbCAtPiBib29sIC0+IGJvb2wgPSBcIiVzZXF1YW5kXCJcbmV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbmV4dGVybmFsIG5vdCA6IGJvb2wgLT4gYm9vbCA9IFwiJWJvb2xub3RcIlxuXG4oKiBXZSB1c2UgW09iai5tYWdpY10gaGVyZSBhcyBvdGhlciBpbXBsZW1lbnRhdGlvbnMgZ2VuZXJhdGUgYSBjb25kaXRpb25hbCBqdW1wIGFuZCB0aGVcbiAgIHBlcmZvcm1hbmNlIGRpZmZlcmVuY2UgaXMgbm90aWNlYWJsZS4gKilcbmxldCBib29sX3RvX2ludCAoeCA6IGJvb2wpIDogaW50ID0gQ2FtbC5PYmoubWFnaWMgeFxuXG4oKiBUaGlzIG5lZWQgdG8gYmUgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgZm9yIHRoZSB3YXJuaW5ncyB0byB3b3JrIHByb3Blcmx5ICopXG5leHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG5sZXQgKCAhPSApID0gQ2FtbC4oICE9IClcbmxldCAoICogKSA9IENhbWwuKCAqIClcbmxldCAoICoqICkgPSBDYW1sLiggKiogKVxubGV0ICggKi4gKSA9IENhbWwuKCAqLiApXG5sZXQgKCArICkgPSBDYW1sLiggKyApXG5sZXQgKCArLiApID0gQ2FtbC4oICsuIClcbmxldCAoIC0gKSA9IENhbWwuKCAtIClcbmxldCAoIC0uICkgPSBDYW1sLiggLS4gKVxubGV0ICggLyApID0gQ2FtbC4oIC8gKVxubGV0ICggLy4gKSA9IENhbWwuKCAvLiApXG5cbm1vZHVsZSBQb2x5ID0gUG9seTAgKCoqIEBjYW5vbmljYWwgQmFzZS5Qb2x5ICopXG5cbm1vZHVsZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICgqIERlY2xhcmVkIGFzIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9hcHBseV9YIHdyYXBwaW5nIGV2ZW4gd2hlblxuICAgICBjb21waWxpbmcgd2l0aG91dCBjcm9zcyBsaWJyYXJ5IGlubGluaW5nLiAqKVxuICBleHRlcm5hbCAoID0gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8PiApIDogaW50IC0+IGludCAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuICBleHRlcm5hbCAoIDwgKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiBpbnQgLT4gaW50IC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG4gIGV4dGVybmFsICggPD0gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG4gIGV4dGVybmFsICggPj0gKSA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG4gIGV4dGVybmFsIGNvbXBhcmUgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWNvbXBhcmVcIlxuICBleHRlcm5hbCBlcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxuICBsZXQgYXNjZW5kaW5nICh4IDogaW50KSB5ID0gY29tcGFyZSB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBpbnQpIHkgPSBjb21wYXJlIHkgeFxuICBsZXQgbWF4ICh4IDogaW50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IGludCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxuaW5jbHVkZSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbm1vZHVsZSBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gUG9seS4oIDwgKSB4IHlcbiAgbGV0ICggPD0gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA9ICkgeCB5XG4gIGxldCAoID4gKSAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuYXNjZW5kaW5nIHggeVxuICBsZXQgZGVzY2VuZGluZyAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBDYW1sLkludDMyLnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IENhbWwuSW50MzIudCkgeSA9IFBvbHkuZXF1YWwgeCB5XG4gIGxldCBtYXggKHggOiBDYW1sLkludDMyLnQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogQ2FtbC5JbnQzMi50KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICgqIERlY2xhcmVkIGFzIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9hcHBseV9YIHdyYXBwaW5nIGV2ZW4gd2hlblxuICAgICBjb21waWxpbmcgd2l0aG91dCBjcm9zcyBsaWJyYXJ5IGlubGluaW5nLiAqKVxuICBleHRlcm5hbCAoID0gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcbiAgZXh0ZXJuYWwgKCA8PiApIDogQ2FtbC5JbnQ2NC50IC0+IENhbWwuSW50NjQudCAtPiBib29sID0gXCIlbm90ZXF1YWxcIlxuICBleHRlcm5hbCAoIDwgKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWxlc3N0aGFuXCJcbiAgZXh0ZXJuYWwgKCA+ICkgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG4gIGV4dGVybmFsICggPD0gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWxlc3NlcXVhbFwiXG4gIGV4dGVybmFsICggPj0gKSA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWdyZWF0ZXJlcXVhbFwiXG4gIGV4dGVybmFsIGNvbXBhcmUgOiBDYW1sLkludDY0LnQgLT4gQ2FtbC5JbnQ2NC50IC0+IGludCA9IFwiJWNvbXBhcmVcIlxuICBleHRlcm5hbCBlcXVhbCA6IENhbWwuSW50NjQudCAtPiBDYW1sLkludDY0LnQgLT4gYm9vbCA9IFwiJWVxdWFsXCJcblxuICBsZXQgYXNjZW5kaW5nICh4IDogQ2FtbC5JbnQ2NC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogQ2FtbC5JbnQ2NC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgbWF4ICh4IDogQ2FtbC5JbnQ2NC50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IENhbWwuSW50NjQudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IENhbWwuTmF0aXZlaW50LnQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogQ2FtbC5OYXRpdmVpbnQudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBDYW1sLk5hdGl2ZWludC50KSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgQm9vbF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogYm9vbCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBib29sKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBib29sKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGJvb2wpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGJvb2wpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBib29sKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGJvb2wpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGJvb2wpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogYm9vbCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBib29sKSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgQ2hhcl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgPSBzdHJ1Y3RcbiAgbGV0ICggPCApICh4IDogY2hhcikgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oIDw+ICkgeCB5XG4gIGxldCAoID0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBjaGFyKSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IGNoYXIpIHkgPSBQb2x5LiggPj0gKSB4IHlcbiAgbGV0IGFzY2VuZGluZyAoeCA6IGNoYXIpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBjaGFyKSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IGNoYXIpIHkgPSBQb2x5LmNvbXBhcmUgeCB5XG4gIGxldCBlcXVhbCAoeCA6IGNoYXIpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogY2hhcikgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBjaGFyKSB5ID0gaWYgeCA8PSB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG5tb2R1bGUgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCBpIHggPSBDYW1sLlVjaGFyLnRvX2ludCB4XG4gIGxldCAoIDwgKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPD0gKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIChpIHgpIChpIHkpXG4gIGxldCAoIDw+ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD4gKSAoaSB4KSAoaSB5KVxuICBsZXQgKCA9ICkgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPSApIChpIHgpIChpIHkpXG4gIGxldCAoID4gKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+ICkgKGkgeCkgKGkgeSlcbiAgbGV0ICggPj0gKSAoeCA6IENhbWwuVWNoYXIudCkgeSA9IEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIChpIHgpIChpIHkpXG5cbiAgbGV0IGFzY2VuZGluZyAoeCA6IENhbWwuVWNoYXIudCkgeSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5hc2NlbmRpbmcgKGkgeCkgKGkgeSlcbiAgOztcblxuICBsZXQgZGVzY2VuZGluZyAoeCA6IENhbWwuVWNoYXIudCkgeSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5kZXNjZW5kaW5nIChpIHgpIChpIHkpXG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgKHggOiBDYW1sLlVjaGFyLnQpIHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmUgKGkgeCkgKGkgeSlcbiAgbGV0IGVxdWFsICh4IDogQ2FtbC5VY2hhci50KSB5ID0gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCAoaSB4KSAoaSB5KVxuICBsZXQgbWF4ICh4IDogQ2FtbC5VY2hhci50KSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IENhbWwuVWNoYXIudCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogZmxvYXQpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBmbG9hdCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogZmxvYXQpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBmbG9hdCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBmbG9hdCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogZmxvYXQpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogZmxvYXQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogZmxvYXQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbm1vZHVsZSBTdHJpbmdfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPD0gKSB4IHlcbiAgbGV0ICggPD4gKSAoeCA6IHN0cmluZykgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBzdHJpbmcpIHkgPSBQb2x5LiggPiApIHggeVxuICBsZXQgKCA+PSApICh4IDogc3RyaW5nKSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmRlc2NlbmRpbmcgeCB5XG4gIGxldCBjb21wYXJlICh4IDogc3RyaW5nKSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiBzdHJpbmcpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogc3RyaW5nKSB5ID0gaWYgeCA+PSB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1pbiAoeCA6IHN0cmluZykgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubW9kdWxlIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8ICkgeCB5XG4gIGxldCAoIDw9ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogYnl0ZXMpIHkgPSBQb2x5LiggPSApIHggeVxuICBsZXQgKCA+ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiBieXRlcykgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogYnl0ZXMpIHkgPSBQb2x5LmFzY2VuZGluZyB4IHlcbiAgbGV0IGRlc2NlbmRpbmcgKHggOiBieXRlcykgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiBieXRlcykgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogYnl0ZXMpIHkgPSBQb2x5LmVxdWFsIHggeVxuICBsZXQgbWF4ICh4IDogYnl0ZXMpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogYnl0ZXMpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbigqIFRoaXMgbmVlZHMgdG8gYmUgZGVmaW5lZCBhcyBhbiBleHRlcm5hbCBzbyB0aGF0IHRoZSBjb21waWxlciBjYW4gc3BlY2lhbGl6ZSBpdCBhcyBhXG4gICBkaXJlY3Qgc2V0IG9yIGNhbWxfbW9kaWZ5ICopXG5leHRlcm5hbCAoIDo9ICkgOiAnYSByZWYgLT4gJ2EgLT4gdW5pdCA9IFwiJXNldGZpZWxkMFwiXG5cbigqIFRoZXNlIG5lZWQgdG8gYmUgZGVmaW5lZCBhcyBhbiBleHRlcm5hbCBvdGhlcndpc2UgdGhlIGNvbXBpbGVyIHdvbid0IHVuYm94XG4gICByZWZlcmVuY2VzICopXG5leHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCByZWYgOiAnYSAtPiAnYSByZWYgPSBcIiVtYWtlbXV0YWJsZVwiXG5cbmxldCAoIEAgKSA9IENhbWwuKCBAIClcbmxldCAoIF4gKSA9IENhbWwuKCBeIClcbmxldCAoIH4tICkgPSBDYW1sLiggfi0gKVxubGV0ICggfi0uICkgPSBDYW1sLiggfi0uIClcbmxldCAoIGFzciApID0gQ2FtbC4oIGFzciApXG5sZXQgKCBsYW5kICkgPSBDYW1sLiggbGFuZCApXG5sZXQgbG5vdCA9IENhbWwubG5vdFxubGV0ICggbG9yICkgPSBDYW1sLiggbG9yIClcbmxldCAoIGxzbCApID0gQ2FtbC4oIGxzbCApXG5sZXQgKCBsc3IgKSA9IENhbWwuKCBsc3IgKVxubGV0ICggbHhvciApID0gQ2FtbC4oIGx4b3IgKVxubGV0ICggbW9kICkgPSBDYW1sLiggbW9kIClcbmxldCBhYnMgPSBDYW1sLmFic1xubGV0IGZhaWx3aXRoID0gQ2FtbC5mYWlsd2l0aFxubGV0IGZzdCA9IENhbWwuZnN0XG5sZXQgaW52YWxpZF9hcmcgPSBDYW1sLmludmFsaWRfYXJnXG5sZXQgc25kID0gQ2FtbC5zbmRcblxuKCogW3JhaXNlXSBuZWVkcyB0byBiZSBkZWZpbmVkIGFzIGFuIGV4dGVybmFsIGFzIHRoZSBjb21waWxlciBhdXRvbWF0aWNhbGx5IHJlcGxhY2VzXG4gICAnJXJhaXNlJyBieSAnJXJlcmFpc2UnIHdoZW4gYXBwcm9wcmlhdGUuICopXG5leHRlcm5hbCByYWlzZSA6IGV4biAtPiBfID0gXCIlcmFpc2VcIlxuXG5sZXQgcGh5c19lcXVhbCA9IENhbWwuKCA9PSApXG5sZXQgZGVjciA9IENhbWwuZGVjclxubGV0IGluY3IgPSBDYW1sLmluY3JcblxuKCogdXNlZCBieSBzZXhwX2NvbnYsIHdoaWNoIGZsb2F0MCBkZXBlbmRzIG9uIHRocm91Z2ggb3B0aW9uICopXG5sZXQgZmxvYXRfb2Zfc3RyaW5nID0gQ2FtbC5mbG9hdF9vZl9zdHJpbmdcblxuKCogW2FtX3Rlc3RpbmddIGlzIHVzZWQgaW4gYSBmZXcgcGxhY2VzIHRvIGJlaGF2ZSBkaWZmZXJlbnRseSB3aGVuIGluIHRlc3RpbmcgbW9kZSwgc3VjaFxuICAgYXMgaW4gW3JhbmRvbS5tbF0uICBbYW1fdGVzdGluZ10gaXMgaW1wbGVtZW50ZWQgdXNpbmcgW0Jhc2VfYW1fdGVzdGluZ10sIGEgd2VhayBDL2pzXG4gICBwcmltaXRpdmUgdGhhdCByZXR1cm5zIFtmYWxzZV0sIGJ1dCB3aGVuIGxpbmtpbmcgYW4gaW5saW5lLXRlc3QtcnVubmVyIGV4ZWN1dGFibGUsIGlzXG4gICBvdmVycmlkZGVuIGJ5IGFub3RoZXIgcHJpbWl0aXZlIHRoYXQgcmV0dXJucyBbdHJ1ZV0uICopXG5leHRlcm5hbCBhbV90ZXN0aW5nIDogdW5pdCAtPiBib29sID0gXCJCYXNlX2FtX3Rlc3RpbmdcIlxuXG5sZXQgYW1fdGVzdGluZyA9IGFtX3Rlc3RpbmcgKClcbiIsIm9wZW4hIEltcG9ydDBcbmluY2x1ZGUgQ2FtbC5QcmludGZcblxuKCoqIGZhaWx3aXRoLCBpbnZhbGlkX2FyZywgYW5kIGV4aXQgYWNjZXB0aW5nIHByaW50ZidzIGZvcm1hdC4gKilcblxubGV0IGZhaWx3aXRoZiBmbXQgPSBrc3ByaW50ZiAoZnVuIHMgKCkgLT4gZmFpbHdpdGggcykgZm10XG5sZXQgaW52YWxpZF9hcmdmIGZtdCA9IGtzcHJpbnRmIChmdW4gcyAoKSAtPiBpbnZhbGlkX2FyZyBzKSBmbXRcbiIsIigqIFtTeXMwXSBkZWZpbmVzIGZ1bmN0aW9ucyB0aGF0IGFyZSBwcmltaXRpdmVzIG9yIGNhbiBiZSBzaW1wbHkgZGVmaW5lZCBpblxuICAgdGVybXMgb2YgW0NhbWwuU3lzXS4gIFtTeXMwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtDYW1sLlN5c10gdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBzeXMubWxcbiAgIHNob3VsZCB1c2UgW0NhbWwuU3lzXS4gW1N5czBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlXG4gICBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuICBBbGwgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIHRoZXNlXG4gICBmdW5jdGlvbnMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLlN5c10gaW4gYnVpbGQgb3JkZXIgc2hvdWxkIGRvXG4gICBbbW9kdWxlIFN5cyA9IFN5czBdLiAgRGVmaW5pbmcgW21vZHVsZSBTeXMgPSBTeXMwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlXG4gICBpdCBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLlN5c10uICopXG5cbm9wZW4hIEltcG9ydDBcblxudHlwZSBiYWNrZW5kX3R5cGUgPSBDYW1sLlN5cy5iYWNrZW5kX3R5cGUgPVxuICB8IE5hdGl2ZVxuICB8IEJ5dGVjb2RlXG4gIHwgT3RoZXIgb2Ygc3RyaW5nXG5cbmxldCBiYWNrZW5kX3R5cGUgPSBDYW1sLlN5cy5iYWNrZW5kX3R5cGVcbmxldCBpbnRlcmFjdGl2ZSA9IENhbWwuU3lzLmludGVyYWN0aXZlXG5sZXQgb3NfdHlwZSA9IENhbWwuU3lzLm9zX3R5cGVcbmxldCB1bml4ID0gQ2FtbC5TeXMudW5peFxubGV0IHdpbjMyID0gQ2FtbC5TeXMud2luMzJcbmxldCBjeWd3aW4gPSBDYW1sLlN5cy5jeWd3aW5cbmxldCB3b3JkX3NpemVfaW5fYml0cyA9IENhbWwuU3lzLndvcmRfc2l6ZVxubGV0IGludF9zaXplX2luX2JpdHMgPSBDYW1sLlN5cy5pbnRfc2l6ZVxubGV0IGJpZ19lbmRpYW4gPSBDYW1sLlN5cy5iaWdfZW5kaWFuXG5sZXQgbWF4X3N0cmluZ19sZW5ndGggPSBDYW1sLlN5cy5tYXhfc3RyaW5nX2xlbmd0aFxubGV0IG1heF9hcnJheV9sZW5ndGggPSBDYW1sLlN5cy5tYXhfYXJyYXlfbGVuZ3RoXG5sZXQgcnVudGltZV92YXJpYW50ID0gQ2FtbC5TeXMucnVudGltZV92YXJpYW50XG5sZXQgcnVudGltZV9wYXJhbWV0ZXJzID0gQ2FtbC5TeXMucnVudGltZV9wYXJhbWV0ZXJzXG5sZXQgYXJndiA9IENhbWwuU3lzLmFyZ3ZcbmxldCBnZXRfYXJndiAoKSA9IENhbWwuU3lzLmFyZ3ZcbmxldCBvY2FtbF92ZXJzaW9uID0gQ2FtbC5TeXMub2NhbWxfdmVyc2lvblxubGV0IGVuYWJsZV9ydW50aW1lX3dhcm5pbmdzID0gQ2FtbC5TeXMuZW5hYmxlX3J1bnRpbWVfd2FybmluZ3NcbmxldCBydW50aW1lX3dhcm5pbmdzX2VuYWJsZWQgPSBDYW1sLlN5cy5ydW50aW1lX3dhcm5pbmdzX2VuYWJsZWRcblxubGV0IGdldGVudl9leG4gdmFyID1cbiAgdHJ5IENhbWwuU3lzLmdldGVudiB2YXIgd2l0aFxuICB8IENhbWwuTm90X2ZvdW5kIC0+XG4gICAgUHJpbnRmLmZhaWx3aXRoZiBcIlN5cy5nZXRlbnZfZXhuOiBlbnZpcm9ubWVudCB2YXJpYWJsZSAlcyBpcyBub3Qgc2V0XCIgdmFyICgpXG47O1xuXG5sZXQgZ2V0ZW52IHZhciA9XG4gIG1hdGNoIENhbWwuU3lzLmdldGVudiB2YXIgd2l0aFxuICB8IHggLT4gU29tZSB4XG4gIHwgZXhjZXB0aW9uIENhbWwuTm90X2ZvdW5kIC0+IE5vbmVcbjs7XG5cbmV4dGVybmFsIG9wYXF1ZV9pZGVudGl0eSA6ICdhIC0+ICdhID0gXCIlb3BhcXVlXCJcblxuZXhjZXB0aW9uIEJyZWFrID0gQ2FtbC5TeXMuQnJlYWtcbiIsIigqIFtBcnJheTBdIGRlZmluZXMgYXJyYXkgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zXG4gICBvZiBbQ2FtbC5BcnJheV0uICBbQXJyYXkwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW0NhbWwuQXJyYXldXG4gICB0aGF0IFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGFycmF5MC5tbCBzaG91bGQgdXNlIFtDYW1sLkFycmF5XS5cbiAgIFtBcnJheTBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGFycmF5cyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuQXJyYXldIGluIGJ1aWxkIG9yZGVyIHNob3VsZFxuICAgZG8gW21vZHVsZSBBcnJheSA9IEFycmF5MF0uICBUaGlzIGluY2x1ZGVzIHVzZXMgb2Ygc3Vic2NyaXB0IHN5bnRheCAoW3guKGkpXSwgW3guKGkpIDwtXG4gICBlXSksIHdoaWNoIHRoZSBPQ2FtbCBwYXJzZXIgZGVzdWdhcnMgaW50byBjYWxscyB0byBbQXJyYXkuZ2V0XSBhbmQgW0FycmF5LnNldF0uXG4gICBEZWZpbmluZyBbbW9kdWxlIEFycmF5ID0gQXJyYXkwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzIG9jYW1sZGVwIGZyb21cbiAgIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkFycmF5XS4gKilcblxub3BlbiEgSW1wb3J0MFxubW9kdWxlIFN5cyA9IFN5czBcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubW9kdWxlIEFycmF5ID0gc3RydWN0XG4gIGV4dGVybmFsIGNyZWF0ZSA6IGludCAtPiAnYSAtPiAnYSBhcnJheSA9IFwiY2FtbF9tYWtlX3ZlY3RcIlxuICBleHRlcm5hbCBjcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCA6IGludCAtPiBmbG9hdCBhcnJheSA9IFwiY2FtbF9tYWtlX2Zsb2F0X3ZlY3RcIlxuICBleHRlcm5hbCBnZXQgOiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgPSBcIiVhcnJheV9zYWZlX2dldFwiXG4gIGV4dGVybmFsIGxlbmd0aCA6ICdhIGFycmF5IC0+IGludCA9IFwiJWFycmF5X2xlbmd0aFwiXG4gIGV4dGVybmFsIHNldCA6ICdhIGFycmF5IC0+IGludCAtPiAnYSAtPiB1bml0ID0gXCIlYXJyYXlfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogJ2EgYXJyYXkgLT4gaW50IC0+ICdhID0gXCIlYXJyYXlfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiAnYSBhcnJheSAtPiBpbnQgLT4gJ2EgLT4gdW5pdCA9IFwiJWFycmF5X3Vuc2FmZV9zZXRcIlxuXG4gIGV4dGVybmFsIHVuc2FmZV9ibGl0XG4gICAgOiAgc3JjOidhIGFycmF5XG4gICAgLT4gc3JjX3BvczppbnRcbiAgICAtPiBkc3Q6J2EgYXJyYXlcbiAgICAtPiBkc3RfcG9zOmludFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiB1bml0XG4gICAgPSBcImNhbWxfYXJyYXlfYmxpdFwiXG5lbmRcblxuaW5jbHVkZSBBcnJheVxuXG5sZXQgbWF4X2xlbmd0aCA9IFN5cy5tYXhfYXJyYXlfbGVuZ3RoXG5cbmxldCBjcmVhdGUgfmxlbiB4ID1cbiAgdHJ5IGNyZWF0ZSBsZW4geCB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBfIC0+IGludmFsaWRfYXJnZiBcIkFycmF5LmNyZWF0ZSB+bGVuOiVkOiBpbnZhbGlkIGxlbmd0aFwiIGxlbiAoKVxuOztcblxubGV0IGNyZWF0ZV9mbG9hdF91bmluaXRpYWxpemVkIH5sZW4gPVxuICB0cnkgY3JlYXRlX2Zsb2F0X3VuaW5pdGlhbGl6ZWQgbGVuIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IF8gLT5cbiAgICBpbnZhbGlkX2FyZ2YgXCJBcnJheS5jcmVhdGVfZmxvYXRfdW5pbml0aWFsaXplZCB+bGVuOiVkOiBpbnZhbGlkIGxlbmd0aFwiIGxlbiAoKVxuOztcblxubGV0IGFwcGVuZCA9IENhbWwuQXJyYXkuYXBwZW5kXG5sZXQgYmxpdCA9IENhbWwuQXJyYXkuYmxpdFxubGV0IGNvbmNhdCA9IENhbWwuQXJyYXkuY29uY2F0XG5sZXQgY29weSA9IENhbWwuQXJyYXkuY29weVxubGV0IGZpbGwgPSBDYW1sLkFycmF5LmZpbGxcbmxldCBpbml0ID0gQ2FtbC5BcnJheS5pbml0XG5sZXQgbWFrZV9tYXRyaXggPSBDYW1sLkFycmF5Lm1ha2VfbWF0cml4XG5sZXQgb2ZfbGlzdCA9IENhbWwuQXJyYXkub2ZfbGlzdFxubGV0IHN1YiA9IENhbWwuQXJyYXkuc3ViXG5sZXQgdG9fbGlzdCA9IENhbWwuQXJyYXkudG9fbGlzdFxuXG4oKiBUaGVzZSBhcmUgZXRhIGV4cGFuZGVkIGluIG9yZGVyIHRvIHBlcm11dGUgcGFyYW1ldGVyIG9yZGVyIHRvIGZvbGxvdyBCYXNlXG4gICBjb252ZW50aW9ucy4gKilcbmxldCBmb2xkIHQgfmluaXQgfmYgPSBDYW1sLkFycmF5LmZvbGRfbGVmdCB0IH5pbml0IH5mXG5sZXQgZm9sZF9yaWdodCB0IH5mIH5pbml0ID0gQ2FtbC5BcnJheS5mb2xkX3JpZ2h0IHQgfmYgfmluaXRcbmxldCBpdGVyIHQgfmYgPSBDYW1sLkFycmF5Lml0ZXIgdCB+ZlxubGV0IGl0ZXJpIHQgfmYgPSBDYW1sLkFycmF5Lml0ZXJpIHQgfmZcbmxldCBtYXAgdCB+ZiA9IENhbWwuQXJyYXkubWFwIHQgfmZcbmxldCBtYXBpIHQgfmYgPSBDYW1sLkFycmF5Lm1hcGkgdCB+ZlxubGV0IHN0YWJsZV9zb3J0IHQgfmNvbXBhcmUgPSBDYW1sLkFycmF5LnN0YWJsZV9zb3J0IHQgfmNtcDpjb21wYXJlXG5cbmxldCBzd2FwIHQgaSBqID1cbiAgbGV0IGVsdF9pID0gdC4oaSkgaW5cbiAgbGV0IGVsdF9qID0gdC4oaikgaW5cbiAgdW5zYWZlX3NldCB0IGkgZWx0X2o7XG4gIHVuc2FmZV9zZXQgdCBqIGVsdF9pXG47O1xuIiwiKCogW0NoYXIwXSBkZWZpbmVzIGNoYXIgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseSBkZWZpbmVkIGluIHRlcm1zIG9mXG4gICBbQ2FtbC5DaGFyXS4gIFtDaGFyMF0gaXMgaW50ZW5kZWQgdG8gY29tcGxldGVseSBleHByZXNzIHRoZSBwYXJ0IG9mIFtDYW1sLkNoYXJdIHRoYXRcbiAgIFtCYXNlXSB1c2VzIC0tIG5vIG90aGVyIGZpbGUgaW4gQmFzZSBvdGhlciB0aGFuIGNoYXIwLm1sIHNob3VsZCB1c2UgW0NhbWwuQ2hhcl0uXG4gICBbQ2hhcjBdIGhhcyBmZXcgZGVwZW5kZW5jaWVzLCBhbmQgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci4gIEFsbFxuICAgQmFzZSBmaWxlcyB0aGF0IG5lZWQgdG8gdXNlIGNoYXJzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5DaGFyXSBpbiBidWlsZCBvcmRlciBzaG91bGQgZG9cbiAgIFttb2R1bGUgQ2hhciA9IENoYXIwXS4gIERlZmluaW5nIFttb2R1bGUgQ2hhciA9IENoYXIwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0XG4gICBwcmV2ZW50cyBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLkNoYXJdLiAqKVxuXG5vcGVuISBJbXBvcnQwXG5cbmxldCBmYWlsd2l0aGYgPSBQcmludGYuZmFpbHdpdGhmXG5sZXQgZXNjYXBlZCA9IENhbWwuQ2hhci5lc2NhcGVkXG5sZXQgbG93ZXJjYXNlID0gQ2FtbC5DaGFyLmxvd2VyY2FzZV9hc2NpaVxubGV0IHRvX2ludCA9IENhbWwuQ2hhci5jb2RlXG5sZXQgdW5zYWZlX29mX2ludCA9IENhbWwuQ2hhci51bnNhZmVfY2hyXG5sZXQgdXBwZXJjYXNlID0gQ2FtbC5DaGFyLnVwcGVyY2FzZV9hc2NpaVxuXG4oKiBXZSB1c2Ugb3VyIG93biByYW5nZSB0ZXN0IHdoZW4gY29udmVydGluZyBpbnRlZ2VycyB0byBjaGFycyByYXRoZXIgdGhhblxuICAgY2FsbGluZyBbQ2FtbC5DaGFyLmNocl0gYmVjYXVzZSBpdCdzIHNpbXBsZSBhbmQgaXQgc2F2ZXMgdXMgYSBmdW5jdGlvbiBjYWxsXG4gICBhbmQgdGhlIHRyeS13aXRoIChleGNlcHRpb25zIGNvc3QsIGVzcGVjaWFsbHkgaW4gdGhlIHdvcmxkIHdpdGggYmFja3RyYWNlcykuICopXG5sZXQgaW50X2lzX29rIGkgPSAwIDw9IGkgJiYgaSA8PSAyNTVcbmxldCBtaW5fdmFsdWUgPSB1bnNhZmVfb2ZfaW50IDBcbmxldCBtYXhfdmFsdWUgPSB1bnNhZmVfb2ZfaW50IDI1NVxubGV0IG9mX2ludCBpID0gaWYgaW50X2lzX29rIGkgdGhlbiBTb21lICh1bnNhZmVfb2ZfaW50IGkpIGVsc2UgTm9uZVxuXG5sZXQgb2ZfaW50X2V4biBpID1cbiAgaWYgaW50X2lzX29rIGlcbiAgdGhlbiB1bnNhZmVfb2ZfaW50IGlcbiAgZWxzZSBmYWlsd2l0aGYgXCJDaGFyLm9mX2ludF9leG4gZ290IGludGVnZXIgb3V0IG9mIHJhbmdlOiAlZFwiIGkgKClcbjs7XG5cbmxldCBlcXVhbCAodDEgOiBjaGFyKSB0MiA9IFBvbHkuZXF1YWwgdDEgdDJcbiIsIigqIFtJbnQwXSBkZWZpbmVzIGludGVnZXIgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseVxuICAgZGVmaW5lZCBpbiB0ZXJtcyBvZiBbQ2FtbF0uIFtJbnQwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlXG4gICBwYXJ0IG9mIFtDYW1sXSB0aGF0IFtCYXNlXSB1c2VzIGZvciBpbnRlZ2VycyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXJcbiAgIHRoYW4gaW50MC5tbCBzaG91bGQgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0aHJvdWdoIFtDYW1sXS4gW0ludDBdIGhhc1xuICAgZmV3IGRlcGVuZGVuY2llcywgYW5kIHNvIGlzIGF2YWlsYWJsZSBlYXJseSBpbiBCYXNlJ3MgYnVpbGQgb3JkZXIuXG5cbiAgIEFsbCBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2UgaW50cyBhbmQgY29tZSBiZWZvcmUgW0Jhc2UuSW50XSBpbiBidWlsZFxuICAgb3JkZXIgc2hvdWxkIGRvOlxuXG4gICB7W1xuICAgICBtb2R1bGUgSW50ICA9IEludDBcbiAgIF19XG5cbiAgIERlZmluaW5nIFttb2R1bGUgSW50ID0gSW50MF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50cyBvY2FtbGRlcFxuICAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5JbnRdLiAqKVxuXG5sZXQgdG9fc3RyaW5nID0gQ2FtbC5zdHJpbmdfb2ZfaW50XG5sZXQgb2Zfc3RyaW5nID0gQ2FtbC5pbnRfb2Zfc3RyaW5nXG5sZXQgdG9fZmxvYXQgPSBDYW1sLmZsb2F0X29mX2ludFxubGV0IG9mX2Zsb2F0ID0gQ2FtbC5pbnRfb2ZfZmxvYXRcbmxldCBtYXhfdmFsdWUgPSBDYW1sLm1heF9pbnRcbmxldCBtaW5fdmFsdWUgPSBDYW1sLm1pbl9pbnRcbmxldCBzdWNjID0gQ2FtbC5zdWNjXG4iLCIoKiBbTGlzdDBdIGRlZmluZXMgbGlzdCBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW4gdGVybXMgb2ZcbiAgIFtDYW1sLkxpc3RdLiAgW0xpc3QwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2YgW0NhbWwuTGlzdF0gdGhhdFxuICAgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyIHRoYW4gbGlzdDAubWwgc2hvdWxkIHVzZSBbQ2FtbC5MaXN0XS5cbiAgIFtMaXN0MF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzIGJ1aWxkIG9yZGVyLiAgQWxsXG4gICBCYXNlIGZpbGVzIHRoYXQgbmVlZCB0byB1c2UgbGlzdHMgYW5kIGNvbWUgYmVmb3JlIFtCYXNlLkxpc3RdIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuICAgW21vZHVsZSBMaXN0ID0gTGlzdDBdLiAgRGVmaW5pbmcgW21vZHVsZSBMaXN0ID0gTGlzdDBdIGlzIGFsc28gbmVjZXNzYXJ5IGJlY2F1c2UgaXRcbiAgIHByZXZlbnRzIG9jYW1sZGVwIGZyb20gbWlzdGFrZW5seSBjYXVzaW5nIGEgZmlsZSB0byBkZXBlbmQgb24gW0Jhc2UuTGlzdF0uICopXG5cbm9wZW4hIEltcG9ydDBcblxubGV0IGhkX2V4biA9IENhbWwuTGlzdC5oZFxubGV0IGxlbmd0aCA9IENhbWwuTGlzdC5sZW5ndGhcbmxldCByZXZfYXBwZW5kID0gQ2FtbC5MaXN0LnJldl9hcHBlbmRcbmxldCB0bF9leG4gPSBDYW1sLkxpc3QudGxcbmxldCB1bnppcCA9IENhbWwuTGlzdC5zcGxpdFxuXG4oKiBUaGVzZSBhcmUgZXRhIGV4cGFuZGVkIGluIG9yZGVyIHRvIHBlcm11dGUgcGFyYW1ldGVyIG9yZGVyIHRvIGZvbGxvdyBCYXNlXG4gICBjb252ZW50aW9ucy4gKilcbmxldCBleGlzdHMgdCB+ZiA9IENhbWwuTGlzdC5leGlzdHMgdCB+ZlxubGV0IGV4aXN0czJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QuZXhpc3RzMiBsMSBsMiB+ZlxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9IENhbWwuTGlzdC5mb2xkX2xlZnQgdCB+ZiB+aW5pdFxubGV0IGZvbGQyX29rIGwxIGwyIH5pbml0IH5mID0gQ2FtbC5MaXN0LmZvbGRfbGVmdDIgbDEgbDIgfmluaXQgfmZcbmxldCBmb3JfYWxsIHQgfmYgPSBDYW1sLkxpc3QuZm9yX2FsbCB0IH5mXG5sZXQgZm9yX2FsbDJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QuZm9yX2FsbDIgbDEgbDIgfmZcbmxldCBpdGVyIHQgfmYgPSBDYW1sLkxpc3QuaXRlciB0IH5mXG5sZXQgaXRlcjJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QuaXRlcjIgbDEgbDIgfmZcbmxldCBub250YWlsX21hcCB0IH5mID0gQ2FtbC5MaXN0Lm1hcCB0IH5mXG5sZXQgbm9udGFpbF9tYXBpIHQgfmYgPSBDYW1sLkxpc3QubWFwaSB0IH5mXG5sZXQgcGFydGl0aW9uIHQgfmYgPSBDYW1sLkxpc3QucGFydGl0aW9uIHQgfmZcbmxldCByZXZfbWFwIHQgfmYgPSBDYW1sLkxpc3QucmV2X21hcCB0IH5mXG5sZXQgcmV2X21hcDJfb2sgbDEgbDIgfmYgPSBDYW1sLkxpc3QucmV2X21hcDIgbDEgbDIgfmZcbmxldCBzb3J0IGwgfmNvbXBhcmUgPSBDYW1sLkxpc3Quc29ydCBsIH5jbXA6Y29tcGFyZVxubGV0IHN0YWJsZV9zb3J0IGwgfmNvbXBhcmUgPSBDYW1sLkxpc3Quc3RhYmxlX3NvcnQgbCB+Y21wOmNvbXBhcmVcblxubGV0IHJldiA9IGZ1bmN0aW9uXG4gIHwgKFtdIHwgWyBfIF0pIGFzIHJlcyAtPiByZXNcbiAgfCB4IDo6IHkgOjogcmVzdCAtPiByZXZfYXBwZW5kIHJlc3QgWyB5OyB4IF1cbjs7XG5cbmxldCBmb2xkX3JpZ2h0IGwgfmYgfmluaXQgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPiBpbml0ICgqIGF2b2lkIHRoZSBhbGxvY2F0aW9uIG9mIFt+Zl0gYmVsb3cgKilcbiAgfCBfIC0+IGZvbGQgfmY6KGZ1biBhIGIgLT4gZiBiIGEpIH5pbml0IChyZXYgbClcbjs7XG4iLCIoKlxuICAgVGhpcyBpcyB0aGUgaW50ZXJmYWNlIHRvIHRoZSBydW50aW1lIHN1cHBvcnQgZm9yIFtwcHhfaGFzaF0uXG5cbiAgIFRoZSBbcHB4X2hhc2hdIHN5bnRheCBleHRlbnNpb24gc3VwcG9ydHM6IFtAQGRlcml2aW5nIGhhc2hdIGFuZCBbJWhhc2hfZm9sZDogVFlQRV0gYW5kXG4gICBbJWhhc2g6IFRZUEVdXG5cbiAgIEZvciB0eXBlIFt0XSBhIGZ1bmN0aW9uIFtoYXNoX2ZvbGRfdF0gb2YgdHlwZSBbSGFzaC5zdGF0ZSAtPiB0IC0+IEhhc2guc3RhdGVdIGlzXG4gICBnZW5lcmF0ZWQuXG5cbiAgIFRoZSBnZW5lcmF0ZWQgW2hhc2hfZm9sZF88VD5dIGZ1bmN0aW9uIGlzIGNvbXBvc2l0aW9uYWwsIGZvbGxvd2luZyB0aGUgc3RydWN0dXJlIG9mIHRoZVxuICAgdHlwZTsgYWxsb3dpbmcgdXNlciBvdmVycmlkZXMgYXQgZXZlcnkgbGV2ZWwuIFRoaXMgaXMgaW4gY29udHJhc3QgdG8gb2NhbWwncyBidWlsdGluXG4gICBwb2x5bW9ycGhpYyBoYXNoaW5nIFtIYXNodGJsLmhhc2hdIHdoaWNoIGlnbm9yZXMgdXNlciBvdmVycmlkZXMuXG5cbiAgIFRoZSBnZW5lcmF0b3IgYWxzbyBwcm92aWRlcyBhIGRpcmVjdCBoYXNoLWZ1bmN0aW9uIFtoYXNoXSAobmFtZWQgW2hhc2hfPFQ+XSB3aGVuIDxUPiAhPVxuICAgXCJ0XCIpIG9mIHR5cGU6IFt0IC0+IEhhc2guaGFzaF92YWx1ZV0uXG5cbiAgIFRoZSBmb2xkaW5nIGhhc2ggZnVuY3Rpb24gY2FuIGJlIGFjY2Vzc2VkIGFzIFslaGFzaF9mb2xkOiBUWVBFXVxuICAgVGhlIGRpcmVjdCBoYXNoIGZ1bmN0aW9uIGNhbiBiZSBhY2Nlc3NlZCBhcyBbJWhhc2g6IFRZUEVdXG4qKVxuXG5vcGVuISBJbXBvcnQwXG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBDaGFyID0gQ2hhcjBcbm1vZHVsZSBJbnQgPSBJbnQwXG5tb2R1bGUgTGlzdCA9IExpc3QwXG5pbmNsdWRlIEhhc2hfaW50ZlxuXG4oKiogQnVpbHRpbiBmb2xkaW5nLXN0eWxlIGhhc2ggZnVuY3Rpb25zLCBhYnN0cmFjdGVkIG92ZXIgW0hhc2hfaW50Zi5TXSAqKVxubW9kdWxlIEZvbGRpbmcgKEhhc2ggOiBIYXNoX2ludGYuUykgOlxuICBIYXNoX2ludGYuQnVpbHRpbl9pbnRmXG4gIHdpdGggdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgIGFuZCB0eXBlIGhhc2hfdmFsdWUgPSBIYXNoLmhhc2hfdmFsdWUgPSBzdHJ1Y3RcbiAgdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlXG4gIHR5cGUgJ2EgZm9sZGVyID0gc3RhdGUgLT4gJ2EgLT4gc3RhdGVcblxuICBsZXQgaGFzaF9mb2xkX3VuaXQgcyAoKSA9IHNcbiAgbGV0IGhhc2hfZm9sZF9pbnQgPSBIYXNoLmZvbGRfaW50XG4gIGxldCBoYXNoX2ZvbGRfaW50NjQgPSBIYXNoLmZvbGRfaW50NjRcbiAgbGV0IGhhc2hfZm9sZF9mbG9hdCA9IEhhc2guZm9sZF9mbG9hdFxuICBsZXQgaGFzaF9mb2xkX3N0cmluZyA9IEhhc2guZm9sZF9zdHJpbmdcbiAgbGV0IGFzX2ludCBmIHMgeCA9IGhhc2hfZm9sZF9pbnQgcyAoZiB4KVxuXG4gICgqIFRoaXMgaWdub3JlcyB0aGUgc2lnbiBiaXQgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIHVubGlrZWx5IHRvIGxlYWQgdG9cbiAgICAgZnJlcXVlbnQgY29sbGlzaW9ucyAobWluX3ZhbHVlIGNvbGxpZGluZyB3aXRoIDAgaXMgdGhlIG1vc3QgbGlrZWx5IG9uZSkuICAqKVxuICBsZXQgaGFzaF9mb2xkX2ludDMyID0gYXNfaW50IENhbWwuSW50MzIudG9faW50XG4gIGxldCBoYXNoX2ZvbGRfY2hhciA9IGFzX2ludCBDaGFyLnRvX2ludFxuXG4gIGxldCBoYXNoX2ZvbGRfYm9vbCA9XG4gICAgYXNfaW50IChmdW5jdGlvblxuICAgICAgfCB0cnVlIC0+IDFcbiAgICAgIHwgZmFsc2UgLT4gMClcbiAgOztcblxuICBsZXQgaGFzaF9mb2xkX25hdGl2ZWludCBzIHggPSBoYXNoX2ZvbGRfaW50NjQgcyAoQ2FtbC5JbnQ2NC5vZl9uYXRpdmVpbnQgeClcblxuICBsZXQgaGFzaF9mb2xkX29wdGlvbiBoYXNoX2ZvbGRfZWxlbSBzID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gaGFzaF9mb2xkX2ludCBzIDBcbiAgICB8IFNvbWUgeCAtPiBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2ludCBzIDEpIHhcbiAgOztcblxuICBsZXQgcmVjIGhhc2hfZm9sZF9saXN0X2JvZHkgaGFzaF9mb2xkX2VsZW0gcyBsaXN0ID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IHNcbiAgICB8IHggOjogeHMgLT4gaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSAoaGFzaF9mb2xkX2VsZW0gcyB4KSB4c1xuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfbGlzdCBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgPVxuICAgICgqIFRoZSBbbGVuZ3RoXSBvZiB0aGUgbGlzdCBtdXN0IGJlIGluY29ycG9yYXRlZCBpbnRvIHRoZSBoYXNoLXN0YXRlIHNvIHZhbHVlcyBvZlxuICAgICAgIHR5cGVzIHN1Y2ggYXMgW3VuaXQgbGlzdF0gLSAoW10sIFsoKV0sIFsoKTsoKV0sLi4pIGFyZSBoYXNoZWQgZGlmZmVyZW50bHkuICopXG4gICAgKCogVGhlIFtsZW5ndGhdIG11c3QgY29tZSBiZWZvcmUgdGhlIGVsZW1lbnRzIHRvIGF2b2lkIGEgdmlvbGF0aW9uIG9mIHRoZSBydWxlXG4gICAgICAgZW5mb3JjZWQgYnkgUGVyZmVjdF9oYXNoLiAqKVxuICAgIGxldCBzID0gaGFzaF9mb2xkX2ludCBzIChMaXN0Lmxlbmd0aCBsaXN0KSBpblxuICAgIGxldCBzID0gaGFzaF9mb2xkX2xpc3RfYm9keSBoYXNoX2ZvbGRfZWxlbSBzIGxpc3QgaW5cbiAgICBzXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9sYXp5X3QgaGFzaF9mb2xkX2VsZW0gcyB4ID0gaGFzaF9mb2xkX2VsZW0gcyAoQ2FtbC5MYXp5LmZvcmNlIHgpXG4gIGxldCBoYXNoX2ZvbGRfcmVmX2Zyb3plbiBoYXNoX2ZvbGRfZWxlbSBzIHggPSBoYXNoX2ZvbGRfZWxlbSBzICF4XG5cbiAgbGV0IHJlYyBoYXNoX2ZvbGRfYXJyYXlfZnJvemVuX2kgaGFzaF9mb2xkX2VsZW0gcyBhcnJheSBpID1cbiAgICBpZiBpID0gQXJyYXkubGVuZ3RoIGFycmF5XG4gICAgdGhlbiBzXG4gICAgZWxzZSAoXG4gICAgICBsZXQgZSA9IEFycmF5LnVuc2FmZV9nZXQgYXJyYXkgaSBpblxuICAgICAgaGFzaF9mb2xkX2FycmF5X2Zyb3plbl9pIGhhc2hfZm9sZF9lbGVtIChoYXNoX2ZvbGRfZWxlbSBzIGUpIGFycmF5IChpICsgMSkpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9hcnJheV9mcm96ZW4gaGFzaF9mb2xkX2VsZW0gcyBhcnJheSA9XG4gICAgaGFzaF9mb2xkX2FycmF5X2Zyb3plbl9pXG4gICAgICAoKiBbbGVuZ3RoXSBtdXN0IGJlIGluY29ycG9yYXRlZCBmb3IgYXJyYXlzLCBhcyBpdCBpcyBmb3IgbGlzdHMuIFNlZSBjb21tZW50IGFib3ZlICopXG4gICAgICBoYXNoX2ZvbGRfZWxlbVxuICAgICAgKGhhc2hfZm9sZF9pbnQgcyAoQXJyYXkubGVuZ3RoIGFycmF5KSlcbiAgICAgIGFycmF5XG4gICAgICAwXG4gIDs7XG5cbiAgKCogdGhlIGR1cGxpY2F0aW9uIGhlcmUgaXMgYmVjYXVzZSB3ZSB0aGlua1xuICAgICBvY2FtbCBjYW4ndCBlbGltaW5hdGUgaW5kaXJlY3QgZnVuY3Rpb24gY2FsbHMgb3RoZXJ3aXNlLiAqKVxuICBsZXQgaGFzaF9uYXRpdmVpbnQgeCA9XG4gICAgSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX25hdGl2ZWludCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIDs7XG5cbiAgbGV0IGhhc2hfaW50NjQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9pbnQ2NCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2ludDMyIHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfaW50MzIgKEhhc2gucmVzZXQgKEhhc2guYWxsb2MgKCkpKSB4KVxuICBsZXQgaGFzaF9jaGFyIHggPSBIYXNoLmdldF9oYXNoX3ZhbHVlIChoYXNoX2ZvbGRfY2hhciAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2ludCB4ID0gSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX2ludCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX2Jvb2wgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9ib29sIChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcblxuICBsZXQgaGFzaF9zdHJpbmcgeCA9XG4gICAgSGFzaC5nZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX3N0cmluZyAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZmxvYXQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF9mbG9hdCAoSGFzaC5yZXNldCAoSGFzaC5hbGxvYyAoKSkpIHgpXG4gIGxldCBoYXNoX3VuaXQgeCA9IEhhc2guZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF91bml0IChIYXNoLnJlc2V0IChIYXNoLmFsbG9jICgpKSkgeClcbmVuZFxuXG5tb2R1bGUgRiAoSGFzaCA6IEhhc2hfaW50Zi5TKSA6XG4gIEhhc2hfaW50Zi5GdWxsXG4gIHdpdGggdHlwZSBoYXNoX3ZhbHVlID0gSGFzaC5oYXNoX3ZhbHVlXG4gICBhbmQgdHlwZSBzdGF0ZSA9IEhhc2guc3RhdGVcbiAgIGFuZCB0eXBlIHNlZWQgPSBIYXNoLnNlZWQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBIYXNoXG5cbiAgdHlwZSAnYSBmb2xkZXIgPSBzdGF0ZSAtPiAnYSAtPiBzdGF0ZVxuXG4gIGxldCBjcmVhdGUgP3NlZWQgKCkgPSByZXNldCA/c2VlZCAoYWxsb2MgKCkpXG4gIGxldCBvZl9mb2xkIGhhc2hfZm9sZF90IHQgPSBnZXRfaGFzaF92YWx1ZSAoaGFzaF9mb2xkX3QgKGNyZWF0ZSAoKSkgdClcblxuICBtb2R1bGUgQnVpbHRpbiA9IEZvbGRpbmcgKEhhc2gpXG5cbiAgbGV0IHJ1biA/c2VlZCBmb2xkZXIgeCA9XG4gICAgSGFzaC5nZXRfaGFzaF92YWx1ZSAoZm9sZGVyIChIYXNoLnJlc2V0ID9zZWVkIChIYXNoLmFsbG9jICgpKSkgeClcbiAgOztcbmVuZFxuXG5tb2R1bGUgSW50ZXJuYWxoYXNoIDogc2lnXG4gIGluY2x1ZGVcbiAgICBIYXNoX2ludGYuU1xuICAgIHdpdGggdHlwZSBzdGF0ZSA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLnN0YXRlXG4gICAgICgqIFdlIGdpdmUgYSBjb25jcmV0ZSB0eXBlIGZvciBbc3RhdGVdLCBhbGJlaXQgb25seSBwYXJ0aWFsbHkgZXhwb3NlZCAoc2VlXG4gICAgICAgIEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzKSwgc28gdGhhdCBpdCB1bmlmaWVzIHdpdGggdGhlIHNhbWUgdHlwZSBpbiBbQmFzZV9ib290XSxcbiAgICAgICAgYW5kIHRvIGFsbG93IG9wdGltaXphdGlvbnMgZm9yIHRoZSBpbW1lZGlhdGUgdHlwZS4gKilcbiAgICAgYW5kIHR5cGUgc2VlZCA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLnNlZWRcbiAgICAgYW5kIHR5cGUgaGFzaF92YWx1ZSA9IEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzLmhhc2hfdmFsdWVcblxuICBleHRlcm5hbCBmb2xkX2ludDY0IDogc3RhdGUgLT4gaW50NjQgLT4gc3RhdGUgPSBcIkJhc2VfaW50ZXJuYWxoYXNoX2ZvbGRfaW50NjRcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGZvbGRfaW50IDogc3RhdGUgLT4gaW50IC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2ludFwiIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgZm9sZF9mbG9hdCA6IHN0YXRlIC0+IGZsb2F0IC0+IHN0YXRlID0gXCJCYXNlX2ludGVybmFsaGFzaF9mb2xkX2Zsb2F0XCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBmb2xkX3N0cmluZyA6IHN0YXRlIC0+IHN0cmluZyAtPiBzdGF0ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZm9sZF9zdHJpbmdcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIGdldF9oYXNoX3ZhbHVlIDogc3RhdGUgLT4gaGFzaF92YWx1ZSA9IFwiQmFzZV9pbnRlcm5hbGhhc2hfZ2V0X2hhc2hfdmFsdWVcIlxuICBbQEBub2FsbG9jXVxuZW5kID0gc3RydWN0XG4gIGxldCBkZXNjcmlwdGlvbiA9IFwiaW50ZXJuYWxoYXNoXCJcblxuICBpbmNsdWRlIEJhc2VfaW50ZXJuYWxoYXNoX3R5cGVzXG5cbiAgbGV0IGFsbG9jICgpID0gY3JlYXRlX3NlZWRlZCAwXG4gIGxldCByZXNldCA/KHNlZWQgPSAwKSBfdCA9IGNyZWF0ZV9zZWVkZWQgc2VlZFxuXG4gIG1vZHVsZSBGb3JfdGVzdHMgPSBzdHJ1Y3RcbiAgICBsZXQgY29tcGFyZV9zdGF0ZSAoYSA6IHN0YXRlKSAoYiA6IHN0YXRlKSA9IGNvbXBhcmUgKGEgOj4gaW50KSAoYiA6PiBpbnQpXG4gICAgbGV0IHN0YXRlX3RvX3N0cmluZyAoc3RhdGUgOiBzdGF0ZSkgPSBJbnQudG9fc3RyaW5nIChzdGF0ZSA6PiBpbnQpXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIGluY2x1ZGUgSW50ZXJuYWxoYXNoXG5cbiAgdHlwZSAnYSBmb2xkZXIgPSBzdGF0ZSAtPiAnYSAtPiBzdGF0ZVxuXG4gIGxldCBjcmVhdGUgP3NlZWQgKCkgPSByZXNldCA/c2VlZCAoYWxsb2MgKCkpXG4gIGxldCBydW4gP3NlZWQgZm9sZGVyIHggPSBnZXRfaGFzaF92YWx1ZSAoZm9sZGVyIChyZXNldCA/c2VlZCAoYWxsb2MgKCkpKSB4KVxuICBsZXQgb2ZfZm9sZCBoYXNoX2ZvbGRfdCB0ID0gZ2V0X2hhc2hfdmFsdWUgKGhhc2hfZm9sZF90IChjcmVhdGUgKCkpIHQpXG5cbiAgbW9kdWxlIEJ1aWx0aW4gPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRm9sZGluZyA9IEZvbGRpbmcgKEludGVybmFsaGFzaClcbiAgICBpbmNsdWRlIEZvbGRpbmdcblxuICAgICgqIFtGb2xkaW5nXSBwcm92aWRlcyBzb21lIGRlZmF1bHQgaW1wbGVtZW50YXRpb25zIGZvciB0aGUgW2hhc2hfKl0gZnVuY3Rpb25zIGJlbG93LFxuICAgICAgIGJ1dCB0aGV5IGFyZSBpbmVmZmljaWVudCBmb3Igc29tZSB1c2UtY2FzZXMgYmVjYXVzZSBvZiB0aGUgdXNlIG9mIHRoZSBbaGFzaF9mb2xkXVxuICAgICAgIGZ1bmN0aW9ucy4gQXQgdGhpcyBwb2ludCwgdGhlIFtoYXNoX3ZhbHVlXSB0eXBlIGhhcyBiZWVuIGZpeGVkIHRvIFtpbnRdLCBzbyB0aGlzXG4gICAgICAgbW9kdWxlIGNhbiBwcm92aWRlIHNwZWNpYWxpemVkIGltcGxlbWVudGF0aW9ucy4gKilcblxuICAgIGxldCBoYXNoX2NoYXIgPSBDaGFyMC50b19pbnRcblxuICAgICgqIFRoaXMgaGFzaCB3YXMgY2hvc2VuIGZyb20gaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmFkYm95LzYyNjc3NDNcblxuICAgICAgIEl0IGF0dGVtcHRzIHRvIGZ1bGZpbGwgdGhlIHByaW1hcnkgZ29hbHMgb2YgYSBub24tY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uOlxuXG4gICAgICAgLSBhIGJpdCBjaGFuZ2UgaW4gdGhlIGlucHV0IHNob3VsZCBjaGFuZ2UgfjEvMiBvZiB0aGUgb3V0cHV0IGJpdHNcbiAgICAgICAtIHRoZSBvdXRwdXQgc2hvdWxkIGJlIHVuaWZvcm1seSBkaXN0cmlidXRlZCBhY3Jvc3MgdGhlIG91dHB1dCByYW5nZVxuICAgICAgIC0gaW5wdXRzIHRoYXQgYXJlIGNsb3NlIHRvIGVhY2ggb3RoZXIgc2hvdWxkbid0IGxlYWQgdG8gb3V0cHV0cyB0aGF0IGFyZSBjbG9zZSB0b1xuICAgICAgICAgZWFjaCBvdGhlci5cbiAgICAgICAtIGFsbCBiaXRzIG9mIHRoZSBpbnB1dCBhcmUgdXNlZCBpbiBnZW5lcmF0aW5nIHRoZSBvdXRwdXRcblxuICAgICAgIEluIG91ciBjYXNlIHdlIGFsc28gd2FudCBpdCB0byBiZSBmYXN0LCBub24tYWxsb2NhdGluZywgYW5kIGlubGluYWJsZS4gICopXG4gICAgbGV0W0BpbmxpbmUgYWx3YXlzXSBoYXNoX2ludCAodCA6IGludCkgPVxuICAgICAgbGV0IHQgPSBsbm90IHQgKyAodCBsc2wgMjEpIGluXG4gICAgICBsZXQgdCA9IHQgbHhvciAodCBsc3IgMjQpIGluXG4gICAgICBsZXQgdCA9IHQgKyAodCBsc2wgMykgKyAodCBsc2wgOCkgaW5cbiAgICAgIGxldCB0ID0gdCBseG9yICh0IGxzciAxNCkgaW5cbiAgICAgIGxldCB0ID0gdCArICh0IGxzbCAyKSArICh0IGxzbCA0KSBpblxuICAgICAgbGV0IHQgPSB0IGx4b3IgKHQgbHNyIDI4KSBpblxuICAgICAgdCArICh0IGxzbCAzMSlcbiAgICA7O1xuXG4gICAgbGV0IGhhc2hfYm9vbCB4ID0gaWYgeCB0aGVuIDEgZWxzZSAwXG5cbiAgICBleHRlcm5hbCBoYXNoX2Zsb2F0IDogZmxvYXQgLT4gaW50ID0gXCJCYXNlX2hhc2hfZG91YmxlXCIgW0BAbm9hbGxvY11cblxuICAgIGxldCBoYXNoX3VuaXQgKCkgPSAwXG4gIGVuZFxuZW5kXG5cbmluY2x1ZGUgVFxuIiwib3BlbiBJbXBvcnQwXG5cbmxldCBwaHlzX2VxdWFsID0gcGh5c19lcXVhbFxuXG5leHRlcm5hbCBwb2x5bW9ycGhpY19jb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50ID0gXCIlY29tcGFyZVwiXG5leHRlcm5hbCBwb2x5bW9ycGhpY19lcXVhbCA6ICdhIC0+ICdhIC0+IGJvb2wgPSBcIiVlcXVhbFwiXG5leHRlcm5hbCAoICYmICkgOiBib29sIC0+IGJvb2wgLT4gYm9vbCA9IFwiJXNlcXVhbmRcIlxuXG5sZXQgY29tcGFyZV9hYnN0cmFjdCB+dHlwZV9uYW1lIF8gXyA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIGZhaWx3aXRoXG4gICAgXCJDb21wYXJlIGNhbGxlZCBvbiB0aGUgdHlwZSAlcywgd2hpY2ggaXMgYWJzdHJhY3QgaW4gYW4gaW1wbGVtZW50YXRpb24uXCJcbiAgICB0eXBlX25hbWVcbjs7XG5cbmxldCBlcXVhbF9hYnN0cmFjdCB+dHlwZV9uYW1lIF8gXyA9XG4gIFByaW50Zi5rc3ByaW50ZlxuICAgIGZhaWx3aXRoXG4gICAgXCJFcXVhbCBjYWxsZWQgb24gdGhlIHR5cGUgJXMsIHdoaWNoIGlzIGFic3RyYWN0IGluIGFuIGltcGxlbWVudGF0aW9uLlwiXG4gICAgdHlwZV9uYW1lXG47O1xuXG50eXBlICdhIGNvbXBhcmUgPSAnYSAtPiAnYSAtPiBpbnRcbnR5cGUgJ2EgZXF1YWwgPSAnYSAtPiAnYSAtPiBib29sXG5cbm1vZHVsZSBDb21wYXJhYmxlID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBjb21wYXJlIDogdCBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIGNvbXBhcmUgLT4gJ2EgdCBjb21wYXJlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIGNvbXBhcmUgLT4gJ2IgY29tcGFyZSAtPiAoJ2EsICdiKSB0IGNvbXBhcmVcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgY29tcGFyZSA6ICdhIGNvbXBhcmUgLT4gJ2IgY29tcGFyZSAtPiAnYyBjb21wYXJlIC0+ICgnYSwgJ2IsICdjKSB0IGNvbXBhcmVcbiAgZW5kXG5lbmRcblxubW9kdWxlIEVxdWFsID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBlcXVhbCA6IHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdhIHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBlcXVhbCA6ICdhIGVxdWFsIC0+ICdiIGVxdWFsIC0+ICgnYSwgJ2IpIHQgZXF1YWxcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgZXF1YWwgOiAnYSBlcXVhbCAtPiAnYiBlcXVhbCAtPiAnYyBlcXVhbCAtPiAoJ2EsICdiLCAnYykgdCBlcXVhbFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQnVpbHRpbiA9IHN0cnVjdFxuICBsZXQgY29tcGFyZV9ib29sIDogYm9vbCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2NoYXIgOiBjaGFyIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfZmxvYXQgOiBmbG9hdCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludCA6IGludCBjb21wYXJlID0gUG9seS5jb21wYXJlXG4gIGxldCBjb21wYXJlX2ludDMyIDogaW50MzIgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuICBsZXQgY29tcGFyZV9pbnQ2NCA6IGludDY0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfbmF0aXZlaW50IDogbmF0aXZlaW50IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfc3RyaW5nIDogc3RyaW5nIGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgbGV0IGNvbXBhcmVfdW5pdCA6IHVuaXQgY29tcGFyZSA9IFBvbHkuY29tcGFyZVxuXG4gIGxldCBjb21wYXJlX2FycmF5IGNvbXBhcmVfZWx0IGEgYiA9XG4gICAgaWYgcGh5c19lcXVhbCBhIGJcbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIGxldCBsZW5fYSA9IEFycmF5MC5sZW5ndGggYSBpblxuICAgICAgbGV0IGxlbl9iID0gQXJyYXkwLmxlbmd0aCBiIGluXG4gICAgICBsZXQgcmV0ID0gY29tcGFyZSBsZW5fYSBsZW5fYiBpblxuICAgICAgaWYgcmV0IDw+IDBcbiAgICAgIHRoZW4gcmV0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHJlYyBsb29wIGkgPVxuICAgICAgICAgIGlmIGkgPSBsZW5fYVxuICAgICAgICAgIHRoZW4gMFxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IGwgPSBBcnJheTAudW5zYWZlX2dldCBhIGlcbiAgICAgICAgICAgIGFuZCByID0gQXJyYXkwLnVuc2FmZV9nZXQgYiBpIGluXG4gICAgICAgICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgbCByIGluXG4gICAgICAgICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGxvb3AgKGkgKyAxKSlcbiAgICAgICAgaW5cbiAgICAgICAgbG9vcCAwKSlcbiAgOztcblxuICBsZXQgcmVjIGNvbXBhcmVfbGlzdCBjb21wYXJlX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgW10sIFtdIC0+IDBcbiAgICB8IFtdLCBfIC0+IC0xXG4gICAgfCBfLCBbXSAtPiAxXG4gICAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgICBsZXQgcmVzID0gY29tcGFyZV9lbHQgeCB5IGluXG4gICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGNvbXBhcmVfbGlzdCBjb21wYXJlX2VsdCB4cyB5c1xuICA7O1xuXG4gIGxldCBjb21wYXJlX29wdGlvbiBjb21wYXJlX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiAwXG4gICAgfCBOb25lLCBTb21lIF8gLT4gLTFcbiAgICB8IFNvbWUgXywgTm9uZSAtPiAxXG4gICAgfCBTb21lIGEsIFNvbWUgYiAtPiBjb21wYXJlX2VsdCBhIGJcbiAgOztcblxuICBsZXQgY29tcGFyZV9yZWYgY29tcGFyZV9lbHQgYSBiID0gY29tcGFyZV9lbHQgIWEgIWJcbiAgbGV0IGVxdWFsX2Jvb2wgOiBib29sIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfY2hhciA6IGNoYXIgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQgOiBpbnQgZXF1YWwgPSBQb2x5LmVxdWFsXG4gIGxldCBlcXVhbF9pbnQzMiA6IGludDMyIGVxdWFsID0gUG9seS5lcXVhbFxuICBsZXQgZXF1YWxfaW50NjQgOiBpbnQ2NCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX25hdGl2ZWludCA6IG5hdGl2ZWludCBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3N0cmluZyA6IHN0cmluZyBlcXVhbCA9IFBvbHkuZXF1YWxcbiAgbGV0IGVxdWFsX3VuaXQgOiB1bml0IGVxdWFsID0gUG9seS5lcXVhbFxuXG4gICgqIFtQb2x5LmVxdWFsXSBpcyBJRUVFIGNvbXBsaWFudCwgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudCBoZXJlLiAqKVxuICBsZXQgZXF1YWxfZmxvYXQgeCB5ID0gZXF1YWxfaW50IChjb21wYXJlX2Zsb2F0IHggeSkgMFxuXG4gIGxldCBlcXVhbF9hcnJheSBlcXVhbF9lbHQgYSBiID1cbiAgICBwaHlzX2VxdWFsIGEgYlxuICAgIHx8XG4gICAgbGV0IGxlbl9hID0gQXJyYXkwLmxlbmd0aCBhIGluXG4gICAgbGV0IGxlbl9iID0gQXJyYXkwLmxlbmd0aCBiIGluXG4gICAgZXF1YWwgbGVuX2EgbGVuX2JcbiAgICAmJlxuICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgIGkgPSBsZW5fYVxuICAgICAgfHxcbiAgICAgIGxldCBsID0gQXJyYXkwLnVuc2FmZV9nZXQgYSBpXG4gICAgICBhbmQgciA9IEFycmF5MC51bnNhZmVfZ2V0IGIgaSBpblxuICAgICAgZXF1YWxfZWx0IGwgciAmJiBsb29wIChpICsgMSlcbiAgICBpblxuICAgIGxvb3AgMFxuICA7O1xuXG4gIGxldCByZWMgZXF1YWxfbGlzdCBlcXVhbF9lbHQgYSBiID1cbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IFtdLCBbXSAtPiB0cnVlXG4gICAgfCBbXSwgXyB8IF8sIFtdIC0+IGZhbHNlXG4gICAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+IGVxdWFsX2VsdCB4IHkgJiYgZXF1YWxfbGlzdCBlcXVhbF9lbHQgeHMgeXNcbiAgOztcblxuICBsZXQgZXF1YWxfb3B0aW9uIGVxdWFsX2VsdCBhIGIgPVxuICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgIHwgTm9uZSwgTm9uZSAtPiB0cnVlXG4gICAgfCBOb25lLCBTb21lIF8gfCBTb21lIF8sIE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgYSwgU29tZSBiIC0+IGVxdWFsX2VsdCBhIGJcbiAgOztcblxuICBsZXQgZXF1YWxfcmVmIGVxdWFsX2VsdCBhIGIgPSBlcXVhbF9lbHQgIWEgIWJcbmVuZFxuIiwiKCoqIFRoaXMgbW9kdWxlIGlzIGZvciB1c2UgYnkgcHB4X2hhc2gsIGFuZCBpcyB0aHVzIG5vdCBpbiB0aGUgaW50ZXJmYWNlIG9mIEJhc2UuICopXG5tb2R1bGUgU3RkID0gc3RydWN0XG4gIG1vZHVsZSBIYXNoID0gSGFzaCAoKiogQGNhbm9uaWNhbCBCYXNlLkhhc2ggKilcbmVuZFxuXG50eXBlICdhIGhhc2hfZm9sZCA9IFN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFN0ZC5IYXNoLnN0YXRlXG5cbm1vZHVsZSBIYXNoYWJsZSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3QgOiB0IGhhc2hfZm9sZFxuICAgIHZhbCBoYXNoIDogdCAtPiBTdGQuSGFzaC5oYXNoX3ZhbHVlXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMxID0gc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3QgOiAnYSBoYXNoX2ZvbGQgLT4gJ2EgdCBoYXNoX2ZvbGRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzIgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRcblxuICAgIHZhbCBoYXNoX2ZvbGRfdCA6ICdhIGhhc2hfZm9sZCAtPiAnYiBoYXNoX2ZvbGQgLT4gKCdhLCAnYikgdCBoYXNoX2ZvbGRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgaGFzaF9mb2xkX3RcbiAgICAgIDogICdhIGhhc2hfZm9sZFxuICAgICAgLT4gJ2IgaGFzaF9mb2xkXG4gICAgICAtPiAnYyBoYXNoX2ZvbGRcbiAgICAgIC0+ICgnYSwgJ2IsICdjKSB0IGhhc2hfZm9sZFxuICBlbmRcbmVuZFxuIiwib3BlbiBIYXNoLkJ1aWx0aW5cbm9wZW4gUHB4X2NvbXBhcmVfbGliLkJ1aWx0aW5cbmluY2x1ZGUgU2V4cGxpYjAuU2V4cFxuXG4oKiogVHlwZSBvZiBTLWV4cHJlc3Npb25zICopXG50eXBlIHQgPSBTZXhwbGliMC5TZXhwLnQgPVxuICB8IEF0b20gb2Ygc3RyaW5nXG4gIHwgTGlzdCBvZiB0IGxpc3RcbltAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG5sZXQgcmVjIGNvbXBhcmUgPVxuICAoZnVuIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDFfIGJfXzAwMl9cbiAgICAgdGhlbiAwXG4gICAgIGVsc2UgKFxuICAgICAgIG1hdGNoIGFfXzAwMV8sIGJfXzAwMl8gd2l0aFxuICAgICAgIHwgQXRvbSBfYV9fMDAzXywgQXRvbSBfYl9fMDA0XyAtPiBjb21wYXJlX3N0cmluZyBfYV9fMDAzXyBfYl9fMDA0X1xuICAgICAgIHwgQXRvbSBfLCBfIC0+IC0xXG4gICAgICAgfCBfLCBBdG9tIF8gLT4gMVxuICAgICAgIHwgTGlzdCBfYV9fMDA1XywgTGlzdCBfYl9fMDA2XyAtPiBjb21wYXJlX2xpc3QgY29tcGFyZSBfYV9fMDA1XyBfYl9fMDA2XylcbiAgICAgICA6IHQgLT4gdCAtPiBpbnQpXG47O1xuXG5sZXQgcmVjIChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgbWF0Y2ggYXJnIHdpdGhcbiAgICAgfCBBdG9tIF9hMCAtPlxuICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgaGFzaF9mb2xkX3N0cmluZyBoc3YgX2EwXG4gICAgIHwgTGlzdCBfYTAgLT5cbiAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxIGluXG4gICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgIGhhc2hfZm9sZF9saXN0IGhhc2hfZm9sZF90IGhzdiBfYTBcbiAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcblxuYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICBsZXQgZnVuYyBhcmcgPVxuICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgKGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guY3JlYXRlICgpIGluXG4gICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgaW5cbiAgZnVuIHggLT4gZnVuYyB4XG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgPSBTZXhwbGliMC5TZXhwX2NvbnYuc2V4cF90X3NleHBfZ3JhbW1hclxubGV0IG9mX3N0cmluZyA9ICgpXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgU3lzID0gU3lzMFxuXG50eXBlIHQgPVxuICB8IFczMlxuICB8IFc2NFxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPVxuICAoZnVuY3Rpb25cbiAgICB8IFczMiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJXMzJcIlxuICAgIHwgVzY0IC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlc2NFwiXG4gICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbltAQEBlbmRdXG5cbmxldCBudW1fYml0cyA9IGZ1bmN0aW9uXG4gIHwgVzMyIC0+IDMyXG4gIHwgVzY0IC0+IDY0XG47O1xuXG5sZXQgd29yZF9zaXplID1cbiAgbWF0Y2ggU3lzLndvcmRfc2l6ZV9pbl9iaXRzIHdpdGhcbiAgfCAzMiAtPiBXMzJcbiAgfCA2NCAtPiBXNjRcbiAgfCBfIC0+IGZhaWx3aXRoIFwidW5rbm93biB3b3JkIHNpemVcIlxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgciA9IHJlZiBbIFwiQmFzZS5TZXhwLnBwX2h1bVwiIF1cbmxldCBhbGwgKCkgPSAhclxubGV0IHJlZ2lzdGVyIHAgPSByIDo9IHAgOjogIXJcblxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgcHAgOiBGb3JtYXR0ZXIudCAtPiB0IC0+IHVuaXRcbmVuZFxuXG5tb2R1bGUgUmVnaXN0ZXJfcHAgKE0gOiBzaWdcbiAgICBpbmNsdWRlIFNcblxuICAgIHZhbCBtb2R1bGVfbmFtZSA6IHN0cmluZ1xuICBlbmQpID1cbnN0cnVjdFxuICBpbmNsdWRlIE1cblxuICBsZXQgKCkgPSByZWdpc3RlciAoTS5tb2R1bGVfbmFtZSBeIFwiLnBwXCIpXG5lbmRcblxubW9kdWxlIFJlZ2lzdGVyIChNIDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgZW5kKSA9XG4gIFJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIGxldCBwcCBmb3JtYXR0ZXIgdCA9IENhbWwuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmb3JtYXR0ZXIgKE0udG9fc3RyaW5nIHQpXG4gIGVuZClcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPSBleG4gW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9leG4gOiB0IC0+IFNleHBsaWIwLlNleHAudClcblxuW0BAQGVuZF1cblxubGV0IGV4aXQgPSBDYW1sLmV4aXRcblxuZXhjZXB0aW9uIEZpbmFsbHkgb2YgdCAqIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBGaW5hbGx5XSAoZnVuY3Rpb25cbiAgICB8IEZpbmFsbHkgKGFyZzBfXzAwMV8sIGFyZzFfXzAwMl8pIC0+XG4gICAgICBsZXQgcmVzMF9fMDAzXyA9IHNleHBfb2ZfdCBhcmcwX18wMDFfXG4gICAgICBhbmQgcmVzMV9fMDA0XyA9IHNleHBfb2ZfdCBhcmcxX18wMDJfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJleG4ubWwuRmluYWxseVwiOyByZXMwX18wMDNfOyByZXMxX18wMDRfIF1cbiAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuOztcblxuW0BAQGVuZF1cblxuZXhjZXB0aW9uIFJlcmFpc2VkIG9mIHN0cmluZyAqIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBSZXJhaXNlZF0gKGZ1bmN0aW9uXG4gICAgfCBSZXJhaXNlZCAoYXJnMF9fMDA1XywgYXJnMV9fMDA2XykgLT5cbiAgICAgIGxldCByZXMwX18wMDdfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDA1X1xuICAgICAgYW5kIHJlczFfXzAwOF8gPSBzZXhwX29mX3QgYXJnMV9fMDA2XyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZXhuLm1sLlJlcmFpc2VkXCI7IHJlczBfXzAwN187IHJlczFfXzAwOF8gXVxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5leGNlcHRpb24gU2V4cCBvZiBTZXhwLnRcblxuKCogV2UgaW5zdGFsbCBhIGN1c3RvbSBleG4tY29udmVydGVyIHJhdGhlciB0aGFuIHVzZTpcblxuICAge1tcbiAgICAgZXhjZXB0aW9uIFNleHAgb2YgU2V4cC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuICAgICAoKiAuLi4gKilcbiAgICAgW0BAQGVuZF1cbiAgIF19XG5cbiAgIHRvIGVsaW1pbmF0ZSB0aGUgZXh0cmEgd3JhcHBpbmcgb2YgWyhTZXhwIC4uLildLiAqKVxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFNleHBdIChmdW5jdGlvblxuICAgIHwgU2V4cCB0IC0+IHRcbiAgICB8IF8gLT5cbiAgICAgICgqIFJlYWNoaW5nIHRoaXMgYnJhbmNoIGluZGljYXRlcyBhIGJ1ZyBpbiBzZXhwbGliLiAqKVxuICAgICAgYXNzZXJ0IGZhbHNlKVxuOztcblxubGV0IGNyZWF0ZV9zIHNleHAgPSBTZXhwIHNleHBcblxubGV0IHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIHQgYmFja3RyYWNlID1cbiAgQ2FtbC5QcmludGV4Yy5yYWlzZV93aXRoX2JhY2t0cmFjZSB0IGJhY2t0cmFjZVxuOztcblxuZXh0ZXJuYWwgaXNfcGh5c19lcXVhbF9tb3N0X3JlY2VudCA6IHQgLT4gYm9vbCA9IFwiQmFzZV9jYW1sX2V4bl9pc19tb3N0X3JlY2VudF9leG5cIlxuXG5sZXQgcmVyYWlzZSBleG4gc3RyID1cbiAgbGV0IGV4bicgPSBSZXJhaXNlZCAoc3RyLCBleG4pIGluXG4gIGlmIGlzX3BoeXNfZXF1YWxfbW9zdF9yZWNlbnQgZXhuXG4gIHRoZW4gKFxuICAgIGxldCBidCA9IENhbWwuUHJpbnRleGMuZ2V0X3Jhd19iYWNrdHJhY2UgKCkgaW5cbiAgICByYWlzZV93aXRoX29yaWdpbmFsX2JhY2t0cmFjZSBleG4nIGJ0KVxuICBlbHNlIHJhaXNlIGV4bidcbjs7XG5cbmxldCByZXJhaXNlZiBleGMgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIChmdW4gc3RyICgpIC0+IHJlcmFpc2UgZXhjIHN0cikgZm9ybWF0XG5sZXQgdG9fc3RyaW5nIGV4YyA9IFNleHAudG9fc3RyaW5nX2h1bSB+aW5kZW50OjIgKHNleHBfb2ZfZXhuIGV4YylcbmxldCB0b19zdHJpbmdfbWFjaCBleGMgPSBTZXhwLnRvX3N0cmluZ19tYWNoIChzZXhwX29mX2V4biBleGMpXG5sZXQgc2V4cF9vZl90ID0gc2V4cF9vZl9leG5cblxubGV0IHByb3RlY3R4IH5mIHggfihmaW5hbGx5IDogXyAtPiB1bml0KSA9XG4gIG1hdGNoIGYgeCB3aXRoXG4gIHwgcmVzIC0+XG4gICAgZmluYWxseSB4O1xuICAgIHJlc1xuICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICBsZXQgYnQgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgKG1hdGNoIGZpbmFsbHkgeCB3aXRoXG4gICAgIHwgKCkgLT4gcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgZXhuIGJ0XG4gICAgIHwgZXhjZXB0aW9uIGZpbmFsX2V4biAtPlxuICAgICAgICgqIFVuZm9ydHVuYXRlbHksIHRoZSBiYWNrdHJhY2Ugb2YgdGhlIFtmaW5hbF9leG5dIGlzIGRpc2NhcmRlZCBoZXJlLiAqKVxuICAgICAgIHJhaXNlX3dpdGhfb3JpZ2luYWxfYmFja3RyYWNlIChGaW5hbGx5IChleG4sIGZpbmFsX2V4bikpIGJ0KVxuOztcblxubGV0IHByb3RlY3QgfmYgfmZpbmFsbHkgPSBwcm90ZWN0eCB+ZiAoKSB+ZmluYWxseVxuXG5sZXQgZG9lc19yYWlzZSAodHlwZSBhKSAoZiA6IHVuaXQgLT4gYSkgPVxuICB0cnlcbiAgICBpZ25vcmUgKGYgKCkgOiBhKTtcbiAgICBmYWxzZVxuICB3aXRoXG4gIHwgXyAtPiB0cnVlXG47O1xuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyX3BwIChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBleG5cblxuICAgIGxldCBwcCBwcGYgdCA9XG4gICAgICBtYXRjaCBzZXhwX29mX2V4bl9vcHQgdCB3aXRoXG4gICAgICB8IFNvbWUgc2V4cCAtPiBTZXhwLnBwX2h1bSBwcGYgc2V4cFxuICAgICAgfCBOb25lIC0+IENhbWwuRm9ybWF0LnBwX3ByaW50X3N0cmluZyBwcGYgKENhbWwuUHJpbnRleGMudG9fc3RyaW5nIHQpXG4gICAgOztcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5FeG5cIlxuICBlbmQpXG5cbmxldCBwcmludF93aXRoX2JhY2t0cmFjZSBleGMgcmF3X2JhY2t0cmFjZSA9XG4gIENhbWwuRm9ybWF0LmVwcmludGYgXCJAWzwyPlVuY2F1Z2h0IGV4Y2VwdGlvbjpAXFxuQFxcbkBbJWFAXUBdQFxcbkAuXCIgcHAgZXhjO1xuICBpZiBDYW1sLlByaW50ZXhjLmJhY2t0cmFjZV9zdGF0dXMgKClcbiAgdGhlbiBDYW1sLlByaW50ZXhjLnByaW50X3Jhd19iYWNrdHJhY2UgQ2FtbC5zdGRlcnIgcmF3X2JhY2t0cmFjZTtcbiAgQ2FtbC5mbHVzaCBDYW1sLnN0ZGVyclxuOztcblxubGV0IHNldF91bmNhdWdodF9leGNlcHRpb25faGFuZGxlciAoKSA9XG4gIENhbWwuUHJpbnRleGMuc2V0X3VuY2F1Z2h0X2V4Y2VwdGlvbl9oYW5kbGVyIHByaW50X3dpdGhfYmFja3RyYWNlXG47O1xuXG5sZXQgaGFuZGxlX3VuY2F1Z2h0X2F1eCB+ZG9fYXRfZXhpdCB+ZXhpdCBmID1cbiAgdHJ5IGYgKCkgd2l0aFxuICB8IGV4YyAtPlxuICAgIGxldCByYXdfYmFja3RyYWNlID0gQ2FtbC5QcmludGV4Yy5nZXRfcmF3X2JhY2t0cmFjZSAoKSBpblxuICAgICgqIE9uZSByZWFzb24gdG8gcnVuIFtkb19hdF9leGl0XSBoYW5kbGVycyBiZWZvcmUgcHJpbnRpbmcgb3V0IHRoZSBlcnJvciBtZXNzYWdlIGlzXG4gICAgICAgdGhhdCBpdCBoZWxwcyBjdXJzZXMgYXBwbGljYXRpb25zIGJyaW5nIHRoZSB0ZXJtaW5hbCBpbiBhIGdvb2Qgc3RhdGUsIG90aGVyd2lzZSB0aGVcbiAgICAgICBlcnJvciBtZXNzYWdlIG1pZ2h0IGdldCBjb3JydXB0ZWQuICBBbHNvLCB0aGUgT0NhbWwgdG9wLWxldmVsIHVuY2F1Z2h0IGV4Y2VwdGlvblxuICAgICAgIGhhbmRsZXIgZG9lcyB0aGUgc2FtZS4gKilcbiAgICBpZiBkb19hdF9leGl0XG4gICAgdGhlbiAoXG4gICAgICB0cnkgQ2FtbC5kb19hdF9leGl0ICgpIHdpdGhcbiAgICAgIHwgXyAtPiAoKSk7XG4gICAgKHRyeSBwcmludF93aXRoX2JhY2t0cmFjZSBleGMgcmF3X2JhY2t0cmFjZSB3aXRoXG4gICAgIHwgXyAtPlxuICAgICAgICh0cnlcbiAgICAgICAgICBDYW1sLlByaW50Zi5lcHJpbnRmIFwiRXhuLmhhbmRsZV91bmNhdWdodCBjb3VsZCBub3QgcHJpbnQ7IGV4aXRpbmcgYW55d2F5XFxuJSFcIlxuICAgICAgICB3aXRoXG4gICAgICAgIHwgXyAtPiAoKSkpO1xuICAgIGV4aXQgMVxuOztcblxubGV0IGhhbmRsZV91bmNhdWdodF9hbmRfZXhpdCBmID0gaGFuZGxlX3VuY2F1Z2h0X2F1eCBmIH5leGl0IH5kb19hdF9leGl0OnRydWVcblxubGV0IGhhbmRsZV91bmNhdWdodCB+ZXhpdDptdXN0X2V4aXQgZiA9XG4gIGhhbmRsZV91bmNhdWdodF9hdXggZiB+ZXhpdDooaWYgbXVzdF9leGl0IHRoZW4gZXhpdCBlbHNlIGlnbm9yZSkgfmRvX2F0X2V4aXQ6bXVzdF9leGl0XG47O1xuXG5sZXQgcmVyYWlzZV91bmNhdWdodCBzdHIgZnVuYyA9XG4gIHRyeSBmdW5jICgpIHdpdGhcbiAgfCBleG4gLT5cbiAgICBsZXQgYnQgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpIGluXG4gICAgcmFpc2Vfd2l0aF9vcmlnaW5hbF9iYWNrdHJhY2UgKFJlcmFpc2VkIChzdHIsIGV4bikpIGJ0XG47O1xuXG5leHRlcm5hbCBjbGVhcl9iYWNrdHJhY2UgOiB1bml0IC0+IHVuaXQgPSBcIkJhc2VfY2xlYXJfY2FtbF9iYWNrdHJhY2VfcG9zXCIgW0BAbm9hbGxvY11cblxubGV0IHJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIGUgPVxuICAoKiBXZSBjbGVhciB0aGUgYmFja3RyYWNlIHRvIHJlZHVjZSBjb25mdXNpb24sIHNvIHRoYXQgcGVvcGxlIGRvbid0IHRoaW5rIHdoYXRldmVyXG4gICAgIGlzIHN0b3JlZCBjb3JyZXNwb25kcyB0byB0aGlzIHJhaXNlLiAqKVxuICBjbGVhcl9iYWNrdHJhY2UgKCk7XG4gIENhbWwucmFpc2Vfbm90cmFjZSBlXG47O1xuXG5sZXQgaW5pdGlhbGl6ZV9tb2R1bGUgKCkgPSBzZXRfdW5jYXVnaHRfZXhjZXB0aW9uX2hhbmRsZXIgKClcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbGV0IGNsZWFyX2JhY2t0cmFjZSA9IGNsZWFyX2JhY2t0cmFjZVxuZW5kXG4iLCIoKiBiZWxvbmdzIGluIENvbW1vbiwgYnV0IG1vdmVkIGhlcmUgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzICopXG5cbm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHJldHVybiA9IHsgcmV0dXJuIDogJ2IuICdhIC0+ICdiIH0gW0BAdW5ib3hlZF1cblxubGV0IHdpdGhfcmV0dXJuICh0eXBlIGEpIGYgPVxuICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICAoKiBSYWlzZWQgdG8gaW5kaWNhdGUgfnJldHVybiB3YXMgY2FsbGVkLiAgTG9jYWwgc28gdGhhdCB0aGUgZXhjZXB0aW9uIGlzIHRpZWQgdG8gYVxuICAgICAgIHBhcnRpY3VsYXIgY2FsbCBvZiBbd2l0aF9yZXR1cm5dLiAqKVxuICAgIGV4Y2VwdGlvbiBSZXR1cm4gb2YgYVxuICBlbmRcbiAgaW5cbiAgbGV0IGlzX2FsaXZlID0gcmVmIHRydWUgaW5cbiAgbGV0IHJldHVybiBhID1cbiAgICBpZiBub3QgIWlzX2FsaXZlXG4gICAgdGhlbiBmYWlsd2l0aCBcInVzZSBvZiBbcmV0dXJuXSBmcm9tIGEgW3dpdGhfcmV0dXJuXSB0aGF0IGFscmVhZHkgcmV0dXJuZWRcIjtcbiAgICBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgKE0uUmV0dXJuIGEpXG4gIGluXG4gIHRyeVxuICAgIGxldCBhID0gZiB7IHJldHVybiB9IGluXG4gICAgaXNfYWxpdmUgOj0gZmFsc2U7XG4gICAgYVxuICB3aXRoXG4gIHwgZXhuIC0+XG4gICAgaXNfYWxpdmUgOj0gZmFsc2U7XG4gICAgKG1hdGNoIGV4biB3aXRoXG4gICAgIHwgTS5SZXR1cm4gYSAtPiBhXG4gICAgIHwgXyAtPiByYWlzZSBleG4pXG47O1xuXG5sZXQgd2l0aF9yZXR1cm5fb3B0aW9uIGYgPVxuICB3aXRoX3JldHVybiAoZnVuIHJldHVybiAtPlxuICAgIGYgeyByZXR1cm4gPSAoZnVuIGEgLT4gcmV0dXJuLnJldHVybiAoU29tZSBhKSkgfTtcbiAgICBOb25lKVxuOztcblxubGV0IHByZXBlbmQgeyByZXR1cm4gfSB+ZiA9IHsgcmV0dXJuID0gKGZ1biB4IC0+IHJldHVybiAoZiB4KSkgfVxuIiwib3BlbiEgSW1wb3J0XG5cbm1vZHVsZSB0eXBlIEJhc2ljID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIHZhbCBiaW5kIDogJ2EgdCAtPiBmOignYSAtPiAnYiB0KSAtPiAnYiB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG5cbiAgKCoqIFRoZSBmb2xsb3dpbmcgaWRlbnRpdGllcyBvdWdodCB0byBob2xkIChmb3Igc29tZSB2YWx1ZSBvZiA9KTpcblxuICAgICAgLSBbcmV0dXJuIHggPj49IGYgPSBmIHhdXG4gICAgICAtIFt0ID4+PSBmdW4geCAtPiByZXR1cm4geCA9IHRdXG4gICAgICAtIFsodCA+Pj0gZikgPj49IGcgPSB0ID4+PSBmdW4geCAtPiAoZiB4ID4+PSBnKV1cblxuICAgICAgTm90ZTogWz4+PV0gaXMgdGhlIGluZml4IG5vdGF0aW9uIGZvciBbYmluZF0pICopXG5cbiAgKCoqIFRoZSBbbWFwXSBhcmd1bWVudCB0byBbTW9uYWQuTWFrZV0gc2F5cyBob3cgdG8gaW1wbGVtZW50IHRoZSBtb25hZCdzIFttYXBdIGZ1bmN0aW9uLlxuICAgICAgW2BEZWZpbmVfdXNpbmdfYmluZF0gbWVhbnMgdG8gZGVmaW5lIFttYXAgdCB+ZiA9IGJpbmQgdCB+ZjooZnVuIGEgLT4gcmV0dXJuIChmIGEpKV0uXG4gICAgICBbYEN1c3RvbV0gb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBwcmVzdW1hYmx5IHdpdGggc29tZXRoaW5nIG1vcmVcbiAgICAgIGVmZmljaWVudC5cblxuICAgICAgU29tZSBvdGhlciBmdW5jdGlvbnMgcmV0dXJuZWQgYnkgW01vbmFkLk1ha2VdIGFyZSBkZWZpbmVkIGluIHRlcm1zIG9mIFttYXBdLCBzb1xuICAgICAgcGFzc2luZyBpbiBhIG1vcmUgZWZmaWNpZW50IFttYXBdIHdpbGwgaW1wcm92ZSB0aGVpciBlZmZpY2llbmN5IGFzIHdlbGwuICopXG4gIHZhbCBtYXAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZCB8IGBDdXN0b20gb2YgJ2EgdCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdCBdXG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXggPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgKCoqIFt0ID4+PSBmXSByZXR1cm5zIGEgY29tcHV0YXRpb24gdGhhdCBzZXF1ZW5jZXMgdGhlIGNvbXB1dGF0aW9ucyByZXByZXNlbnRlZCBieSB0d29cbiAgICAgIG1vbmFkIGVsZW1lbnRzLiAgVGhlIHJlc3VsdGluZyBjb21wdXRhdGlvbiBmaXJzdCBkb2VzIFt0XSB0byB5aWVsZCBhIHZhbHVlIFt2XSwgYW5kXG4gICAgICB0aGVuIHJ1bnMgdGhlIGNvbXB1dGF0aW9uIHJldHVybmVkIGJ5IFtmIHZdLiAqKVxuICB2YWwgKCA+Pj0gKSA6ICdhIHQgLT4gKCdhIC0+ICdiIHQpIC0+ICdiIHRcblxuICAoKiogW3QgPj58IGZdIGlzIFt0ID4+PSAoZnVuIGEgLT4gcmV0dXJuIChmIGEpKV0uICopXG4gIHZhbCAoID4+fCApIDogJ2EgdCAtPiAoJ2EgLT4gJ2IpIC0+ICdiIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTeW50YXggPSBzaWdcbiAgKCoqIE9wZW5pbmcgYSBtb2R1bGUgb2YgdGhpcyB0eXBlIGFsbG93cyBvbmUgdG8gdXNlIHRoZSBbJWJpbmRdIGFuZCBbJW1hcF0gc3ludGF4XG4gICAgICBleHRlbnNpb25zIGRlZmluZWQgYnkgcHB4X2xldCwgYW5kIGJyaW5ncyBbcmV0dXJuXSBpbnRvIHNjb3BlLiAqKVxuXG4gIHR5cGUgJ2EgdFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgKCoqIFRoZXNlIGFyZSBjb252ZW5pZW50IHRvIGhhdmUgaW4gc2NvcGUgd2hlbiBwcm9ncmFtbWluZyB3aXRoIGEgbW9uYWQ6ICopXG5cbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuXG4gICAgaW5jbHVkZSBJbmZpeCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICAgdmFsIHJldHVybiA6ICdhIC0+ICdhIHRcbiAgICAgIHZhbCBiaW5kIDogJ2EgdCAtPiBmOignYSAtPiAnYiB0KSAtPiAnYiB0XG4gICAgICB2YWwgbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdFxuICAgICAgdmFsIGJvdGggOiAnYSB0IC0+ICdiIHQgLT4gKCdhICogJ2IpIHRcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzIDogc2lnIGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3ludGF4ID0gc2lnXG4gIHR5cGUgJ2EgdFxuXG4gIGluY2x1ZGUgSW5maXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBtb2R1bGUgTW9uYWRfaW5maXggOiBJbmZpeCB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgKCoqIFtiaW5kIHQgfmZdID0gW3QgPj49IGZdICopXG4gIHZhbCBiaW5kIDogJ2EgdCAtPiBmOignYSAtPiAnYiB0KSAtPiAnYiB0XG5cbiAgKCoqIFtyZXR1cm4gdl0gcmV0dXJucyB0aGUgKHRyaXZpYWwpIGNvbXB1dGF0aW9uIHRoYXQgcmV0dXJucyB2LiAqKVxuICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuXG4gICgqKiBbbWFwIHQgfmZdIGlzIHQgPj58IGYuICopXG4gIHZhbCBtYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAnYiB0XG5cbiAgKCoqIFtqb2luIHRdIGlzIFt0ID4+PSAoZnVuIHQnIC0+IHQnKV0uICopXG4gIHZhbCBqb2luIDogJ2EgdCB0IC0+ICdhIHRcblxuICAoKiogW2lnbm9yZV9tIHRdIGlzIFttYXAgdCB+ZjooZnVuIF8gLT4gKCkpXS4gIFtpZ25vcmVfbV0gdXNlZCB0byBiZSBjYWxsZWQgW2lnbm9yZV0sXG4gICAgICBidXQgd2UgZGVjaWRlZCB0aGF0IHdhcyBhIGJhZCBuYW1lLCBiZWNhdXNlIGl0IHNoYWRvd2VkIHRoZSB3aWRlbHkgdXNlZFxuICAgICAgW0NhbWwuaWdub3JlXS4gIFNvbWUgbW9uYWRzIHN0aWxsIGRvIFtsZXQgaWdub3JlID0gaWdub3JlX21dIGZvciBoaXN0b3JpY2FsXG4gICAgICByZWFzb25zLiAqKVxuICB2YWwgaWdub3JlX20gOiAnYSB0IC0+IHVuaXQgdFxuXG4gIHZhbCBhbGwgOiAnYSB0IGxpc3QgLT4gJ2EgbGlzdCB0XG5cbiAgKCoqIExpa2UgW2FsbF0sIGJ1dCBlbnN1cmVzIHRoYXQgZXZlcnkgbW9uYWRpYyB2YWx1ZSBpbiB0aGUgbGlzdCBwcm9kdWNlcyBhIHVuaXQgdmFsdWUsXG4gICAgICBhbGwgb2Ygd2hpY2ggYXJlIGRpc2NhcmRlZCByYXRoZXIgdGhhbiBiZWluZyBjb2xsZWN0ZWQgaW50byBhIGxpc3QuICopXG4gIHZhbCBhbGxfdW5pdCA6IHVuaXQgdCBsaXN0IC0+IHVuaXQgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgaW5jbHVkZSBTX3dpdGhvdXRfc3ludGF4IHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgaW5jbHVkZSBTeW50YXggd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEJhc2ljMiA9IHNpZ1xuICAoKiogTXVsdGkgcGFyYW1ldGVyIG1vbmFkLiBUaGUgc2Vjb25kIHBhcmFtZXRlciBnZXRzIHVuaWZpZWQgYWNyb3NzIGFsbCB0aGUgY29tcHV0YXRpb24uXG4gICAgICBUaGlzIGlzIHVzZWQgdG8gZW5jb2RlIG1vbmFkcyB3b3JraW5nIG9uIGEgbXVsdGkgcGFyYW1ldGVyIGRhdGEgc3RydWN0dXJlIGxpa2VcbiAgICAgIChbKCdhLCdiKSByZXN1bHRdKS4gKilcblxuICB0eXBlICgnYSwgJ2UpIHRcblxuICB2YWwgYmluZCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZSkgdCkgLT4gKCdiLCAnZSkgdFxuICB2YWwgbWFwIDogWyBgRGVmaW5lX3VzaW5nX2JpbmQgfCBgQ3VzdG9tIG9mICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2UpIHQgXVxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXgyID0gc2lnXG4gICgqKiBTYW1lIGFzIHshSW5maXh9LCBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHR3byBhcmd1bWVudHMuIFRoZSBzZWNvbmQgaXMgYWx3YXlzIGp1c3RcbiAgICAgIHBhc3NlZCB0aHJvdWdoLiAqKVxuXG4gIHR5cGUgKCdhLCAnZSkgdFxuXG4gIHZhbCAoID4+PSApIDogKCdhLCAnZSkgdCAtPiAoJ2EgLT4gKCdiLCAnZSkgdCkgLT4gKCdiLCAnZSkgdFxuICB2YWwgKCA+PnwgKSA6ICgnYSwgJ2UpIHQgLT4gKCdhIC0+ICdiKSAtPiAoJ2IsICdlKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgU3ludGF4MiA9IHNpZ1xuICB0eXBlICgnYSwgJ2UpIHRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcblxuICAgIGluY2x1ZGUgSW5maXgyIHdpdGggdHlwZSAoJ2EsICdlKSB0IDo9ICgnYSwgJ2UpIHRcblxuICAgIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfKSB0XG4gICAgICB2YWwgYmluZCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gKCdiLCAnZSkgdCkgLT4gKCdiLCAnZSkgdFxuICAgICAgdmFsIG1hcCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2UpIHRcbiAgICAgIHZhbCBib3RoIDogKCdhLCAnZSkgdCAtPiAoJ2IsICdlKSB0IC0+ICgnYSAqICdiLCAnZSkgdFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgOiBzaWcgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMyID0gc2lnXG4gICgqKiBUaGUgc2FtZSBhcyB7IVN9IGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdHdvIGFyZ3VtZW50cy4gVGhlIHNlY29uZCBpcyBhbHdheXMganVzdFxuICAgICAgcGFzc2VkIHRocm91Z2guICopXG5cbiAgdHlwZSAoJ2EsICdlKSB0XG5cbiAgaW5jbHVkZSBJbmZpeDIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdFxuICBpbmNsdWRlIFN5bnRheDIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdFxuICBtb2R1bGUgTW9uYWRfaW5maXggOiBJbmZpeDIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdlKSB0KSAtPiAoJ2IsICdlKSB0XG4gIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcbiAgdmFsIG1hcCA6ICgnYSwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2UpIHRcbiAgdmFsIGpvaW4gOiAoKCdhLCAnZSkgdCwgJ2UpIHQgLT4gKCdhLCAnZSkgdFxuICB2YWwgaWdub3JlX20gOiAoXywgJ2UpIHQgLT4gKHVuaXQsICdlKSB0XG4gIHZhbCBhbGwgOiAoJ2EsICdlKSB0IGxpc3QgLT4gKCdhIGxpc3QsICdlKSB0XG4gIHZhbCBhbGxfdW5pdCA6ICh1bml0LCAnZSkgdCBsaXN0IC0+ICh1bml0LCAnZSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEJhc2ljMyA9IHNpZ1xuICAoKiogTXVsdGkgcGFyYW1ldGVyIG1vbmFkLiBUaGUgc2Vjb25kIGFuZCB0aGlyZCBwYXJhbWV0ZXJzIGdldCB1bmlmaWVkIGFjcm9zcyBhbGwgdGhlXG4gICAgICBjb21wdXRhdGlvbi4gKilcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdkLCAnZSkgdCkgLT4gKCdiLCAnZCwgJ2UpIHRcblxuICB2YWwgbWFwXG4gICAgOiBbIGBEZWZpbmVfdXNpbmdfYmluZCB8IGBDdXN0b20gb2YgKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2QsICdlKSB0IF1cblxuICB2YWwgcmV0dXJuIDogJ2EgLT4gKCdhLCBfLCBfKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXgzID0gc2lnXG4gICgqKiBTYW1lIGFzIEluZml4LCBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHRocmVlIGFyZ3VtZW50cy4gVGhlIHNlY29uZCBhbmQgdGhpcmQgYXJlXG4gICAgICBhbHdheXMganVzdCBwYXNzZWQgdGhyb3VnaC4gKilcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0XG5cbiAgdmFsICggPj49ICkgOiAoJ2EsICdkLCAnZSkgdCAtPiAoJ2EgLT4gKCdiLCAnZCwgJ2UpIHQpIC0+ICgnYiwgJ2QsICdlKSB0XG4gIHZhbCAoID4+fCApIDogKCdhLCAnZCwgJ2UpIHQgLT4gKCdhIC0+ICdiKSAtPiAoJ2IsICdkLCAnZSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFN5bnRheDMgPSBzaWdcbiAgdHlwZSAoJ2EsICdkLCAnZSkgdFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4IDogc2lnXG4gICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXywgXykgdFxuXG4gICAgaW5jbHVkZSBJbmZpeDMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSB0XG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgICAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXywgXykgdFxuICAgICAgdmFsIGJpbmQgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdkLCAnZSkgdCkgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgICAgIHZhbCBtYXAgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgICAgIHZhbCBib3RoIDogKCdhLCAnZCwgJ2UpIHQgLT4gKCdiLCAnZCwgJ2UpIHQgLT4gKCdhICogJ2IsICdkLCAnZSkgdFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgOiBzaWcgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMzID0gc2lnXG4gICgqKiBUaGUgc2FtZSBhcyB7IVN9IGV4Y2VwdCB0aGUgbW9uYWQgdHlwZSBoYXMgdGhyZWUgYXJndW1lbnRzLiBUaGUgc2Vjb25kXG4gICAgICBhbmQgdGhpcmQgYXJlIGFsd2F5cyBqdXN0IHBhc3NlZCB0aHJvdWdoLiAqKVxuXG4gIHR5cGUgKCdhLCAnZCwgJ2UpIHRcblxuICBpbmNsdWRlIEluZml4MyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIHRcbiAgaW5jbHVkZSBTeW50YXgzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgdFxuICBtb2R1bGUgTW9uYWRfaW5maXggOiBJbmZpeDMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdkLCAnZSkgdCAtPiBmOignYSAtPiAoJ2IsICdkLCAnZSkgdCkgLT4gKCdiLCAnZCwgJ2UpIHRcbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgXywgXykgdFxuICB2YWwgbWFwIDogKCdhLCAnZCwgJ2UpIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2QsICdlKSB0XG4gIHZhbCBqb2luIDogKCgnYSwgJ2QsICdlKSB0LCAnZCwgJ2UpIHQgLT4gKCdhLCAnZCwgJ2UpIHRcbiAgdmFsIGlnbm9yZV9tIDogKF8sICdkLCAnZSkgdCAtPiAodW5pdCwgJ2QsICdlKSB0XG4gIHZhbCBhbGwgOiAoJ2EsICdkLCAnZSkgdCBsaXN0IC0+ICgnYSBsaXN0LCAnZCwgJ2UpIHRcbiAgdmFsIGFsbF91bml0IDogKHVuaXQsICdkLCAnZSkgdCBsaXN0IC0+ICh1bml0LCAnZCwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBCYXNpY19pbmRleGVkID0gc2lnXG4gICgqKiBJbmRleGVkIG1vbmFkLCBpbiB0aGUgc3R5bGUgb2YgQXRrZXkuIFRoZSBzZWNvbmQgYW5kIHRoaXJkIHBhcmFtZXRlcnMgYXJlIGNvbXBvc2VkXG4gICAgICBhY3Jvc3MgYWxsIGNvbXB1dGF0aW9uLiBUbyBzZWUgdGhpcyBtb3JlIGNsZWFybHksIHlvdSBjYW4gbG9vayBhdCB0aGUgdHlwZSBvZiBiaW5kOlxuXG4gICAgICB7W1xuICAgICAgICB2YWwgYmluZCA6ICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrKSB0KSAtPiAoJ2IsICdpLCAnaykgdFxuICAgICAgXX1cblxuICAgICAgYW5kIGlzb2xhdGUgc29tZSBvZiB0aGUgdHlwZSB2YXJpYWJsZXMgdG8gc2VlIHRoZWlyIGluZGl2aWR1YWwgYmVoYXZpb3JzOlxuXG4gICAgICB7W1xuICAgICAgICB2YWwgYmluZCA6ICdhICAgICAgICAgICAgIC0+IGY6KCdhIC0+ICAnYiAgICAgICAgICAgKSAtPiAgJ2JcbiAgICAgICAgdmFsIGJpbmQgOiAgICAgICdpLCAnaiAgICAtPiAgICAgICAgICAgICAgICdqLCAnayAgICAgLT4gICAgICdpLCAna1xuICAgICAgXX1cblxuICAgICAgRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQXRrZXktc3R5bGUgaW5kZXhlZCBtb25hZHMsIHNlZTpcblxuICAgICAge3ZcbiAgICAgICAgUGFyYW1ldGVyaXNlZCBOb3Rpb25zIG9mIENvbXB1dGF0aW9uXG4gICAgICAgIFJvYmVydCBBdGtleVxuICAgICAgICBodHRwOi8vYmVudG5pYi5vcmcvcGFyYW1ub3Rpb25zLWpmcC5wZGZcbiAgICAgIHZ9ICopXG5cbiAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gIHZhbCBiaW5kIDogKCdhLCAnaSwgJ2opIHQgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG5cbiAgdmFsIG1hcFxuICAgIDogWyBgRGVmaW5lX3VzaW5nX2JpbmQgfCBgQ3VzdG9tIG9mICgnYSwgJ2ksICdqKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaikgdCBdXG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgSW5maXhfaW5kZXhlZCA9IHNpZ1xuICAoKiogU2FtZSBhcyB7IUluZml4fSwgZXhjZXB0IHRoZSBtb25hZCB0eXBlIGhhcyB0aHJlZSBhcmd1bWVudHMuIFRoZSBzZWNvbmQgYW5kXG4gICAgICB0aGlyZCBhcmUgY29tcG9zZWQgYWNyb3NzIGFsbCBjb21wdXRhdGlvbi4gKilcblxuICB0eXBlICgnYSwgJ2ksICdqKSB0XG5cbiAgdmFsICggPj49ICkgOiAoJ2EsICdpLCAnaikgdCAtPiAoJ2EgLT4gKCdiLCAnaiwgJ2spIHQpIC0+ICgnYiwgJ2ksICdrKSB0XG4gIHZhbCAoID4+fCApIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFN5bnRheF9pbmRleGVkID0gc2lnXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICBtb2R1bGUgTGV0X3N5bnRheCA6IHNpZ1xuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSkgdFxuXG4gICAgaW5jbHVkZSBJbmZpeF9pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgdFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggOiBzaWdcbiAgICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSkgdFxuICAgICAgdmFsIGJpbmQgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcbiAgICAgIHZhbCBtYXAgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2opIHRcbiAgICAgIHZhbCBib3RoIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdiLCAnaiwgJ2spIHQgLT4gKCdhICogJ2IsICdpLCAnaykgdFxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgOiBzaWcgZW5kXG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfaW5kZXhlZCA9IHNpZ1xuICAoKiogVGhlIHNhbWUgYXMgeyFTfSBleGNlcHQgdGhlIG1vbmFkIHR5cGUgaGFzIHRocmVlIGFyZ3VtZW50cy4gVGhlIHNlY29uZCBhbmRcbiAgICAgIHRoaXJkIGFyZSBjb21wb3NlZCBhY3Jvc3MgYWxsIGNvbXB1dGF0aW9uLiAqKVxuXG4gIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICBpbmNsdWRlIEluZml4X2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSB0XG4gIGluY2x1ZGUgU3ludGF4X2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSB0XG4gIG1vZHVsZSBNb25hZF9pbmZpeCA6IEluZml4X2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSB0XG5cbiAgdmFsIGJpbmQgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAoJ2IsICdqLCAnaykgdCkgLT4gKCdiLCAnaSwgJ2spIHRcbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpKSB0XG4gIHZhbCBtYXAgOiAoJ2EsICdpLCAnaikgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2opIHRcbiAgdmFsIGpvaW4gOiAoKCdhLCAnaiwgJ2spIHQsICdpLCAnaikgdCAtPiAoJ2EsICdpLCAnaykgdFxuICB2YWwgaWdub3JlX20gOiAoXywgJ2ksICdqKSB0IC0+ICh1bml0LCAnaSwgJ2opIHRcbiAgdmFsIGFsbCA6ICgnYSwgJ2ksICdpKSB0IGxpc3QgLT4gKCdhIGxpc3QsICdpLCAnaSkgdFxuICB2YWwgYWxsX3VuaXQgOiAodW5pdCwgJ2ksICdpKSB0IGxpc3QgLT4gKHVuaXQsICdpLCAnaSkgdFxuZW5kXG5cbm1vZHVsZSBTX3RvX1MyIChYIDogUykgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbmVuZFxuXG5tb2R1bGUgUzJfdG9fUzMgKFggOiBTMikgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuZW5kXG5cbm1vZHVsZSBTX3RvX1NfaW5kZXhlZCAoWCA6IFMpIDogU19pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA9ICdhIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2ksICdqKSB0ID0gJ2EgWC50XG5lbmRcblxubW9kdWxlIFMyX3RvX1MgKFggOiBTMikgOiBTIHdpdGggdHlwZSAnYSB0ID0gKCdhLCB1bml0KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAnYSB0ID0gKCdhLCB1bml0KSBYLnRcbmVuZFxuXG5tb2R1bGUgUzNfdG9fUzIgKFggOiBTMykgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICgnYSwgJ2UsIHVuaXQpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAoJ2EsICdlLCB1bml0KSBYLnRcbmVuZFxuXG5tb2R1bGUgU19pbmRleGVkX3RvX1MyIChYIDogU19pbmRleGVkKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSwgJ2UpIFgudCA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSwgJ2UpIFgudFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1vbmFkID0gc2lnXG4gICgqKiBBIG1vbmFkIGlzIGFuIGFic3RyYWN0aW9uIG9mIHRoZSBjb25jZXB0IG9mIHNlcXVlbmNpbmcgb2YgY29tcHV0YXRpb25zLiAgQSB2YWx1ZSBvZlxuICAgICAgdHlwZSBbJ2EgbW9uYWRdIHJlcHJlc2VudHMgYSBjb21wdXRhdGlvbiB0aGF0IHJldHVybnMgYSB2YWx1ZSBvZiB0eXBlIFsnYV0uICopXG5cbiAgbW9kdWxlIHR5cGUgQmFzaWMgPSBCYXNpY1xuICBtb2R1bGUgdHlwZSBCYXNpYzIgPSBCYXNpYzJcbiAgbW9kdWxlIHR5cGUgQmFzaWMzID0gQmFzaWMzXG4gIG1vZHVsZSB0eXBlIEJhc2ljX2luZGV4ZWQgPSBCYXNpY19pbmRleGVkXG4gIG1vZHVsZSB0eXBlIEluZml4ID0gSW5maXhcbiAgbW9kdWxlIHR5cGUgSW5maXgyID0gSW5maXgyXG4gIG1vZHVsZSB0eXBlIEluZml4MyA9IEluZml4M1xuICBtb2R1bGUgdHlwZSBJbmZpeF9pbmRleGVkID0gSW5maXhfaW5kZXhlZFxuICBtb2R1bGUgdHlwZSBTeW50YXggPSBTeW50YXhcbiAgbW9kdWxlIHR5cGUgU3ludGF4MiA9IFN5bnRheDJcbiAgbW9kdWxlIHR5cGUgU3ludGF4MyA9IFN5bnRheDNcbiAgbW9kdWxlIHR5cGUgU3ludGF4X2luZGV4ZWQgPSBTeW50YXhfaW5kZXhlZFxuICBtb2R1bGUgdHlwZSBTX3dpdGhvdXRfc3ludGF4ID0gU193aXRob3V0X3N5bnRheFxuICBtb2R1bGUgdHlwZSBTID0gU1xuICBtb2R1bGUgdHlwZSBTMiA9IFMyXG4gIG1vZHVsZSB0eXBlIFMzID0gUzNcbiAgbW9kdWxlIHR5cGUgU19pbmRleGVkID0gU19pbmRleGVkXG5cbiAgbW9kdWxlIE1ha2UgKFggOiBCYXNpYykgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIFgudFxuICBtb2R1bGUgTWFrZTIgKFggOiBCYXNpYzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50XG4gIG1vZHVsZSBNYWtlMyAoWCA6IEJhc2ljMykgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIFgudFxuXG4gIG1vZHVsZSBNYWtlX2luZGV4ZWQgKFggOiBCYXNpY19pbmRleGVkKSA6XG4gICAgU19pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50XG5cbiAgKCoqIERlZmluZSBhIG1vbmFkIHRocm91Z2ggYW4gaXNvbW9ycGhpc20gd2l0aCBhbiBleGlzdGluZyBtb25hZC4gRm9yIGV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgJ2EgdCA9IHsgdmFsdWUgOiAnYSB9XG5cbiAgICAgICAgaW5jbHVkZSBNb25hZC5PZl9tb25hZCAoTW9uYWQuSWRlbnQpIChzdHJ1Y3RcbiAgICAgICAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgICAgICAgIGxldCB0b19tb25hZCB7IHZhbHVlIH0gPSB2YWx1ZVxuICAgICAgICAgICAgbGV0IG9mX21vbmFkIHZhbHVlID0geyB2YWx1ZSB9XG4gICAgICAgICAgZW5kKVxuICAgICAgXX0gKilcbiAgbW9kdWxlIE9mX21vbmFkXG4gICAgICAoTW9uYWQgOiBTKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgdHlwZSAnYSB0XG5cbiAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICdhIHQgLT4gJ2EgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogJ2EgTW9uYWQudCAtPiAnYSB0XG4gICAgICAgICAgICAgICAgICAgZW5kKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50XG5cbiAgbW9kdWxlIE9mX21vbmFkMlxuICAgICAgKE1vbmFkIDogUzIpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiKSBNb25hZC50IC0+ICgnYSwgJ2IpIHRcbiAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIE0udFxuXG4gIG1vZHVsZSBPZl9tb25hZDNcbiAgICAgIChNb25hZCA6IFMzKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2IsICdjKSB0IC0+ICgnYSwgJ2IsICdjKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX21vbmFkIDogKCdhLCAnYiwgJ2MpIE1vbmFkLnQgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgTS50XG5cbiAgbW9kdWxlIE9mX21vbmFkX2luZGV4ZWRcbiAgICAgIChNb25hZCA6IFNfaW5kZXhlZCkgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAoJ2EsICdpLCAnaikgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2ksICdqKSB0IC0+ICgnYSwgJ2ksICdqKSBNb25hZC50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2ksICdqKSBNb25hZC50IC0+ICgnYSwgJ2ksICdqKSB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpIDogU19pbmRleGVkIHdpdGggdHlwZSAoJ2EsICdpLCAnaikgdCA6PSAoJ2EsICdpLCAnaikgTS50XG5cbiAgbW9kdWxlIElkZW50IDogUyB3aXRoIHR5cGUgJ2EgdCA9ICdhXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBNb25hZF9pbnRmXG5cbm1vZHVsZSB0eXBlIEJhc2ljX2dlbmVyYWwgPSBzaWdcbiAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG5cbiAgdmFsIGJpbmRcbiAgICA6ICAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgLT4gZjooJ2EgLT4gKCdiLCAnaiwgJ2ssICdkLCAnZSkgdClcbiAgICAtPiAoJ2IsICdpLCAnaywgJ2QsICdlKSB0XG5cbiAgdmFsIG1hcFxuICAgIDogWyBgRGVmaW5lX3VzaW5nX2JpbmRcbiAgICAgIHwgYEN1c3RvbSBvZiAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0IC0+IGY6KCdhIC0+ICdiKSAtPiAoJ2IsICdpLCAnaiwgJ2QsICdlKSB0XG4gICAgICBdXG5cbiAgdmFsIHJldHVybiA6ICdhIC0+ICgnYSwgJ2ksICdpLCAnZCwgJ2UpIHRcbmVuZFxuXG5tb2R1bGUgTWFrZV9nZW5lcmFsIChNIDogQmFzaWNfZ2VuZXJhbCkgPSBzdHJ1Y3RcbiAgbGV0IGJpbmQgPSBNLmJpbmRcbiAgbGV0IHJldHVybiA9IE0ucmV0dXJuXG4gIGxldCBtYXBfdmlhX2JpbmQgbWEgfmYgPSBNLmJpbmQgbWEgfmY6KGZ1biBhIC0+IE0ucmV0dXJuIChmIGEpKVxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIE0ubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfYmluZCAtPiBtYXBfdmlhX2JpbmRcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbW9kdWxlIE1vbmFkX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPj49ICkgdCBmID0gYmluZCB0IH5mXG4gICAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgZW5kXG5cbiAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuXG4gICAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBiaW5kID0gYmluZFxuICAgICAgbGV0IG1hcCA9IG1hcFxuICAgICAgbGV0IGJvdGggYSBiID0gYSA+Pj0gZnVuIGEgLT4gYiA+PnwgZnVuIGIgLT4gYSwgYlxuXG4gICAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3QgZW5kXG4gICAgZW5kXG4gIGVuZFxuXG4gIGxldCBqb2luIHQgPSB0ID4+PSBmdW4gdCcgLT4gdCdcbiAgbGV0IGlnbm9yZV9tIHQgPSBtYXAgdCB+ZjooZnVuIF8gLT4gKCkpXG5cbiAgbGV0IGFsbCA9XG4gICAgbGV0IHJlYyBsb29wIHZzID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIChMaXN0LnJldiB2cylcbiAgICAgIHwgdCA6OiB0cyAtPiB0ID4+PSBmdW4gdiAtPiBsb29wICh2IDo6IHZzKSB0c1xuICAgIGluXG4gICAgZnVuIHRzIC0+IGxvb3AgW10gdHNcbiAgOztcblxuICBsZXQgcmVjIGFsbF91bml0ID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldHVybiAoKVxuICAgIHwgdCA6OiB0cyAtPiB0ID4+PSBmdW4gKCkgLT4gYWxsX3VuaXQgdHNcbiAgOztcbmVuZFxuXG5tb2R1bGUgTWFrZV9pbmRleGVkIChNIDogQmFzaWNfaW5kZXhlZCkgOlxuICBTX2luZGV4ZWQgd2l0aCB0eXBlICgnYSwgJ2ksICdqKSB0IDo9ICgnYSwgJ2ksICdqKSBNLnQgPSBNYWtlX2dlbmVyYWwgKHN0cnVjdFxuICAgIGluY2x1ZGUgTVxuXG4gICAgdHlwZSAoJ2EsICdpLCAnaiwgJ2QsICdlKSB0ID0gKCdhLCAnaSwgJ2opIE0udFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlMyAoTSA6IEJhc2ljMykgOiBTMyB3aXRoIHR5cGUgKCdhLCAnZCwgJ2UpIHQgOj0gKCdhLCAnZCwgJ2UpIE0udCA9XG4gIE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkLCAnZSkgTS50XG4gIGVuZClcblxubW9kdWxlIE1ha2UyIChNIDogQmFzaWMyKSA6IFMyIHdpdGggdHlwZSAoJ2EsICdkKSB0IDo9ICgnYSwgJ2QpIE0udCA9IE1ha2VfZ2VuZXJhbCAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBNLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZSAoTSA6IEJhc2ljKSA6IFMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgTS50ID0gTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgICBpbmNsdWRlIE1cblxuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICdhIE0udFxuICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZF9nZW5lcmFsIChNb25hZCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuXG4gICAgdmFsIGJpbmRcbiAgICAgIDogICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcbiAgICAgIC0+IGY6KCdhIC0+ICgnYiwgJ2osICdrLCAnZCwgJ2UpIHQpXG4gICAgICAtPiAoJ2IsICdpLCAnaywgJ2QsICdlKSB0XG5cbiAgICB2YWwgbWFwIDogKCdhLCAnaSwgJ2osICdkLCAnZSkgdCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsICdpLCAnaSwgJ2QsICdlKSB0XG4gIGVuZCkgKE0gOiBzaWdcbiAgICAgICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHRcblxuICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgLT4gKCdhLCAnaSwgJ2osICdkLCAnZSkgTW9uYWQudFxuICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2ksICdqLCAnZCwgJ2UpIE1vbmFkLnQgLT4gKCdhLCAnaSwgJ2osICdkLCAnZSkgdFxuICAgICAgICBlbmQpID1cbiAgTWFrZV9nZW5lcmFsIChzdHJ1Y3RcbiAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaiwgJ2QsICdlKSBNLnRcblxuICAgIGxldCByZXR1cm4gYSA9IE0ub2ZfbW9uYWQgKE1vbmFkLnJldHVybiBhKVxuICAgIGxldCBiaW5kIHQgfmYgPSBNLm9mX21vbmFkIChNb25hZC5iaW5kIChNLnRvX21vbmFkIHQpIH5mOihmdW4gYSAtPiBNLnRvX21vbmFkIChmIGEpKSlcbiAgICBsZXQgbWFwID0gYEN1c3RvbSAoZnVuIHQgfmYgLT4gTS5vZl9tb25hZCAoTW9uYWQubWFwIChNLnRvX21vbmFkIHQpIH5mKSlcbiAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWRfaW5kZXhlZFxuICAgIChNb25hZCA6IFNfaW5kZXhlZCkgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnaSwgJ2opIHRcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX21vbmFkIDogKCdhLCAnaSwgJ2opIHQgLT4gKCdhLCAnaSwgJ2opIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9tb25hZCA6ICgnYSwgJ2ksICdqKSBNb25hZC50IC0+ICgnYSwgJ2ksICdqKSB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2ksICdqKSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdpLCAnaikgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQzXG4gICAgKE1vbmFkIDogUzMpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHRcblxuICAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAoJ2EsICdiLCAnYykgdCAtPiAoJ2EsICdiLCAnYykgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiLCAnYykgTW9uYWQudCAtPiAoJ2EsICdiLCAnYykgdFxuICAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICgnYSwgJ2QsICdlKSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkLCAnZSkgTS50XG4gICAgZW5kKVxuXG5tb2R1bGUgT2ZfbW9uYWQyXG4gICAgKE1vbmFkIDogUzIpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgICAgICAgICAgICAgICAgIHZhbCB0b19tb25hZCA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgTW9uYWQudFxuICAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAoJ2EsICdiKSBNb25hZC50IC0+ICgnYSwgJ2IpIHRcbiAgICAgICAgICAgICAgICAgIGVuZCkgPVxuICBPZl9tb25hZF9nZW5lcmFsXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNb25hZFxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBNb25hZC50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgTVxuXG4gICAgICB0eXBlICgnYSwgJ2ksICdqLCAnZCwgJ2UpIHQgPSAoJ2EsICdkKSBNLnRcbiAgICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZFxuICAgIChNb25hZCA6IFMpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgdHlwZSAnYSB0XG5cbiAgICAgICAgICAgICAgICAgICB2YWwgdG9fbW9uYWQgOiAnYSB0IC0+ICdhIE1vbmFkLnRcbiAgICAgICAgICAgICAgICAgICB2YWwgb2ZfbW9uYWQgOiAnYSBNb25hZC50IC0+ICdhIHRcbiAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE9mX21vbmFkX2dlbmVyYWxcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIE1vbmFkXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICdhIE1vbmFkLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgaW5jbHVkZSBNXG5cbiAgICAgIHR5cGUgKCdhLCAnaSwgJ2osICdkLCAnZSkgdCA9ICdhIE0udFxuICAgIGVuZClcblxubW9kdWxlIElkZW50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhXG5cbiAgaW5jbHVkZSBNYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgIGxldCBiaW5kIGEgfmYgPSBmIGFcbiAgICAgIGxldCByZXR1cm4gYSA9IGFcbiAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIChmdW4gYSB+ZiAtPiBmIGEpXG4gICAgZW5kKVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQXBwbGljYXRpdmVfaW50ZlxubW9kdWxlIExpc3QgPSBMaXN0MFxuXG4oKiogVGhpcyBtb2R1bGUgc2VydmVzIG1vc3RseSBhcyBhIHBhcnRpYWwgY2hlY2sgdGhhdCBbUzJdIGFuZCBbU10gYXJlIGluIHN5bmMsIGJ1dFxuICAgIGFjdHVhbGx5IGNhbGxpbmcgaXQgaXMgb2NjYXNpb25hbGx5IHVzZWZ1bC4gKilcbm1vZHVsZSBTX3RvX1MyIChYIDogUykgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbmVuZFxuXG5tb2R1bGUgUzJfdG9fUyAoWCA6IFMyKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAoJ2EsIHVuaXQpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICdhIHQgPSAoJ2EsIHVuaXQpIFgudFxuZW5kXG5cbm1vZHVsZSBTMl90b19TMyAoWCA6IFMyKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudCA9IHN0cnVjdFxuICBpbmNsdWRlIFhcblxuICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG5lbmRcblxubW9kdWxlIFMzX3RvX1MyIChYIDogUzMpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2QpIHQgPSAoJ2EsICdkLCB1bml0KSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgdHlwZSAoJ2EsICdkKSB0ID0gKCdhLCAnZCwgdW5pdCkgWC50XG5lbmRcblxubW9kdWxlIE1ha2UzIChYIDogQmFzaWMzKSA6IFMzIHdpdGggdHlwZSAoJ2EsICdkLCAnZSkgdCA6PSAoJ2EsICdkLCAnZSkgWC50ID0gc3RydWN0XG4gIGluY2x1ZGUgWFxuXG4gIGxldCAoIDwqPiApID0gYXBwbHlcbiAgbGV0IGRlcml2ZWRfbWFwIHQgfmYgPSByZXR1cm4gZiA8Kj4gdFxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIFgubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfYXBwbHkgLT4gZGVyaXZlZF9tYXBcbiAgICB8IGBDdXN0b20geCAtPiB4XG4gIDs7XG5cbiAgbGV0ICggPj58ICkgdCBmID0gbWFwIHQgfmZcbiAgbGV0IG1hcDIgdGEgdGIgfmYgPSBtYXAgfmYgdGEgPCo+IHRiXG4gIGxldCBtYXAzIHRhIHRiIHRjIH5mID0gbWFwIH5mIHRhIDwqPiB0YiA8Kj4gdGNcbiAgbGV0IGFsbCB0cyA9IExpc3QuZm9sZF9yaWdodCB0cyB+aW5pdDoocmV0dXJuIFtdKSB+ZjoobWFwMiB+ZjooZnVuIHggeHMgLT4geCA6OiB4cykpXG4gIGxldCBib3RoIHRhIHRiID0gbWFwMiB0YSB0YiB+ZjooZnVuIGEgYiAtPiBhLCBiKVxuICBsZXQgKCAqPiApIHUgdiA9IHJldHVybiAoZnVuICgpIHkgLT4geSkgPCo+IHUgPCo+IHZcbiAgbGV0ICggPCogKSB1IHYgPSByZXR1cm4gKGZ1biB4ICgpIC0+IHgpIDwqPiB1IDwqPiB2XG4gIGxldCBhbGxfdW5pdCB0cyA9IExpc3QuZm9sZCB0cyB+aW5pdDoocmV0dXJuICgpKSB+ZjooICo+IClcblxuICBtb2R1bGUgQXBwbGljYXRpdmVfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA8Kj4gKSA9ICggPCo+IClcbiAgICBsZXQgKCAqPiApID0gKCAqPiApXG4gICAgbGV0ICggPCogKSA9ICggPCogKVxuICAgIGxldCAoID4+fCApID0gKCA+PnwgKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZTIgKFggOiBCYXNpYzIpIDogUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50ID0gTWFrZTMgKHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgdHlwZSAoJ2EsICdkLCAnZSkgdCA9ICgnYSwgJ2QpIFgudFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlIChYIDogQmFzaWMpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnQgPSBNYWtlMiAoc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICB0eXBlICgnYSwgJ2UpIHQgPSAnYSBYLnRcbiAgZW5kKVxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4M1xuICAgIChYIDogRm9yX2xldF9zeW50YXgzKSAoSW50ZiA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgdHlwZSBTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpXG4gICAgKEltcGwgOiBJbnRmLlMpID1cbnN0cnVjdFxuICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgIGluY2x1ZGUgWFxuXG4gICAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gSW1wbFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgTWFrZV9sZXRfc3ludGF4MlxuICAgIChYIDogRm9yX2xldF9zeW50YXgyKSAoSW50ZiA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGUgdHlwZSBTXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQpXG4gICAgKEltcGwgOiBJbnRmLlMpID1cbiAgTWFrZV9sZXRfc3ludGF4M1xuICAgIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgWFxuXG4gICAgICB0eXBlICgnYSwgJ2QsIF8pIHQgPSAoJ2EsICdkKSBYLnRcbiAgICBlbmQpXG4gICAgKEludGYpXG4gICAgKEltcGwpXG5cbm1vZHVsZSBNYWtlX2xldF9zeW50YXhcbiAgICAoWCA6IEZvcl9sZXRfc3ludGF4KSAoSW50ZiA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZSB0eXBlIFNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kKVxuICAgIChJbXBsIDogSW50Zi5TKSA9XG4gIE1ha2VfbGV0X3N5bnRheDJcbiAgICAoc3RydWN0XG4gICAgICBpbmNsdWRlIFhcblxuICAgICAgdHlwZSAoJ2EsIF8pIHQgPSAnYSBYLnRcbiAgICBlbmQpXG4gICAgKEludGYpXG4gICAgKEltcGwpXG5cbigqKiBUaGlzIGZ1bmN0b3IgY2xvc2VseSByZXNlbWJsZXMgW01ha2UzXSwgYW5kIGluZGVlZCBpdCBjb3VsZCBiZSBpbXBsZW1lbnRlZFxuICAgIG11Y2ggc2hvcnRlciBpbiB0ZXJtcyBvZiBbTWFrZTNdLiBIb3dldmVyLCB3ZSBpbXBsZW1lbnQgaXQgYnkgaGFuZCBzbyB0aGF0XG4gICAgdGhlIHJlc3VsdGluZyBmdW5jdGlvbnMgYXJlIG1vcmUgZWZmaWNpZW50LCBlLmcuIHVzaW5nIFttYXAyXSBkaXJlY3RseSBpbnN0ZWFkIG9mXG4gICAgZGVmaW5pbmcgW2FwcGx5XSBpbiB0ZXJtcyBvZiBpdCBhbmQgdGhlbiBbbWFwMl0gaW4gdGVybXMgb2YgdGhhdC4gRm9yIG1vc3RcbiAgICBhcHBsaWNhdGl2ZXMgdGhpcyBkb2VzIG5vdCBtYXR0ZXIsIGJ1dCBmb3Igc29tZSAoc3VjaCBhcyBCb25zYWkuVmFsdWUudCksIGl0IGhhcyBhXG4gICAgbGFyZ2VyIGltcGFjdC4gKilcbm1vZHVsZSBNYWtlM191c2luZ19tYXAyIChYIDogQmFzaWMzX3VzaW5nX21hcDIpIDpcbiAgUzMgd2l0aCB0eXBlICgnYSwgJ2QsICdlKSB0IDo9ICgnYSwgJ2QsICdlKSBYLnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBYXG5cbiAgbGV0IGFwcGx5IHRmIHRhID0gbWFwMiB0ZiB0YSB+ZjooZnVuIGYgYSAtPiBmIGEpXG4gIGxldCAoIDwqPiApID0gYXBwbHlcbiAgbGV0IGRlcml2ZWRfbWFwIHQgfmYgPSByZXR1cm4gZiA8Kj4gdFxuXG4gIGxldCBtYXAgPVxuICAgIG1hdGNoIFgubWFwIHdpdGhcbiAgICB8IGBEZWZpbmVfdXNpbmdfbWFwMiAtPiBkZXJpdmVkX21hcFxuICAgIHwgYEN1c3RvbSB4IC0+IHhcbiAgOztcblxuICBsZXQgKCA+PnwgKSB0IGYgPSBtYXAgdCB+ZlxuICBsZXQgYm90aCB0YSB0YiA9IG1hcDIgdGEgdGIgfmY6KGZ1biBhIGIgLT4gYSwgYilcbiAgbGV0IG1hcDMgdGEgdGIgdGMgfmYgPSBtYXAyIChtYXAyIHRhIHRiIH5mKSB0YyB+ZjooZnVuIGZhYiBjIC0+IGZhYiBjKVxuICBsZXQgYWxsIHRzID0gTGlzdC5mb2xkX3JpZ2h0IHRzIH5pbml0OihyZXR1cm4gW10pIH5mOihtYXAyIH5mOihmdW4geCB4cyAtPiB4IDo6IHhzKSlcbiAgbGV0ICggKj4gKSB1IHYgPSBtYXAyIHUgdiB+ZjooZnVuICgpIHkgLT4geSlcbiAgbGV0ICggPCogKSB1IHYgPSBtYXAyIHUgdiB+ZjooZnVuIHggKCkgLT4geClcbiAgbGV0IGFsbF91bml0IHRzID0gTGlzdC5mb2xkIHRzIH5pbml0OihyZXR1cm4gKCkpIH5mOiggKj4gKVxuXG4gIG1vZHVsZSBBcHBsaWNhdGl2ZV9pbmZpeCA9IHN0cnVjdFxuICAgIGxldCAoIDwqPiApID0gKCA8Kj4gKVxuICAgIGxldCAoICo+ICkgPSAoICo+IClcbiAgICBsZXQgKCA8KiApID0gKCA8KiApXG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBNYWtlMl91c2luZ19tYXAyIChYIDogQmFzaWMyX3VzaW5nX21hcDIpIDpcbiAgUzIgd2l0aCB0eXBlICgnYSwgJ2UpIHQgOj0gKCdhLCAnZSkgWC50ID0gTWFrZTNfdXNpbmdfbWFwMiAoc3RydWN0XG4gICAgaW5jbHVkZSBYXG5cbiAgICB0eXBlICgnYSwgJ2QsICdlKSB0ID0gKCdhLCAnZCkgWC50XG4gIGVuZClcblxubW9kdWxlIE1ha2VfdXNpbmdfbWFwMiAoWCA6IEJhc2ljX3VzaW5nX21hcDIpIDogUyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBYLnQgPVxuICBNYWtlMl91c2luZ19tYXAyIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFhcblxuICAgIHR5cGUgKCdhLCAnZSkgdCA9ICdhIFgudFxuICBlbmQpXG5cbm1vZHVsZSBPZl9tb25hZDIgKE0gOiBNb25hZC5TMikgOiBTMiB3aXRoIHR5cGUgKCdhLCAnZSkgdCA6PSAoJ2EsICdlKSBNLnQgPSBNYWtlMiAoc3RydWN0XG4gICAgdHlwZSAoJ2EsICdlKSB0ID0gKCdhLCAnZSkgTS50XG5cbiAgICBsZXQgcmV0dXJuID0gTS5yZXR1cm5cbiAgICBsZXQgYXBwbHkgbWYgbXggPSBNLmJpbmQgbWYgfmY6KGZ1biBmIC0+IE0ubWFwIG14IH5mKVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIE0ubWFwXG4gIGVuZClcblxubW9kdWxlIE9mX21vbmFkIChNIDogTW9uYWQuUykgOiBTIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udCA9IE9mX21vbmFkMiAoc3RydWN0XG4gICAgaW5jbHVkZSBNXG5cbiAgICB0eXBlICgnYSwgXykgdCA9ICdhIE0udFxuICBlbmQpXG5cbm1vZHVsZSBDb21wb3NlIChGIDogUykgKEcgOiBTKSA6IFMgd2l0aCB0eXBlICdhIHQgPSAnYSBGLnQgRy50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIEYudCBHLnRcblxuICBpbmNsdWRlIE1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgICAgbGV0IHJldHVybiBhID0gRy5yZXR1cm4gKEYucmV0dXJuIGEpXG4gICAgICBsZXQgYXBwbHkgdGYgdHggPSBHLmFwcGx5IChHLm1hcCB+ZjpGLmFwcGx5IHRmKSB0eFxuICAgICAgbGV0IGN1c3RvbV9tYXAgdCB+ZiA9IEcubWFwIH5mOihGLm1hcCB+ZikgdFxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gY3VzdG9tX21hcFxuICAgIGVuZClcbmVuZFxuXG5tb2R1bGUgUGFpciAoRiA6IFMpIChHIDogUykgOiBTIHdpdGggdHlwZSAnYSB0ID0gJ2EgRi50ICogJ2EgRy50ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIEYudCAqICdhIEcudFxuXG4gIGluY2x1ZGUgTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgICBsZXQgcmV0dXJuIGEgPSBGLnJldHVybiBhLCBHLnJldHVybiBhXG4gICAgICBsZXQgYXBwbHkgdGYgdHggPSBGLmFwcGx5IChmc3QgdGYpIChmc3QgdHgpLCBHLmFwcGx5IChzbmQgdGYpIChzbmQgdHgpXG4gICAgICBsZXQgY3VzdG9tX21hcCB0IH5mID0gRi5tYXAgfmYgKGZzdCB0KSwgRy5tYXAgfmYgKHNuZCB0KVxuICAgICAgbGV0IG1hcCA9IGBDdXN0b20gY3VzdG9tX21hcFxuICAgIGVuZClcbmVuZFxuIiwiKCogW0J5dGVzMF0gZGVmaW5lcyBzdHJpbmcgZnVuY3Rpb25zIHRoYXQgYXJlIHByaW1pdGl2ZXMgb3IgY2FuIGJlIHNpbXBseVxuICAgZGVmaW5lZCBpbiB0ZXJtcyBvZiBbQ2FtbC5CeXRlc10uIFtCeXRlczBdIGlzIGludGVuZGVkIHRvIGNvbXBsZXRlbHkgZXhwcmVzc1xuICAgdGhlIHBhcnQgb2YgW0NhbWwuQnl0ZXNdIHRoYXQgW0Jhc2VdIHVzZXMgLS0gbm8gb3RoZXIgZmlsZSBpbiBCYXNlIG90aGVyXG4gICB0aGFuIGJ5dGVzMC5tbCBzaG91bGQgdXNlIFtDYW1sLkJ5dGVzXS4gW0J5dGVzMF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZFxuICAgc28gaXMgYXZhaWxhYmxlIGVhcmx5IGluIEJhc2UncyBidWlsZCBvcmRlci5cblxuICAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBzdHJpbmdzIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5CeXRlc10gaW5cbiAgIGJ1aWxkIG9yZGVyIHNob3VsZCBkbzpcblxuICAge1tcbiAgICAgbW9kdWxlIEJ5dGVzICA9IEJ5dGVzMFxuICAgXX1cblxuICAgRGVmaW5pbmcgW21vZHVsZSBCeXRlcyA9IEJ5dGVzMF0gaXMgYWxzbyBuZWNlc3NhcnkgYmVjYXVzZSBpdCBwcmV2ZW50c1xuICAgb2NhbWxkZXAgZnJvbSBtaXN0YWtlbmx5IGNhdXNpbmcgYSBmaWxlIHRvIGRlcGVuZCBvbiBbQmFzZS5CeXRlc10uICopXG5cbm9wZW4hIEltcG9ydDBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbm1vZHVsZSBQcmltaXRpdmVzID0gc3RydWN0XG4gIGV4dGVybmFsIGdldCA6IGJ5dGVzIC0+IGludCAtPiBjaGFyID0gXCIlYnl0ZXNfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBsZW5ndGggOiBieXRlcyAtPiBpbnQgPSBcIiVieXRlc19sZW5ndGhcIlxuICBleHRlcm5hbCB1bnNhZmVfZ2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgPSBcIiVieXRlc191bnNhZmVfZ2V0XCJcbiAgZXh0ZXJuYWwgc2V0ICAgICAgICA6IGJ5dGVzIC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcIiVieXRlc19zYWZlX3NldFwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfdW5zYWZlX3NldFwiXG5cbiAgKCogW3Vuc2FmZV9ibGl0X3N0cmluZ10gaXMgbm90IGV4cG9ydGVkIGluIHRoZSBbc3RkbGliXSBzbyB3ZSBleHBvcnQgaXQgaGVyZSAqKVxuICBleHRlcm5hbCB1bnNhZmVfYmxpdF9zdHJpbmdcbiAgICA6ICBzcmM6c3RyaW5nXG4gICAgLT4gc3JjX3BvczppbnRcbiAgICAtPiBkc3Q6Ynl0ZXNcbiAgICAtPiBkc3RfcG9zOmludFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiB1bml0XG4gICAgPSBcImNhbWxfYmxpdF9zdHJpbmdcIlxuICBbQEBub2FsbG9jXVxuXG4gIGV4dGVybmFsIHVuc2FmZV9nZXRfaW50NjQgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgPSBcIiVjYW1sX2J5dGVzX2dldDY0dVwiXG4gIGV4dGVybmFsIHVuc2FmZV9zZXRfaW50NjQgOiBieXRlcyAtPiBpbnQgLT4gaW50NjQgLT4gdW5pdCA9IFwiJWNhbWxfYnl0ZXNfc2V0NjR1XCJcbmVuZFxuXG5pbmNsdWRlIFByaW1pdGl2ZXNcblxubGV0IG1heF9sZW5ndGggPSBTeXMubWF4X3N0cmluZ19sZW5ndGhcbmxldCBibGl0ID0gQ2FtbC5CeXRlcy5ibGl0XG5sZXQgYmxpdF9zdHJpbmcgPSBDYW1sLkJ5dGVzLmJsaXRfc3RyaW5nXG5sZXQgY29tcGFyZSA9IENhbWwuQnl0ZXMuY29tcGFyZVxubGV0IGNvcHkgPSBDYW1sLkJ5dGVzLmNvcHlcbmxldCBjcmVhdGUgPSBDYW1sLkJ5dGVzLmNyZWF0ZVxubGV0IGZpbGwgPSBDYW1sLkJ5dGVzLmZpbGxcbmxldCBtYWtlID0gQ2FtbC5CeXRlcy5tYWtlXG5sZXQgbWFwID0gQ2FtbC5CeXRlcy5tYXBcbmxldCBtYXBpID0gQ2FtbC5CeXRlcy5tYXBpXG5sZXQgc3ViID0gQ2FtbC5CeXRlcy5zdWJcbmxldCB1bnNhZmVfYmxpdCA9IENhbWwuQnl0ZXMudW5zYWZlX2JsaXRcbmxldCB0b19zdHJpbmcgPSBDYW1sLkJ5dGVzLnRvX3N0cmluZ1xubGV0IG9mX3N0cmluZyA9IENhbWwuQnl0ZXMub2Zfc3RyaW5nXG5sZXQgdW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpzID0gQ2FtbC5CeXRlcy51bnNhZmVfdG9fc3RyaW5nIHNcbmxldCB1bnNhZmVfb2Zfc3RyaW5nX3Byb21pc2Vfbm9fbXV0YXRpb24gPSBDYW1sLkJ5dGVzLnVuc2FmZV9vZl9zdHJpbmdcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlICgnYSwgJ3dpdG5lc3MpIHQgPVxuICB7IGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnRcbiAgOyBzZXhwX29mX3QgOiAnYSAtPiBTZXhwLnRcbiAgfVxuXG50eXBlICgnYSwgJ2IpIGNvbXBhcmF0b3IgPSAoJ2EsICdiKSB0XG5cbm1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgdHlwZSB0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAodCwgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EgdCwgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIHR5cGUgU19mYyA9IHNpZ1xuICB0eXBlIGNvbXBhcmFibGVfdFxuXG4gIGluY2x1ZGUgUyB3aXRoIHR5cGUgdCA6PSBjb21wYXJhYmxlX3RcbmVuZFxuXG5tb2R1bGUgTW9kdWxlID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9IChtb2R1bGUgUyB3aXRoIHR5cGUgdCA9ICdhIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdiKVxuZW5kXG5cbmxldCBtYWtlICh0eXBlIHQpIH5jb21wYXJlIH5zZXhwX29mX3QgPVxuICAobW9kdWxlIHN0cnVjdFxuICAgIHR5cGUgY29tcGFyYWJsZV90ID0gdFxuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgICBsZXQgY29tcGFyYXRvciA9IHsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgZW5kIDogU19mY1xuICAgIHdpdGggdHlwZSBjb21wYXJhYmxlX3QgPSB0KVxuOztcblxubW9kdWxlIFNfdG9fUzEgKFMgOiBTKSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSBTLnRcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBTLmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIG9wZW4gU1xuXG4gIGxldCBjb21wYXJhdG9yID0gY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBNYWtlIChNIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgaW5jbHVkZSBNXG5cbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciA9IE0ueyBjb21wYXJlOyBzZXhwX29mX3QgfVxuZW5kXG5cbm1vZHVsZSBNYWtlMSAoTSA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gICAgdmFsIHNleHBfb2ZfdCA6ICdhIHQgLT4gU2V4cC50XG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBNLnsgY29tcGFyZTsgc2V4cF9vZl90IH1cbmVuZFxuXG5tb2R1bGUgUG9seSA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYVxuXG4gIGluY2x1ZGUgTWFrZTEgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcblxuICAgICAgbGV0IGNvbXBhcmUgPSBQb2x5LmNvbXBhcmVcbiAgICAgIGxldCBzZXhwX29mX3QgXyA9IFNleHAuQXRvbSBcIl9cIlxuICAgIGVuZClcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkID0gc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdjbXAgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsICdjbXApIGNvbXBhcmF0b3IgLT4gKCdhIHQsICdjbXAgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWQgKE0gOiBzaWdcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSAnY21wIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmU7IHNleHBfb2ZfdCA9IE0uc2V4cF9vZl90IGEuc2V4cF9vZl90IH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAoJ2NtcF9hLCAnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBjb21wYXJhdG9yXG4gICAgOiAgKCdhLCAnY21wX2EpIGNvbXBhcmF0b3JcbiAgICAtPiAoJ2IsICdjbXBfYikgY29tcGFyYXRvclxuICAgIC0+ICgoJ2EsICdiKSB0LCAoJ2NtcF9hLCAnY21wX2IpIGNvbXBhcmF0b3Jfd2l0bmVzcykgY29tcGFyYXRvclxuZW5kXG5cbm1vZHVsZSBEZXJpdmVkMiAoTSA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2EsICdiKSB0XG4gICAgICAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgKCdjbXBfYSwgJ2NtcF9iKSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICBsZXQgY29tcGFyYXRvciBhIGIgPVxuICAgIHsgY29tcGFyZSA9IE0uY29tcGFyZSBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgOyBzZXhwX29mX3QgPSBNLnNleHBfb2ZfdCBhLnNleHBfb2ZfdCBiLnNleHBfb2ZfdFxuICAgIH1cbiAgOztcbmVuZFxuXG5tb2R1bGUgdHlwZSBEZXJpdmVkX3BoYW50b20gPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgJ2NtcCBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgY29tcGFyYXRvclxuICAgIDogICgnYSwgJ2NtcCkgY29tcGFyYXRvclxuICAgIC0+ICgoJ2EsIF8pIHQsICdjbXAgY29tcGFyYXRvcl93aXRuZXNzKSBjb21wYXJhdG9yXG5lbmRcblxubW9kdWxlIERlcml2ZWRfcGhhbnRvbSAoTSA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIGNvbXBhcmUgOiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gaW50XG4gICAgdmFsIHNleHBfb2ZfdCA6ICgnYSAtPiBTZXhwLnQpIC0+ICgnYSwgXykgdCAtPiBTZXhwLnRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSAnY21wX2EgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgbGV0IGNvbXBhcmF0b3IgYSA9XG4gICAgeyBjb21wYXJlID0gTS5jb21wYXJlIGEuY29tcGFyZTsgc2V4cF9vZl90ID0gTS5zZXhwX29mX3QgYS5zZXhwX29mX3QgfVxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2YsICdzKSB0ID1cbiAgfCBGaXJzdCBvZiAnZlxuICB8IFNlY29uZCBvZiAnc1xuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxubGV0IGNvbXBhcmUgOlxuICAnZiAncy4gKCdmIC0+ICdmIC0+IGludCkgLT4gKCdzIC0+ICdzIC0+IGludCkgLT4gKCdmLCAncykgdCAtPiAoJ2YsICdzKSB0IC0+IGludFxuICA9XG4gIGZ1biBfY21wX19mIF9jbXBfX3MgYV9fMDAxXyBiX18wMDJfIC0+XG4gIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwMV8gYl9fMDAyX1xuICB0aGVuIDBcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDAxXywgYl9fMDAyXyB3aXRoXG4gICAgfCBGaXJzdCBfYV9fMDAzXywgRmlyc3QgX2JfXzAwNF8gLT4gX2NtcF9fZiBfYV9fMDAzXyBfYl9fMDA0X1xuICAgIHwgRmlyc3QgXywgXyAtPiAtMVxuICAgIHwgXywgRmlyc3QgXyAtPiAxXG4gICAgfCBTZWNvbmQgX2FfXzAwNV8sIFNlY29uZCBfYl9fMDA2XyAtPiBfY21wX19zIF9hX18wMDVfIF9iX18wMDZfKVxuOztcblxubGV0IGhhc2hfZm9sZF90XG4gIDogdHlwZSBmIHMuXG4gICAgKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBmIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHMgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+IChmLCBzKSB0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gID1cbiAgZnVuIF9oYXNoX2ZvbGRfZiBfaGFzaF9mb2xkX3MgaHN2IGFyZyAtPlxuICBtYXRjaCBhcmcgd2l0aFxuICB8IEZpcnN0IF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDAgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9mIGhzdiBfYTBcbiAgfCBTZWNvbmQgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMSBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX3MgaHN2IF9hMFxuOztcblxubGV0IHRfb2Zfc2V4cCA6XG4gICdmICdzLlxuICAoU2V4cGxpYjAuU2V4cC50IC0+ICdmKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+ICdzKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gKCdmLCAncykgdFxuICA9XG4gIGZ1biAodHlwZSBmX18wMjNfIHNfXzAyNF8pXG4gICAgICA6ICAoKFNleHBsaWIwLlNleHAudCAtPiBmX18wMjNfKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+IHNfXzAyNF8pIC0+IFNleHBsaWIwLlNleHAudFxuICAgICAgICAgIC0+IChmX18wMjNfLCBzX18wMjRfKSB0KSAtPlxuICAgIGxldCBlcnJvcl9zb3VyY2VfXzAxMV8gPSBcImVpdGhlcjAubWwudFwiIGluXG4gICAgZnVuIF9vZl9mX18wMDdfIF9vZl9zX18wMDhfIC0+IGZ1bmN0aW9uXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImZpcnN0XCIgfCBcIkZpcnN0XCIpIGFzIF90YWdfXzAxNF8pIDo6IHNleHBfYXJnc19fMDE1XykgYXNcbiAgICAgICAgX3NleHBfXzAxM18gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDE1XyB3aXRoXG4gICAgICAgICB8IFsgYXJnMF9fMDE2XyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMTdfID0gX29mX2ZfXzAwN18gYXJnMF9fMDE2XyBpblxuICAgICAgICAgICBGaXJzdCByZXMwX18wMTdfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDExX1xuICAgICAgICAgICAgIF90YWdfXzAxNF9cbiAgICAgICAgICAgICBfc2V4cF9fMDEzXylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwic2Vjb25kXCIgfCBcIlNlY29uZFwiKSBhcyBfdGFnX18wMTlfKSA6OiBzZXhwX2FyZ3NfXzAyMF8pIGFzXG4gICAgICAgIF9zZXhwX18wMThfIC0+XG4gICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAyMF8gd2l0aFxuICAgICAgICAgfCBbIGFyZzBfXzAyMV8gXSAtPlxuICAgICAgICAgICBsZXQgcmVzMF9fMDIyXyA9IF9vZl9zX18wMDhfIGFyZzBfXzAyMV8gaW5cbiAgICAgICAgICAgU2Vjb25kIHJlczBfXzAyMl9cbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMTFfXG4gICAgICAgICAgICAgX3RhZ19fMDE5X1xuICAgICAgICAgICAgIF9zZXhwX18wMThfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZmlyc3RcIiB8IFwiRmlyc3RcIikgYXMgc2V4cF9fMDEyXyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTJfXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJzZWNvbmRcIiB8IFwiU2Vjb25kXCIpIGFzIHNleHBfXzAxMl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEyX1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAxMF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTBfXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMTBfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDExXyBzZXhwX18wMTBfXG4gICAgICB8IHNleHBfXzAxMF8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAxMV8gc2V4cF9fMDEwX1xuOztcblxubGV0IHNleHBfb2ZfdCA6XG4gICdmICdzLlxuICAoJ2YgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ3MgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoJ2YsICdzKSB0IC0+IFNleHBsaWIwLlNleHAudFxuICA9XG4gIGZ1biAodHlwZSBmX18wMzFfIHNfXzAzMl8pXG4gICAgICA6ICAoKGZfXzAzMV8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoc19fMDMyXyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgICAgLT4gKGZfXzAzMV8sIHNfXzAzMl8pIHQgLT4gU2V4cGxpYjAuU2V4cC50KSAtPlxuICAgIGZ1biBfb2ZfZl9fMDI1XyBfb2Zfc19fMDI2XyAtPiBmdW5jdGlvblxuICAgICAgfCBGaXJzdCBhcmcwX18wMjdfIC0+XG4gICAgICAgIGxldCByZXMwX18wMjhfID0gX29mX2ZfXzAyNV8gYXJnMF9fMDI3XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJGaXJzdFwiOyByZXMwX18wMjhfIF1cbiAgICAgIHwgU2Vjb25kIGFyZzBfXzAyOV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAzMF8gPSBfb2Zfc19fMDI2XyBhcmcwX18wMjlfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlNlY29uZFwiOyByZXMwX18wMzBfIF1cbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOlxuICAgICAgICdmIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgIC0+ICdzIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgIC0+ICgnZiwgJ3MpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gID1cbiAgZnVuIF8nZl9zZXhwX2dyYW1tYXIgXydzX3NleHBfZ3JhbW1hciAtPlxuICB7IHVudHlwZWQgPVxuICAgICAgVmFyaWFudFxuICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICBbIE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiRmlyc3RcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Zfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIlNlY29uZFwiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nc19zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxuW0BAQGVuZF1cbiIsIigqIFRoZSB0eXBlIFt0XSBzaG91bGQgYmUgYWJzdHJhY3QgdG8gbWFrZSB0aGUgZnNldCBhbmQgc2V0IGZ1bmN0aW9ucyB1bmF2YWlsYWJsZVxuICAgZm9yIHByaXZhdGUgdHlwZXMgYXQgdGhlIGxldmVsIG9mIHR5cGVzIChhbmQgbm90IGJ5IHB1dHRpbmcgTm9uZSBpbiB0aGUgZmllbGQpLlxuICAgVW5mb3J0dW5hdGVseSwgbWFraW5nIHRoZSB0eXBlIGFic3RyYWN0IG1lYW5zIHRoYXQgd2hlbiBjcmVhdGluZyBmaWVsZHMgKHRocm91Z2hcbiAgIGEgW2NyZWF0ZV0gZnVuY3Rpb24pIHZhbHVlIHJlc3RyaWN0aW9uIGtpY2tzIGluLiBUaGlzIGlzIHdvcmtlZCBhcm91bmQgYnkgaW5zdGVhZFxuICAgbm90IG1ha2luZyB0aGUgdHlwZSBhYnN0cmFjdCwgYnV0IGZvcmNpbmcgYW55b25lIGJyZWFraW5nIHRoZSBhYnN0cmFjdGlvbiB0byB1c2VcbiAgIHRoZSBbRm9yX2dlbmVyYXRlZF9jb2RlXSBtb2R1bGUsIG1ha2luZyBpdCBvYnZpb3VzIHRvIGFueSByZWFkZXIgdGhhdCBzb21ldGhpbmcgdWdseVxuICAgaXMgZ29pbmcgb24uXG4gICB0X3dpdGhfcGVybSAoYW5kIGRlcml2YXRpdmVzKSBpcyB0aGUgdHlwZSB0aGF0IHVzZXJzIHJlYWxseSB1c2UuIEl0IGlzIGEgY29uc3RydWN0b3JcbiAgIGJlY2F1c2U6XG4gICAxLiBpdCBtYWtlcyB0eXBlIGVycm9ycyBtb3JlIHJlYWRhYmxlIChsZXNzIGFsaWFzaW5nKVxuICAgMi4gdGhlIHR5cGVyIGluIG9jYW1sIDQuMDEgYWxsb3dzIHRoaXM6XG5cbiAgIHtbXG4gICAgIG1vZHVsZSBBID0gc3RydWN0XG4gICAgICAgdHlwZSB0ID0ge2EgOiBpbnR9XG4gICAgIGVuZFxuICAgICB0eXBlIHQgPSBBLnRcbiAgICAgbGV0IGYgKHggOiB0KSA9IHguYVxuICAgXX1cblxuICAgKGFsdGhvdWdoIHdpdGggV2FybmluZyA0MDogYSBpcyB1c2VkIG91dCBvZiBzY29wZSlcbiAgIHdoaWNoIG1lYW5zIHRoYXQgaWYgW3Rfd2l0aF9wZXJtXSB3YXMgcmVhbGx5IGFuIGFsaWFzIG9uIFtGb3JfZ2VuZXJhdGVkX2NvZGUudF0sXG4gICBwZW9wbGUgY291bGQgc2F5IFt0LnNldHRlcl0gYW5kIGJyZWFrIHRoZSBhYnN0cmFjdGlvbiB3aXRoIG5vIGluZGljYXRpb24gdGhhdFxuICAgc29tZXRoaW5nIHVnbHkgaXMgZ29pbmcgb24gaW4gdGhlIHNvdXJjZSBjb2RlLlxuICAgVGhlIHdhcm5pbmcgaXMgKEkgdGhpbmspIGZvciBwZW9wbGUgd2hvIHdhbnQgdG8gbWFrZSB0aGVpciBjb2RlIGNvbXBhdGlibGUgd2l0aFxuICAgcHJldmlvdXMgdmVyc2lvbnMgb2Ygb2NhbWwsIHNvIHdlIG1heSB2ZXJ5IHdlbGwgdHVybiBpdCBvZmYuXG5cbiAgIFRoZSB0eXBlIHRfd2l0aF9wZXJtIGNvdWxkIGFsc28gaGF2ZSBiZWVuIGEgW3VuaXQgLT4gRm9yX2dlbmVyYXRlZF9jb2RlLnRdIHRvIHdvcmtcbiAgIGFyb3VuZCB2YWx1ZSByZXN0cmljdGlvbiBhbmQgdGhlbiBbRm9yX2dlbmVyYXRlZF9jb2RlLnRdIHdvdWxkIGhhdmUgYmVlbiBhIHByb3BlclxuICAgYWJzdHJhY3QgdHlwZSwgYnV0IGl0IGxvb2tzIGxpa2UgaXQgY291bGQgaW1wYWN0IHBlcmZvcm1hbmNlIChmb3IgZXhhbXBsZSwgYSBmb2xkIG9uIGFcbiAgIHJlY29yZCB0eXBlIHdpdGggNDAgZmllbGRzIHdvdWxkIGFjdHVhbGx5IGFsbG9jYXRlIHRoZSA0MCBbRm9yX2dlbmVyYXRlZF9jb2RlLnRdJ3MgYXRcbiAgIGV2ZXJ5IHNpbmdsZSBmb2xkLikgKilcblxubW9kdWxlIEZvcl9nZW5lcmF0ZWRfY29kZSA9IHN0cnVjdFxuICB0eXBlICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSB0ID1cbiAgICB7IGZvcmNlX3ZhcmlhbmNlIDogJ3Blcm0gLT4gdW5pdFxuICAgIDsgKCogZm9yY2UgW3RdIHRvIGJlIGNvbnRyYXZhcmlhbnQgaW4gWydwZXJtXSwgYmVjYXVzZSBwaGFudG9tIHR5cGUgdmFyaWFibGVzIG9uXG4gICAgICAgICBjb25jcmV0ZSB0eXBlcyBkb24ndCB3b3JrIHRoYXQgd2VsbCBvdGhlcndpc2UgKHVzaW5nIDo+IGNhbiByZW1vdmUgdGhlbSBlYXNpbHkpICopXG4gICAgICBuYW1lIDogc3RyaW5nXG4gICAgOyBzZXR0ZXIgOiAoJ3JlY29yZCAtPiAnZmllbGQgLT4gdW5pdCkgb3B0aW9uXG4gICAgOyBnZXR0ZXIgOiAncmVjb3JkIC0+ICdmaWVsZFxuICAgIDsgZnNldCA6ICdyZWNvcmQgLT4gJ2ZpZWxkIC0+ICdyZWNvcmRcbiAgICB9XG5cbiAgbGV0IG9wYXF1ZV9pZGVudGl0eSA9IFN5czAub3BhcXVlX2lkZW50aXR5XG5lbmRcblxudHlwZSAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm0gPVxuICB8IEZpZWxkIG9mICgncGVybSwgJ3JlY29yZCwgJ2ZpZWxkKSBGb3JfZ2VuZXJhdGVkX2NvZGUudFxuW0BAdW5ib3hlZF1cblxudHlwZSAoJ3JlY29yZCwgJ2ZpZWxkKSB0ID0gKFsgYFJlYWQgfCBgU2V0X2FuZF9jcmVhdGUgXSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybVxudHlwZSAoJ3JlY29yZCwgJ2ZpZWxkKSByZWFkb25seV90ID0gKFsgYFJlYWQgXSwgJ3JlY29yZCwgJ2ZpZWxkKSB0X3dpdGhfcGVybVxuXG5sZXQgbmFtZSAoRmllbGQgZmllbGQpID0gZmllbGQubmFtZVxubGV0IGdldCAoRmllbGQgZmllbGQpIHIgPSBmaWVsZC5nZXR0ZXIgclxubGV0IGZzZXQgKEZpZWxkIGZpZWxkKSByIHYgPSBmaWVsZC5mc2V0IHIgdlxubGV0IHNldHRlciAoRmllbGQgZmllbGQpID0gZmllbGQuc2V0dGVyXG5cbnR5cGUgKCdwZXJtLCAncmVjb3JkLCAncmVzdWx0KSB1c2VyID1cbiAgeyBmIDogJ2ZpZWxkLiAoJ3Blcm0sICdyZWNvcmQsICdmaWVsZCkgdF93aXRoX3Blcm0gLT4gJ3Jlc3VsdCB9XG5cbmxldCBtYXAgKEZpZWxkIGZpZWxkKSByIH5mID0gZmllbGQuZnNldCByIChmIChmaWVsZC5nZXR0ZXIgcikpXG5cbmxldCB1cGRhdGVyIChGaWVsZCBmaWVsZCkgPVxuICBtYXRjaCBmaWVsZC5zZXR0ZXIgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgc2V0dGVyIC0+IFNvbWUgKGZ1biByIH5mIC0+IHNldHRlciByIChmIChmaWVsZC5nZXR0ZXIgcikpKVxuOztcbiIsIigqIFtTdHJpbmcwXSBkZWZpbmVzIHN0cmluZyBmdW5jdGlvbnMgdGhhdCBhcmUgcHJpbWl0aXZlcyBvciBjYW4gYmUgc2ltcGx5IGRlZmluZWQgaW5cbiAgIHRlcm1zIG9mIFtDYW1sLlN0cmluZ10uIFtTdHJpbmcwXSBpcyBpbnRlbmRlZCB0byBjb21wbGV0ZWx5IGV4cHJlc3MgdGhlIHBhcnQgb2ZcbiAgIFtDYW1sLlN0cmluZ10gdGhhdCBbQmFzZV0gdXNlcyAtLSBubyBvdGhlciBmaWxlIGluIEJhc2Ugb3RoZXIgdGhhbiBzdHJpbmcwLm1sIHNob3VsZFxuICAgdXNlIFtDYW1sLlN0cmluZ10uICBbU3RyaW5nMF0gaGFzIGZldyBkZXBlbmRlbmNpZXMsIGFuZCBzbyBpcyBhdmFpbGFibGUgZWFybHkgaW4gQmFzZSdzXG4gICBidWlsZCBvcmRlci5cblxuICAgQWxsIEJhc2UgZmlsZXMgdGhhdCBuZWVkIHRvIHVzZSBzdHJpbmdzLCBpbmNsdWRpbmcgdGhlIHN1YnNjcmlwdCBzeW50YXhcbiAgIFt4LihpKV0gb3IgW3guKGkpIDwtIGVdIHdoaWNoIHRoZSBPQ2FtbCBwYXJzZXIgZGVzdWdhcnMgaW50byBjYWxscyB0b1xuICAgW1N0cmluZ10sIGFuZCBjb21lIGJlZm9yZSBbQmFzZS5TdHJpbmddIGluIGJ1aWxkIG9yZGVyIHNob3VsZCBkb1xuXG4gICB7W1xuICAgICBtb2R1bGUgU3RyaW5nID0gU3RyaW5nMFxuICAgXX1cblxuICAgRGVmaW5pbmcgW21vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXSBpcyBhbHNvIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IHByZXZlbnRzXG4gICBvY2FtbGRlcCBmcm9tIG1pc3Rha2VubHkgY2F1c2luZyBhIGZpbGUgdG8gZGVwZW5kIG9uIFtCYXNlLlN0cmluZ10uICopXG5cbm9wZW4hIEltcG9ydDBcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzMFxubW9kdWxlIFN5cyA9IFN5czBcblxubW9kdWxlIFN0cmluZyA9IHN0cnVjdFxuICBleHRlcm5hbCBnZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfc2FmZV9nZXRcIlxuICBleHRlcm5hbCBsZW5ndGggOiBzdHJpbmcgLT4gaW50ID0gXCIlc3RyaW5nX2xlbmd0aFwiXG4gIGV4dGVybmFsIHVuc2FmZV9nZXQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgPSBcIiVzdHJpbmdfdW5zYWZlX2dldFwiXG4gIGV4dGVybmFsIHNldCAgICAgICAgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlYnl0ZXNfc2FmZV9zZXRcIlxuICBleHRlcm5hbCB1bnNhZmVfc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJWJ5dGVzX3Vuc2FmZV9zZXRcIlxuZW5kXG5cbmluY2x1ZGUgU3RyaW5nXG5cbmxldCBtYXhfbGVuZ3RoID0gU3lzLm1heF9zdHJpbmdfbGVuZ3RoXG5sZXQgKCBeICkgPSAoIF4gKVxubGV0IGNhcGl0YWxpemUgPSBDYW1sLlN0cmluZy5jYXBpdGFsaXplX2FzY2lpXG5sZXQgY29tcGFyZSA9IENhbWwuU3RyaW5nLmNvbXBhcmVcblxubGV0IGNvcHkgeCA9XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmdcbiAgICB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpcbiAgICAgIChCeXRlcy5vZl9zdHJpbmcgeClcbjs7XG5cbmxldCBlc2NhcGVkID0gQ2FtbC5TdHJpbmcuZXNjYXBlZFxubGV0IGxvd2VyY2FzZSA9IENhbWwuU3RyaW5nLmxvd2VyY2FzZV9hc2NpaVxubGV0IG1ha2UgPSBDYW1sLlN0cmluZy5tYWtlXG5sZXQgc3ViID0gQ2FtbC5TdHJpbmcuc3ViXG5sZXQgdW5jYXBpdGFsaXplID0gQ2FtbC5TdHJpbmcudW5jYXBpdGFsaXplX2FzY2lpXG5sZXQgdW5zYWZlX2JsaXQgPSBDYW1sLlN0cmluZy51bnNhZmVfYmxpdFxubGV0IHVwcGVyY2FzZSA9IENhbWwuU3RyaW5nLnVwcGVyY2FzZV9hc2NpaVxuXG5sZXQgY29uY2F0ID8oc2VwID0gXCJcIikgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+IFwiXCJcbiAgKCogVGhlIHN0ZGxpYiBkb2VzIG5vdCBzcGVjaWFsaXplIHRoaXMgY2FzZSBiZWNhdXNlIGl0IGNvdWxkIGJyZWFrIGV4aXN0aW5nIHByb2plY3RzLiAqKVxuICB8IFsgeCBdIC0+IHhcbiAgfCBsIC0+IENhbWwuU3RyaW5nLmNvbmNhdCB+c2VwIGxcbjs7XG5cbigqIFRoZXNlIGFyZSBldGEgZXhwYW5kZWQgaW4gb3JkZXIgdG8gcGVybXV0ZSBwYXJhbWV0ZXIgb3JkZXIgdG8gZm9sbG93IEJhc2VcbiAgIGNvbnZlbnRpb25zLiAqKVxubGV0IGl0ZXIgdCB+ZiA9IENhbWwuU3RyaW5nLml0ZXIgdCB+ZlxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gQ2FtbC5MZXhpbmcucG9zaXRpb24gPVxuICAgIHsgcG9zX2ZuYW1lIDogc3RyaW5nXG4gICAgOyBwb3NfbG51bSA6IGludFxuICAgIDsgcG9zX2JvbCA6IGludFxuICAgIDsgcG9zX2NudW0gOiBpbnRcbiAgICB9XG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlID1cbiAgICAoZnVuIGFfXzAwMV8gYl9fMDAyXyAtPlxuICAgICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwMV8gYl9fMDAyX1xuICAgICAgIHRoZW4gMFxuICAgICAgIGVsc2UgKFxuICAgICAgICAgbWF0Y2ggY29tcGFyZV9zdHJpbmcgYV9fMDAxXy5wb3NfZm5hbWUgYl9fMDAyXy5wb3NfZm5hbWUgd2l0aFxuICAgICAgICAgfCAwIC0+XG4gICAgICAgICAgIChtYXRjaCBjb21wYXJlX2ludCBhX18wMDFfLnBvc19sbnVtIGJfXzAwMl8ucG9zX2xudW0gd2l0aFxuICAgICAgICAgICAgfCAwIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBjb21wYXJlX2ludCBhX18wMDFfLnBvc19ib2wgYl9fMDAyXy5wb3NfYm9sIHdpdGhcbiAgICAgICAgICAgICAgIHwgMCAtPiBjb21wYXJlX2ludCBhX18wMDFfLnBvc19jbnVtIGJfXzAwMl8ucG9zX2NudW1cbiAgICAgICAgICAgICAgIHwgbiAtPiBuKVxuICAgICAgICAgICAgfCBuIC0+IG4pXG4gICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgIDogdCAtPiB0IC0+IGludClcbiAgOztcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgZnVuIGhzdiBhcmcgLT5cbiAgICAgIGxldCBoc3YgPVxuICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgICAgIGhhc2hfZm9sZF9zdHJpbmcgaHN2IGFyZy5wb3NfZm5hbWVcbiAgICAgICAgICBpblxuICAgICAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfbG51bVxuICAgICAgICBpblxuICAgICAgICBoYXNoX2ZvbGRfaW50IGhzdiBhcmcucG9zX2JvbFxuICAgICAgaW5cbiAgICAgIGhhc2hfZm9sZF9pbnQgaHN2IGFyZy5wb3NfY251bVxuICA7O1xuXG4gIGxldCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyBhcmcgPVxuICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgICAgaGFzaF9mb2xkX3QgaHN2IGFyZylcbiAgICBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW4geyBwb3NfZm5hbWUgPSBwb3NfZm5hbWVfXzAwNF9cbiAgICAgICAgIDsgcG9zX2xudW0gPSBwb3NfbG51bV9fMDA2X1xuICAgICAgICAgOyBwb3NfYm9sID0gcG9zX2JvbF9fMDA4X1xuICAgICAgICAgOyBwb3NfY251bSA9IHBvc19jbnVtX18wMTBfXG4gICAgICAgICB9IC0+XG4gICAgICBsZXQgYm5kc19fMDAzXyA9IFtdIGluXG4gICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgIGxldCBhcmdfXzAxMV8gPSBzZXhwX29mX2ludCBwb3NfY251bV9fMDEwXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfY251bVwiOyBhcmdfXzAxMV8gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMDlfID0gc2V4cF9vZl9pbnQgcG9zX2JvbF9fMDA4XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfYm9sXCI7IGFyZ19fMDA5XyBdIDo6IGJuZHNfXzAwM19cbiAgICAgIGluXG4gICAgICBsZXQgYm5kc19fMDAzXyA9XG4gICAgICAgIGxldCBhcmdfXzAwN18gPSBzZXhwX29mX2ludCBwb3NfbG51bV9fMDA2XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJwb3NfbG51bVwiOyBhcmdfXzAwN18gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgbGV0IGJuZHNfXzAwM18gPVxuICAgICAgICBsZXQgYXJnX18wMDVfID0gc2V4cF9vZl9zdHJpbmcgcG9zX2ZuYW1lX18wMDRfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBvc19mbmFtZVwiOyBhcmdfXzAwNV8gXSA6OiBibmRzX18wMDNfXG4gICAgICBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IGJuZHNfXzAwM19cbiAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG4oKiBUaGlzIGlzIHRoZSBzYW1lIGZ1bmN0aW9uIGFzIFBweF9oZXJlLmxpZnRfcG9zaXRpb25fYXNfc3RyaW5nLiAqKVxubGV0IG1ha2VfbG9jYXRpb25fc3RyaW5nIH5wb3NfZm5hbWUgfnBvc19sbnVtIH5wb3NfY251bSB+cG9zX2JvbCA9XG4gIFN0cmluZy5jb25jYXRcbiAgICBbIHBvc19mbmFtZTsgXCI6XCI7IEludC50b19zdHJpbmcgcG9zX2xudW07IFwiOlwiOyBJbnQudG9fc3RyaW5nIChwb3NfY251bSAtIHBvc19ib2wpIF1cbjs7XG5cbmxldCB0b19zdHJpbmcgeyBDYW1sLkxleGluZy5wb3NfZm5hbWU7IHBvc19sbnVtOyBwb3NfY251bTsgcG9zX2JvbCB9ID1cbiAgbWFrZV9sb2NhdGlvbl9zdHJpbmcgfnBvc19mbmFtZSB+cG9zX2xudW0gfnBvc19jbnVtIH5wb3NfYm9sXG47O1xuXG5sZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKHRvX3N0cmluZyB0KVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIExpc3QwXG5cbmxldCBpc19lbXB0eSA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBwYXJ0aXRpb25fbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCBmc3Qgc25kID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJldiBmc3QsIHJldiBzbmRcbiAgICB8IHggOjogdCAtPlxuICAgICAgKG1hdGNoIChmIHggOiBfIEVpdGhlcjAudCkgd2l0aFxuICAgICAgIHwgRmlyc3QgeSAtPiBsb29wIHQgKHkgOjogZnN0KSBzbmRcbiAgICAgICB8IFNlY29uZCB5IC0+IGxvb3AgdCBmc3QgKHkgOjogc25kKSlcbiAgaW5cbiAgbG9vcCB0IFtdIFtdXG47O1xuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgRWl0aGVyID0gRWl0aGVyMFxuXG50eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBDYW1sLnJlc3VsdCA9XG4gIHwgT2sgb2YgJ2FcbiAgfCBFcnJvciBvZiAnYlxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hciwgY29tcGFyZSwgZXF1YWwsIGhhc2hdXG5cbmxldCB0X29mX3NleHAgOlxuICAnYSAnYi5cbiAgKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gKFNleHBsaWIwLlNleHAudCAtPiAnYikgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICgnYSwgJ2IpIHRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDE3XyBiX18wMThfKVxuICAgICAgOiAgKChTZXhwbGliMC5TZXhwLnQgLT4gYV9fMDE3XykgLT4gKFNleHBsaWIwLlNleHAudCAtPiBiX18wMThfKSAtPiBTZXhwbGliMC5TZXhwLnRcbiAgICAgICAgICAtPiAoYV9fMDE3XywgYl9fMDE4XykgdCkgLT5cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wMDVfID0gXCJyZXN1bHQubWwudFwiIGluXG4gICAgZnVuIF9vZl9hX18wMDFfIF9vZl9iX18wMDJfIC0+IGZ1bmN0aW9uXG4gICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcIm9rXCIgfCBcIk9rXCIpIGFzIF90YWdfXzAwOF8pIDo6IHNleHBfYXJnc19fMDA5XykgYXNcbiAgICAgICAgX3NleHBfXzAwN18gLT5cbiAgICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDA5XyB3aXRoXG4gICAgICAgICB8IFsgYXJnMF9fMDEwXyBdIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMTFfID0gX29mX2FfXzAwMV8gYXJnMF9fMDEwXyBpblxuICAgICAgICAgICBPayByZXMwX18wMTFfXG4gICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDA1X1xuICAgICAgICAgICAgIF90YWdfXzAwOF9cbiAgICAgICAgICAgICBfc2V4cF9fMDA3XylcbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiZXJyb3JcIiB8IFwiRXJyb3JcIikgYXMgX3RhZ19fMDEzXykgOjogc2V4cF9hcmdzX18wMTRfKSBhc1xuICAgICAgICBfc2V4cF9fMDEyXyAtPlxuICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMTRfIHdpdGhcbiAgICAgICAgIHwgWyBhcmcwX18wMTVfIF0gLT5cbiAgICAgICAgICAgbGV0IHJlczBfXzAxNl8gPSBfb2ZfYl9fMDAyXyBhcmcwX18wMTVfIGluXG4gICAgICAgICAgIEVycm9yIHJlczBfXzAxNl9cbiAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDVfXG4gICAgICAgICAgICAgX3RhZ19fMDEzX1xuICAgICAgICAgICAgIF9zZXhwX18wMTJfKVxuICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwib2tcIiB8IFwiT2tcIikgYXMgc2V4cF9fMDA2XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDZfXG4gICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcnJvclwiIHwgXCJFcnJvclwiKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgICAgfCBzZXhwX18wMDRfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNF9cbjs7XG5cbmxldCBzZXhwX29mX3QgOlxuICAnYSAnYi5cbiAgKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDI1XyBiX18wMjZfKVxuICAgICAgOiAgKChhX18wMjVfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzAyNl8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgIC0+IChhX18wMjVfLCBiX18wMjZfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAxOV8gX29mX2JfXzAyMF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgT2sgYXJnMF9fMDIxXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDIyXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2tcIjsgcmVzMF9fMDIyXyBdXG4gICAgICB8IEVycm9yIGFyZzBfXzAyM18gLT5cbiAgICAgICAgbGV0IHJlczBfXzAyNF8gPSBfb2ZfYl9fMDIwXyBhcmcwX18wMjNfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkVycm9yXCI7IHJlczBfXzAyNF8gXVxuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgLT4gJ2IgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciBfJ2Jfc2V4cF9ncmFtbWFyIC0+XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgeyBuYW1lID0gXCJPa1wiXG4gICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlIHsgYXJncyA9IENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiRXJyb3JcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Jfc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gIH1cbjs7XG5cbmxldCBjb21wYXJlIDpcbiAgJ2EgJ2IuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgdCAtPiBpbnRcbiAgPVxuICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAyN18gYl9fMDI4XyAtPlxuICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMjdfIGJfXzAyOF9cbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIG1hdGNoIGFfXzAyN18sIGJfXzAyOF8gd2l0aFxuICAgIHwgT2sgX2FfXzAyOV8sIE9rIF9iX18wMzBfIC0+IF9jbXBfX2EgX2FfXzAyOV8gX2JfXzAzMF9cbiAgICB8IE9rIF8sIF8gLT4gLTFcbiAgICB8IF8sIE9rIF8gLT4gMVxuICAgIHwgRXJyb3IgX2FfXzAzMV8sIEVycm9yIF9iX18wMzJfIC0+IF9jbXBfX2IgX2FfXzAzMV8gX2JfXzAzMl8pXG47O1xuXG5sZXQgZXF1YWwgOlxuICAnYSAnYi4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYiAtPiAnYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHQgLT4gYm9vbFxuICA9XG4gIGZ1biBfY21wX19hIF9jbXBfX2IgYV9fMDMzXyBiX18wMzRfIC0+XG4gIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAzM18gYl9fMDM0X1xuICB0aGVuIHRydWVcbiAgZWxzZSAoXG4gICAgbWF0Y2ggYV9fMDMzXywgYl9fMDM0XyB3aXRoXG4gICAgfCBPayBfYV9fMDM1XywgT2sgX2JfXzAzNl8gLT4gX2NtcF9fYSBfYV9fMDM1XyBfYl9fMDM2X1xuICAgIHwgT2sgXywgXyAtPiBmYWxzZVxuICAgIHwgXywgT2sgXyAtPiBmYWxzZVxuICAgIHwgRXJyb3IgX2FfXzAzN18sIEVycm9yIF9iX18wMzhfIC0+IF9jbXBfX2IgX2FfXzAzN18gX2JfXzAzOF8pXG47O1xuXG5sZXQgaGFzaF9mb2xkX3RcbiAgOiB0eXBlIGEgYi5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGEgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgLT4gKGEsIGIpIHRcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgPVxuICBmdW4gX2hhc2hfZm9sZF9hIF9oYXNoX2ZvbGRfYiBoc3YgYXJnIC0+XG4gIG1hdGNoIGFyZyB3aXRoXG4gIHwgT2sgX2EwIC0+XG4gICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMCBpblxuICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICBfaGFzaF9mb2xkX2EgaHN2IF9hMFxuICB8IEVycm9yIF9hMCAtPlxuICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDEgaW5cbiAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgX2hhc2hfZm9sZF9iIGhzdiBfYTBcbjs7XG5cbltAQEBlbmRdXG5cbmluY2x1ZGUgTW9uYWQuTWFrZTIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICBsZXQgYmluZCB4IH5mID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgICAgfCBPayB4IC0+IGYgeFxuICAgIDs7XG5cbiAgICBsZXQgbWFwIHggfmYgPVxuICAgICAgbWF0Y2ggeCB3aXRoXG4gICAgICB8IEVycm9yIF8gYXMgeCAtPiB4XG4gICAgICB8IE9rIHggLT4gT2sgKGYgeClcbiAgICA7O1xuXG4gICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgbGV0IHJldHVybiB4ID0gT2sgeFxuICBlbmQpXG5cbmxldCBpbnZhcmlhbnQgY2hlY2tfb2sgY2hlY2tfZXJyb3IgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE9rIG9rIC0+IGNoZWNrX29rIG9rXG4gIHwgRXJyb3IgZXJyb3IgLT4gY2hlY2tfZXJyb3IgZXJyb3Jcbjs7XG5cbmxldCBmYWlsIHggPSBFcnJvciB4XG5sZXQgZmFpbGYgZm9ybWF0ID0gUHJpbnRmLmtzcHJpbnRmIGZhaWwgZm9ybWF0XG5cbmxldCBtYXBfZXJyb3IgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE9rIF8gYXMgeCAtPiB4XG4gIHwgRXJyb3IgeCAtPiBFcnJvciAoZiB4KVxuOztcblxubW9kdWxlIEVycm9yID0gTW9uYWQuTWFrZTIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2IsICdhKSB0XG5cbiAgICBsZXQgYmluZCB4IH5mID1cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBPayBfIGFzIG9rIC0+IG9rXG4gICAgICB8IEVycm9yIGUgLT4gZiBlXG4gICAgOztcblxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcF9lcnJvclxuICAgIGxldCByZXR1cm4gZSA9IEVycm9yIGVcbiAgZW5kKVxuXG5sZXQgaXNfb2sgPSBmdW5jdGlvblxuICB8IE9rIF8gLT4gdHJ1ZVxuICB8IEVycm9yIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19lcnJvciA9IGZ1bmN0aW9uXG4gIHwgT2sgXyAtPiBmYWxzZVxuICB8IEVycm9yIF8gLT4gdHJ1ZVxuOztcblxubGV0IG9rID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IFNvbWUgeFxuICB8IEVycm9yIF8gLT4gTm9uZVxuOztcblxubGV0IGVycm9yID0gZnVuY3Rpb25cbiAgfCBPayBfIC0+IE5vbmVcbiAgfCBFcnJvciB4IC0+IFNvbWUgeFxuOztcblxubGV0IG9mX29wdGlvbiBvcHQgfmVycm9yID1cbiAgbWF0Y2ggb3B0IHdpdGhcbiAgfCBTb21lIHggLT4gT2sgeFxuICB8IE5vbmUgLT4gRXJyb3IgZXJyb3Jcbjs7XG5cbmxldCBpdGVyIHYgfmYgPVxuICBtYXRjaCB2IHdpdGhcbiAgfCBPayB4IC0+IGYgeFxuICB8IEVycm9yIF8gLT4gKClcbjs7XG5cbmxldCBpdGVyX2Vycm9yIHYgfmYgPVxuICBtYXRjaCB2IHdpdGhcbiAgfCBPayBfIC0+ICgpXG4gIHwgRXJyb3IgeCAtPiBmIHhcbjs7XG5cbmxldCB0b19laXRoZXIgOiBfIHQgLT4gXyBFaXRoZXIudCA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiBGaXJzdCB4XG4gIHwgRXJyb3IgeCAtPiBTZWNvbmQgeFxuOztcblxubGV0IG9mX2VpdGhlciA6IF8gRWl0aGVyLnQgLT4gXyB0ID0gZnVuY3Rpb25cbiAgfCBGaXJzdCB4IC0+IE9rIHhcbiAgfCBTZWNvbmQgeCAtPiBFcnJvciB4XG47O1xuXG5sZXQgb2tfaWZfdHJ1ZSBib29sIH5lcnJvciA9IGlmIGJvb2wgdGhlbiBPayAoKSBlbHNlIEVycm9yIGVycm9yXG5cbmxldCB0cnlfd2l0aCBmID1cbiAgdHJ5IE9rIChmICgpKSB3aXRoXG4gIHwgZXhuIC0+IEVycm9yIGV4blxuOztcblxubGV0IG9rX2V4biA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3IgZXhuIC0+IHJhaXNlIGV4blxuOztcblxubGV0IG9rX29yX2ZhaWx3aXRoID0gZnVuY3Rpb25cbiAgfCBPayB4IC0+IHhcbiAgfCBFcnJvciBzdHIgLT4gZmFpbHdpdGggc3RyXG47O1xuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgKCdvaywgJ2VycikgX3Jlc3VsdCA9ICgnb2ssICdlcnIpIHQgPVxuICAgIHwgT2sgb2YgJ29rXG4gICAgfCBFcnJvciBvZiAnZXJyXG5cbiAgbGV0IGlzX2Vycm9yID0gaXNfZXJyb3JcbiAgbGV0IGlzX29rID0gaXNfb2tcbmVuZFxuXG5sZXQgY29tYmluZSB0MSB0MiB+b2sgfmVyciA9XG4gIG1hdGNoIHQxLCB0MiB3aXRoXG4gIHwgT2sgXywgRXJyb3IgZSB8IEVycm9yIGUsIE9rIF8gLT4gRXJyb3IgZVxuICB8IE9rIG9rMSwgT2sgb2syIC0+IE9rIChvayBvazEgb2syKVxuICB8IEVycm9yIGVycjEsIEVycm9yIGVycjIgLT4gRXJyb3IgKGVyciBlcnIxIGVycjIpXG47O1xuXG5sZXQgY29tYmluZV9lcnJvcnMgbCA9XG4gIGxldCBvaywgZXJycyA9IExpc3QxLnBhcnRpdGlvbl9tYXAgbCB+Zjp0b19laXRoZXIgaW5cbiAgbWF0Y2ggZXJycyB3aXRoXG4gIHwgW10gLT4gT2sgb2tcbiAgfCBfIDo6IF8gLT4gRXJyb3IgZXJyc1xuOztcblxubGV0IGNvbWJpbmVfZXJyb3JzX3VuaXQgbCA9IG1hcCAoY29tYmluZV9lcnJvcnMgbCkgfmY6KGZ1biAoXyA6IHVuaXQgbGlzdCkgLT4gKCkpXG5cbigqIGRlcHJlY2F0ZWQgYmluZGluZyBmb3IgZXhwb3J0IG9ubHkgKilcbmxldCBva19mc3QgPSB0b19laXRoZXJcbiIsIigqKiBQcm92aWRlcyBnZW5lcmljIHNpZ25hdHVyZXMgZm9yIGNvbnRhaW5lciBkYXRhIHN0cnVjdHVyZXMuXG5cbiAgICBUaGVzZSBzaWduYXR1cmVzIGluY2x1ZGUgZnVuY3Rpb25zIChbaXRlcl0sIFtmb2xkXSwgW2V4aXN0c10sIFtmb3JfYWxsXSwgLi4uKSB0aGF0XG4gICAgeW91IHdvdWxkIGV4cGVjdCB0byBmaW5kIGluIGFueSBjb250YWluZXIuIFVzZWQgYnkgaW5jbHVkaW5nIFtDb250YWluZXIuUzBdIG9yXG4gICAgW0NvbnRhaW5lci5TMV0gaW4gdGhlIHNpZ25hdHVyZSBmb3IgZXZlcnkgY29udGFpbmVyLWxpa2UgZGF0YSBzdHJ1Y3R1cmUgKFtBcnJheV0sXG4gICAgW0xpc3RdLCBbU3RyaW5nXSwgLi4uKSB0byBlbnN1cmUgYSBjb25zaXN0ZW50IGludGVyZmFjZS4gKilcblxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgKCoqIFtDb250aW51ZV9vcl9zdG9wLnRdIGlzIHVzZWQgYnkgdGhlIFtmXSBhcmd1bWVudCB0byBbZm9sZF91bnRpbF0gaW4gb3JkZXIgdG9cbiAgICAgIGluZGljYXRlIHdoZXRoZXIgZm9sZGluZyBzaG91bGQgY29udGludWUsIG9yIHN0b3AgZWFybHkuXG5cbiAgICAgIEBjYW5vbmljYWwgQmFzZS5Db250YWluZXIuQ29udGludWVfb3Jfc3RvcFxuICAqKVxuICBtb2R1bGUgQ29udGludWVfb3Jfc3RvcCA9IHN0cnVjdFxuICAgIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgICB8IENvbnRpbnVlIG9mICdhXG4gICAgICB8IFN0b3Agb2YgJ2JcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSBFeHBvcnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5Db250YWluZXIuU3VtbWFibGUgKilcbm1vZHVsZSB0eXBlIFN1bW1hYmxlID0gc2lnXG4gIHR5cGUgdFxuXG4gICgqKiBUaGUgcmVzdWx0IG9mIHN1bW1pbmcgbm8gdmFsdWVzLiAqKVxuICB2YWwgemVybyA6IHRcblxuICAoKiogQW4gb3BlcmF0aW9uIHRoYXQgY29tYmluZXMgdHdvIFt0XSdzIGFuZCBoYW5kbGVzIFt6ZXJvICsgeF0gYnkganVzdCByZXR1cm5pbmcgW3hdLFxuICAgICAgYXMgd2VsbCBhcyBpbiB0aGUgc3ltbWV0cmljIGNhc2UuICopXG4gIHZhbCAoICsgKSA6IHQgLT4gdCAtPiB0XG5lbmRcblxuKCoqIFNpZ25hdHVyZSBmb3IgbW9ub21vcnBoaWMgY29udGFpbmVyIC0gYSBjb250YWluZXIgZm9yIGEgc3BlY2lmaWMgZWxlbWVudCB0eXBlLCBlLmcuLFxuICAgIHN0cmluZywgd2hpY2ggaXMgYSBjb250YWluZXIgb2YgY2hhcmFjdGVycyAoW3R5cGUgZWx0ID0gY2hhcl0pIGFuZCBuZXZlciBvZiBhbnl0aGluZ1xuICAgIGVsc2UuICopXG5tb2R1bGUgdHlwZSBTMCA9IHNpZ1xuICB0eXBlIHRcbiAgdHlwZSBlbHRcblxuICAoKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVsZW1lbnQgaXMgdGhlcmUsIHVzaW5nIGVxdWFsaXR5IG9uIFtlbHRdcy4gKilcbiAgdmFsIG1lbSA6IHQgLT4gZWx0IC0+IGJvb2xcblxuICB2YWwgbGVuZ3RoIDogdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogdCAtPiBib29sXG5cbiAgKCoqIFtpdGVyXSBtdXN0IGFsbG93IGV4Y2VwdGlvbnMgcmFpc2VkIGluIFtmXSB0byBlc2NhcGUsIHRlcm1pbmF0aW5nIHRoZSBpdGVyYXRpb25cbiAgICAgIGNsZWFubHkuICBUaGUgc2FtZSBob2xkcyBmb3IgYWxsIGZ1bmN0aW9ucyBiZWxvdyB0YWtpbmcgYW4gW2ZdLiAqKVxuICB2YWwgaXRlciA6IHQgLT4gZjooZWx0IC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gcmV0dXJucyBbZiAoLi4uIGYgKGYgKGYgaW5pdCBlMSkgZTIpIGUzIC4uLikgZW5dLCB3aGVyZSBbZTEuLmVuXVxuICAgICAgYXJlIHRoZSBlbGVtZW50cyBvZiBbdF0uICopXG4gIHZhbCBmb2xkIDogdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgKCoqIFtmb2xkX3Jlc3VsdCB0IH5pbml0IH5mXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0gdGhhdCBydW5zIGluIHRoZVxuICAgICAgW1Jlc3VsdF0gbW9uYWQuICBJZiBbZl0gcmV0dXJucyBhbiBbRXJyb3IgX10sIHRoYXQgdmFsdWUgaXMgcmV0dXJuZWQgd2l0aG91dCBhbnlcbiAgICAgIGFkZGl0aW9uYWwgaW52b2NhdGlvbnMgb2YgW2ZdLiAqKVxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgIGlzIGNvbXB1dGVkIGJ5IFtmaW5pc2hdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIG1heWJlX25lZ2F0aXZlID1cbiAgICAgICAgICB8IEZvdW5kX25lZ2F0aXZlIG9mIGludFxuICAgICAgICAgIHwgQWxsX25vbm5lZ2F0aXZlIG9mIHsgc3VtIDogaW50IH1cblxuICAgICAgICAoKiogW2ZpcnN0X25lZ19vcl9zdW0gbGlzdF0gcmV0dXJucyB0aGUgZmlyc3QgbmVnYXRpdmUgbnVtYmVyIGluIFtsaXN0XSwgaWYgYW55LFxuICAgICAgICAgICAgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHN1bSBvZiB0aGUgbGlzdC4gKilcbiAgICAgICAgbGV0IGZpcnN0X25lZ19vcl9zdW0gPVxuICAgICAgICAgIExpc3QuZm9sZF91bnRpbCB+aW5pdDowXG4gICAgICAgICAgICB+ZjooZnVuIHN1bSB4IC0+XG4gICAgICAgICAgICAgIGlmIHggPCAwXG4gICAgICAgICAgICAgIHRoZW4gU3RvcCAoRm91bmRfbmVnYXRpdmUgeClcbiAgICAgICAgICAgICAgZWxzZSBDb250aW51ZSAoc3VtICsgeCkpXG4gICAgICAgICAgICB+ZmluaXNoOihmdW4gc3VtIC0+IEFsbF9ub25uZWdhdGl2ZSB7IHN1bSB9KVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB4ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgMzsgNDsgNV1cbiAgICAgICAgdmFsIHggOiBtYXliZV9uZWdhdGl2ZSA9IEFsbF9ub25uZWdhdGl2ZSB7c3VtID0gMTV9XG5cbiAgICAgICAgbGV0IHkgPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAtMzsgNDsgNV1cbiAgICAgICAgdmFsIHkgOiBtYXliZV9uZWdhdGl2ZSA9IEZvdW5kX25lZ2F0aXZlIC0zXG4gICAgICBdfSAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiBlbHQgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkXG4gICAgICBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdLiBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdIGZvciBhbGxcbiAgICAgIGVsZW1lbnRzLiBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgZm9yIHdoaWNoIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGNvdW50IDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFJldHVybnMgdGhlIHN1bSBvZiBbZiBpXSBmb3IgYWxsIFtpXSBpbiB0aGUgY29udGFpbmVyLiAqKVxuICB2YWwgc3VtIDogKG1vZHVsZSBTdW1tYWJsZSB3aXRoIHR5cGUgdCA9ICdzdW0pIC0+IHQgLT4gZjooZWx0IC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGVsdCBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiB0IC0+IGY6KGVsdCAtPiAnYSBvcHRpb24pIC0+ICdhIG9wdGlvblxuXG4gIHZhbCB0b19saXN0IDogdCAtPiBlbHQgbGlzdFxuICB2YWwgdG9fYXJyYXkgOiB0IC0+IGVsdCBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluIChyZXNwLiBtYXgpIGVsZW1lbnQgZnJvbSB0aGUgY29sbGVjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgW2NvbXBhcmVdXG4gICAgICBmdW5jdGlvbi4gSW4gY2FzZSBvZiBhIHRpZSwgdGhlIGZpcnN0IGVsZW1lbnQgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGVcbiAgICAgIGNvbGxlY3Rpb24gaXMgcmV0dXJuZWQuIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIFtmb2xkXSBzbyBpdCBoYXMgdGhlIHNhbWVcbiAgICAgIGNvbXBsZXhpdHkgYXMgW2ZvbGRdLiBSZXR1cm5zIFtOb25lXSBpZmYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuICopXG4gIHZhbCBtaW5fZWx0IDogdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0IDogdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIFMwX3BoYW50b20gPSBzaWdcbiAgdHlwZSBlbHRcbiAgdHlwZSAnYSB0XG5cbiAgKCoqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbGVtZW50IGlzIHRoZXJlLCB1c2luZyBlcXVhbGl0eSBvbiBbZWx0XXMuICopXG4gIHZhbCBtZW0gOiBfIHQgLT4gZWx0IC0+IGJvb2xcblxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiBfIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6IF8gdCAtPiBmOihlbHQgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSByZXR1cm5zIFtmICguLi4gZiAoZiAoZiBpbml0IGUxKSBlMikgZTMgLi4uKSBlbl0sIHdoZXJlIFtlMS4uZW5dXG4gICAgICBhcmUgdGhlIGVsZW1lbnRzIG9mIFt0XS4gKilcbiAgdmFsIGZvbGQgOiBfIHQgLT4gaW5pdDonYWNjdW0gLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgXyB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gZWx0IC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgIGlzIGNvbXB1dGVkIGJ5IFtmaW5pc2hdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIG1heWJlX25lZ2F0aXZlID1cbiAgICAgICAgICB8IEZvdW5kX25lZ2F0aXZlIG9mIGludFxuICAgICAgICAgIHwgQWxsX25vbm5lZ2F0aXZlIG9mIHsgc3VtIDogaW50IH1cblxuICAgICAgICAoKiogW2ZpcnN0X25lZ19vcl9zdW0gbGlzdF0gcmV0dXJucyB0aGUgZmlyc3QgbmVnYXRpdmUgbnVtYmVyIGluIFtsaXN0XSwgaWYgYW55LFxuICAgICAgICAgICAgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHN1bSBvZiB0aGUgbGlzdC4gKilcbiAgICAgICAgbGV0IGZpcnN0X25lZ19vcl9zdW0gPVxuICAgICAgICAgIExpc3QuZm9sZF91bnRpbCB+aW5pdDowXG4gICAgICAgICAgICB+ZjooZnVuIHN1bSB4IC0+XG4gICAgICAgICAgICAgIGlmIHggPCAwXG4gICAgICAgICAgICAgIHRoZW4gU3RvcCAoRm91bmRfbmVnYXRpdmUgeClcbiAgICAgICAgICAgICAgZWxzZSBDb250aW51ZSAoc3VtICsgeCkpXG4gICAgICAgICAgICB+ZmluaXNoOihmdW4gc3VtIC0+IEFsbF9ub25uZWdhdGl2ZSB7IHN1bSB9KVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB4ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgMzsgNDsgNV1cbiAgICAgICAgdmFsIHggOiBtYXliZV9uZWdhdGl2ZSA9IEFsbF9ub25uZWdhdGl2ZSB7c3VtID0gMTV9XG5cbiAgICAgICAgbGV0IHkgPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAtMzsgNDsgNV1cbiAgICAgICAgdmFsIHkgOiBtYXliZV9uZWdhdGl2ZSA9IEZvdW5kX25lZ2F0aXZlIC0zXG4gICAgICBdfSAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogIF8gdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+IGVsdCAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZXJlIGV4aXN0cyBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgcHJvdmlkZWRcbiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0uICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogXyB0IC0+IGY6KGVsdCAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzdW0gb2YgW2YgaV0gZm9yIGFsbCBbaV0gaW4gdGhlIGNvbnRhaW5lci4gVGhlIG9yZGVyIGluIHdoaWNoIHRoZVxuICAgICAgZWxlbWVudHMgd2lsbCBiZSBzdW1tZWQgaXMgdW5zcGVjaWZpZWQuICopXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gXyB0IC0+IGY6KGVsdCAtPiAnc3VtKSAtPiAnc3VtXG5cbiAgKCoqIFJldHVybnMgYXMgYW4gW29wdGlvbl0gdGhlIGZpcnN0IGVsZW1lbnQgZm9yIHdoaWNoIFtmXSBldmFsdWF0ZXMgdG8gdHJ1ZS4gKilcbiAgdmFsIGZpbmQgOiBfIHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGVsdCBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiBfIHQgLT4gZjooZWx0IC0+ICdhIG9wdGlvbikgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIHRvX2xpc3QgOiBfIHQgLT4gZWx0IGxpc3RcbiAgdmFsIHRvX2FycmF5IDogXyB0IC0+IGVsdCBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluIChyZXNwIG1heCkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBbY29tcGFyZV1cbiAgICAgIGZ1bmN0aW9uLCBvciBbTm9uZV0gaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuICBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgZW5jb3VudGVyZWQgd2hpbGUgdHJhdmVyc2luZyB0aGUgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gKilcbiAgdmFsIG1pbl9lbHQgOiBfIHQgLT4gY29tcGFyZTooZWx0IC0+IGVsdCAtPiBpbnQpIC0+IGVsdCBvcHRpb25cblxuICB2YWwgbWF4X2VsdCA6IF8gdCAtPiBjb21wYXJlOihlbHQgLT4gZWx0IC0+IGludCkgLT4gZWx0IG9wdGlvblxuZW5kXG5cbigqKiBTaWduYXR1cmUgZm9yIHBvbHltb3JwaGljIGNvbnRhaW5lciwgZS5nLiwgWydhIGxpc3RdIG9yIFsnYSBhcnJheV0uICopXG5tb2R1bGUgdHlwZSBTMSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICAoKiogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGVsZW1lbnQgaXMgdGhlcmUsIHVzaW5nIFtlcXVhbF0uICopXG4gIHZhbCBtZW0gOiAnYSB0IC0+ICdhIC0+IGVxdWFsOignYSAtPiAnYSAtPiBib29sKSAtPiBib29sXG5cbiAgdmFsIGxlbmd0aCA6ICdhIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6ICdhIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6ICdhIHQgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBbZm9sZCB0IH5pbml0IH5mXSByZXR1cm5zIFtmICguLi4gZiAoZiAoZiBpbml0IGUxKSBlMikgZTMgLi4uKSBlbl0sIHdoZXJlIFtlMS4uZW5dXG4gICAgICBhcmUgdGhlIGVsZW1lbnRzIG9mIFt0XSAgKilcbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudClcbiAgICAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnRcblxuICAoKiogW2ZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gSWYgW2ZdIG5ldmVyIHJldHVybnMgW1N0b3AgX10sIHRoZSBmaW5hbCByZXN1bHRcbiAgICAgIGlzIGNvbXB1dGVkIGJ5IFtmaW5pc2hdLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIG1heWJlX25lZ2F0aXZlID1cbiAgICAgICAgICB8IEZvdW5kX25lZ2F0aXZlIG9mIGludFxuICAgICAgICAgIHwgQWxsX25vbm5lZ2F0aXZlIG9mIHsgc3VtIDogaW50IH1cblxuICAgICAgICAoKiogW2ZpcnN0X25lZ19vcl9zdW0gbGlzdF0gcmV0dXJucyB0aGUgZmlyc3QgbmVnYXRpdmUgbnVtYmVyIGluIFtsaXN0XSwgaWYgYW55LFxuICAgICAgICAgICAgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHN1bSBvZiB0aGUgbGlzdC4gKilcbiAgICAgICAgbGV0IGZpcnN0X25lZ19vcl9zdW0gPVxuICAgICAgICAgIExpc3QuZm9sZF91bnRpbCB+aW5pdDowXG4gICAgICAgICAgICB+ZjooZnVuIHN1bSB4IC0+XG4gICAgICAgICAgICAgIGlmIHggPCAwXG4gICAgICAgICAgICAgIHRoZW4gU3RvcCAoRm91bmRfbmVnYXRpdmUgeClcbiAgICAgICAgICAgICAgZWxzZSBDb250aW51ZSAoc3VtICsgeCkpXG4gICAgICAgICAgICB+ZmluaXNoOihmdW4gc3VtIC0+IEFsbF9ub25uZWdhdGl2ZSB7IHN1bSB9KVxuICAgICAgICA7O1xuXG4gICAgICAgIGxldCB4ID0gZmlyc3RfbmVnX29yX3N1bSBbMTsgMjsgMzsgNDsgNV1cbiAgICAgICAgdmFsIHggOiBtYXliZV9uZWdhdGl2ZSA9IEFsbF9ub25uZWdhdGl2ZSB7c3VtID0gMTV9XG5cbiAgICAgICAgbGV0IHkgPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAtMzsgNDsgNV1cbiAgICAgICAgdmFsIHkgOiBtYXliZV9uZWdhdGl2ZSA9IEZvdW5kX25lZ2F0aXZlIC0zXG4gICAgICBdfSAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICdhIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2N1bSAtPiAnZmluYWwpXG4gICAgLT4gJ2ZpbmFsXG5cbiAgKCoqIFJldHVybnMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIHRoZXJlIGV4aXN0cyBhbiBlbGVtZW50IGZvciB3aGljaCB0aGUgcHJvdmlkZWRcbiAgICAgIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0uICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBleGlzdHMgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgY291bnQgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGludFxuXG4gICgqKiBSZXR1cm5zIHRoZSBzdW0gb2YgW2YgaV0gZm9yIGFsbCBbaV0gaW4gdGhlIGNvbnRhaW5lci4gKilcbiAgdmFsIHN1bSA6IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKSAtPiAnYSB0IC0+IGY6KCdhIC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIFJldHVybnMgdGhlIGZpcnN0IGV2YWx1YXRpb24gb2YgW2ZdIHRoYXQgcmV0dXJucyBbU29tZV0sIGFuZCByZXR1cm5zIFtOb25lXSBpZiB0aGVyZVxuICAgICAgaXMgbm8gc3VjaCBlbGVtZW50LiAgKilcbiAgdmFsIGZpbmRfbWFwIDogJ2EgdCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICdiIG9wdGlvblxuXG4gIHZhbCB0b19saXN0IDogJ2EgdCAtPiAnYSBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICdhIHQgLT4gJ2EgYXJyYXlcblxuICAoKiogUmV0dXJucyBhIG1pbmltdW0gKHJlc3AgbWF4aW11bSkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZFxuICAgICAgW2NvbXBhcmVdIGZ1bmN0aW9uLCBvciBbTm9uZV0gaWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkuIEluIGNhc2Ugb2YgYSB0aWUsIHRoZSBmaXJzdFxuICAgICAgZWxlbWVudCBlbmNvdW50ZXJlZCB3aGlsZSB0cmF2ZXJzaW5nIHRoZSBjb2xsZWN0aW9uIGlzIHJldHVybmVkLiBUaGUgaW1wbGVtZW50YXRpb25cbiAgICAgIHVzZXMgW2ZvbGRdIHNvIGl0IGhhcyB0aGUgc2FtZSBjb21wbGV4aXR5IGFzIFtmb2xkXS4gKilcbiAgdmFsIG1pbl9lbHQgOiAnYSB0IC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1heF9lbHQgOiAnYSB0IC0+IGNvbXBhcmU6KCdhIC0+ICdhIC0+IGludCkgLT4gJ2Egb3B0aW9uXG5lbmRcblxubW9kdWxlIHR5cGUgUzFfcGhhbnRvbV9pbnZhcmlhbnQgPSBzaWdcbiAgdHlwZSAoJ2EsICdwaGFudG9tKSB0XG5cbiAgKCoqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBlbGVtZW50IGlzIHRoZXJlLCB1c2luZyBbZXF1YWxdLiAqKVxuICB2YWwgbWVtIDogKCdhLCBfKSB0IC0+ICdhIC0+IGVxdWFsOignYSAtPiAnYSAtPiBib29sKSAtPiBib29sXG5cbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBpdGVyIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gcmV0dXJucyBbZiAoLi4uIGYgKGYgKGYgaW5pdCBlMSkgZTIpIGUzIC4uLikgZW5dLCB3aGVyZSBbZTEuLmVuXVxuICAgICAgYXJlIHRoZSBlbGVtZW50cyBvZiBbdF0uICopXG4gIHZhbCBmb2xkIDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgdCB+aW5pdCB+Zl0gaXMgYSBzaG9ydC1jaXJjdWl0aW5nIHZlcnNpb24gb2YgW2ZvbGRdIHRoYXQgcnVucyBpbiB0aGVcbiAgICAgIFtSZXN1bHRdIG1vbmFkLiAgSWYgW2ZdIHJldHVybnMgYW4gW0Vycm9yIF9dLCB0aGF0IHZhbHVlIGlzIHJldHVybmVkIHdpdGhvdXQgYW55XG4gICAgICBhZGRpdGlvbmFsIGludm9jYXRpb25zIG9mIFtmXS4gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2hdIGlzIGEgc2hvcnQtY2lyY3VpdGluZyB2ZXJzaW9uIG9mIFtmb2xkXS4gSWYgW2ZdXG4gICAgICByZXR1cm5zIFtTdG9wIF9dIHRoZSBjb21wdXRhdGlvbiBjZWFzZXMgYW5kIHJlc3VsdHMgaW4gdGhhdCB2YWx1ZS4gSWYgW2ZdIHJldHVybnNcbiAgICAgIFtDb250aW51ZSBfXSwgdGhlIGZvbGQgd2lsbCBwcm9jZWVkLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgdGhlIGZpbmFsIHJlc3VsdFxuICAgICAgaXMgY29tcHV0ZWQgYnkgW2ZpbmlzaF0uXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgbWF5YmVfbmVnYXRpdmUgPVxuICAgICAgICAgIHwgRm91bmRfbmVnYXRpdmUgb2YgaW50XG4gICAgICAgICAgfCBBbGxfbm9ubmVnYXRpdmUgb2YgeyBzdW0gOiBpbnQgfVxuXG4gICAgICAgICgqKiBbZmlyc3RfbmVnX29yX3N1bSBsaXN0XSByZXR1cm5zIHRoZSBmaXJzdCBuZWdhdGl2ZSBudW1iZXIgaW4gW2xpc3RdLCBpZiBhbnksXG4gICAgICAgICAgICBvdGhlcndpc2UgcmV0dXJucyB0aGUgc3VtIG9mIHRoZSBsaXN0LiAqKVxuICAgICAgICBsZXQgZmlyc3RfbmVnX29yX3N1bSA9XG4gICAgICAgICAgTGlzdC5mb2xkX3VudGlsIH5pbml0OjBcbiAgICAgICAgICAgIH5mOihmdW4gc3VtIHggLT5cbiAgICAgICAgICAgICAgaWYgeCA8IDBcbiAgICAgICAgICAgICAgdGhlbiBTdG9wIChGb3VuZF9uZWdhdGl2ZSB4KVxuICAgICAgICAgICAgICBlbHNlIENvbnRpbnVlIChzdW0gKyB4KSlcbiAgICAgICAgICAgIH5maW5pc2g6KGZ1biBzdW0gLT4gQWxsX25vbm5lZ2F0aXZlIHsgc3VtIH0pXG4gICAgICAgIDs7XG5cbiAgICAgICAgbGV0IHggPSBmaXJzdF9uZWdfb3Jfc3VtIFsxOyAyOyAzOyA0OyA1XVxuICAgICAgICB2YWwgeCA6IG1heWJlX25lZ2F0aXZlID0gQWxsX25vbm5lZ2F0aXZlIHtzdW0gPSAxNX1cblxuICAgICAgICBsZXQgeSA9IGZpcnN0X25lZ19vcl9zdW0gWzE7IDI7IC0zOyA0OyA1XVxuICAgICAgICB2YWwgeSA6IG1heWJlX25lZ2F0aXZlID0gRm91bmRfbmVnYXRpdmUgLTNcbiAgICAgIF19ICopXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gICgqKiBSZXR1cm5zIFt0cnVlXSBpZiBhbmQgb25seSBpZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCBmb3Igd2hpY2ggdGhlIHByb3ZpZGVkXG4gICAgICBmdW5jdGlvbiBldmFsdWF0ZXMgdG8gW3RydWVdLiAgVGhpcyBpcyBhIHNob3J0LWNpcmN1aXRpbmcgb3BlcmF0aW9uLiAqKVxuICB2YWwgZXhpc3RzIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0byBbdHJ1ZV0gZm9yIGFsbFxuICAgICAgZWxlbWVudHMuICBUaGlzIGlzIGEgc2hvcnQtY2lyY3VpdGluZyBvcGVyYXRpb24uICopXG4gIHZhbCBmb3JfYWxsIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGZvciB3aGljaCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gZXZhbHVhdGVzIHRvIHRydWUuICopXG4gIHZhbCBjb3VudCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcblxuICAoKiogUmV0dXJucyB0aGUgc3VtIG9mIFtmIGldIGZvciBhbGwgW2ldIGluIHRoZSBjb250YWluZXIuICopXG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gKCdhLCBfKSB0IC0+IGY6KCdhIC0+ICdzdW0pIC0+ICdzdW1cblxuICAoKiogUmV0dXJucyBhcyBhbiBbb3B0aW9uXSB0aGUgZmlyc3QgZWxlbWVudCBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAqKVxuICB2YWwgZmluZCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiBbZl0gdGhhdCByZXR1cm5zIFtTb21lXSwgYW5kIHJldHVybnMgW05vbmVdIGlmIHRoZXJlXG4gICAgICBpcyBubyBzdWNoIGVsZW1lbnQuICAqKVxuICB2YWwgZmluZF9tYXAgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cblxuICB2YWwgdG9fbGlzdCA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICgnYSwgXykgdCAtPiAnYSBhcnJheVxuXG4gICgqKiBSZXR1cm5zIGEgbWluIChyZXNwIG1heCkgZWxlbWVudCBmcm9tIHRoZSBjb2xsZWN0aW9uIHVzaW5nIHRoZSBwcm92aWRlZCBbY29tcGFyZV1cbiAgICAgIGZ1bmN0aW9uLiBJbiBjYXNlIG9mIGEgdGllLCB0aGUgZmlyc3QgZWxlbWVudCBlbmNvdW50ZXJlZCB3aGlsZSB0cmF2ZXJzaW5nIHRoZVxuICAgICAgY29sbGVjdGlvbiBpcyByZXR1cm5lZC4gVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgW2ZvbGRdIHNvIGl0IGhhcyB0aGUgc2FtZSBjb21wbGV4aXR5XG4gICAgICBhcyBbZm9sZF0uIFJldHVybnMgW05vbmVdIGlmZiB0aGUgY29sbGVjdGlvbiBpcyBlbXB0eS4gKilcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBvcHRpb25cblxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvblxuZW5kXG5cbm1vZHVsZSB0eXBlIFMxX3BoYW50b20gPSBzaWdcbiAgdHlwZSAoJ2EsICsncGhhbnRvbSkgdFxuXG4gIGluY2x1ZGUgUzFfcGhhbnRvbV9pbnZhcmlhbnQgd2l0aCB0eXBlICgnYSwgJ3BoYW50b20pIHQgOj0gKCdhLCAncGhhbnRvbSkgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIEdlbmVyaWMgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgZWx0XG5cbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbiAgdmFsIGlzX2VtcHR5IDogXyB0IC0+IGJvb2xcbiAgdmFsIGl0ZXIgOiAnYSB0IC0+IGY6KCdhIGVsdCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBmb2xkIDogJ2EgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICdhY2N1bSkgLT4gJ2FjY3VtXG5cbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2FjY3VtXG4gICAgLT4gZjooJ2FjY3VtIC0+ICdhIGVsdCAtPiAoJ2FjY3VtLCAnZSkgUmVzdWx0LnQpXG4gICAgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50XG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZXhpc3RzIDogJ2EgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbCA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogJ2EgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBzdW0gOiAobW9kdWxlIFN1bW1hYmxlIHdpdGggdHlwZSB0ID0gJ3N1bSkgLT4gJ2EgdCAtPiBmOignYSBlbHQgLT4gJ3N1bSkgLT4gJ3N1bVxuICB2YWwgZmluZCA6ICdhIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIGZpbmRfbWFwIDogJ2EgdCAtPiBmOignYSBlbHQgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cbiAgdmFsIHRvX2xpc3QgOiAnYSB0IC0+ICdhIGVsdCBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICdhIHQgLT4gJ2EgZWx0IGFycmF5XG4gIHZhbCBtaW5fZWx0IDogJ2EgdCAtPiBjb21wYXJlOignYSBlbHQgLT4gJ2EgZWx0IC0+IGludCkgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgbWF4X2VsdCA6ICdhIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBHZW5lcmljX3BoYW50b20gPSBzaWdcbiAgdHlwZSAoJ2EsICdwaGFudG9tKSB0XG4gIHR5cGUgJ2EgZWx0XG5cbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuICB2YWwgaXNfZW1wdHkgOiAoXywgXykgdCAtPiBib29sXG4gIHZhbCBpdGVyIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBmb2xkIDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICB2YWwgZm9sZF9yZXN1bHRcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgZWx0IC0+ICgnYWNjdW0sICdmaW5hbCkgQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2FjY3VtIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZXhpc3RzIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsIDogKCdhLCBfKSB0IC0+IGY6KCdhIGVsdCAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIHN1bVxuICAgIDogIChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKVxuICAgIC0+ICgnYSwgXykgdFxuICAgIC0+IGY6KCdhIGVsdCAtPiAnc3VtKVxuICAgIC0+ICdzdW1cblxuICB2YWwgZmluZCA6ICgnYSwgXykgdCAtPiBmOignYSBlbHQgLT4gYm9vbCkgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgZmluZF9tYXAgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+ICdiIG9wdGlvbikgLT4gJ2Igb3B0aW9uXG4gIHZhbCB0b19saXN0IDogKCdhLCBfKSB0IC0+ICdhIGVsdCBsaXN0XG4gIHZhbCB0b19hcnJheSA6ICgnYSwgXykgdCAtPiAnYSBlbHQgYXJyYXlcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIG1heF9lbHQgOiAoJ2EsIF8pIHQgLT4gY29tcGFyZTooJ2EgZWx0IC0+ICdhIGVsdCAtPiBpbnQpIC0+ICdhIGVsdCBvcHRpb25cbmVuZFxuXG5tb2R1bGUgdHlwZSBNYWtlX2dlbl9hcmcgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgZWx0XG5cbiAgdmFsIGZvbGQgOiAnYSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSBlbHQgLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogVGhlIFtpdGVyXSBhcmd1bWVudCB0byBbQ29udGFpbmVyLk1ha2VdIHNwZWNpZmllcyBob3cgdG8gaW1wbGVtZW50IHRoZVxuICAgICAgY29udGFpbmVyJ3MgW2l0ZXJdIGZ1bmN0aW9uLiAgW2BEZWZpbmVfdXNpbmdfZm9sZF0gbWVhbnMgdG8gZGVmaW5lIFtpdGVyXVxuICAgICAgdmlhOlxuXG4gICAgICB7W1xuICAgICAgICBpdGVyIHQgfmYgPSBDb250YWluZXIuaXRlciB+Zm9sZCB0IH5mXG4gICAgICBdfVxuXG4gICAgICBbYEN1c3RvbV0gb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uLCBwcmVzdW1hYmx5IHdpdGggc29tZXRoaW5nIG1vcmVcbiAgICAgIGVmZmljaWVudC4gIFNldmVyYWwgb3RoZXIgZnVuY3Rpb25zIHJldHVybmVkIGJ5IFtDb250YWluZXIuTWFrZV0gYXJlIGRlZmluZWQgaW5cbiAgICAgIHRlcm1zIG9mIFtpdGVyXSwgc28gcGFzc2luZyBpbiBhIG1vcmUgZWZmaWNpZW50IFtpdGVyXSB3aWxsIGltcHJvdmUgdGhlaXIgZWZmaWNpZW5jeVxuICAgICAgYXMgd2VsbC4gKilcbiAgdmFsIGl0ZXIgOiBbIGBEZWZpbmVfdXNpbmdfZm9sZCB8IGBDdXN0b20gb2YgJ2EgdCAtPiBmOignYSBlbHQgLT4gdW5pdCkgLT4gdW5pdCBdXG5cbiAgKCoqIFRoZSBbbGVuZ3RoXSBhcmd1bWVudCB0byBbQ29udGFpbmVyLk1ha2VdIHNwZWNpZmllcyBob3cgdG8gaW1wbGVtZW50IHRoZVxuICAgICAgY29udGFpbmVyJ3MgW2xlbmd0aF0gZnVuY3Rpb24uICBbYERlZmluZV91c2luZ19mb2xkXSBtZWFucyB0byBkZWZpbmVcbiAgICAgIFtsZW5ndGhdIHZpYTpcblxuICAgICAge1tcbiAgICAgICAgbGVuZ3RoIHQgfmYgPSBDb250YWluZXIubGVuZ3RoIH5mb2xkIHQgfmZcbiAgICAgIF19XG5cbiAgICAgIFtgQ3VzdG9tXSBvdmVycmlkZXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24sIHByZXN1bWFibHkgd2l0aCBzb21ldGhpbmcgbW9yZVxuICAgICAgZWZmaWNpZW50LiAgU2V2ZXJhbCBvdGhlciBmdW5jdGlvbnMgcmV0dXJuZWQgYnkgW0NvbnRhaW5lci5NYWtlXSBhcmUgZGVmaW5lZCBpblxuICAgICAgdGVybXMgb2YgW2xlbmd0aF0sIHNvIHBhc3NpbmcgaW4gYSBtb3JlIGVmZmljaWVudCBbbGVuZ3RoXSB3aWxsIGltcHJvdmUgdGhlaXJcbiAgICAgIGVmZmljaWVuY3kgYXMgd2VsbC4gKilcbiAgdmFsIGxlbmd0aCA6IFsgYERlZmluZV91c2luZ19mb2xkIHwgYEN1c3RvbSBvZiAnYSB0IC0+IGludCBdXG5lbmRcblxubW9kdWxlIHR5cGUgTWFrZV9hcmcgPSBNYWtlX2dlbl9hcmcgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBNb25hZC5JZGVudC50XG5cbm1vZHVsZSB0eXBlIE1ha2UwX2FyZyA9IHNpZ1xuICBtb2R1bGUgRWx0IDogc2lnXG4gICAgdHlwZSB0XG5cbiAgICB2YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuICBlbmRcblxuICB0eXBlIHRcblxuICBpbmNsdWRlIE1ha2VfZ2VuX2FyZyB3aXRoIHR5cGUgJ2EgdCA6PSB0IGFuZCB0eXBlICdhIGVsdCA6PSBFbHQudFxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbnRhaW5lciA9IHNpZ1xuICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgRXhwb3J0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIFMwID0gUzBcbiAgbW9kdWxlIHR5cGUgUzBfcGhhbnRvbSA9IFMwX3BoYW50b21cbiAgbW9kdWxlIHR5cGUgUzEgPSBTMVxuICBtb2R1bGUgdHlwZSBTMV9waGFudG9tX2ludmFyaWFudCA9IFMxX3BoYW50b21faW52YXJpYW50XG4gIG1vZHVsZSB0eXBlIFMxX3BoYW50b20gPSBTMV9waGFudG9tXG4gIG1vZHVsZSB0eXBlIEdlbmVyaWMgPSBHZW5lcmljXG4gIG1vZHVsZSB0eXBlIEdlbmVyaWNfcGhhbnRvbSA9IEdlbmVyaWNfcGhhbnRvbVxuICBtb2R1bGUgdHlwZSBTdW1tYWJsZSA9IFN1bW1hYmxlXG5cbiAgKCoqIEdlbmVyaWMgZGVmaW5pdGlvbnMgb2YgY29udGFpbmVyIG9wZXJhdGlvbnMgaW4gdGVybXMgb2YgW2ZvbGRdLlxuXG4gICAgICBFLmcuOiBbaXRlciB+Zm9sZCB0IH5mID0gZm9sZCB0IH5pbml0OigpIH5mOihmdW4gKCkgYSAtPiBmIGEpXS4gKilcblxuICB0eXBlICgndCwgJ2EsICdhY2N1bSkgZm9sZCA9ICd0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuICB0eXBlICgndCwgJ2EpIGl0ZXIgPSAndCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHR5cGUgJ3QgbGVuZ3RoID0gJ3QgLT4gaW50XG5cbiAgdmFsIGl0ZXIgOiBmb2xkOigndCwgJ2EsIHVuaXQpIGZvbGQgLT4gKCd0LCAnYSkgaXRlclxuICB2YWwgY291bnQgOiBmb2xkOigndCwgJ2EsIGludCkgZm9sZCAtPiAndCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgbWluX2VsdFxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ2Egb3B0aW9uKSBmb2xkXG4gICAgLT4gJ3RcbiAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIG1heF9lbHRcbiAgICA6ICBmb2xkOigndCwgJ2EsICdhIG9wdGlvbikgZm9sZFxuICAgIC0+ICd0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2EgLT4gaW50KVxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBsZW5ndGggOiBmb2xkOigndCwgXywgaW50KSBmb2xkIC0+ICd0IC0+IGludFxuICB2YWwgdG9fbGlzdCA6IGZvbGQ6KCd0LCAnYSwgJ2EgbGlzdCkgZm9sZCAtPiAndCAtPiAnYSBsaXN0XG5cbiAgdmFsIHN1bVxuICAgIDogIGZvbGQ6KCd0LCAnYSwgJ3N1bSkgZm9sZFxuICAgIC0+IChtb2R1bGUgU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKVxuICAgIC0+ICd0XG4gICAgLT4gZjooJ2EgLT4gJ3N1bSlcbiAgICAtPiAnc3VtXG5cbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgZm9sZDooJ3QsICdhLCAnYikgZm9sZFxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOignYiAtPiAnYSAtPiAoJ2IsICdlKSBSZXN1bHQudClcbiAgICAtPiAndFxuICAgIC0+ICgnYiwgJ2UpIFJlc3VsdC50XG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICBmb2xkOigndCwgJ2EsICdiKSBmb2xkXG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+ICdhIC0+ICgnYiwgJ2ZpbmFsKSBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYiAtPiAnZmluYWwpXG4gICAgLT4gJ3RcbiAgICAtPiAnZmluYWxcblxuICAoKiogR2VuZXJpYyBkZWZpbml0aW9ucyBvZiBjb250YWluZXIgb3BlcmF0aW9ucyBpbiB0ZXJtcyBvZiBbaXRlcl0gYW5kIFtsZW5ndGhdLiAqKVxuICB2YWwgaXNfZW1wdHkgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gYm9vbFxuXG4gIHZhbCBleGlzdHMgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbCA6IGl0ZXI6KCd0LCAnYSkgaXRlciAtPiAndCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmaW5kIDogaXRlcjooJ3QsICdhKSBpdGVyIC0+ICd0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvblxuICB2YWwgZmluZF9tYXAgOiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiBvcHRpb25cbiAgdmFsIHRvX2FycmF5IDogbGVuZ3RoOid0IGxlbmd0aCAtPiBpdGVyOigndCwgJ2EpIGl0ZXIgLT4gJ3QgLT4gJ2EgYXJyYXlcblxuICAoKiogVGhlIGlkaW9tIGZvciB1c2luZyBbQ29udGFpbmVyLk1ha2VdIGlzIHRvIGJpbmQgdGhlIHJlc3VsdGluZyBtb2R1bGUgYW5kIHRvXG4gICAgICBleHBsaWNpdGx5IGltcG9ydCBlYWNoIG9mIHRoZSBmdW5jdGlvbnMgdGhhdCBvbmUgd2FudHM6XG5cbiAgICAgIHtbXG4gICAgICAgIG1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKHN0cnVjdCAuLi4gZW5kKVxuICAgICAgICBsZXQgY291bnQgICAgPSBDLmNvdW50XG4gICAgICAgIGxldCBleGlzdHMgICA9IEMuZXhpc3RzXG4gICAgICAgIGxldCBmaW5kICAgICA9IEMuZmluZFxuICAgICAgICAoKiAuLi4gKilcbiAgICAgIF19XG5cbiAgICAgIFRoaXMgaXMgcHJlZmVyYWJsZSB0bzpcblxuICAgICAge1tcbiAgICAgICAgaW5jbHVkZSBDb250YWluZXIuTWFrZSAoc3RydWN0IC4uLiBlbmQpXG4gICAgICBdfVxuXG4gICAgICBiZWNhdXNlIHRoZSBbaW5jbHVkZV0gbWFrZXMgaXQgdG9vIGVhc3kgdG8gc2hhZG93IHNwZWNpYWxpemVkIGltcGxlbWVudGF0aW9ucyBvZlxuICAgICAgY29udGFpbmVyIGZ1bmN0aW9ucyAoW2xlbmd0aF0gYmVpbmcgYSBjb21tb24gb25lKS5cblxuICAgICAgW0NvbnRhaW5lci5NYWtlMF0gaXMgbGlrZSBbQ29udGFpbmVyLk1ha2VdLCBidXQgZm9yIG1vbm9tb3JwaGljIGNvbnRhaW5lcnMgbGlrZVxuICAgICAgW3N0cmluZ10uICopXG4gIG1vZHVsZSBNYWtlIChUIDogTWFrZV9hcmcpIDogUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50XG5cbiAgbW9kdWxlIE1ha2UwIChUIDogTWFrZTBfYXJnKSA6IFMwIHdpdGggdHlwZSB0IDo9IFQudCBhbmQgdHlwZSBlbHQgOj0gVC5FbHQudFxuXG4gIG1vZHVsZSBNYWtlX2dlbiAoVCA6IE1ha2VfZ2VuX2FyZykgOlxuICAgIEdlbmVyaWMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgVC50IGFuZCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBDb250YWluZXJfaW50ZlxuXG5sZXQgd2l0aF9yZXR1cm4gPSBXaXRoX3JldHVybi53aXRoX3JldHVyblxuXG50eXBlICgndCwgJ2EsICdhY2N1bSkgZm9sZCA9ICd0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxudHlwZSAoJ3QsICdhKSBpdGVyID0gJ3QgLT4gZjooJ2EgLT4gdW5pdCkgLT4gdW5pdFxudHlwZSAndCBsZW5ndGggPSAndCAtPiBpbnRcblxubGV0IGl0ZXIgfmZvbGQgdCB+ZiA9IGZvbGQgdCB+aW5pdDooKSB+ZjooZnVuICgpIGEgLT4gZiBhKVxubGV0IGNvdW50IH5mb2xkIHQgfmYgPSBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIG4gYSAtPiBpZiBmIGEgdGhlbiBuICsgMSBlbHNlIG4pXG5cbmxldCBzdW0gKHR5cGUgYSkgfmZvbGQgKG1vZHVsZSBNIDogU3VtbWFibGUgd2l0aCB0eXBlIHQgPSBhKSB0IH5mID1cbiAgZm9sZCB0IH5pbml0Ok0uemVybyB+ZjooZnVuIG4gYSAtPiBNLiggKyApIG4gKGYgYSkpXG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdCA9XG4gIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgIFJlc3VsdC5Pa1xuICAgICAgKGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBpdGVtIC0+XG4gICAgICAgICBtYXRjaCBmIGFjYyBpdGVtIHdpdGhcbiAgICAgICAgIHwgUmVzdWx0Lk9rIHggLT4geFxuICAgICAgICAgfCBFcnJvciBfIGFzIGUgLT4gcmV0dXJuIGUpKSlcbjs7XG5cbmxldCBmb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIH5maW5pc2ggdCA9XG4gIHdpdGhfcmV0dXJuIChmdW4geyByZXR1cm4gfSAtPlxuICAgIGZpbmlzaFxuICAgICAgKGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBpdGVtIC0+XG4gICAgICAgICBtYXRjaCBmIGFjYyBpdGVtIHdpdGhcbiAgICAgICAgIHwgQ29udGludWVfb3Jfc3RvcC5Db250aW51ZSB4IC0+IHhcbiAgICAgICAgIHwgU3RvcCB4IC0+IHJldHVybiB4KSkpXG47O1xuXG5sZXQgbWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlID1cbiAgZm9sZCB0IH5pbml0Ok5vbmUgfmY6KGZ1biBhY2MgZWx0IC0+XG4gICAgbWF0Y2ggYWNjIHdpdGhcbiAgICB8IE5vbmUgLT4gU29tZSBlbHRcbiAgICB8IFNvbWUgbWluIC0+IGlmIGNvbXBhcmUgbWluIGVsdCA+IDAgdGhlbiBTb21lIGVsdCBlbHNlIGFjYylcbjs7XG5cbmxldCBtYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmUgPVxuICBmb2xkIHQgfmluaXQ6Tm9uZSB+ZjooZnVuIGFjYyBlbHQgLT5cbiAgICBtYXRjaCBhY2Mgd2l0aFxuICAgIHwgTm9uZSAtPiBTb21lIGVsdFxuICAgIHwgU29tZSBtYXggLT4gaWYgY29tcGFyZSBtYXggZWx0IDwgMCB0aGVuIFNvbWUgZWx0IGVsc2UgYWNjKVxuOztcblxubGV0IGxlbmd0aCB+Zm9sZCBjID0gZm9sZCBjIH5pbml0OjAgfmY6KGZ1biBhY2MgXyAtPiBhY2MgKyAxKVxuXG5sZXQgaXNfZW1wdHkgfml0ZXIgYyA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIF8gLT4gci5yZXR1cm4gZmFsc2UpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgZXhpc3RzIH5pdGVyIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyIGMgfmY6KGZ1biB4IC0+IGlmIGYgeCB0aGVuIHIucmV0dXJuIHRydWUpO1xuICAgIGZhbHNlKVxuOztcblxubGV0IGZvcl9hbGwgfml0ZXIgYyB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgYyB+ZjooZnVuIHggLT4gaWYgbm90IChmIHgpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgZmluZF9tYXAgfml0ZXIgdCB+ZiA9XG4gIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgdCB+ZjooZnVuIHggLT5cbiAgICAgIG1hdGNoIGYgeCB3aXRoXG4gICAgICB8IE5vbmUgLT4gKClcbiAgICAgIHwgU29tZSBfIGFzIHJlcyAtPiByLnJldHVybiByZXMpO1xuICAgIE5vbmUpXG47O1xuXG5sZXQgZmluZCB+aXRlciBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlciBjIH5mOihmdW4geCAtPiBpZiBmIHggdGhlbiByLnJldHVybiAoU29tZSB4KSk7XG4gICAgTm9uZSlcbjs7XG5cbmxldCB0b19saXN0IH5mb2xkIGMgPSBMaXN0LnJldiAoZm9sZCBjIH5pbml0OltdIH5mOihmdW4gYWNjIHggLT4geCA6OiBhY2MpKVxuXG5sZXQgdG9fYXJyYXkgfmxlbmd0aCB+aXRlciBjID1cbiAgbGV0IGFycmF5ID0gcmVmIFt8fF0gaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICBpdGVyIGMgfmY6KGZ1biB4IC0+XG4gICAgaWYgIWkgPSAwIHRoZW4gYXJyYXkgOj0gQXJyYXkuY3JlYXRlIH5sZW46KGxlbmd0aCBjKSB4O1xuICAgICFhcnJheS4oIWkpIDwtIHg7XG4gICAgaW5jciBpKTtcbiAgIWFycmF5XG47O1xuXG5tb2R1bGUgTWFrZV9nZW4gKFQgOiBNYWtlX2dlbl9hcmcpIDogc2lnXG4gIGluY2x1ZGUgR2VuZXJpYyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnQgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdFxuZW5kID0gc3RydWN0XG4gIGxldCBmb2xkID0gVC5mb2xkXG5cbiAgbGV0IGl0ZXIgPVxuICAgIG1hdGNoIFQuaXRlciB3aXRoXG4gICAgfCBgQ3VzdG9tIGl0ZXIgLT4gaXRlclxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IH5mIC0+IGl0ZXIgfmZvbGQgdCB+ZlxuICA7O1xuXG4gIGxldCBsZW5ndGggPVxuICAgIG1hdGNoIFQubGVuZ3RoIHdpdGhcbiAgICB8IGBDdXN0b20gbGVuZ3RoIC0+IGxlbmd0aFxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IC0+IGxlbmd0aCB+Zm9sZCB0XG4gIDs7XG5cbiAgbGV0IGlzX2VtcHR5IHQgPSBpc19lbXB0eSB+aXRlciB0XG4gIGxldCBzdW0gbSB0ID0gc3VtIH5mb2xkIG0gdFxuICBsZXQgY291bnQgdCB+ZiA9IGNvdW50IH5mb2xkIHQgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gZXhpc3RzIH5pdGVyIHQgfmZcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IGZvcl9hbGwgfml0ZXIgdCB+ZlxuICBsZXQgZmluZF9tYXAgdCB+ZiA9IGZpbmRfbWFwIH5pdGVyIHQgfmZcbiAgbGV0IGZpbmQgdCB+ZiA9IGZpbmQgfml0ZXIgdCB+ZlxuICBsZXQgdG9fbGlzdCB0ID0gdG9fbGlzdCB+Zm9sZCB0XG4gIGxldCB0b19hcnJheSB0ID0gdG9fYXJyYXkgfmxlbmd0aCB+aXRlciB0XG4gIGxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBtaW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbiAgbGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IG1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuICBsZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IGZvbGRfcmVzdWx0IHQgfmZvbGQgfmluaXQgfmZcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiB+ZmluaXNoID0gZm9sZF91bnRpbCB0IH5mb2xkIH5pbml0IH5mIH5maW5pc2hcbmVuZFxuXG5tb2R1bGUgTWFrZSAoVCA6IE1ha2VfYXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2VfZ2VuIChzdHJ1Y3RcbiAgICAgIGluY2x1ZGUgVFxuXG4gICAgICB0eXBlICdhIGVsdCA9ICdhXG4gICAgZW5kKVxuXG4gIGxldCBtZW0gdCBhIH5lcXVhbCA9IGV4aXN0cyB0IH5mOihlcXVhbCBhKVxuZW5kXG5cbm1vZHVsZSBNYWtlMCAoVCA6IE1ha2UwX2FyZykgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAnYSB0ID0gVC50XG4gICAgICB0eXBlICdhIGVsdCA9IFQuRWx0LnRcbiAgICBlbmQpXG5cbiAgbGV0IG1lbSB0IGVsdCA9IGV4aXN0cyB0IH5mOihULkVsdC5lcXVhbCBlbHQpXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBDYW1sLkxhenlcblxudHlwZSAnYSB0ID0gJ2EgbGF6eV90IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCB0X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIHQgPSBsYXp5X3Rfb2Zfc2V4cFxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfbGF6eV90XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGxhenlfdF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hclxuOztcblxuW0BAQGVuZF1cblxubGV0IG1hcCB0IH5mID0gbGF6eSAoZiAoZm9yY2UgdCkpXG5cbmxldCBjb21wYXJlIGNvbXBhcmVfYSB0MSB0MiA9XG4gIGlmIHBoeXNfZXF1YWwgdDEgdDIgdGhlbiAwIGVsc2UgY29tcGFyZV9hIChmb3JjZSB0MSkgKGZvcmNlIHQyKVxuOztcblxubGV0IGVxdWFsIGVxdWFsX2EgdDEgdDIgPSBpZiBwaHlzX2VxdWFsIHQxIHQyIHRoZW4gdHJ1ZSBlbHNlIGVxdWFsX2EgKGZvcmNlIHQxKSAoZm9yY2UgdDIpXG5sZXQgaGFzaF9mb2xkX3QgPSBIYXNoLkJ1aWx0aW4uaGFzaF9mb2xkX2xhenlfdFxuXG5pbmNsdWRlIE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuIHggPSBmcm9tX3ZhbCB4XG4gICAgbGV0IGJpbmQgdCB+ZiA9IGxhenkgKGZvcmNlIChmIChmb3JjZSB0KSkpXG4gICAgbGV0IG1hcCA9IG1hcFxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmQpXG5cbm1vZHVsZSBUX3VuZm9yY2luZyA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIGlmIGlzX3ZhbCB0IHRoZW4gc2V4cF9vZl9hIChmb3JjZSB0KSBlbHNlIHNleHBfb2Zfc3RyaW5nIFwiPHVuZm9yY2VkIGxhenk+XCJcbiAgOztcbmVuZFxuIiwiKCogU3BsaXQgb2ZmIHRvIGF2b2lkIGEgY3ljbGljIGRlcGVuZGVuY3kgd2l0aCBbT3JfZXJyb3JdLiAqKVxuXG5vcGVuISBJbXBvcnRcblxubGV0IGludmFsaWRfYXJnZiA9IFByaW50Zi5pbnZhbGlkX2FyZ2ZcblxubGV0IHNsb3dfY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGggPVxuICBpZiBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTmVnYXRpdmUgcG9zaXRpb246ICVkXCIgcG9zICgpO1xuICBpZiBsZW4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTmVnYXRpdmUgbGVuZ3RoOiAlZFwiIGxlbiAoKTtcbiAgKCogV2UgdXNlIFtwb3MgPiB0b3RhbF9sZW5ndGggLSBsZW5dIHJhdGhlciB0aGFuIFtwb3MgKyBsZW4gPiB0b3RhbF9sZW5ndGhdIHRvIGF2b2lkIHRoZVxuICAgICBwb3NzaWJpbGl0eSBvZiBvdmVyZmxvdy4gKilcbiAgaWYgcG9zID4gdG90YWxfbGVuZ3RoIC0gbGVuXG4gIHRoZW4gaW52YWxpZF9hcmdmIFwicG9zICsgbGVuIHBhc3QgZW5kOiAlZCArICVkID4gJWRcIiBwb3MgbGVuIHRvdGFsX2xlbmd0aCAoKVxuW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBjaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aCA9XG4gICgqIFRoaXMgaXMgYmV0dGVyIHRoYW4gW3Nsb3dfY2hlY2tfcG9zX2xlbl9leG5dIGZvciB0d28gcmVhc29uczpcblxuICAgICAtIG11Y2ggbGVzcyBpbmxpbmVkIGNvZGVcbiAgICAgLSBvbmx5IG9uZSBjb25kaXRpb25hbCBqdW1wXG5cbiAgICAgVGhlIHJlYXNvbiBpdCB3b3JrcyBpcyB0aGF0IGNoZWNraW5nIFs8IDBdIGlzIHRlc3RpbmcgdGhlIGhpZ2hlc3Qgb3JkZXIgYml0LCBzb1xuICAgICBbYSA8IDAgfHwgYiA8IDBdIGlzIHRoZSBzYW1lIGFzIFthIGxvciBiIDwgMF0uXG5cbiAgICAgW3BvcyArIGxlbl0gY2FuIG92ZXJmbG93LCBzbyBbcG9zID4gdG90YWxfbGVuZ3RoIC0gbGVuXSBpcyBub3QgZXF1aXZhbGVudCB0b1xuICAgICBbdG90YWxfbGVuZ3RoIC0gbGVuIC0gcG9zIDwgMF0sIHdlIG5lZWQgdG8gdGVzdCBmb3IgW3BvcyArIGxlbl0gb3ZlcmZsb3cgYXNcbiAgICAgd2VsbC4gKilcbiAgbGV0IHN0b3AgPSBwb3MgKyBsZW4gaW5cbiAgaWYgcG9zIGxvciBsZW4gbG9yIHN0b3AgbG9yICh0b3RhbF9sZW5ndGggLSBzdG9wKSA8IDBcbiAgdGhlbiBzbG93X2NoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoXG47O1xuXG5sZXQgZ2V0X3Bvc19sZW5fZXhuID8ocG9zID0gMCkgP2xlbiAoKSB+dG90YWxfbGVuZ3RoID1cbiAgbGV0IGxlbiA9XG4gICAgbWF0Y2ggbGVuIHdpdGhcbiAgICB8IFNvbWUgaSAtPiBpXG4gICAgfCBOb25lIC0+IHRvdGFsX2xlbmd0aCAtIHBvc1xuICBpblxuICBjaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDtcbiAgcG9zLCBsZW5cbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBzbG93X2NoZWNrX3Bvc19sZW5fZXhuID0gc2xvd19jaGVja19wb3NfbGVuX2V4blxuZW5kXG4iLCJcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuXG5tb2R1bGUgUmVwciA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgc3QgOiBpbnQgYXJyYXlcbiAgICA7IG11dGFibGUgaWR4IDogaW50XG4gICAgfVxuXG4gIGxldCBvZl9zdGF0ZSA6IENhbWwuUmFuZG9tLlN0YXRlLnQgLT4gdCA9IENhbWwuT2JqLm1hZ2ljXG5lbmRcblxubGV0IGFzc2lnbiB0MSB0MiA9XG4gIGxldCB0MSA9IFJlcHIub2Zfc3RhdGUgKExhenkuZm9yY2UgdDEpIGluXG4gIGxldCB0MiA9IFJlcHIub2Zfc3RhdGUgKExhenkuZm9yY2UgdDIpIGluXG4gIEFycmF5LmJsaXQgfnNyYzp0Mi5zdCB+c3JjX3BvczowIH5kc3Q6dDEuc3QgfmRzdF9wb3M6MCB+bGVuOihBcnJheS5sZW5ndGggdDEuc3QpO1xuICB0MS5pZHggPC0gdDIuaWR4XG5cbmxldCBtYWtlX2RlZmF1bHQgZGVmYXVsdCA9IGRlZmF1bHRcblxubGV0W0BpbmxpbmUgYWx3YXlzXSBnZXRfc3RhdGUgc3RhdGUgPSBzdGF0ZVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIENoYXIgPSBDaGFyMFxuXG4oKiBVbmZvcnR1bmF0ZWx5LCBiZWNhdXNlIHRoZSBzdGFuZGFyZCBsaWJyYXJ5IGRvZXMgbm90IGV4cG9zZVxuICAgW0NhbWwuUmFuZG9tLlN0YXRlLmRlZmF1bHRdLCB3ZSBoYXZlIHRvIGNvbnN0cnVjdCBvdXIgb3duLiAgV2UgdGhlbiBidWlsZCB0aGVcbiAgIFtDYW1sLlJhbmRvbS5pbnRdLCBbQ2FtbC5SYW5kb20uYm9vbF0gZnVuY3Rpb25zIGFuZCBmcmllbmRzIHVzaW5nIHRoYXQgZGVmYXVsdCBzdGF0ZSBpblxuICAgZXhhY3RseSB0aGUgc2FtZSB3YXkgYXMgdGhlIHN0YW5kYXJkIGxpYnJhcnkuXG5cbiAgIE9uZSBvdGhlciB0cmlja2luZXNzIGlzIHRoYXQgd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIHVuZXhwb3NlZCBbQ2FtbC5SYW5kb20uU3RhdGUuYXNzaWduXVxuICAgZnVuY3Rpb24sIHdoaWNoIGFjY2Vzc2VzIHRoZSB1bmV4cG9zZWQgc3RhdGUgcmVwcmVzZW50YXRpb24uICBTbywgd2UgY29weSB0aGVcbiAgIFtTdGF0ZS5yZXByXSB0eXBlIGRlZmluaXRpb24gYW5kIFthc3NpZ25dIGZ1bmN0aW9uIHRvIGhlcmUgZnJvbSB0aGUgc3RhbmRhcmQgbGlicmFyeSxcbiAgIGFuZCB1c2UgW09iai5tYWdpY10gdG8gZ2V0IGFjY2VzcyB0byB0aGUgdW5kZXJseWluZyBpbXBsZW1lbnRhdGlvbi4gKilcblxuKCogUmVncmVzc2lvbiB0ZXN0cyBvdWdodCB0byBiZSBkZXRlcm1pbmlzdGljIGJlY2F1c2UgdGhhdCB3YXkgYW55b25lIHdobyBicmVha3MgdGhlIHRlc3RcbiAgIGtub3dzIHRoYXQgaXQncyB0aGVpciBjb2RlIHRoYXQgYnJva2UgdGhlIHRlc3QuICBJZiB0ZXN0cyBhcmUgbm9uZGV0ZXJtaW5pc3RpYywgYSB0ZXN0XG4gICBmYWlsdXJlIG1heSBpbnN0ZWFkIGhhcHBlbiBiZWNhdXNlIHRoZSB0ZXN0IHJ1bm5lciBnb3QgdW5sdWNreSBhbmQgdW5jb3ZlcmVkIGFuXG4gICBleGlzdGluZyBidWcgaW4gdGhlIGNvZGUgc3VwcG9zZWRseSBiZWluZyBcInByb3RlY3RlZFwiIGJ5IHRoZSB0ZXN0IGluIHF1ZXN0aW9uLiAqKVxubGV0IGZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyB+YWxsb3dfaW5fdGVzdHMgPVxuICBpZiBhbV90ZXN0aW5nXG4gIHRoZW4gKFxuICAgIG1hdGNoIGFsbG93X2luX3Rlc3RzIHdpdGhcbiAgICB8IFNvbWUgdHJ1ZSAtPiAoKVxuICAgIHwgTm9uZSB8IFNvbWUgZmFsc2UgLT5cbiAgICAgIGZhaWx3aXRoXG4gICAgICAgIFwiaW5pdGlhbGl6aW5nIFJhbmRvbSB3aXRoIGEgbm9uZGV0ZXJtaW5pc3RpYyBzZWVkIGlzIGZvcmJpZGRlbiBpbiBpbmxpbmUgdGVzdHNcIilcbjs7XG5cbmV4dGVybmFsIHJhbmRvbV9zZWVkIDogdW5pdCAtPiBpbnQgYXJyYXkgPSBcImNhbWxfc3lzX3JhbmRvbV9zZWVkXCJcblxubGV0IHJhbmRvbV9zZWVkID9hbGxvd19pbl90ZXN0cyAoKSA9XG4gIGZvcmJpZF9ub25kZXRlcm1pbmlzbV9pbl90ZXN0cyB+YWxsb3dfaW5fdGVzdHM7XG4gIHJhbmRvbV9zZWVkICgpXG47O1xuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgKCogV2UgYWxsb3cgbGF6aW5lc3Mgb25seSBmb3IgdGhlIGRlZmluaXRpb24gb2YgW2RlZmF1bHRdLCBiZWxvdywgd2hpY2ggbWF5IGxhemlseSBjYWxsXG4gICAgIFttYWtlX3NlbGZfaW5pdF0uIEZvciBhbGwgb3RoZXIgcHVycG9zZXMsIHdlIGNyZWF0ZSBhbmQgdXNlIFt0XSBlYWdlcmx5LiAqKVxuICB0eXBlIHQgPSBDYW1sLlJhbmRvbS5TdGF0ZS50IExhenkudFxuXG4gIGxldCBiaXRzIHQgPSBDYW1sLlJhbmRvbS5TdGF0ZS5iaXRzIChMYXp5LmZvcmNlIHQpXG4gIGxldCBib29sIHQgPSBDYW1sLlJhbmRvbS5TdGF0ZS5ib29sIChMYXp5LmZvcmNlIHQpXG4gIGxldCBpbnQgdCB4ID0gQ2FtbC5SYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHQpIHhcbiAgbGV0IGludDMyIHQgeCA9IENhbWwuUmFuZG9tLlN0YXRlLmludDMyIChMYXp5LmZvcmNlIHQpIHhcbiAgbGV0IGludDY0IHQgeCA9IENhbWwuUmFuZG9tLlN0YXRlLmludDY0IChMYXp5LmZvcmNlIHQpIHhcbiAgbGV0IG5hdGl2ZWludCB0IHggPSBDYW1sLlJhbmRvbS5TdGF0ZS5uYXRpdmVpbnQgKExhenkuZm9yY2UgdCkgeFxuICBsZXQgbWFrZSBzZWVkID0gTGF6eS5mcm9tX3ZhbCAoQ2FtbC5SYW5kb20uU3RhdGUubWFrZSBzZWVkKVxuICBsZXQgY29weSB0ID0gTGF6eS5mcm9tX3ZhbCAoQ2FtbC5SYW5kb20uU3RhdGUuY29weSAoTGF6eS5mb3JjZSB0KSlcbiAgbGV0IGNoYXIgdCA9IGludCB0IDI1NiB8PiBDaGFyLnVuc2FmZV9vZl9pbnRcbiAgbGV0IGFzY2lpIHQgPSBpbnQgdCAxMjggfD4gQ2hhci51bnNhZmVfb2ZfaW50XG5cbiAgbGV0IG1ha2Vfc2VsZl9pbml0ID9hbGxvd19pbl90ZXN0cyAoKSA9XG4gICAgZm9yYmlkX25vbmRldGVybWluaXNtX2luX3Rlc3RzIH5hbGxvd19pbl90ZXN0cztcbiAgICBMYXp5LmZyb21fdmFsIChDYW1sLlJhbmRvbS5TdGF0ZS5tYWtlX3NlbGZfaW5pdCAoKSlcbiAgOztcblxuICBsZXQgYXNzaWduID0gUmFuZG9tX3JlcHIuYXNzaWduXG5cbiAgbGV0IGZ1bGxfaW5pdCB0IHNlZWQgPSBhc3NpZ24gdCAobWFrZSBzZWVkKVxuXG4gIGxldCBkZWZhdWx0ID1cbiAgICBpZiBhbV90ZXN0aW5nXG4gICAgdGhlbiAoXG4gICAgICAoKiBXZSBkZWZpbmUgQmFzZSdzIGRlZmF1bHQgcmFuZG9tIHN0YXRlIGFzIGEgY29weSBvZiBPQ2FtbCdzIGRlZmF1bHQgcmFuZG9tIHN0YXRlLlxuICAgICAgICAgVGhpcyBtZWFucyB0aGF0IHByb2dyYW1zIHRoYXQgdXNlIEJhc2UuUmFuZG9tIHdpbGwgc2VlIHRoZSBzYW1lIHNlcXVlbmNlIG9mXG4gICAgICAgICByYW5kb20gYml0cyBhcyBpZiB0aGV5IGhhZCB1c2VkIENhbWwuUmFuZG9tLiBIb3dldmVyLCBiZWNhdXNlIFtnZXRfc3RhdGVdIHJldHVybnNcbiAgICAgICAgIGEgY29weSwgQmFzZS5SYW5kb20gYW5kIE9DYW1sLlJhbmRvbSBhcmUgbm90IHVzaW5nIHRoZSBzYW1lIHN0YXRlLiBJZiBhIHByb2dyYW1cbiAgICAgICAgIHVzZWQgYm90aCwgZWFjaCBvZiB0aGVtIHdvdWxkIGdvIHRocm91Z2ggdGhlIHNhbWUgc2VxdWVuY2Ugb2YgcmFuZG9tIGJpdHMuIFRvXG4gICAgICAgICBhdm9pZCB0aGF0LCB3ZSByZXNldCBPQ2FtbCdzIHJhbmRvbSBzdGF0ZSB0byBhIGRpZmZlcmVudCBzZWVkLCBnaXZpbmcgaXQgYVxuICAgICAgICAgZGlmZmVyZW50IHNlcXVlbmNlLiAqKVxuICAgICAgbGV0IHQgPSBDYW1sLlJhbmRvbS5nZXRfc3RhdGUgKCkgaW5cbiAgICAgIENhbWwuUmFuZG9tLmluaXQgMTM3O1xuICAgICAgTGF6eS5mcm9tX3ZhbCB0KVxuICAgIGVsc2VcbiAgICAgIGxhenlcbiAgICAgICAgKCogT3V0c2lkZSBvZiB0ZXN0cywgd2UgaW5pdGlhbGl6ZSByYW5kb20gc3RhdGUgbm9uZGV0ZXJtaW5pc3RpY2FsbHkgYW5kIGxhemlseS5cbiAgICAgICAgICAgV2UgZm9yY2UgdGhlIHJhbmRvbSBpbml0aWFsaXphdGlvbiB0byBiZSBsYXp5IHNvIHRoYXQgd2UgZG8gbm90IHBheSBhbnkgY29zdFxuICAgICAgICAgICBmb3IgaXQgaW4gcHJvZ3JhbXMgdGhhdCBkbyBub3QgdXNlIHJhbmRvbW5lc3MuICopXG4gICAgICAgIChMYXp5LmZvcmNlIChtYWtlX3NlbGZfaW5pdCAoKSkpXG4gIDs7XG5cbiAgbGV0IGludF9vbl82NGJpdHMgdCBib3VuZCA9XG4gICAgaWYgYm91bmQgPD0gMHgzRkZGRkZGRiAoKiAoMSBsc2wgMzApIC0gMSAqKVxuICAgIHRoZW4gaW50IHQgYm91bmRcbiAgICBlbHNlIENhbWwuSW50NjQudG9faW50IChpbnQ2NCB0IChDYW1sLkludDY0Lm9mX2ludCBib3VuZCkpXG4gIDs7XG5cbiAgbGV0IGludF9vbl8zMmJpdHMgdCBib3VuZCA9XG4gICAgKCogTm90IGFsd2F5cyB0cnVlIHdpdGggdGhlIEphdmFTY3JpcHQgYmFja2VuZC4gKilcbiAgICBpZiBib3VuZCA8PSAweDNGRkZGRkZGICgqICgxIGxzbCAzMCkgLSAxICopXG4gICAgdGhlbiBpbnQgdCBib3VuZFxuICAgIGVsc2UgQ2FtbC5JbnQzMi50b19pbnQgKGludDMyIHQgKENhbWwuSW50MzIub2ZfaW50IGJvdW5kKSlcbiAgOztcblxuICBsZXQgaW50ID1cbiAgICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICB8IFc2NCAtPiBpbnRfb25fNjRiaXRzXG4gICAgfCBXMzIgLT4gaW50X29uXzMyYml0c1xuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludDY0ID1cbiAgICBsZXQgb3BlbiBDYW1sLkludDY0IGluXG4gICAgbGV0IGJpdHMgc3RhdGUgPSBvZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgZnVuIHN0YXRlIC0+XG4gICAgICBsb2d4b3JcbiAgICAgICAgKGJpdHMgc3RhdGUpXG4gICAgICAgIChsb2d4b3IgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDMwKSAoc2hpZnRfbGVmdCAoYml0cyBzdGF0ZSkgNjApKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludDMyID1cbiAgICBsZXQgb3BlbiBDYW1sLkludDMyIGluXG4gICAgbGV0IGJpdHMgc3RhdGUgPSBvZl9pbnQgKGJpdHMgc3RhdGUpIGluXG4gICAgZnVuIHN0YXRlIC0+IGxvZ3hvciAoYml0cyBzdGF0ZSkgKHNoaWZ0X2xlZnQgKGJpdHMgc3RhdGUpIDMwKVxuICA7O1xuXG4gIGxldCBmdWxsX3JhbmdlX2ludF9vbl82NGJpdHMgc3RhdGUgPSBDYW1sLkludDY0LnRvX2ludCAoZnVsbF9yYW5nZV9pbnQ2NCBzdGF0ZSlcbiAgbGV0IGZ1bGxfcmFuZ2VfaW50X29uXzMyYml0cyBzdGF0ZSA9IENhbWwuSW50MzIudG9faW50IChmdWxsX3JhbmdlX2ludDMyIHN0YXRlKVxuXG4gIGxldCBmdWxsX3JhbmdlX2ludCA9XG4gICAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gICAgfCBXNjQgLT4gZnVsbF9yYW5nZV9pbnRfb25fNjRiaXRzXG4gICAgfCBXMzIgLT4gZnVsbF9yYW5nZV9pbnRfb25fMzJiaXRzXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzY0Yml0cyBzdGF0ZSA9XG4gICAgQ2FtbC5JbnQ2NC50b19uYXRpdmVpbnQgKGZ1bGxfcmFuZ2VfaW50NjQgc3RhdGUpXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50X29uXzMyYml0cyBzdGF0ZSA9XG4gICAgQ2FtbC5OYXRpdmVpbnQub2ZfaW50MzIgKGZ1bGxfcmFuZ2VfaW50MzIgc3RhdGUpXG4gIDs7XG5cbiAgbGV0IGZ1bGxfcmFuZ2VfbmF0aXZlaW50ID1cbiAgICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgICB8IFc2NCAtPiBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl82NGJpdHNcbiAgICB8IFczMiAtPiBmdWxsX3JhbmdlX25hdGl2ZWludF9vbl8zMmJpdHNcbiAgOztcblxuICBsZXQgcmFpc2VfY3Jvc3NlZF9ib3VuZHMgbmFtZSBsb3dlcl9ib3VuZCB1cHBlcl9ib3VuZCBzdHJpbmdfb2ZfYm91bmQgPVxuICAgIFByaW50Zi5mYWlsd2l0aGZcbiAgICAgIFwiUmFuZG9tLiVzOiBjcm9zc2VkIGJvdW5kcyBbJXMgPiAlc11cIlxuICAgICAgbmFtZVxuICAgICAgKHN0cmluZ19vZl9ib3VuZCBsb3dlcl9ib3VuZClcbiAgICAgIChzdHJpbmdfb2ZfYm91bmQgdXBwZXJfYm91bmQpXG4gICAgICAoKVxuICBbQEBjb2xkXSBbQEBpbmxpbmUgbmV2ZXJdIFtAQGxvY2FsIG5ldmVyXSBbQEBzcGVjaWFsaXNlIG5ldmVyXVxuICA7O1xuXG4gIGxldCBpbnRfaW5jbCA9XG4gICAgbGV0IHJlYyBpbl9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgICBsZXQgaW50ID0gZnVsbF9yYW5nZV9pbnQgc3RhdGUgaW5cbiAgICAgIGlmIGludCA+PSBsbyAmJiBpbnQgPD0gaGkgdGhlbiBpbnQgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICAgIGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJpbnRcIiBsbyBoaSBJbnQudG9fc3RyaW5nO1xuICAgICAgbGV0IGRpZmYgPSBoaSAtIGxvIGluXG4gICAgICBpZiBkaWZmID0gSW50Lm1heF92YWx1ZVxuICAgICAgdGhlbiBsbyArIChmdWxsX3JhbmdlX2ludCBzdGF0ZSBsYW5kIEludC5tYXhfdmFsdWUpXG4gICAgICBlbHNlIGlmIGRpZmYgPj0gMFxuICAgICAgdGhlbiBsbyArIGludCBzdGF0ZSAoSW50LnN1Y2MgZGlmZilcbiAgICAgIGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgOztcblxuICBsZXQgaW50MzJfaW5jbCA9XG4gICAgbGV0IG9wZW4gSW50MzJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHJlYyBpbl9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgICBsZXQgaW50ID0gZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSBpblxuICAgICAgaWYgaW50ID49IGxvICYmIGludCA8PSBoaSB0aGVuIGludCBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gICAgaW5cbiAgICBsZXQgb3BlbiBDYW1sLkludDMyIGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJpbnQzMlwiIGxvIGhpIHRvX3N0cmluZztcbiAgICAgIGxldCBkaWZmID0gc3ViIGhpIGxvIGluXG4gICAgICBpZiBkaWZmID0gbWF4X2ludFxuICAgICAgdGhlbiBhZGQgbG8gKGxvZ2FuZCAoZnVsbF9yYW5nZV9pbnQzMiBzdGF0ZSkgbWF4X2ludClcbiAgICAgIGVsc2UgaWYgZGlmZiA+PSAwbFxuICAgICAgdGhlbiBhZGQgbG8gKGludDMyIHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBuYXRpdmVpbnRfaW5jbCA9XG4gICAgbGV0IG9wZW4gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCByZWMgaW5fcmFuZ2Ugc3RhdGUgbG8gaGkgPVxuICAgICAgbGV0IGludCA9IGZ1bGxfcmFuZ2VfbmF0aXZlaW50IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIENhbWwuTmF0aXZlaW50IGluXG4gICAgZnVuIHN0YXRlIGxvIGhpIC0+XG4gICAgICBpZiBsbyA+IGhpIHRoZW4gcmFpc2VfY3Jvc3NlZF9ib3VuZHMgXCJuYXRpdmVpbnRcIiBsbyBoaSB0b19zdHJpbmc7XG4gICAgICBsZXQgZGlmZiA9IHN1YiBoaSBsbyBpblxuICAgICAgaWYgZGlmZiA9IG1heF9pbnRcbiAgICAgIHRoZW4gYWRkIGxvIChsb2dhbmQgKGZ1bGxfcmFuZ2VfbmF0aXZlaW50IHN0YXRlKSBtYXhfaW50KVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBuXG4gICAgICB0aGVuIGFkZCBsbyAobmF0aXZlaW50IHN0YXRlIChzdWNjIGRpZmYpKVxuICAgICAgZWxzZSBpbl9yYW5nZSBzdGF0ZSBsbyBoaVxuICA7O1xuXG4gIGxldCBpbnQ2NF9pbmNsID1cbiAgICBsZXQgb3BlbiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgICBsZXQgcmVjIGluX3JhbmdlIHN0YXRlIGxvIGhpID1cbiAgICAgIGxldCBpbnQgPSBmdWxsX3JhbmdlX2ludDY0IHN0YXRlIGluXG4gICAgICBpZiBpbnQgPj0gbG8gJiYgaW50IDw9IGhpIHRoZW4gaW50IGVsc2UgaW5fcmFuZ2Ugc3RhdGUgbG8gaGlcbiAgICBpblxuICAgIGxldCBvcGVuIENhbWwuSW50NjQgaW5cbiAgICBmdW4gc3RhdGUgbG8gaGkgLT5cbiAgICAgIGlmIGxvID4gaGkgdGhlbiByYWlzZV9jcm9zc2VkX2JvdW5kcyBcImludDY0XCIgbG8gaGkgdG9fc3RyaW5nO1xuICAgICAgbGV0IGRpZmYgPSBzdWIgaGkgbG8gaW5cbiAgICAgIGlmIGRpZmYgPSBtYXhfaW50XG4gICAgICB0aGVuIGFkZCBsbyAobG9nYW5kIChmdWxsX3JhbmdlX2ludDY0IHN0YXRlKSBtYXhfaW50KVxuICAgICAgZWxzZSBpZiBkaWZmID49IDBMXG4gICAgICB0aGVuIGFkZCBsbyAoaW50NjQgc3RhdGUgKHN1Y2MgZGlmZikpXG4gICAgICBlbHNlIGluX3JhbmdlIHN0YXRlIGxvIGhpXG4gIDs7XG5cbiAgKCogUmV0dXJuIGEgdW5pZm9ybWx5IHJhbmRvbSBmbG9hdCBpbiBbMCwgMSkuICopXG4gIGxldCByZWMgcmF3ZmxvYXQgc3RhdGUgPVxuICAgIGxldCBvcGVuIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBpblxuICAgIGxldCBzY2FsZSA9IDB4MXAtMzAgaW5cbiAgICAoKiAyXi0zMCAqKVxuICAgIGxldCByMSA9IENhbWwuZmxvYXRfb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGxldCByMiA9IENhbWwuZmxvYXRfb2ZfaW50IChiaXRzIHN0YXRlKSBpblxuICAgIGxldCByZXN1bHQgPSAoKHIxICouIHNjYWxlKSArLiByMikgKi4gc2NhbGUgaW5cbiAgICAoKiBXaXRoIHZlcnkgc21hbGwgcHJvYmFiaWxpdHksIHJlc3VsdCBjYW4gcm91bmQgdXAgdG8gMS4wLCBzbyBpbiB0aGF0IGNhc2UsIHdlIGp1c3RcbiAgICAgICB0cnkgYWdhaW4uICopXG4gICAgaWYgcmVzdWx0IDwgMS4wIHRoZW4gcmVzdWx0IGVsc2UgcmF3ZmxvYXQgc3RhdGVcbiAgOztcblxuICBsZXQgZmxvYXQgc3RhdGUgaGkgPSByYXdmbG9hdCBzdGF0ZSAqLiBoaVxuXG4gIGxldCBmbG9hdF9yYW5nZSBzdGF0ZSBsbyBoaSA9XG4gICAgbGV0IG9wZW4gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgaWYgbG8gPiBoaSB0aGVuIHJhaXNlX2Nyb3NzZWRfYm91bmRzIFwiZmxvYXRcIiBsbyBoaSBDYW1sLnN0cmluZ19vZl9mbG9hdDtcbiAgICBsbyArLiBmbG9hdCBzdGF0ZSAoaGkgLS4gbG8pXG4gIDs7XG5lbmRcblxubGV0IGRlZmF1bHQgPSBSYW5kb21fcmVwci5tYWtlX2RlZmF1bHQgU3RhdGUuZGVmYXVsdFxuXG5sZXQgYml0cyAoKSA9IFN0YXRlLmJpdHMgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KVxubGV0IGludCB4ID0gU3RhdGUuaW50IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeFxubGV0IGludDMyIHggPSBTdGF0ZS5pbnQzMiAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBuYXRpdmVpbnQgeCA9IFN0YXRlLm5hdGl2ZWludCAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHhcbmxldCBpbnQ2NCB4ID0gU3RhdGUuaW50NjQgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4XG5sZXQgZmxvYXQgeCA9IFN0YXRlLmZsb2F0IChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeFxubGV0IGludF9pbmNsIHggeSA9IFN0YXRlLmludF9pbmNsIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgaW50MzJfaW5jbCB4IHkgPSBTdGF0ZS5pbnQzMl9pbmNsIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdCkgeCB5XG5sZXQgbmF0aXZlaW50X2luY2wgeCB5ID0gU3RhdGUubmF0aXZlaW50X2luY2wgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4IHlcbmxldCBpbnQ2NF9pbmNsIHggeSA9IFN0YXRlLmludDY0X2luY2wgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSB4IHlcbmxldCBmbG9hdF9yYW5nZSB4IHkgPSBTdGF0ZS5mbG9hdF9yYW5nZSAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpIHggeVxubGV0IGJvb2wgKCkgPSBTdGF0ZS5ib29sIChSYW5kb21fcmVwci5nZXRfc3RhdGUgZGVmYXVsdClcbmxldCBjaGFyICgpID0gU3RhdGUuY2hhciAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpXG5sZXQgYXNjaWkgKCkgPSBTdGF0ZS5hc2NpaSAoUmFuZG9tX3JlcHIuZ2V0X3N0YXRlIGRlZmF1bHQpXG5sZXQgZnVsbF9pbml0IHNlZWQgPSBTdGF0ZS5mdWxsX2luaXQgKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSBzZWVkXG5sZXQgaW5pdCBzZWVkID0gZnVsbF9pbml0IFt8IHNlZWQgfF1cbmxldCBzZWxmX2luaXQgP2FsbG93X2luX3Rlc3RzICgpID0gZnVsbF9pbml0IChyYW5kb21fc2VlZCA/YWxsb3dfaW5fdGVzdHMgKCkpXG5sZXQgc2V0X3N0YXRlIHMgPSBTdGF0ZS5hc3NpZ24gKFJhbmRvbV9yZXByLmdldF9zdGF0ZSBkZWZhdWx0KSBzXG4iLCIoKiogQW4gaW50ZXJuYWwtb25seSBtb2R1bGUgZmFjdG9yZWQgb3V0IGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgYmV0d2VlbiBjb3JlX2FycmF5XG4gICAgYW5kIGNvcmVfbGlzdC4gIENvbnRhaW5zIGNvZGUgZm9yIHBlcm11dGluZyBhbiBhcnJheS4gKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFycmF5MFxuXG5sZXQgcGVybXV0ZSA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSA/KHBvcyA9IDApID9sZW4gdCA9XG4gICgqIENvcGllZCBmcm9tIFtPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uMF0gdG8gYXZvaWQgYWxsb2NhdGluZyBhIHR1cGxlIHdoZW4gY29tcGlsaW5nXG4gICAgIHdpdGhvdXQgZmxhbWJkYS4gKilcbiAgbGV0IHRvdGFsX2xlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBTb21lIGwgLT4gbFxuICAgIHwgTm9uZSAtPiB0b3RhbF9sZW5ndGggLSBwb3NcbiAgaW5cbiAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjAuY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg7XG4gIGxldCBudW1fc3dhcHMgPSBsZW4gLSAxIGluXG4gIGZvciBpID0gbnVtX3N3YXBzIGRvd250byAxIGRvXG4gICAgbGV0IHRoaXNfaSA9IHBvcyArIGkgaW5cbiAgICAoKiBbcmFuZG9tX2ldIGlzIGRyYXduIGZyb20gW3Bvcyx0aGlzX2ldICopXG4gICAgbGV0IHJhbmRvbV9pID0gcG9zICsgUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKGkgKyAxKSBpblxuICAgIHN3YXAgdCB0aGlzX2kgcmFuZG9tX2lcbiAgZG9uZVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgY29uc3QgYyBfID0gY1xuXG5leHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuXG4oKiB0aGlzIGhhcyB0aGUgc2FtZSBiZWhhdmlvciBhcyBbQ2FtbC5pZ25vcmVdICopXG5cbmxldCBub24gZiB4ID0gbm90IChmIHgpXG5cbmxldCBmb3JldmVyIGYgPVxuICBsZXQgcmVjIGZvcmV2ZXIgKCkgPVxuICAgIGYgKCk7XG4gICAgZm9yZXZlciAoKVxuICBpblxuICB0cnkgZm9yZXZlciAoKSB3aXRoXG4gIHwgZSAtPiBlXG47O1xuXG5leHRlcm5hbCBpZCA6ICdhIC0+ICdhID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgKCB8PiApIDogJ2EgLT4gKCdhIC0+ICdiKSAtPiAnYiA9IFwiJXJldmFwcGx5XCJcblxuKCogVGhlIHR5cGljYWwgdXNlIGNhc2UgZm9yIHRoZXNlIGZ1bmN0aW9ucyBpcyB0byBwYXNzIGluIGZ1bmN0aW9uYWwgYXJndW1lbnRzIGFuZCBnZXRcbiAgIGZ1bmN0aW9ucyBhcyBhIHJlc3VsdC4gKilcbmxldCBjb21wb3NlIGYgZyB4ID0gZiAoZyB4KVxubGV0IGZsaXAgZiB4IHkgPSBmIHkgeFxubGV0IHJlYyBhcHBseV9uX3RpbWVzIH5uIGYgeCA9IGlmIG4gPD0gMCB0aGVuIHggZWxzZSBhcHBseV9uX3RpbWVzIH5uOihuIC0gMSkgZiAoZiB4KVxuIiwib3BlbiEgSW1wb3J0XG5cbnR5cGUgdCA9XG4gIHwgTGVzc1xuICB8IEVxdWFsXG4gIHwgR3JlYXRlclxuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIGVudW1lcmF0ZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZSA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG5cbmxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgIHwgTGVzcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDBcbiAgICAgfCBFcXVhbCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDFcbiAgICAgfCBHcmVhdGVyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMlxuICAgICAgICAgICAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG47O1xuXG5sZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbmxldCBhbGwgPSAoWyBMZXNzOyBFcXVhbDsgR3JlYXRlciBdIDogdCBsaXN0KVxuXG5sZXQgdF9vZl9zZXhwID1cbiAgKGxldCBlcnJvcl9zb3VyY2VfXzAwNV8gPSBcIm9yZGVyaW5nLm1sLnRcIiBpblxuICAgZnVuY3Rpb25cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImxlc3NcIiB8IFwiTGVzc1wiKSAtPiBMZXNzXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcXVhbFwiIHwgXCJFcXVhbFwiKSAtPiBFcXVhbFxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZ3JlYXRlclwiIHwgXCJHcmVhdGVyXCIpIC0+IEdyZWF0ZXJcbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibGVzc1wiIHwgXCJMZXNzXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJlcXVhbFwiIHwgXCJFcXVhbFwiKSA6OiBfKSBhcyBzZXhwX18wMDZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDVfIHNleHBfXzAwNl9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiZ3JlYXRlclwiIHwgXCJHcmVhdGVyXCIpIDo6IF8pIGFzIHNleHBfXzAwNl8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA1XyBzZXhwX18wMDRfXG4gICB8IHNleHBfXzAwNF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNV8gc2V4cF9fMDA0X1xuICAgICAgICAgICAgICAgICAgIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG47O1xuXG5sZXQgc2V4cF9vZl90ID1cbiAgKGZ1bmN0aW9uXG4gICAgfCBMZXNzIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkxlc3NcIlxuICAgIHwgRXF1YWwgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXF1YWxcIlxuICAgIHwgR3JlYXRlciAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJHcmVhdGVyXCJcbiAgICAgICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTGVzc1wiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiRXF1YWxcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkdyZWF0ZXJcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxuW0BAQGVuZF1cblxubGV0IGVxdWFsIGEgYiA9IGNvbXBhcmUgYSBiID0gMFxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgX29yZGVyaW5nID0gdCA9XG4gICAgfCBMZXNzXG4gICAgfCBFcXVhbFxuICAgIHwgR3JlYXRlclxuZW5kXG5cbmxldCBvZl9pbnQgbiA9IGlmIG4gPCAwIHRoZW4gTGVzcyBlbHNlIGlmIG4gPSAwIHRoZW4gRXF1YWwgZWxzZSBHcmVhdGVyXG5cbmxldCB0b19pbnQgPSBmdW5jdGlvblxuICB8IExlc3MgLT4gLTFcbiAgfCBFcXVhbCAtPiAwXG4gIHwgR3JlYXRlciAtPiAxXG47O1xuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbm1vZHVsZSBFaXRoZXIgPSBFaXRoZXIwXG5cblxuaW5jbHVkZSBMaXN0MVxuXG4oKiBUaGlzIGl0c2VsZiBpbmNsdWRlcyBbTGlzdDBdLiAqKVxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBsaXN0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IGxpc3Rfb2Zfc2V4cFxuICBsZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID0gc2V4cF9vZl9saXN0XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBsaXN0X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgT3JfdW5lcXVhbF9sZW5ndGhzID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBPayBvZiAnYVxuICAgIHwgVW5lcXVhbF9sZW5ndGhzXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gIGxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICAgIGZ1biBfY21wX19hIGFfXzAwNl8gYl9fMDA3XyAtPlxuICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwNl8gYl9fMDA3X1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDA2XywgYl9fMDA3XyB3aXRoXG4gICAgICB8IE9rIF9hX18wMDhfLCBPayBfYl9fMDA5XyAtPiBfY21wX19hIF9hX18wMDhfIF9iX18wMDlfXG4gICAgICB8IE9rIF8sIF8gLT4gLTFcbiAgICAgIHwgXywgT2sgXyAtPiAxXG4gICAgICB8IFVuZXF1YWxfbGVuZ3RocywgVW5lcXVhbF9sZW5ndGhzIC0+IDApXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgZnVuICh0eXBlIGFfXzAxM18pIDogKChhX18wMTNfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gYV9fMDEzXyB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAxMF8gLT4gZnVuY3Rpb25cbiAgICAgIHwgT2sgYXJnMF9fMDExXyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDEyXyA9IF9vZl9hX18wMTBfIGFyZzBfXzAxMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2tcIjsgcmVzMF9fMDEyXyBdXG4gICAgICB8IFVuZXF1YWxfbGVuZ3RocyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmVxdWFsX2xlbmd0aHNcIlxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxuaW5jbHVkZSBUXG5cbmxldCBpbnZhcmlhbnQgZiB0ID0gaXRlciB0IH5mXG5sZXQgb2ZfbGlzdCB0ID0gdFxuXG5sZXQgcmFuZ2UnIH5jb21wYXJlIH5zdHJpZGUgPyhzdGFydCA9IGBpbmNsdXNpdmUpID8oc3RvcCA9IGBleGNsdXNpdmUpIHN0YXJ0X2kgc3RvcF9pID1cbiAgbGV0IG5leHRfaSA9IHN0cmlkZSBzdGFydF9pIGluXG4gIGxldCBvcmRlciB4IHkgPSBPcmRlcmluZy5vZl9pbnQgKGNvbXBhcmUgeCB5KSBpblxuICBsZXQgcmFpc2Vfc3RyaWRlX2Nhbm5vdF9yZXR1cm5fc2FtZV92YWx1ZSAoKSA9XG4gICAgaW52YWxpZF9hcmcgXCJMaXN0LnJhbmdlJzogc3RyaWRlIGZ1bmN0aW9uIGNhbm5vdCByZXR1cm4gdGhlIHNhbWUgdmFsdWVcIlxuICBpblxuICBsZXQgaW5pdGlhbF9zdHJpZGVfb3JkZXIgPVxuICAgIG1hdGNoIG9yZGVyIHN0YXJ0X2kgbmV4dF9pIHdpdGhcbiAgICB8IEVxdWFsIC0+IHJhaXNlX3N0cmlkZV9jYW5ub3RfcmV0dXJuX3NhbWVfdmFsdWUgKClcbiAgICB8IExlc3MgLT4gYExlc3NcbiAgICB8IEdyZWF0ZXIgLT4gYEdyZWF0ZXJcbiAgaW5cbiAgbGV0IHJlYyBsb29wIGkgYWNjdW0gPVxuICAgIGxldCBpX3RvX3N0b3Bfb3JkZXIgPSBvcmRlciBpIHN0b3BfaSBpblxuICAgIG1hdGNoIGlfdG9fc3RvcF9vcmRlciwgaW5pdGlhbF9zdHJpZGVfb3JkZXIgd2l0aFxuICAgIHwgTGVzcywgYExlc3MgfCBHcmVhdGVyLCBgR3JlYXRlciAtPlxuICAgICAgKCogaGF2ZW4ndCB5ZXQgcmVhY2hlZCBbc3RvcF9pXS4gQ29udGludWUuICopXG4gICAgICBsZXQgbmV4dF9pID0gc3RyaWRlIGkgaW5cbiAgICAgIChtYXRjaCBvcmRlciBpIG5leHRfaSwgaW5pdGlhbF9zdHJpZGVfb3JkZXIgd2l0aFxuICAgICAgIHwgRXF1YWwsIF8gLT4gcmFpc2Vfc3RyaWRlX2Nhbm5vdF9yZXR1cm5fc2FtZV92YWx1ZSAoKVxuICAgICAgIHwgTGVzcywgYEdyZWF0ZXIgfCBHcmVhdGVyLCBgTGVzcyAtPlxuICAgICAgICAgaW52YWxpZF9hcmcgXCJMaXN0LnJhbmdlJzogc3RyaWRlIGZ1bmN0aW9uIGNhbm5vdCBjaGFuZ2UgZGlyZWN0aW9uXCJcbiAgICAgICB8IExlc3MsIGBMZXNzIHwgR3JlYXRlciwgYEdyZWF0ZXIgLT4gbG9vcCBuZXh0X2kgKGkgOjogYWNjdW0pKVxuICAgIHwgTGVzcywgYEdyZWF0ZXIgfCBHcmVhdGVyLCBgTGVzcyAtPlxuICAgICAgKCogc3RlcHBlZCBwYXN0IFtzdG9wX2ldLiAgRmluaXNoZWQuICopXG4gICAgICBhY2N1bVxuICAgIHwgRXF1YWwsIF8gLT5cbiAgICAgICgqIHJlYWNoZWQgW3N0b3BfaV0uICBGaW5pc2hlZC4gKilcbiAgICAgIChtYXRjaCBzdG9wIHdpdGhcbiAgICAgICB8IGBpbmNsdXNpdmUgLT4gaSA6OiBhY2N1bVxuICAgICAgIHwgYGV4Y2x1c2l2ZSAtPiBhY2N1bSlcbiAgaW5cbiAgbGV0IHN0YXJ0X2kgPVxuICAgIG1hdGNoIHN0YXJ0IHdpdGhcbiAgICB8IGBpbmNsdXNpdmUgLT4gc3RhcnRfaVxuICAgIHwgYGV4Y2x1c2l2ZSAtPiBuZXh0X2lcbiAgaW5cbiAgcmV2IChsb29wIHN0YXJ0X2kgW10pXG47O1xuXG5sZXQgcmFuZ2UgPyhzdHJpZGUgPSAxKSA/KHN0YXJ0ID0gYGluY2x1c2l2ZSkgPyhzdG9wID0gYGV4Y2x1c2l2ZSkgc3RhcnRfaSBzdG9wX2kgPVxuICBpZiBzdHJpZGUgPSAwIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LnJhbmdlOiBzdHJpZGUgbXVzdCBiZSBub24temVyb1wiO1xuICByYW5nZScgfmNvbXBhcmUgfnN0cmlkZTooZnVuIHggLT4geCArIHN0cmlkZSkgfnN0YXJ0IH5zdG9wIHN0YXJ0X2kgc3RvcF9pXG47O1xuXG5sZXQgaGQgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCB4IDo6IF8gLT4gU29tZSB4XG47O1xuXG5sZXQgdGwgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBfIDo6IHQnIC0+IFNvbWUgdCdcbjs7XG5cbmxldCBudGggdCBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCByZWMgbnRoX2F1eCB0IG4gPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IFtdIC0+IE5vbmVcbiAgICAgIHwgYSA6OiB0IC0+IGlmIG4gPSAwIHRoZW4gU29tZSBhIGVsc2UgbnRoX2F1eCB0IChuIC0gMSlcbiAgICBpblxuICAgIG50aF9hdXggdCBuKVxuOztcblxubGV0IG50aF9leG4gdCBuID1cbiAgbWF0Y2ggbnRoIHQgbiB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZ2YgXCJMaXN0Lm50aF9leG4gJWQgY2FsbGVkIG9uIGxpc3Qgb2YgbGVuZ3RoICVkXCIgbiAobGVuZ3RoIHQpICgpXG4gIHwgU29tZSBhIC0+IGFcbjs7XG5cbmxldCB1bm9yZGVyZWRfYXBwZW5kIGwxIGwyID1cbiAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgfCBbXSwgbCB8IGwsIFtdIC0+IGxcbiAgfCBfIC0+IHJldl9hcHBlbmQgbDEgbDJcbjs7XG5cbm1vZHVsZSBDaGVja19sZW5ndGgyID0gc3RydWN0XG4gIHR5cGUgKCdhLCAnYikgdCA9XG4gICAgfCBTYW1lX2xlbmd0aCBvZiBpbnRcbiAgICB8IFVuZXF1YWxfbGVuZ3RocyBvZlxuICAgICAgICB7IHNoYXJlZF9sZW5ndGggOiBpbnRcbiAgICAgICAgOyB0YWlsX29mX2EgOiAnYSBsaXN0XG4gICAgICAgIDsgdGFpbF9vZl9iIDogJ2IgbGlzdFxuICAgICAgICB9XG5cbiAgKCogSW4gdGhlIFtVbmVxdWFsX2xlbmd0aHNdIGNhc2UsIGF0IGxlYXN0IG9uZSBvZiB0aGUgdGFpbHMgd2lsbCBiZSBub24tZW1wdHkuICopXG4gIGxldCBvZl9saXN0cyBsMSBsMiA9XG4gICAgbGV0IHJlYyBsb29wIGEgYiBzaGFyZWRfbGVuZ3RoID1cbiAgICAgIG1hdGNoIGEsIGIgd2l0aFxuICAgICAgfCBbXSwgW10gLT4gU2FtZV9sZW5ndGggc2hhcmVkX2xlbmd0aFxuICAgICAgfCBfIDo6IGEsIF8gOjogYiAtPiBsb29wIGEgYiAoc2hhcmVkX2xlbmd0aCArIDEpXG4gICAgICB8IFtdLCBfIHwgXywgW10gLT4gVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hID0gYTsgdGFpbF9vZl9iID0gYiB9XG4gICAgaW5cbiAgICBsb29wIGwxIGwyIDBcbiAgOztcbmVuZFxuXG5sZXQgY2hlY2tfbGVuZ3RoMl9leG4gbmFtZSBsMSBsMiA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDIub2ZfbGlzdHMgbDEgbDIgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gKClcbiAgfCBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2E7IHRhaWxfb2ZfYiB9IC0+XG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcImxlbmd0aCBtaXNtYXRjaCBpbiAlczogJWQgPD4gJWRcIlxuICAgICAgbmFtZVxuICAgICAgKHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9hKVxuICAgICAgKHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9iKVxuICAgICAgKClcbjs7XG5cbmxldCBjaGVja19sZW5ndGgyIGwxIGwyIH5mID1cbiAgbWF0Y2ggQ2hlY2tfbGVuZ3RoMi5vZl9saXN0cyBsMSBsMiB3aXRoXG4gIHwgU2FtZV9sZW5ndGggXyAtPiBPcl91bmVxdWFsX2xlbmd0aHMuT2sgKGYgbDEgbDIpXG4gIHwgVW5lcXVhbF9sZW5ndGhzIF8gLT4gVW5lcXVhbF9sZW5ndGhzXG47O1xuXG5tb2R1bGUgQ2hlY2tfbGVuZ3RoMyA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IsICdjKSB0ID1cbiAgICB8IFNhbWVfbGVuZ3RoIG9mIGludFxuICAgIHwgVW5lcXVhbF9sZW5ndGhzIG9mXG4gICAgICAgIHsgc2hhcmVkX2xlbmd0aCA6IGludFxuICAgICAgICA7IHRhaWxfb2ZfYSA6ICdhIGxpc3RcbiAgICAgICAgOyB0YWlsX29mX2IgOiAnYiBsaXN0XG4gICAgICAgIDsgdGFpbF9vZl9jIDogJ2MgbGlzdFxuICAgICAgICB9XG5cbiAgKCogSW4gdGhlIFtVbmVxdWFsX2xlbmd0aHNdIGNhc2UsIGF0IGxlYXN0IG9uZSBvZiB0aGUgdGFpbHMgd2lsbCBiZSBub24tZW1wdHkuICopXG4gIGxldCBvZl9saXN0cyBsMSBsMiBsMyA9XG4gICAgbGV0IHJlYyBsb29wIGEgYiBjIHNoYXJlZF9sZW5ndGggPVxuICAgICAgbWF0Y2ggYSwgYiwgYyB3aXRoXG4gICAgICB8IFtdLCBbXSwgW10gLT4gU2FtZV9sZW5ndGggc2hhcmVkX2xlbmd0aFxuICAgICAgfCBfIDo6IGEsIF8gOjogYiwgXyA6OiBjIC0+IGxvb3AgYSBiIGMgKHNoYXJlZF9sZW5ndGggKyAxKVxuICAgICAgfCBbXSwgXywgXyB8IF8sIFtdLCBfIHwgXywgXywgW10gLT5cbiAgICAgICAgVW5lcXVhbF9sZW5ndGhzIHsgc2hhcmVkX2xlbmd0aDsgdGFpbF9vZl9hID0gYTsgdGFpbF9vZl9iID0gYjsgdGFpbF9vZl9jID0gYyB9XG4gICAgaW5cbiAgICBsb29wIGwxIGwyIGwzIDBcbiAgOztcbmVuZFxuXG5sZXQgY2hlY2tfbGVuZ3RoM19leG4gbmFtZSBsMSBsMiBsMyA9XG4gIG1hdGNoIENoZWNrX2xlbmd0aDMub2ZfbGlzdHMgbDEgbDIgbDMgd2l0aFxuICB8IFNhbWVfbGVuZ3RoIF8gLT4gKClcbiAgfCBVbmVxdWFsX2xlbmd0aHMgeyBzaGFyZWRfbGVuZ3RoOyB0YWlsX29mX2E7IHRhaWxfb2ZfYjsgdGFpbF9vZl9jIH0gLT5cbiAgICBsZXQgbjEgPSBzaGFyZWRfbGVuZ3RoICsgbGVuZ3RoIHRhaWxfb2ZfYSBpblxuICAgIGxldCBuMiA9IHNoYXJlZF9sZW5ndGggKyBsZW5ndGggdGFpbF9vZl9iIGluXG4gICAgbGV0IG4zID0gc2hhcmVkX2xlbmd0aCArIGxlbmd0aCB0YWlsX29mX2MgaW5cbiAgICBpbnZhbGlkX2FyZ2YgXCJsZW5ndGggbWlzbWF0Y2ggaW4gJXM6ICVkIDw+ICVkIHx8ICVkIDw+ICVkXCIgbmFtZSBuMSBuMiBuMiBuMyAoKVxuOztcblxubGV0IGNoZWNrX2xlbmd0aDMgbDEgbDIgbDMgfmYgPVxuICBtYXRjaCBDaGVja19sZW5ndGgzLm9mX2xpc3RzIGwxIGwyIGwzIHdpdGhcbiAgfCBTYW1lX2xlbmd0aCBfIC0+IE9yX3VuZXF1YWxfbGVuZ3Rocy5PayAoZiBsMSBsMiBsMylcbiAgfCBVbmVxdWFsX2xlbmd0aHMgXyAtPiBVbmVxdWFsX2xlbmd0aHNcbjs7XG5cbmxldCBpdGVyMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGl0ZXIyX29rIH5mKVxuXG5sZXQgaXRlcjJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJpdGVyMl9leG5cIiBsMSBsMjtcbiAgaXRlcjJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCByZXZfbWFwMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KHJldl9tYXAyX29rIH5mKVxuXG5sZXQgcmV2X21hcDJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJyZXZfbWFwMl9leG5cIiBsMSBsMjtcbiAgcmV2X21hcDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBmb2xkMiBsMSBsMiB+aW5pdCB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGZvbGQyX29rIH5pbml0IH5mKVxuXG5sZXQgZm9sZDJfZXhuIGwxIGwyIH5pbml0IH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJmb2xkMl9leG5cIiBsMSBsMjtcbiAgZm9sZDJfb2sgbDEgbDIgfmluaXQgfmZcbjs7XG5cbmxldCBmb3JfYWxsMiBsMSBsMiB+ZiA9IGNoZWNrX2xlbmd0aDIgbDEgbDIgfmY6KGZvcl9hbGwyX29rIH5mKVxuXG5sZXQgZm9yX2FsbDJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJmb3JfYWxsMl9leG5cIiBsMSBsMjtcbiAgZm9yX2FsbDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCBleGlzdHMyIGwxIGwyIH5mID0gY2hlY2tfbGVuZ3RoMiBsMSBsMiB+ZjooZXhpc3RzMl9vayB+ZilcblxubGV0IGV4aXN0czJfZXhuIGwxIGwyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJleGlzdHMyX2V4blwiIGwxIGwyO1xuICBleGlzdHMyX29rIGwxIGwyIH5mXG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgZXF1YWwgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBmYWxzZVxuICAgIHwgYiA6OiBicyAtPiBlcXVhbCBhIGIgfHwgbG9vcCBlcXVhbCBhIGJzXG4gIGluXG4gIGxvb3AgZXF1YWwgYSB0XG47O1xuXG4oKiBUaGlzIGlzIGEgY29weSBvZiB0aGUgY29kZSBmcm9tIHRoZSBzdGFuZGFyZCBsaWJyYXJ5LCB3aXRoIGFuIGV4dHJhIGV0YS1leHBhbnNpb24gdG9cbiAgIGF2b2lkIGNyZWF0aW5nIHBhcnRpYWwgY2xvc3VyZXMgKHNob3dlZCB1cCBmb3IgW2ZpbHRlcl0pIGluIHByb2ZpbGluZykuICopXG5sZXQgcmV2X2ZpbHRlciB0IH5mID1cbiAgbGV0IHJlYyBmaW5kIH5mIGFjY3UgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gYWNjdVxuICAgIHwgeCA6OiBsIC0+IGlmIGYgeCB0aGVuIGZpbmQgfmYgKHggOjogYWNjdSkgbCBlbHNlIGZpbmQgfmYgYWNjdSBsXG4gIGluXG4gIGZpbmQgfmYgW10gdFxuOztcblxubGV0IGZpbHRlciB0IH5mID0gcmV2IChyZXZfZmlsdGVyIHQgfmYpXG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPlxuICAgICAgKG1hdGNoIGYgeCB3aXRoXG4gICAgICAgfCBOb25lIC0+IGxvb3AgbFxuICAgICAgIHwgU29tZSBfIGFzIHIgLT4gcilcbiAgaW5cbiAgbG9vcCB0XG47O1xuXG5sZXQgZmluZF9tYXBfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kX21hcF9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRfbWFwIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBfZXhuXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHggOjogbCAtPiBpZiBmIHggdGhlbiBTb21lIHggZWxzZSBsb29wIGxcbiAgaW5cbiAgbG9vcCB0XG47O1xuXG5sZXQgZmluZF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LmZpbmRfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IHJlYyBmaW5kX2V4biB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgeCA6OiB0IC0+IGlmIGYgeCB0aGVuIHggZWxzZSBmaW5kX2V4biB0IH5mXG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9leG5cbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT4gaWYgZiBpIHggdGhlbiBTb21lIChpLCB4KSBlbHNlIGxvb3AgKGkgKyAxKSBsXG4gIGluXG4gIGxvb3AgMCB0XG47O1xuXG5sZXQgZmluZGlfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kaV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZGlfZXhuIHQgfmYgPVxuICAgIG1hdGNoIGZpbmRpIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gIGZpbmRpX2V4blxuOztcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIGkgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBOb25lXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgIChtYXRjaCBmIGkgeCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgcmVzdWx0IC0+IHJlc3VsdFxuICAgICAgIHwgTm9uZSAtPiBsb29wIChpICsgMSkgbClcbiAgaW5cbiAgbG9vcCAwIHRcbjs7XG5cbmxldCBmaW5kX21hcGlfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiTGlzdC5maW5kX21hcGlfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwaV9leG4gdCB+ZiA9XG4gICAgbWF0Y2ggZmluZF9tYXBpIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICB8IFNvbWUgeCAtPiB4XG4gIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9tYXBpX2V4blxuOztcblxubGV0IGZvcl9hbGxpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IHRydWVcbiAgICB8IGhkIDo6IHRsIC0+IGYgaSBoZCAmJiBsb29wIChpICsgMSkgdGxcbiAgaW5cbiAgbG9vcCAwIHRcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgaSB0ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IFtdIC0+IGZhbHNlXG4gICAgfCBoZCA6OiB0bCAtPiBmIGkgaGQgfHwgbG9vcCAoaSArIDEpIHRsXG4gIGluXG4gIGxvb3AgMCB0XG47O1xuXG4oKiogRm9yIHRoZSBjb250YWluZXIgaW50ZXJmYWNlLiAqKVxubGV0IGZvbGRfbGVmdCA9IGZvbGRcblxubGV0IHRvX2FycmF5ID0gQXJyYXkub2ZfbGlzdFxubGV0IHRvX2xpc3QgdCA9IHRcblxubGV0IG1heF9ub25fdGFpbGNhbGwgPVxuICBtYXRjaCBTeXMuYmFja2VuZF90eXBlIHdpdGhcbiAgfCBTeXMuTmF0aXZlIHwgU3lzLkJ5dGVjb2RlIC0+IDFfMDAwXG4gICgqIFdlIGRvbid0IGtub3cgdGhlIHNpemUgb2YgdGhlIHN0YWNrLCBiZXR0ZXIgYmUgc2FmZSBhbmQgYXNzdW1lIGl0J3Mgc21hbGwuIFRoaXNcbiAgICAgbnVtYmVyIHdhcyB0YWtlbiBmcm9tIG9jYW1sI3N0ZGxpYi9saXN0Lm1sIHdoaWNoIGlzIGFsc28gZXF1YWwgdG8gdGhlIGRlZmF1bHQgbGltaXRcbiAgICAgb2YgcmVjdXJzaXZlIGNhbGwgaW4gdGhlIGpzX29mX29jYW1sIGNvbXBpbGVyIGJlZm9yZSBzd2l0Y2hpbmcgdG8gdHJhbXBvbGluZS4gKilcbiAgfCBTeXMuT3RoZXIgXyAtPiA1MFxuOztcblxuKCoqIFRhaWwgcmVjdXJzaXZlIHZlcnNpb25zIG9mIHN0YW5kYXJkIFtMaXN0XSBtb2R1bGUgKilcblxubGV0IHRhaWxfYXBwZW5kIGwxIGwyID0gcmV2X2FwcGVuZCAocmV2IGwxKSBsMlxuXG4oKiBUaGVyZSBhcmUgYSBmZXcgb3B0aW1pemVkIGxpc3Qgb3BlcmF0aW9ucyBoZXJlLCBpbmNsdWRpbmcgYXBwZW5kIGFuZCBtYXAuICBUaGVyZSBhcmVcbiAgIGJhc2ljYWxseSB0d28gb3B0aW1pemF0aW9ucyBpbiBwbGF5OiBsb29wIHVucm9sbGluZywgYW5kIGR5bmFtaWMgc3dpdGNoaW5nIGJldHdlZW5cbiAgIHN0YWNrIGFuZCBoZWFwIGFsbG9jYXRpb24uXG5cbiAgIFRoZSBsb29wLXVucm9sbGluZyBpcyBzdHJhaWdodGZvcndhcmQsIHdlIGp1c3QgdW5yb2xsIDUgbGV2ZWxzIG9mIHRoZSBsb29wLiAgVGhpcyBtYWtlc1xuICAgZWFjaCBpdGVyYXRpb24gZmFzdGVyLCBhbmQgYWxzbyByZWR1Y2VzIHRoZSBudW1iZXIgb2Ygc3RhY2sgZnJhbWVzIGNvbnN1bWVkIHBlciBsaXN0XG4gICBlbGVtZW50LlxuXG4gICBUaGUgZHluYW1pYyBzd2l0Y2hpbmcgaXMgZG9uZSBieSBjb3VudGluZyB0aGUgbnVtYmVyIG9mIHN0YWNrIGZyYW1lcywgYW5kIHRoZW5cbiAgIHN3aXRjaGluZyB0byB0aGUgXCJzbG93XCIgaW1wbGVtZW50YXRpb24gd2hlbiB3ZSBleGNlZWQgYSBnaXZlbiBsaW1pdC4gIFRoaXMgbWVhbnMgdGhhdFxuICAgc2hvcnQgbGlzdHMgdXNlIHRoZSBmYXN0IHN0YWNrLWFsbG9jYXRpb24gbWV0aG9kLCBhbmQgbG9uZyBsaXN0cyB1c2UgYSBzbG93ZXIgb25lIHRoYXRcbiAgIGRvZXNuJ3QgcmVxdWlyZSBzdGFjayBzcGFjZS4gKilcbmxldCByZWMgY291bnRfYXBwZW5kIGwxIGwyIGNvdW50ID1cbiAgbWF0Y2ggbDIgd2l0aFxuICB8IFtdIC0+IGwxXG4gIHwgXyAtPlxuICAgIChtYXRjaCBsMSB3aXRoXG4gICAgIHwgW10gLT4gbDJcbiAgICAgfCBbIHgxIF0gLT4geDEgOjogbDJcbiAgICAgfCBbIHgxOyB4MiBdIC0+IHgxIDo6IHgyIDo6IGwyXG4gICAgIHwgWyB4MTsgeDI7IHgzIF0gLT4geDEgOjogeDIgOjogeDMgOjogbDJcbiAgICAgfCBbIHgxOyB4MjsgeDM7IHg0IF0gLT4geDEgOjogeDIgOjogeDMgOjogeDQgOjogbDJcbiAgICAgfCB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiB0bCAtPlxuICAgICAgIHgxXG4gICAgICAgOjogeDJcbiAgICAgICA6OiB4M1xuICAgICAgIDo6IHg0XG4gICAgICAgOjogeDVcbiAgICAgICA6OlxuICAgICAgIChpZiBjb3VudCA+IG1heF9ub25fdGFpbGNhbGxcbiAgICAgICAgdGhlbiB0YWlsX2FwcGVuZCB0bCBsMlxuICAgICAgICBlbHNlIGNvdW50X2FwcGVuZCB0bCBsMiAoY291bnQgKyAxKSkpXG47O1xuXG5sZXQgYXBwZW5kIGwxIGwyID0gY291bnRfYXBwZW5kIGwxIGwyIDBcblxuKCogQW4gb3JkaW5hcnkgdGFpbCByZWN1cnNpdmUgbWFwIGJ1aWxkcyB1cCBhbiBpbnRlcm1lZGlhdGUgKHJldmVyc2VkKSByZXByZXNlbnRhdGlvbixcbiAgIHdpdGggb25lIGhlYXAgYWxsb2NhdGVkIG9iamVjdCBwZXIgZWxlbWVudC4gVGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvbiBpbnN0ZWFkIGNodW5rc1xuICAgOSBvYmplY3RzIGludG8gb25lIGhlYXAgYWxsb2NhdGVkIG9iamVjdCwgcmVkdWNpbmcgYWxsb2NhdGlvbiBhbmQgcGVyZm9ybWFuY2UgY29zdHNcbiAgIGFjY29yZGluZ2x5LiBOb3RlIHRoYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBsaXN0IGlzIGRvbmUgYnkgdGhlIHN0ZGxpYidzIG1hcFxuICAgZnVuY3Rpb24uICopXG5sZXQgdGFpbF9tYXAgeHMgfmYgPVxuICBsZXQgcmVjIHJpc2UgeXMgPSBmdW5jdGlvblxuICAgIHwgW10gLT4geXNcbiAgICB8ICh5MCwgeTEsIHkyLCB5MywgeTQsIHk1LCB5NiwgeTcsIHk4KSA6OiBicyAtPlxuICAgICAgcmlzZSAoeTAgOjogeTEgOjogeTIgOjogeTMgOjogeTQgOjogeTUgOjogeTYgOjogeTcgOjogeTggOjogeXMpIGJzXG4gIGluXG4gIGxldCByZWMgZGl2ZSBicyA9IGZ1bmN0aW9uXG4gICAgfCB4MCA6OiB4MSA6OiB4MiA6OiB4MyA6OiB4NCA6OiB4NSA6OiB4NiA6OiB4NyA6OiB4OCA6OiB4cyAtPlxuICAgICAgbGV0IHkwID0gZiB4MCBpblxuICAgICAgbGV0IHkxID0gZiB4MSBpblxuICAgICAgbGV0IHkyID0gZiB4MiBpblxuICAgICAgbGV0IHkzID0gZiB4MyBpblxuICAgICAgbGV0IHk0ID0gZiB4NCBpblxuICAgICAgbGV0IHk1ID0gZiB4NSBpblxuICAgICAgbGV0IHk2ID0gZiB4NiBpblxuICAgICAgbGV0IHk3ID0gZiB4NyBpblxuICAgICAgbGV0IHk4ID0gZiB4OCBpblxuICAgICAgZGl2ZSAoKHkwLCB5MSwgeTIsIHkzLCB5NCwgeTUsIHk2LCB5NywgeTgpIDo6IGJzKSB4c1xuICAgIHwgeHMgLT4gcmlzZSAobm9udGFpbF9tYXAgfmYgeHMpIGJzXG4gIGluXG4gIGRpdmUgW10geHNcbjs7XG5cbmxldCByZWMgY291bnRfbWFwIH5mIGwgY3RyID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW11cbiAgfCBbIHgxIF0gLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgWyBmMSBdXG4gIHwgWyB4MTsgeDIgXSAtPlxuICAgIGxldCBmMSA9IGYgeDEgaW5cbiAgICBsZXQgZjIgPSBmIHgyIGluXG4gICAgWyBmMTsgZjIgXVxuICB8IFsgeDE7IHgyOyB4MyBdIC0+XG4gICAgbGV0IGYxID0gZiB4MSBpblxuICAgIGxldCBmMiA9IGYgeDIgaW5cbiAgICBsZXQgZjMgPSBmIHgzIGluXG4gICAgWyBmMTsgZjI7IGYzIF1cbiAgfCBbIHgxOyB4MjsgeDM7IHg0IF0gLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgbGV0IGYyID0gZiB4MiBpblxuICAgIGxldCBmMyA9IGYgeDMgaW5cbiAgICBsZXQgZjQgPSBmIHg0IGluXG4gICAgWyBmMTsgZjI7IGYzOyBmNCBdXG4gIHwgeDEgOjogeDIgOjogeDMgOjogeDQgOjogeDUgOjogdGwgLT5cbiAgICBsZXQgZjEgPSBmIHgxIGluXG4gICAgbGV0IGYyID0gZiB4MiBpblxuICAgIGxldCBmMyA9IGYgeDMgaW5cbiAgICBsZXQgZjQgPSBmIHg0IGluXG4gICAgbGV0IGY1ID0gZiB4NSBpblxuICAgIGYxXG4gICAgOjogZjJcbiAgICA6OiBmM1xuICAgIDo6IGY0XG4gICAgOjogZjVcbiAgICA6OiAoaWYgY3RyID4gbWF4X25vbl90YWlsY2FsbCB0aGVuIHRhaWxfbWFwIH5mIHRsIGVsc2UgY291bnRfbWFwIH5mIHRsIChjdHIgKyAxKSlcbjs7XG5cbmxldCBtYXAgbCB+ZiA9IGNvdW50X21hcCB+ZiBsIDBcblxubGV0IGZvbGRpbmdfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpXG47O1xuXG5sZXQgZm9sZF9tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgKCA+PnwgKSBsIGYgPSBtYXAgbCB+ZlxubGV0IG1hcDJfb2sgbDEgbDIgfmYgPSByZXYgKHJldl9tYXAyX29rIGwxIGwyIH5mKVxubGV0IG1hcDIgbDEgbDIgfmYgPSBjaGVja19sZW5ndGgyIGwxIGwyIH5mOihtYXAyX29rIH5mKVxuXG5sZXQgbWFwMl9leG4gbDEgbDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIm1hcDJfZXhuXCIgbDEgbDI7XG4gIG1hcDJfb2sgbDEgbDIgfmZcbjs7XG5cbmxldCByZXZfbWFwM19vayBsMSBsMiBsMyB+ZiA9XG4gIGxldCByZWMgbG9vcCBsMSBsMiBsMyBhYyA9XG4gICAgbWF0Y2ggbDEsIGwyLCBsMyB3aXRoXG4gICAgfCBbXSwgW10sIFtdIC0+IGFjXG4gICAgfCB4MSA6OiBsMSwgeDIgOjogbDIsIHgzIDo6IGwzIC0+IGxvb3AgbDEgbDIgbDMgKGYgeDEgeDIgeDMgOjogYWMpXG4gICAgfCBfIC0+IGFzc2VydCBmYWxzZVxuICBpblxuICBsb29wIGwxIGwyIGwzIFtdXG47O1xuXG5sZXQgcmV2X21hcDMgbDEgbDIgbDMgfmYgPSBjaGVja19sZW5ndGgzIGwxIGwyIGwzIH5mOihyZXZfbWFwM19vayB+ZilcblxubGV0IHJldl9tYXAzX2V4biBsMSBsMiBsMyB+ZiA9XG4gIGNoZWNrX2xlbmd0aDNfZXhuIFwicmV2X21hcDNfZXhuXCIgbDEgbDIgbDM7XG4gIHJldl9tYXAzX29rIGwxIGwyIGwzIH5mXG47O1xuXG5sZXQgbWFwM19vayBsMSBsMiBsMyB+ZiA9IHJldiAocmV2X21hcDNfb2sgbDEgbDIgbDMgfmYpXG5sZXQgbWFwMyBsMSBsMiBsMyB+ZiA9IGNoZWNrX2xlbmd0aDMgbDEgbDIgbDMgfmY6KG1hcDNfb2sgfmYpXG5cbmxldCBtYXAzX2V4biBsMSBsMiBsMyB+ZiA9XG4gIGNoZWNrX2xlbmd0aDNfZXhuIFwibWFwM19leG5cIiBsMSBsMiBsMztcbiAgbWFwM19vayBsMSBsMiBsMyB+ZlxuOztcblxubGV0IHJlYyByZXZfbWFwX2FwcGVuZCBsMSBsMiB+ZiA9XG4gIG1hdGNoIGwxIHdpdGhcbiAgfCBbXSAtPiBsMlxuICB8IGggOjogdCAtPiByZXZfbWFwX2FwcGVuZCB+ZiB0IChmIGggOjogbDIpXG47O1xuXG5sZXQgdW56aXAgbGlzdCA9XG4gIGxldCByZWMgbG9vcCBsaXN0IGwxIGwyID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IGwxLCBsMlxuICAgIHwgKHgsIHkpIDo6IHRsIC0+IGxvb3AgdGwgKHggOjogbDEpICh5IDo6IGwyKVxuICBpblxuICBsb29wIChyZXYgbGlzdCkgW10gW11cbjs7XG5cbmxldCB1bnppcDMgbGlzdCA9XG4gIGxldCByZWMgbG9vcCBsaXN0IGwxIGwyIGwzID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IGwxLCBsMiwgbDNcbiAgICB8ICh4LCB5LCB6KSA6OiB0bCAtPiBsb29wIHRsICh4IDo6IGwxKSAoeSA6OiBsMikgKHogOjogbDMpXG4gIGluXG4gIGxvb3AgKHJldiBsaXN0KSBbXSBbXSBbXVxuOztcblxubGV0IHppcF9leG4gbDEgbDIgPVxuICB0cnkgbWFwMl9vayB+ZjooZnVuIGEgYiAtPiBhLCBiKSBsMSBsMiB3aXRoXG4gIHwgXyAtPiBpbnZhbGlkX2FyZ2YgXCJsZW5ndGggbWlzbWF0Y2ggaW4gemlwX2V4bjogJWQgPD4gJWRcIiAobGVuZ3RoIGwxKSAobGVuZ3RoIGwyKSAoKVxuOztcblxubGV0IHppcCBsMSBsMiA9IG1hcDIgfmY6KGZ1biBhIGIgLT4gYSwgYikgbDEgbDJcblxuKCoqIEFkZGl0aW9uYWwgbGlzdCBvcGVyYXRpb25zICopXG5cbmxldCByZXZfbWFwaSBsIH5mID1cbiAgbGV0IHJlYyBsb29wIGkgYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IGFjY1xuICAgIHwgaCA6OiB0IC0+IGxvb3AgKGkgKyAxKSAoZiBpIGggOjogYWNjKSB0XG4gIGluXG4gIGxvb3AgMCBbXSBsXG47O1xuXG5sZXQgbWFwaSBsIH5mID0gcmV2IChyZXZfbWFwaSBsIH5mKVxuXG5sZXQgZm9sZGluZ19tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSlcbjs7XG5cbmxldCBmb2xkX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCBpdGVyaSBsIH5mID1cbiAgaWdub3JlXG4gICAgKGZvbGQgbCB+aW5pdDowIH5mOihmdW4gaSB4IC0+XG4gICAgICAgZiBpIHg7XG4gICAgICAgaSArIDEpXG4gICAgIDogaW50KVxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBzbmQgKGZvbGQgdCB+aW5pdDooMCwgaW5pdCkgfmY6KGZ1biAoaSwgYWNjKSB2IC0+IGkgKyAxLCBmIGkgYWNjIHYpKVxuOztcblxubGV0IGZpbHRlcmkgbCB+ZiA9XG4gIHJldiAoZm9sZGkgbCB+ZjooZnVuIHBvcyBhY2MgeCAtPiBpZiBmIHBvcyB4IHRoZW4geCA6OiBhY2MgZWxzZSBhY2MpIH5pbml0OltdKVxuOztcblxubGV0IHJlZHVjZSBsIH5mID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gTm9uZVxuICB8IGhkIDo6IHRsIC0+IFNvbWUgKGZvbGQgfmluaXQ6aGQgfmYgdGwpXG47O1xuXG5sZXQgcmVkdWNlX2V4biBsIH5mID1cbiAgbWF0Y2ggcmVkdWNlIGwgfmYgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJMaXN0LnJlZHVjZV9leG5cIlxuICB8IFNvbWUgdiAtPiB2XG47O1xuXG5sZXQgcmVkdWNlX2JhbGFuY2VkIGwgfmYgPVxuICAoKiBDYWxsIHRoZSBcInNpemVcIiBvZiBhIHZhbHVlIHRoZSBudW1iZXIgb2YgbGlzdCBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBjb21iaW5lZCBpbnRvXG4gICAgIGl0IHZpYSBjYWxscyB0byBbZl0uICBXZSBwcm9jZWVkIGJ5IHVzaW5nIFtmXSB0byBjb21iaW5lIGVsZW1lbnRzIGluIHRoZSBhY2N1bXVsYXRvclxuICAgICBvZiB0aGUgc2FtZSBzaXplIHVudGlsIHdlIGNhbid0IGNvbWJpbmUgYW55IG1vcmUsIHRoZW4gZ2V0dGluZyBhIG5ldyBlbGVtZW50IGZyb20gdGhlXG4gICAgIGlucHV0IGxpc3QgYW5kIHJlcGVhdGluZy5cblxuICAgICBXaXRoIHRoaXMgc3RyYXRlZ3ksIGluIHRoZSBhY2N1bXVsYXRvcjpcbiAgICAgLSB3ZSBvbmx5IGV2ZXIgaGF2ZSBlbGVtZW50cyBvZiBzaXplcyBhIHBvd2VyIG9mIHR3b1xuICAgICAtIHdlIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBlbGVtZW50IG9mIGVhY2ggc2l6ZVxuICAgICAtIHRoZSBzdW0gb2YgYWxsIHRoZSBlbGVtZW50IHNpemVzIGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29uc3VtZWRcblxuICAgICBUaGVzZSBjb25kaXRpb25zIGVuZm9yY2UgdGhhdCBsaXN0IG9mIGVsZW1lbnRzIG9mIGVhY2ggc2l6ZSBpcyBwcmVjaXNlbHkgdGhlIGJpbmFyeVxuICAgICBleHBhbnNpb24gb2YgdGhlIG51bWJlciBvZiBlbGVtZW50cyBjb25zdW1lZDogaWYgeW91J3ZlIGNvbnN1bWVkIDEzID0gMGIxMTAxXG4gICAgIGVsZW1lbnRzLCB5b3UgaGF2ZSBvbmUgZWxlbWVudCBvZiBzaXplIDgsIG9uZSBvZiBzaXplIDQsIGFuZCBvbmUgb2Ygc2l6ZSAxLiAgSGVuY2VcbiAgICAgd2hlbiBhIG5ldyBlbGVtZW50IGNvbWVzIGFsb25nLCB0aGUgbnVtYmVyIG9mIGNvbWJpbmluZ3MgeW91IG5lZWQgdG8gZG8gaXMgdGhlIG51bWJlclxuICAgICBvZiB0cmFpbGluZyAxcyBpbiB0aGUgYmluYXJ5IGV4cGFuc2lvbiBvZiBbbnVtXSwgdGhlIG51bWJlciBvZiBlbGVtZW50cyB0aGF0IGhhdmVcbiAgICAgYWxyZWFkeSBnb25lIGludG8gdGhlIGFjY3VtdWxhdG9yLiAgVGhlIGFjY3VtdWxhdG9yIGlzIGluIGFzY2VuZGluZyBvcmRlciBvZiBzaXplLCBzb1xuICAgICB0aGUgbmV4dCBlbGVtZW50IHRvIGNvbWJpbmUgd2l0aCBpcyBhbHdheXMgdGhlIGhlYWQgb2YgdGhlIGxpc3QuICopXG4gIGxldCByZWMgc3RlcF9hY2N1bSBudW0gYWNjIHggPVxuICAgIGlmIG51bSBsYW5kIDEgPSAwXG4gICAgdGhlbiB4IDo6IGFjY1xuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYWNjIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAoKiBOZXcgZWxlbWVudHMgZnJvbSBsYXRlciBpbiB0aGUgaW5wdXQgbGlzdCBnbyBvbiB0aGUgZnJvbnQgb2YgdGhlIGFjY3VtdWxhdG9yLCBzb1xuICAgICAgICAgdGhlIGFjY3VtdWxhdG9yIGlzIGluIHJldmVyc2Ugb3JkZXIgd3J0IHRoZSBvcmlnaW5hbCBsaXN0IG9yZGVyLCBoZW5jZSBbZiB5IHhdXG4gICAgICAgICBpbnN0ZWFkIG9mIFtmIHggeV0uICopXG4gICAgICB8IHkgOjogeXMgLT4gc3RlcF9hY2N1bSAobnVtIGFzciAxKSB5cyAoZiB5IHgpKVxuICBpblxuICAoKiBFeHBlcmltZW50YWxseSwgaW5saW5pbmcgW2ZvbGRpXSBhbmQgdW5yb2xsaW5nIHRoaXMgbG9vcCBhIGZldyB0aW1lcyBjYW4gcmVkdWNlXG4gICAgIHJ1bnRpbWUgZG93biB0byBhIHRoaXJkIGFuZCBhbGxvY2F0aW9uIHRvIDEvMTZ0aCBvciBzbyBpbiB0aGUgbWljcm9iZW5jaG1hcmtzIGJlbG93LlxuICAgICBIb3dldmVyLCBpbiBtb3N0IHVzZSBjYXNlcyBbZl0gaXMgbGlrZWx5IHRvIGJlIGV4cGVuc2l2ZSAob3RoZXJ3aXNlIHdoeSBkbyB5b3UgY2FyZVxuICAgICBhYm91dCB0aGUgb3JkZXIgb2YgcmVkdWN0aW9uPykgc28gdGhlIG92ZXJoZWFkIG9mIHRoaXMgZnVuY3Rpb24gaXRzZWxmIGRvZXNuJ3QgcmVhbGx5XG4gICAgIG1hdHRlci4gSWYgeW91IGNvbWUgdXAgd2l0aCBhIHVzZS1jYXNlIHdoZXJlIGl0IGRvZXMsIHRoZW4gdGhhdCdzIHNvbWV0aGluZyB5b3UgbWlnaHRcbiAgICAgd2FudCB0byB0cnk6IHNlZSBoZyBsb2cgLXByIDQ5ZWYwNjVmNDI5ZC4gKilcbiAgbWF0Y2ggZm9sZGkgbCB+aW5pdDpbXSB+ZjpzdGVwX2FjY3VtIHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiB4cyAtPiBTb21lIChmb2xkIHhzIH5pbml0OnggfmY6KGZ1biB4IHkgLT4gZiB5IHgpKVxuOztcblxubGV0IHJlZHVjZV9iYWxhbmNlZF9leG4gbCB+ZiA9XG4gIG1hdGNoIHJlZHVjZV9iYWxhbmNlZCBsIH5mIHdpdGhcbiAgfCBOb25lIC0+IGludmFsaWRfYXJnIFwiTGlzdC5yZWR1Y2VfYmFsYW5jZWRfZXhuXCJcbiAgfCBTb21lIHYgLT4gdlxuOztcblxubGV0IGdyb3VwaSBsIH5icmVhayA9XG4gIGxldCBncm91cHMgPVxuICAgIGZvbGRpIGwgfmluaXQ6W10gfmY6KGZ1biBpIGFjYyB4IC0+XG4gICAgICBtYXRjaCBhY2Mgd2l0aFxuICAgICAgfCBbXSAtPiBbIFsgeCBdIF1cbiAgICAgIHwgY3VycmVudF9ncm91cCA6OiB0bCAtPlxuICAgICAgICBpZiBicmVhayBpIChoZF9leG4gY3VycmVudF9ncm91cCkgeFxuICAgICAgICB0aGVuIFsgeCBdIDo6IGN1cnJlbnRfZ3JvdXAgOjogdGwgKCogc3RhcnQgbmV3IGdyb3VwICopXG4gICAgICAgIGVsc2UgKHggOjogY3VycmVudF9ncm91cCkgOjogdGwpXG4gICAgKCogZXh0ZW5kIGN1cnJlbnQgZ3JvdXAgKilcbiAgaW5cbiAgbWF0Y2ggZ3JvdXBzIHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IGwgLT4gcmV2X21hcCBsIH5mOnJldlxuOztcblxubGV0IGdyb3VwIGwgfmJyZWFrID0gZ3JvdXBpIGwgfmJyZWFrOihmdW4gXyB4IHkgLT4gYnJlYWsgeCB5KVxuXG5sZXQgc29ydF9hbmRfZ3JvdXAgbCB+Y29tcGFyZSA9XG4gIGwgfD4gc3RhYmxlX3NvcnQgfmNvbXBhcmUgfD4gZ3JvdXAgfmJyZWFrOihmdW4geCB5IC0+IGNvbXBhcmUgeCB5IDw+IDApXG47O1xuXG5sZXQgY29uY2F0X21hcCBsIH5mID1cbiAgbGV0IHJlYyBhdXggYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJldiBhY2NcbiAgICB8IGhkIDo6IHRsIC0+IGF1eCAocmV2X2FwcGVuZCAoZiBoZCkgYWNjKSB0bFxuICBpblxuICBhdXggW10gbFxuOztcblxubGV0IGNvbmNhdF9tYXBpIGwgfmYgPVxuICBsZXQgcmVjIGF1eCBjb250IGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByZXYgYWNjXG4gICAgfCBoZCA6OiB0bCAtPiBhdXggKGNvbnQgKyAxKSAocmV2X2FwcGVuZCAoZiBjb250IGhkKSBhY2MpIHRsXG4gIGluXG4gIGF1eCAwIFtdIGxcbjs7XG5cbmxldCBtZXJnZSBsMSBsMiB+Y29tcGFyZSA9XG4gIGxldCByZWMgbG9vcCBhY2MgbDEgbDIgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBbXSwgbDIgLT4gcmV2X2FwcGVuZCBhY2MgbDJcbiAgICB8IGwxLCBbXSAtPiByZXZfYXBwZW5kIGFjYyBsMVxuICAgIHwgaDEgOjogdDEsIGgyIDo6IHQyIC0+XG4gICAgICBpZiBjb21wYXJlIGgxIGgyIDw9IDAgdGhlbiBsb29wIChoMSA6OiBhY2MpIHQxIGwyIGVsc2UgbG9vcCAoaDIgOjogYWNjKSBsMSB0MlxuICBpblxuICBsb29wIFtdIGwxIGwyXG47O1xuXG5tb2R1bGUgQ2FydGVzaWFuX3Byb2R1Y3QgPSBzdHJ1Y3RcbiAgKCogV2UgYXJlIGV4cGxpY2l0IGFib3V0IHdoYXQgd2UgZXhwb3J0IGZyb20gZnVuY3RvcnMgc28gdGhhdCB3ZSBkb24ndCBhY2NpZGVudGFsbHlcbiAgICAgcmViaW5kIG1vcmUgZWZmaWNpZW50IGxpc3Qtc3BlY2lmaWMgZnVuY3Rpb25zLiAqKVxuXG4gIGxldCBiaW5kID0gY29uY2F0X21hcFxuICBsZXQgbWFwID0gbWFwXG4gIGxldCBtYXAyIGEgYiB+ZiA9IGNvbmNhdF9tYXAgYSB+ZjooZnVuIHggLT4gbWFwIGIgfmY6KGZ1biB5IC0+IGYgeCB5KSlcbiAgbGV0IHJldHVybiB4ID0gWyB4IF1cbiAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gIGxldCAoID4+PSApIHQgZiA9IGJpbmQgdCB+ZlxuXG4gIG9wZW4gc3RydWN0XG4gICAgbW9kdWxlIEFwcGxpY2F0aXZlID0gQXBwbGljYXRpdmUuTWFrZV91c2luZ19tYXAyIChzdHJ1Y3RcbiAgICAgICAgdHlwZSAnYSB0ID0gJ2EgbGlzdFxuXG4gICAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgICAgbGV0IG1hcCA9IGBDdXN0b20gbWFwXG4gICAgICAgIGxldCBtYXAyID0gbWFwMlxuICAgICAgZW5kKVxuXG4gICAgbW9kdWxlIE1vbmFkID0gTW9uYWQuTWFrZSAoc3RydWN0XG4gICAgICAgIHR5cGUgJ2EgdCA9ICdhIGxpc3RcblxuICAgICAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICAgICAgICBsZXQgYmluZCA9IGJpbmRcbiAgICAgIGVuZClcbiAgZW5kXG5cbiAgbGV0IGFsbCA9IE1vbmFkLmFsbFxuICBsZXQgYWxsX3VuaXQgPSBNb25hZC5hbGxfdW5pdFxuICBsZXQgaWdub3JlX20gPSBNb25hZC5pZ25vcmVfbVxuICBsZXQgam9pbiA9IE1vbmFkLmpvaW5cblxuICBtb2R1bGUgTW9uYWRfaW5maXggPSBzdHJ1Y3RcbiAgICBsZXQgKCA+PnwgKSA9ICggPj58IClcbiAgICBsZXQgKCA+Pj0gKSA9ICggPj49IClcbiAgZW5kXG5cbiAgbGV0IGFwcGx5ID0gQXBwbGljYXRpdmUuYXBwbHlcbiAgbGV0IGJvdGggPSBBcHBsaWNhdGl2ZS5ib3RoXG4gIGxldCBtYXAzID0gQXBwbGljYXRpdmUubWFwM1xuICBsZXQgKCA8Kj4gKSA9IEFwcGxpY2F0aXZlLiggPCo+IClcbiAgbGV0ICggKj4gKSA9IEFwcGxpY2F0aXZlLiggKj4gKVxuICBsZXQgKCA8KiApID0gQXBwbGljYXRpdmUuKCA8KiApXG5cbiAgbW9kdWxlIEFwcGxpY2F0aXZlX2luZml4ID0gc3RydWN0XG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgbGV0ICggPCo+ICkgPSBBcHBsaWNhdGl2ZS4oIDwqPiApXG4gICAgbGV0ICggKj4gKSA9IEFwcGxpY2F0aXZlLiggKj4gKVxuICAgIGxldCAoIDwqICkgPSBBcHBsaWNhdGl2ZS4oIDwqIClcbiAgZW5kXG5cbiAgbW9kdWxlIExldF9zeW50YXggPSBzdHJ1Y3RcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gICAgbGV0ICggPj58ICkgPSAoID4+fCApXG4gICAgbGV0ICggPj49ICkgPSAoID4+PSApXG5cbiAgICBtb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gbWFwXG4gICAgICBsZXQgYm90aCA9IGJvdGhcblxuICAgICAgbW9kdWxlIE9wZW5fb25fcmhzID0gc3RydWN0IGVuZFxuICAgIGVuZFxuICBlbmRcbmVuZFxuXG5pbmNsdWRlIChDYXJ0ZXNpYW5fcHJvZHVjdCA6IE1vbmFkLlMgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdClcblxuKCoqIHJldHVybnMgZmluYWwgZWxlbWVudCBvZiBsaXN0ICopXG5sZXQgcmVjIGxhc3RfZXhuIGxpc3QgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbIHggXSAtPiB4XG4gIHwgXyA6OiB0bCAtPiBsYXN0X2V4biB0bFxuICB8IFtdIC0+IGludmFsaWRfYXJnIFwiTGlzdC5sYXN0XCJcbjs7XG5cbigqKiBvcHRpb25hbGx5IHJldHVybnMgZmluYWwgZWxlbWVudCBvZiBsaXN0ICopXG5sZXQgcmVjIGxhc3QgbGlzdCA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFsgeCBdIC0+IFNvbWUgeFxuICB8IF8gOjogdGwgLT4gbGFzdCB0bFxuICB8IFtdIC0+IE5vbmVcbjs7XG5cbmxldCByZWMgaXNfcHJlZml4IGxpc3QgfnByZWZpeCB+ZXF1YWwgPVxuICBtYXRjaCBwcmVmaXggd2l0aFxuICB8IFtdIC0+IHRydWVcbiAgfCBoZCA6OiB0bCAtPlxuICAgIChtYXRjaCBsaXN0IHdpdGhcbiAgICAgfCBbXSAtPiBmYWxzZVxuICAgICB8IGhkJyA6OiB0bCcgLT4gZXF1YWwgaGQgaGQnICYmIGlzX3ByZWZpeCB0bCcgfnByZWZpeDp0bCB+ZXF1YWwpXG47O1xuXG5sZXQgZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUgdCB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgYTEgOjogdCAtPlxuICAgIGxldCByZWMgbG9vcCBhMSB0ID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBbXSAtPiBOb25lXG4gICAgICB8IGEyIDo6IHQgLT4gaWYgZXF1YWwgYTEgYTIgdGhlbiBTb21lIChhMSwgYTIpIGVsc2UgbG9vcCBhMiB0XG4gICAgaW5cbiAgICBsb29wIGExIHRcbjs7XG5cbigqIHJldHVybnMgbGlzdCB3aXRob3V0IGFkamFjZW50IGR1cGxpY2F0ZXMgKilcbmxldCByZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyA/KHdoaWNoX3RvX2tlZXAgPSBgTGFzdCkgbGlzdCB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgdG9fa2VlcCBhY2N1bSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiB0b19rZWVwIDo6IGFjY3VtXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgaWYgZXF1YWwgaGQgdG9fa2VlcFxuICAgICAgdGhlbiAoXG4gICAgICAgIGxldCB0b19rZWVwID1cbiAgICAgICAgICBtYXRjaCB3aGljaF90b19rZWVwIHdpdGhcbiAgICAgICAgICB8IGBGaXJzdCAtPiB0b19rZWVwXG4gICAgICAgICAgfCBgTGFzdCAtPiBoZFxuICAgICAgICBpblxuICAgICAgICBsb29wIHRvX2tlZXAgYWNjdW0gdGwpXG4gICAgICBlbHNlIGxvb3AgaGQgKHRvX2tlZXAgOjogYWNjdW0pIHRsXG4gIGluXG4gIG1hdGNoIGxpc3Qgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaGQgOjogdGwgLT4gcmV2IChsb29wIGhkIFtdIHRsKVxuOztcblxuKCoqIHJldHVybnMgc29ydGVkIHZlcnNpb24gb2YgbGlzdCB3aXRoIGR1cGxpY2F0ZXMgcmVtb3ZlZCAqKVxubGV0IGRlZHVwX2FuZF9zb3J0IGxpc3QgfmNvbXBhcmUgPVxuICBtYXRjaCBsaXN0IHdpdGhcbiAgfCBbXSB8IFsgXyBdIC0+IGxpc3QgKCogcGVyZm9ybWFuY2UgaGFjayAqKVxuICB8IF8gLT5cbiAgICBsZXQgZXF1YWwgeCB4JyA9IGNvbXBhcmUgeCB4JyA9IDAgaW5cbiAgICBsZXQgc29ydGVkID0gc29ydCB+Y29tcGFyZSBsaXN0IGluXG4gICAgcmVtb3ZlX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZXMgfmVxdWFsIHNvcnRlZFxuOztcblxubGV0IGZpbmRfYV9kdXAgbCB+Y29tcGFyZSA9XG4gIGxldCBzb3J0ZWQgPSBzb3J0IGwgfmNvbXBhcmUgaW5cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiBOb25lXG4gICAgfCBoZDEgOjogKGhkMiA6OiBfIGFzIHRsKSAtPiBpZiBjb21wYXJlIGhkMSBoZDIgPSAwIHRoZW4gU29tZSBoZDEgZWxzZSBsb29wIHRsXG4gIGluXG4gIGxvb3Agc29ydGVkXG47O1xuXG5sZXQgY29udGFpbnNfZHVwIGxzdCB+Y29tcGFyZSA9XG4gIG1hdGNoIGZpbmRfYV9kdXAgbHN0IH5jb21wYXJlIHdpdGhcbiAgfCBTb21lIF8gLT4gdHJ1ZVxuICB8IE5vbmUgLT4gZmFsc2Vcbjs7XG5cbmxldCBmaW5kX2FsbF9kdXBzIGwgfmNvbXBhcmUgPVxuICAoKiBXZSBhZGQgdGhpcyByZXZlcnNhbCwgc28gd2UgY2FuIHNraXAgYSBbcmV2XSBhdCB0aGUgZW5kLiBXZSBjb3VsZCBza2lwXG4gICAgIFtyZXZdIGFueXdheSBzaW5jZSB3ZSBkb24gbm90IGdpdmUgYW55IG9yZGVyaW5nIGd1YXJhbnRlZXMsIGJ1dCBpdCBpc1xuICAgICBuaWNlIHRvIGdldCByZXN1bHRzIGluIG5hdHVyYWwgb3JkZXIuICopXG4gIGxldCBjb21wYXJlIGEgYiA9IC0xICogY29tcGFyZSBhIGIgaW5cbiAgbGV0IHNvcnRlZCA9IHNvcnQgfmNvbXBhcmUgbCBpblxuICAoKiBXYWxrIHRoZSBsaXN0IGFuZCByZWNvcmQgdGhlIGZpcnN0IG9mIGVhY2ggY29uc2VjdXRpdmUgcnVuIG9mIGlkZW50aWNhbCBlbGVtZW50cyAqKVxuICBsZXQgcmVjIGxvb3Agc29ydGVkIHByZXYgfmFscmVhZHlfcmVjb3JkZWQgYWNjID1cbiAgICBtYXRjaCBzb3J0ZWQgd2l0aFxuICAgIHwgW10gLT4gYWNjXG4gICAgfCBoZCA6OiB0bCAtPlxuICAgICAgaWYgY29tcGFyZSBwcmV2IGhkIDw+IDBcbiAgICAgIHRoZW4gbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDpmYWxzZSBhY2NcbiAgICAgIGVsc2UgaWYgYWxyZWFkeV9yZWNvcmRlZFxuICAgICAgdGhlbiBsb29wIHRsIGhkIH5hbHJlYWR5X3JlY29yZGVkOnRydWUgYWNjXG4gICAgICBlbHNlIGxvb3AgdGwgaGQgfmFscmVhZHlfcmVjb3JkZWQ6dHJ1ZSAoaGQgOjogYWNjKVxuICBpblxuICBtYXRjaCBzb3J0ZWQgd2l0aFxuICB8IFtdIC0+IFtdXG4gIHwgaGQgOjogdGwgLT4gbG9vcCB0bCBoZCB+YWxyZWFkeV9yZWNvcmRlZDpmYWxzZSBbXVxuOztcblxubGV0IHJlYyBhbGxfZXF1YWxfdG8gdCB2IH5lcXVhbCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFtdIC0+IHRydWVcbiAgfCB4IDo6IHhzIC0+IGVxdWFsIHggdiAmJiBhbGxfZXF1YWxfdG8geHMgdiB+ZXF1YWxcbjs7XG5cbmxldCBhbGxfZXF1YWwgdCB+ZXF1YWwgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBOb25lXG4gIHwgeCA6OiB4cyAtPiBpZiBhbGxfZXF1YWxfdG8geHMgeCB+ZXF1YWwgdGhlbiBTb21lIHggZWxzZSBOb25lXG47O1xuXG5sZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG5sZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcblxubGV0IGNvdW50aSB0IH5mID1cbiAgZm9sZGkgdCB+aW5pdDowIH5mOihmdW4gaWR4IGNvdW50IGEgLT4gaWYgZiBpZHggYSB0aGVuIGNvdW50ICsgMSBlbHNlIGNvdW50KVxuOztcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIG4gPCAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTGlzdC5pbml0ICVkXCIgbiAoKTtcbiAgbGV0IHJlYyBsb29wIGkgYWNjdW0gPVxuICAgIGFzc2VydCAoaSA+PSAwKTtcbiAgICBpZiBpID0gMCB0aGVuIGFjY3VtIGVsc2UgbG9vcCAoaSAtIDEpIChmIChpIC0gMSkgOjogYWNjdW0pXG4gIGluXG4gIGxvb3AgbiBbXVxuOztcblxubGV0IHJldl9maWx0ZXJfbWFwIGwgfmYgPVxuICBsZXQgcmVjIGxvb3AgbCBhY2N1bSA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgfCBbXSAtPiBhY2N1bVxuICAgIHwgaGQgOjogdGwgLT5cbiAgICAgIChtYXRjaCBmIGhkIHdpdGhcbiAgICAgICB8IFNvbWUgeCAtPiBsb29wIHRsICh4IDo6IGFjY3VtKVxuICAgICAgIHwgTm9uZSAtPiBsb29wIHRsIGFjY3VtKVxuICBpblxuICBsb29wIGwgW11cbjs7XG5cbmxldCBmaWx0ZXJfbWFwIGwgfmYgPSByZXYgKHJldl9maWx0ZXJfbWFwIGwgfmYpXG5cbmxldCByZXZfZmlsdGVyX21hcGkgbCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpIGwgYWNjdW0gPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gLT4gYWNjdW1cbiAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAobWF0Y2ggZiBpIGhkIHdpdGhcbiAgICAgICB8IFNvbWUgeCAtPiBsb29wIChpICsgMSkgdGwgKHggOjogYWNjdW0pXG4gICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKSB0bCBhY2N1bSlcbiAgaW5cbiAgbG9vcCAwIGwgW11cbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSBsIH5mID0gcmV2IChyZXZfZmlsdGVyX21hcGkgbCB+ZilcbmxldCBmaWx0ZXJfb3B0IGwgPSBmaWx0ZXJfbWFwIGwgfmY6Rm4uaWRcblxubGV0IHBhcnRpdGlvbjNfbWFwIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCBmc3Qgc25kIHRyZCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiByZXYgZnN0LCByZXYgc25kLCByZXYgdHJkXG4gICAgfCB4IDo6IHQgLT5cbiAgICAgIChtYXRjaCBmIHggd2l0aFxuICAgICAgIHwgYEZzdCB5IC0+IGxvb3AgdCAoeSA6OiBmc3QpIHNuZCB0cmRcbiAgICAgICB8IGBTbmQgeSAtPiBsb29wIHQgZnN0ICh5IDo6IHNuZCkgdHJkXG4gICAgICAgfCBgVHJkIHkgLT4gbG9vcCB0IGZzdCBzbmQgKHkgOjogdHJkKSlcbiAgaW5cbiAgbG9vcCB0IFtdIFtdIFtdXG47O1xuXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPVxuICBsZXQgZiB4IDogXyBFaXRoZXIudCA9IGlmIGYgeCB0aGVuIEZpcnN0IHggZWxzZSBTZWNvbmQgeCBpblxuICBwYXJ0aXRpb25fbWFwIHQgfmZcbjs7XG5cbmxldCBwYXJ0aXRpb25fcmVzdWx0IHQgPSBwYXJ0aXRpb25fbWFwIHQgfmY6UmVzdWx0LnRvX2VpdGhlclxuXG5tb2R1bGUgQXNzb2MgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhICogJ2IpIGxpc3QgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAnYSAnYi5cbiAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKVxuICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ2IpXG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKCdhLCAnYikgdFxuICAgID1cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wMjJfID0gXCJsaXN0Lm1sLkFzc29jLnRcIiBpblxuICAgIGZ1biBfb2ZfYV9fMDE0XyBfb2ZfYl9fMDE1XyB4X18wMjNfIC0+XG4gICAgICBsaXN0X29mX3NleHBcbiAgICAgICAgKGZ1bmN0aW9uXG4gICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wMTdfOyBhcmcxX18wMThfIF0gLT5cbiAgICAgICAgICAgIGxldCByZXMwX18wMTlfID0gX29mX2FfXzAxNF8gYXJnMF9fMDE3X1xuICAgICAgICAgICAgYW5kIHJlczFfXzAyMF8gPSBfb2ZfYl9fMDE1XyBhcmcxX18wMThfIGluXG4gICAgICAgICAgICByZXMwX18wMTlfLCByZXMxX18wMjBfXG4gICAgICAgICAgfCBzZXhwX18wMjFfIC0+XG4gICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkXG4gICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDIyX1xuICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgIHNleHBfXzAyMV8pXG4gICAgICAgIHhfXzAyM19cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnYSAnYi5cbiAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gX29mX2FfXzAyNF8gX29mX2JfXzAyNV8geF9fMDMwXyAtPlxuICAgICAgc2V4cF9vZl9saXN0XG4gICAgICAgIChmdW4gKGFyZzBfXzAyNl8sIGFyZzFfXzAyN18pIC0+XG4gICAgICAgICAgIGxldCByZXMwX18wMjhfID0gX29mX2FfXzAyNF8gYXJnMF9fMDI2X1xuICAgICAgICAgICBhbmQgcmVzMV9fMDI5XyA9IF9vZl9iX18wMjVfIGFyZzFfXzAyN18gaW5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMDI4XzsgcmVzMV9fMDI5XyBdKVxuICAgICAgICB4X18wMzBfXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgXydiX3NleHBfZ3JhbW1hciAtPlxuICAgICAgbGlzdF9zZXhwX2dyYW1tYXJcbiAgICAgICAgeyB1bnR5cGVkID1cbiAgICAgICAgICAgIExpc3QgKENvbnMgKF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZCwgQ29ucyAoXydiX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkpKVxuICAgICAgICB9XG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICBsZXQgcGFpcl9vZl9ncm91cCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhc3NlcnQgZmFsc2VcbiAgICB8IChrLCBfKSA6OiBfIGFzIGxpc3QgLT4gaywgbWFwIGxpc3QgfmY6c25kXG4gIDs7XG5cbiAgbGV0IGdyb3VwIGFsaXN0IH5lcXVhbCA9XG4gICAgZ3JvdXAgYWxpc3QgfmJyZWFrOihmdW4gKHgsIF8pICh5LCBfKSAtPiBub3QgKGVxdWFsIHggeSkpIHw+IG1hcCB+ZjpwYWlyX29mX2dyb3VwXG4gIDs7XG5cbiAgbGV0IHNvcnRfYW5kX2dyb3VwIGFsaXN0IH5jb21wYXJlID1cbiAgICBzb3J0X2FuZF9ncm91cCBhbGlzdCB+Y29tcGFyZTooZnVuICh4LCBfKSAoeSwgXykgLT4gY29tcGFyZSB4IHkpXG4gICAgfD4gbWFwIH5mOnBhaXJfb2ZfZ3JvdXBcbiAgOztcblxuICBsZXQgZmluZCB0IH5lcXVhbCBrZXkgPVxuICAgIG1hdGNoIGZpbmQgdCB+ZjooZnVuIChrZXknLCBfKSAtPiBlcXVhbCBrZXkga2V5Jykgd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gU29tZSAoc25kIHgpXG4gIDs7XG5cbiAgbGV0IGZpbmRfZXhuID1cbiAgICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJMaXN0LkFzc29jLmZpbmRfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgICBsZXQgZmluZF9leG4gdCB+ZXF1YWwga2V5ID1cbiAgICAgIG1hdGNoIGZpbmQgdCBrZXkgfmVxdWFsIHdpdGhcbiAgICAgIHwgTm9uZSAtPiByYWlzZSBub3RfZm91bmRcbiAgICAgIHwgU29tZSB2YWx1ZSAtPiB2YWx1ZVxuICAgIGluXG4gICAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICAgIGZpbmRfZXhuXG4gIDs7XG5cbiAgbGV0IG1lbSB0IH5lcXVhbCBrZXkgPVxuICAgIG1hdGNoIGZpbmQgdCB+ZXF1YWwga2V5IHdpdGhcbiAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgXyAtPiB0cnVlXG4gIDs7XG5cbiAgbGV0IHJlbW92ZSB0IH5lcXVhbCBrZXkgPSBmaWx0ZXIgdCB+ZjooZnVuIChrZXknLCBfKSAtPiBub3QgKGVxdWFsIGtleSBrZXknKSlcblxuICBsZXQgYWRkIHQgfmVxdWFsIGtleSB2YWx1ZSA9XG4gICAgKCogdGhlIHJlbW92ZSBkb2Vzbid0IGNoYW5nZSB0aGUgbWFwIHNlbWFudGljcywgYnV0IGtlZXBzIHRoZSBsaXN0IHNtYWxsICopXG4gICAgKGtleSwgdmFsdWUpIDo6IHJlbW92ZSB0IH5lcXVhbCBrZXlcbiAgOztcblxuICBsZXQgaW52ZXJzZSB0ID0gbWFwIHQgfmY6KGZ1biAoeCwgeSkgLT4geSwgeClcbiAgbGV0IG1hcCB0IH5mID0gbWFwIHQgfmY6KGZ1biAoa2V5LCB2YWx1ZSkgLT4ga2V5LCBmIHZhbHVlKVxuZW5kXG5cbmxldCBzdWIgbCB+cG9zIH5sZW4gPVxuICAoKiBXZSB1c2UgW3BvcyA+IGxlbmd0aCBsIC0gbGVuXSByYXRoZXIgdGhhbiBbcG9zICsgbGVuID4gbGVuZ3RoIGxdIHRvIGF2b2lkIHRoZVxuICAgICBwb3NzaWJpbGl0eSBvZiBvdmVyZmxvdy4gKilcbiAgaWYgcG9zIDwgMCB8fCBsZW4gPCAwIHx8IHBvcyA+IGxlbmd0aCBsIC0gbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJMaXN0LnN1YlwiO1xuICByZXZcbiAgICAoZm9sZGkgbCB+aW5pdDpbXSB+ZjooZnVuIGkgYWNjIGVsIC0+XG4gICAgICAgaWYgaSA+PSBwb3MgJiYgaSA8IHBvcyArIGxlbiB0aGVuIGVsIDo6IGFjYyBlbHNlIGFjYykpXG47O1xuXG5sZXQgc3BsaXRfbiB0X29yaWcgbiA9XG4gIGlmIG4gPD0gMFxuICB0aGVuIFtdLCB0X29yaWdcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIG4gdCBhY2N1bSA9XG4gICAgICBpZiBuID0gMFxuICAgICAgdGhlbiByZXYgYWNjdW0sIHRcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBbXSAtPiB0X29yaWcsIFtdICgqIGluIHRoaXMgY2FzZSwgdF9vcmlnID0gcmV2IGFjY3VtICopXG4gICAgICAgIHwgaGQgOjogdGwgLT4gbG9vcCAobiAtIDEpIHRsIChoZCA6OiBhY2N1bSkpXG4gICAgaW5cbiAgICBsb29wIG4gdF9vcmlnIFtdKVxuOztcblxuKCogY29waWVkIGZyb20gW3NwbGl0X25dIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSB0dXBsZSAqKVxubGV0IHRha2UgdF9vcmlnIG4gPVxuICBpZiBuIDw9IDBcbiAgdGhlbiBbXVxuICBlbHNlIChcbiAgICBsZXQgcmVjIGxvb3AgbiB0IGFjY3VtID1cbiAgICAgIGlmIG4gPSAwXG4gICAgICB0aGVuIHJldiBhY2N1bVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IFtdIC0+IHRfb3JpZ1xuICAgICAgICB8IGhkIDo6IHRsIC0+IGxvb3AgKG4gLSAxKSB0bCAoaGQgOjogYWNjdW0pKVxuICAgIGluXG4gICAgbG9vcCBuIHRfb3JpZyBbXSlcbjs7XG5cbmxldCByZWMgZHJvcCB0IG4gPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBfIDo6IHRsIHdoZW4gbiA+IDAgLT4gZHJvcCB0bCAobiAtIDEpXG4gIHwgdCAtPiB0XG47O1xuXG5sZXQgY2h1bmtzX29mIGwgfmxlbmd0aCA9XG4gIGlmIGxlbmd0aCA8PSAwIHRoZW4gaW52YWxpZF9hcmdmIFwiTGlzdC5jaHVua3Nfb2Y6IEV4cGVjdGVkIGxlbmd0aCA+IDAsIGdvdCAlZFwiIGxlbmd0aCAoKTtcbiAgbGV0IHJlYyBhdXggb2ZfbGVuZ3RoIGFjYyBsID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+IHJldiBhY2NcbiAgICB8IF8gOjogXyAtPlxuICAgICAgbGV0IHN1Ymxpc3QsIGwgPSBzcGxpdF9uIGwgbGVuZ3RoIGluXG4gICAgICBhdXggb2ZfbGVuZ3RoIChzdWJsaXN0IDo6IGFjYykgbFxuICBpblxuICBhdXggbGVuZ3RoIFtdIGxcbjs7XG5cbmxldCBzcGxpdF93aGlsZSB4cyB+ZiA9XG4gIGxldCByZWMgbG9vcCBhY2MgPSBmdW5jdGlvblxuICAgIHwgaGQgOjogdGwgd2hlbiBmIGhkIC0+IGxvb3AgKGhkIDo6IGFjYykgdGxcbiAgICB8IHQgLT4gcmV2IGFjYywgdFxuICBpblxuICBsb29wIFtdIHhzXG47O1xuXG4oKiBjb3BpZWQgZnJvbSBbc3BsaXRfd2hpbGVdIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSB0dXBsZSAqKVxubGV0IHRha2Vfd2hpbGUgeHMgfmYgPVxuICBsZXQgcmVjIGxvb3AgYWNjID0gZnVuY3Rpb25cbiAgICB8IGhkIDo6IHRsIHdoZW4gZiBoZCAtPiBsb29wIChoZCA6OiBhY2MpIHRsXG4gICAgfCBfIC0+IHJldiBhY2NcbiAgaW5cbiAgbG9vcCBbXSB4c1xuOztcblxubGV0IHJlYyBkcm9wX3doaWxlIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBoZCA6OiB0bCB3aGVuIGYgaGQgLT4gZHJvcF93aGlsZSB0bCB+ZlxuICB8IHQgLT4gdFxuOztcblxubGV0IGRyb3BfbGFzdCB0ID1cbiAgbWF0Y2ggcmV2IHQgd2l0aFxuICB8IFtdIC0+IE5vbmVcbiAgfCBfIDo6IGxzdCAtPiBTb21lIChyZXYgbHN0KVxuOztcblxubGV0IGRyb3BfbGFzdF9leG4gdCA9XG4gIG1hdGNoIGRyb3BfbGFzdCB0IHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiTGlzdC5kcm9wX2xhc3RfZXhuOiBlbXB0eSBsaXN0XCJcbiAgfCBTb21lIGxzdCAtPiBsc3Rcbjs7XG5cbmxldCBjYXJ0ZXNpYW5fcHJvZHVjdCBsaXN0MSBsaXN0MiA9XG4gIGlmIGlzX2VtcHR5IGxpc3QyXG4gIHRoZW4gW11cbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIGwxIGwyIGFjY3VtID1cbiAgICAgIG1hdGNoIGwxIHdpdGhcbiAgICAgIHwgW10gLT4gYWNjdW1cbiAgICAgIHwgaGQgOjogdGwgLT4gbG9vcCB0bCBsMiAocmV2X2FwcGVuZCAobWFwIH5mOihmdW4geCAtPiBoZCwgeCkgbDIpIGFjY3VtKVxuICAgIGluXG4gICAgcmV2IChsb29wIGxpc3QxIGxpc3QyIFtdKSlcbjs7XG5cbmxldCBjb25jYXQgbCA9IGZvbGRfcmlnaHQgbCB+aW5pdDpbXSB+ZjphcHBlbmRcbmxldCBjb25jYXRfbm9fb3JkZXIgbCA9IGZvbGQgbCB+aW5pdDpbXSB+ZjooZnVuIGFjYyBsIC0+IHJldl9hcHBlbmQgbCBhY2MpXG5sZXQgY29ucyB4IGwgPSB4IDo6IGxcblxubGV0IGlzX3NvcnRlZCBsIH5jb21wYXJlID1cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiB0cnVlXG4gICAgfCB4MSA6OiAoeDIgOjogXyBhcyByZXN0KSAtPiBjb21wYXJlIHgxIHgyIDw9IDAgJiYgbG9vcCByZXN0XG4gIGluXG4gIGxvb3AgbFxuOztcblxubGV0IGlzX3NvcnRlZF9zdHJpY3RseSBsIH5jb21wYXJlID1cbiAgbGV0IHJlYyBsb29wIGwgPVxuICAgIG1hdGNoIGwgd2l0aFxuICAgIHwgW10gfCBbIF8gXSAtPiB0cnVlXG4gICAgfCB4MSA6OiAoeDIgOjogXyBhcyByZXN0KSAtPiBjb21wYXJlIHgxIHgyIDwgMCAmJiBsb29wIHJlc3RcbiAgaW5cbiAgbG9vcCBsXG47O1xuXG5tb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgbGV0ICggQCApID0gYXBwZW5kXG5lbmRcblxubGV0IHBlcm11dGUgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbGlzdCA9XG4gIG1hdGNoIGxpc3Qgd2l0aFxuICAoKiBzcGVjaWFsIGNhc2VzIHRvIHNwZWVkIHRoaW5ncyB1cCBpbiB0cml2aWFsIGNhc2VzICopXG4gIHwgW10gfCBbIF8gXSAtPiBsaXN0XG4gIHwgWyB4OyB5IF0gLT4gaWYgUmFuZG9tLlN0YXRlLmJvb2wgcmFuZG9tX3N0YXRlIHRoZW4gWyB5OyB4IF0gZWxzZSBsaXN0XG4gIHwgXyAtPlxuICAgIGxldCBhcnIgPSBBcnJheS5vZl9saXN0IGxpc3QgaW5cbiAgICBBcnJheV9wZXJtdXRlLnBlcm11dGUgYXJyIH5yYW5kb21fc3RhdGU7XG4gICAgQXJyYXkudG9fbGlzdCBhcnJcbjs7XG5cbmxldCByYW5kb21fZWxlbWVudF9leG4gPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbGlzdCA9XG4gIGlmIGlzX2VtcHR5IGxpc3RcbiAgdGhlbiBmYWlsd2l0aCBcIkxpc3QucmFuZG9tX2VsZW1lbnRfZXhuOiBlbXB0eSBsaXN0XCJcbiAgZWxzZSBudGhfZXhuIGxpc3QgKFJhbmRvbS5TdGF0ZS5pbnQgcmFuZG9tX3N0YXRlIChsZW5ndGggbGlzdCkpXG47O1xuXG5sZXQgcmFuZG9tX2VsZW1lbnQgPyhyYW5kb21fc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgbGlzdCA9XG4gIHRyeSBTb21lIChyYW5kb21fZWxlbWVudF9leG4gfnJhbmRvbV9zdGF0ZSBsaXN0KSB3aXRoXG4gIHwgXyAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGNvbXBhcmUgY21wIGEgYiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IFtdLCBbXSAtPiAwXG4gIHwgW10sIF8gLT4gLTFcbiAgfCBfLCBbXSAtPiAxXG4gIHwgeCA6OiB4cywgeSA6OiB5cyAtPlxuICAgIGxldCBuID0gY21wIHggeSBpblxuICAgIGlmIG4gPSAwIHRoZW4gY29tcGFyZSBjbXAgeHMgeXMgZWxzZSBuXG47O1xuXG5sZXQgaGFzaF9mb2xkX3QgPSBoYXNoX2ZvbGRfbGlzdFxuXG5sZXQgZXF1YWwgZXF1YWwgdDEgdDIgPVxuICBsZXQgcmVjIGxvb3AgfmVxdWFsIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgW10sIFtdIC0+IHRydWVcbiAgICB8IHgxIDo6IHQxLCB4MiA6OiB0MiAtPiBlcXVhbCB4MSB4MiAmJiBsb29wIH5lcXVhbCB0MSB0MlxuICAgIHwgXyAtPiBmYWxzZVxuICBpblxuICBsb29wIH5lcXVhbCB0MSB0MlxuOztcblxubGV0IHRyYW5zcG9zZSA9XG4gIGxldCByZWMgc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiB0IGNvbHVtbl9hY2MgdHJpbW1lZCBmb3VuZF9lbXB0eSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBbXSAtPiBjb2x1bW5fYWNjLCB0cmltbWVkLCBmb3VuZF9lbXB0eVxuICAgIHwgW10gOjogdGwgLT4gc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiB0bCBjb2x1bW5fYWNjIHRyaW1tZWQgdHJ1ZVxuICAgIHwgKHggOjogeHMpIDo6IHRsIC0+XG4gICAgICBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHRsICh4IDo6IGNvbHVtbl9hY2MpICh4cyA6OiB0cmltbWVkKSBmb3VuZF9lbXB0eVxuICBpblxuICBsZXQgc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiByb3dzID0gc3BsaXRfb2ZmX2ZpcnN0X2NvbHVtbiByb3dzIFtdIFtdIGZhbHNlIGluXG4gIGxldCByZWMgbG9vcCByb3dzIGNvbHVtbnMgZG9fcmV2ID1cbiAgICBtYXRjaCBzcGxpdF9vZmZfZmlyc3RfY29sdW1uIHJvd3Mgd2l0aFxuICAgIHwgW10sIFtdLCBfIC0+IFNvbWUgKHJldiBjb2x1bW5zKVxuICAgIHwgY29sdW1uLCB0cmltbWVkX3Jvd3MsIGZvdW5kX2VtcHR5IC0+XG4gICAgICBpZiBmb3VuZF9lbXB0eVxuICAgICAgdGhlbiBOb25lXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGNvbHVtbiA9IGlmIGRvX3JldiB0aGVuIHJldiBjb2x1bW4gZWxzZSBjb2x1bW4gaW5cbiAgICAgICAgbG9vcCB0cmltbWVkX3Jvd3MgKGNvbHVtbiA6OiBjb2x1bW5zKSAobm90IGRvX3JldikpXG4gIGluXG4gIGZ1biB0IC0+IGxvb3AgdCBbXSB0cnVlXG47O1xuXG5leGNlcHRpb24gVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3RocyBvZiBpbnQgbGlzdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF1cblxubGV0ICgpID1cbiAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgWyVleHRlbnNpb25fY29uc3RydWN0b3IgVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3Roc11cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3RocyBhcmcwX18wMzFfIC0+XG4gICAgICAgIGxldCByZXMwX18wMzJfID0gc2V4cF9vZl9saXN0IHNleHBfb2ZfaW50IGFyZzBfXzAzMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJsaXN0Lm1sLlRyYW5zcG9zZV9nb3RfbGlzdHNfb2ZfZGlmZmVyZW50X2xlbmd0aHNcIlxuICAgICAgICAgIDsgcmVzMF9fMDMyX1xuICAgICAgICAgIF1cbiAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgdHJhbnNwb3NlX2V4biBsID1cbiAgbWF0Y2ggdHJhbnNwb3NlIGwgd2l0aFxuICB8IFNvbWUgbCAtPiBsXG4gIHwgTm9uZSAtPiByYWlzZSAoVHJhbnNwb3NlX2dvdF9saXN0c19vZl9kaWZmZXJlbnRfbGVuZ3RocyAobWFwIGwgfmY6bGVuZ3RoKSlcbjs7XG5cbmxldCBpbnRlcnNwZXJzZSB0IH5zZXAgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBbXSAtPiBbXVxuICB8IHggOjogeHMgLT4geCA6OiBmb2xkX3JpZ2h0IHhzIH5pbml0OltdIH5mOihmdW4geSBhY2MgLT4gc2VwIDo6IHkgOjogYWNjKVxuOztcblxubGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHRcblxubGV0IGlzX3N1ZmZpeCBsaXN0IH5zdWZmaXggfmVxdWFsOmVxdWFsX2VsdCA9XG4gIGxldCBsaXN0X2xlbiA9IGxlbmd0aCBsaXN0IGluXG4gIGxldCBzdWZmaXhfbGVuID0gbGVuZ3RoIHN1ZmZpeCBpblxuICBsaXN0X2xlbiA+PSBzdWZmaXhfbGVuICYmIGVxdWFsIGVxdWFsX2VsdCAoZHJvcCBsaXN0IChsaXN0X2xlbiAtIHN1ZmZpeF9sZW4pKSBzdWZmaXhcbjs7XG4iLCIoKiBUaGlzIG1vZHVsZSBpcyB0cnlpbmcgdG8gbWluaW1pemUgZGVwZW5kZW5jaWVzIG9uIG1vZHVsZXMgaW4gQ29yZSwgc28gYXMgdG8gYWxsb3dcbiAgIFtJbmZvXSwgW0Vycm9yXSwgYW5kIFtPcl9lcnJvcl0gdG8gYmUgdXNlZCBpbiBhcyBtYW55IHBsYWNlcyBhcyBwb3NzaWJsZS4gUGxlYXNlIGF2b2lkXG4gICBhZGRpbmcgbmV3IGRlcGVuZGVuY2llcy4gKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEluZm9faW50ZlxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcblxubW9kdWxlIE1lc3NhZ2UgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB8IENvdWxkX25vdF9jb25zdHJ1Y3Qgb2YgU2V4cC50XG4gICAgfCBTdHJpbmcgb2Ygc3RyaW5nXG4gICAgfCBFeG4gb2YgZXhuXG4gICAgfCBTZXhwIG9mIFNleHAudFxuICAgIHwgVGFnX3NleHAgb2Ygc3RyaW5nICogU2V4cC50ICogU291cmNlX2NvZGVfcG9zaXRpb24wLnQgb3B0aW9uXG4gICAgfCBUYWdfdCBvZiBzdHJpbmcgKiB0XG4gICAgfCBUYWdfYXJnIG9mIHN0cmluZyAqIFNleHAudCAqIHRcbiAgICB8IE9mX2xpc3Qgb2YgaW50IG9wdGlvbiAqIHQgbGlzdFxuICAgIHwgV2l0aF9iYWNrdHJhY2Ugb2YgdCAqIHN0cmluZyAoKiBiYWNrdHJhY2UgKilcbiAgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgbGV0IHJlYyBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IGFyZzBfXzAwMV8gLT5cbiAgICAgICAgbGV0IHJlczBfXzAwMl8gPSBTZXhwLnNleHBfb2ZfdCBhcmcwX18wMDFfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkNvdWxkX25vdF9jb25zdHJ1Y3RcIjsgcmVzMF9fMDAyXyBdXG4gICAgICB8IFN0cmluZyBhcmcwX18wMDNfIC0+XG4gICAgICAgIGxldCByZXMwX18wMDRfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDAzXyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJTdHJpbmdcIjsgcmVzMF9fMDA0XyBdXG4gICAgICB8IEV4biBhcmcwX18wMDVfIC0+XG4gICAgICAgIGxldCByZXMwX18wMDZfID0gc2V4cF9vZl9leG4gYXJnMF9fMDA1XyBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJFeG5cIjsgcmVzMF9fMDA2XyBdXG4gICAgICB8IFNleHAgYXJnMF9fMDA3XyAtPlxuICAgICAgICBsZXQgcmVzMF9fMDA4XyA9IFNleHAuc2V4cF9vZl90IGFyZzBfXzAwN18gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiU2V4cFwiOyByZXMwX18wMDhfIF1cbiAgICAgIHwgVGFnX3NleHAgKGFyZzBfXzAwOV8sIGFyZzFfXzAxMF8sIGFyZzJfXzAxMV8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMTJfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDA5X1xuICAgICAgICBhbmQgcmVzMV9fMDEzXyA9IFNleHAuc2V4cF9vZl90IGFyZzFfXzAxMF9cbiAgICAgICAgYW5kIHJlczJfXzAxNF8gPSBzZXhwX29mX29wdGlvbiBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90IGFyZzJfXzAxMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJUYWdfc2V4cFwiOyByZXMwX18wMTJfOyByZXMxX18wMTNfOyByZXMyX18wMTRfIF1cbiAgICAgIHwgVGFnX3QgKGFyZzBfXzAxNV8sIGFyZzFfXzAxNl8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMTdfID0gc2V4cF9vZl9zdHJpbmcgYXJnMF9fMDE1X1xuICAgICAgICBhbmQgcmVzMV9fMDE4XyA9IHNleHBfb2ZfdCBhcmcxX18wMTZfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlRhZ190XCI7IHJlczBfXzAxN187IHJlczFfXzAxOF8gXVxuICAgICAgfCBUYWdfYXJnIChhcmcwX18wMTlfLCBhcmcxX18wMjBfLCBhcmcyX18wMjFfKSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDIyXyA9IHNleHBfb2Zfc3RyaW5nIGFyZzBfXzAxOV9cbiAgICAgICAgYW5kIHJlczFfXzAyM18gPSBTZXhwLnNleHBfb2ZfdCBhcmcxX18wMjBfXG4gICAgICAgIGFuZCByZXMyX18wMjRfID0gc2V4cF9vZl90IGFyZzJfXzAyMV8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJUYWdfYXJnXCI7IHJlczBfXzAyMl87IHJlczFfXzAyM187IHJlczJfXzAyNF8gXVxuICAgICAgfCBPZl9saXN0IChhcmcwX18wMjVfLCBhcmcxX18wMjZfKSAtPlxuICAgICAgICBsZXQgcmVzMF9fMDI3XyA9IHNleHBfb2Zfb3B0aW9uIHNleHBfb2ZfaW50IGFyZzBfXzAyNV9cbiAgICAgICAgYW5kIHJlczFfXzAyOF8gPSBzZXhwX29mX2xpc3Qgc2V4cF9vZl90IGFyZzFfXzAyNl8gaW5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiT2ZfbGlzdFwiOyByZXMwX18wMjdfOyByZXMxX18wMjhfIF1cbiAgICAgIHwgV2l0aF9iYWNrdHJhY2UgKGFyZzBfXzAyOV8sIGFyZzFfXzAzMF8pIC0+XG4gICAgICAgIGxldCByZXMwX18wMzFfID0gc2V4cF9vZl90IGFyZzBfXzAyOV9cbiAgICAgICAgYW5kIHJlczFfXzAzMl8gPSBzZXhwX29mX3N0cmluZyBhcmcxX18wMzBfIGluXG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIldpdGhfYmFja3RyYWNlXCI7IHJlczBfXzAzMV87IHJlczFfXzAzMl8gXVxuICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IHJlYyB0b19zdHJpbmdzX2h1bSB0IGFjID1cbiAgICAoKiBXZSB1c2UgW1NleHAudG9fc3RyaW5nX21hY2hdLCBkZXNwaXRlIHRoZSBmYWN0IHRoYXQgd2UgYXJlIGltcGxlbWVudGluZ1xuICAgICAgIFt0b19zdHJpbmdzX2h1bV0sIGJlY2F1c2Ugd2Ugd2FudCB0aGUgaW5mbyB0byBmaXQgb24gYSBzaW5nbGUgbGluZSwgYW5kIG9uY2Ugd2UndmVcbiAgICAgICBoYWQgdG8gcmVzb3J0IHRvIHNleHBzLCB0aGUgbWVzc2FnZSBpcyBnb2luZyB0byBzdGFydCBub3QgbG9va2luZyBzbyBwcmV0dHlcbiAgICAgICBhbnl3YXkuICopXG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBDb3VsZF9ub3RfY29uc3RydWN0IHNleHAgLT5cbiAgICAgIFwiY291bGQgbm90IGNvbnN0cnVjdCBpbmZvOiBcIiA6OiBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHAgOjogYWNcbiAgICB8IFN0cmluZyBzdHJpbmcgLT4gc3RyaW5nIDo6IGFjXG4gICAgfCBFeG4gZXhuIC0+IFNleHAudG9fc3RyaW5nX21hY2ggKEV4bi5zZXhwX29mX3QgZXhuKSA6OiBhY1xuICAgIHwgU2V4cCBzZXhwIC0+IFNleHAudG9fc3RyaW5nX21hY2ggc2V4cCA6OiBhY1xuICAgIHwgVGFnX3NleHAgKHRhZywgc2V4cCwgXykgLT4gdGFnIDo6IFwiOiBcIiA6OiBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHAgOjogYWNcbiAgICB8IFRhZ190ICh0YWcsIHQpIC0+IHRhZyA6OiBcIjogXCIgOjogdG9fc3RyaW5nc19odW0gdCBhY1xuICAgIHwgVGFnX2FyZyAodGFnLCBzZXhwLCB0KSAtPlxuICAgICAgbGV0IGJvZHkgPSBTZXhwLnRvX3N0cmluZ19tYWNoIHNleHAgOjogXCI6IFwiIDo6IHRvX3N0cmluZ3NfaHVtIHQgYWMgaW5cbiAgICAgIGlmIFN0cmluZy5sZW5ndGggdGFnID0gMCB0aGVuIGJvZHkgZWxzZSB0YWcgOjogXCI6IFwiIDo6IGJvZHlcbiAgICB8IFdpdGhfYmFja3RyYWNlICh0LCBiYWNrdHJhY2UpIC0+XG4gICAgICB0b19zdHJpbmdzX2h1bSB0IChcIlxcbkJhY2t0cmFjZTpcXG5cIiA6OiBiYWNrdHJhY2UgOjogYWMpXG4gICAgfCBPZl9saXN0ICh0cnVuY19hZnRlciwgdHMpIC0+XG4gICAgICBsZXQgdHMgPVxuICAgICAgICBtYXRjaCB0cnVuY19hZnRlciB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiB0c1xuICAgICAgICB8IFNvbWUgbWF4IC0+XG4gICAgICAgICAgbGV0IG4gPSBMaXN0Lmxlbmd0aCB0cyBpblxuICAgICAgICAgIGlmIG4gPD0gbWF4XG4gICAgICAgICAgdGhlbiB0c1xuICAgICAgICAgIGVsc2UgTGlzdC50YWtlIHRzIG1heCBAIFsgU3RyaW5nIChQcmludGYuc3ByaW50ZiBcImFuZCAlZCBtb3JlIGluZm9cIiAobiAtIG1heCkpIF1cbiAgICAgIGluXG4gICAgICBMaXN0LmZvbGQgKExpc3QucmV2IHRzKSB+aW5pdDphYyB+ZjooZnVuIGFjIHQgLT5cbiAgICAgICAgdG9fc3RyaW5nc19odW0gdCAoaWYgTGlzdC5pc19lbXB0eSBhYyB0aGVuIGFjIGVsc2UgXCI7IFwiIDo6IGFjKSlcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nX2h1bV9kZXByZWNhdGVkIHQgPSBTdHJpbmcuY29uY2F0ICh0b19zdHJpbmdzX2h1bSB0IFtdKVxuXG4gIGxldCByZWMgdG9fc2V4cHNfaHVtIHQgYWMgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgQ291bGRfbm90X2NvbnN0cnVjdCBfIGFzIHQgLT4gc2V4cF9vZl90IHQgOjogYWNcbiAgICB8IFN0cmluZyBzdHJpbmcgLT4gQXRvbSBzdHJpbmcgOjogYWNcbiAgICB8IEV4biBleG4gLT4gRXhuLnNleHBfb2ZfdCBleG4gOjogYWNcbiAgICB8IFNleHAgc2V4cCAtPiBzZXhwIDo6IGFjXG4gICAgfCBUYWdfc2V4cCAodGFnLCBzZXhwLCBoZXJlKSAtPlxuICAgICAgTGlzdFxuICAgICAgICAoQXRvbSB0YWdcbiAgICAgICAgIDo6IHNleHBcbiAgICAgICAgIDo6XG4gICAgICAgICAobWF0Y2ggaGVyZSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IFtdXG4gICAgICAgICAgfCBTb21lIGhlcmUgLT4gWyBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90IGhlcmUgXSkpXG4gICAgICA6OiBhY1xuICAgIHwgVGFnX3QgKHRhZywgdCkgLT4gTGlzdCAoQXRvbSB0YWcgOjogdG9fc2V4cHNfaHVtIHQgW10pIDo6IGFjXG4gICAgfCBUYWdfYXJnICh0YWcsIHNleHAsIHQpIC0+XG4gICAgICBsZXQgYm9keSA9IHNleHAgOjogdG9fc2V4cHNfaHVtIHQgW10gaW5cbiAgICAgIGlmIFN0cmluZy5sZW5ndGggdGFnID0gMCB0aGVuIExpc3QgYm9keSA6OiBhYyBlbHNlIExpc3QgKEF0b20gdGFnIDo6IGJvZHkpIDo6IGFjXG4gICAgfCBXaXRoX2JhY2t0cmFjZSAodCwgYmFja3RyYWNlKSAtPlxuICAgICAgU2V4cC5MaXN0IFsgdG9fc2V4cF9odW0gdDsgU2V4cC5BdG9tIGJhY2t0cmFjZSBdIDo6IGFjXG4gICAgfCBPZl9saXN0IChfLCB0cykgLT5cbiAgICAgIExpc3QuZm9sZCAoTGlzdC5yZXYgdHMpIH5pbml0OmFjIH5mOihmdW4gYWMgdCAtPiB0b19zZXhwc19odW0gdCBhYylcblxuICBhbmQgdG9fc2V4cF9odW0gdCA9XG4gICAgbWF0Y2ggdG9fc2V4cHNfaHVtIHQgW10gd2l0aFxuICAgIHwgWyBzZXhwIF0gLT4gc2V4cFxuICAgIHwgc2V4cHMgLT4gU2V4cC5MaXN0IHNleHBzXG4gIDs7XG5cbiAgKCogV2UgdXNlIFtwcm90ZWN0XSB0byBndWFyZCBhZ2FpbnN0IGV4Y2VwdGlvbnMgcmFpc2VkIGJ5IHVzZXItc3VwcGxpZWQgZnVuY3Rpb25zLCBzb1xuICAgICB0aGF0IGZhaWx1cmUgdG8gcHJvZHVjZSBvbmUgcGFydCBvZiBhbiBpbmZvIGRvZXNuJ3QgaW50ZXJmZXJlIHdpdGggb3RoZXIgcGFydHMuICopXG4gIGxldCBwcm90ZWN0IGYgPVxuICAgIHRyeSBmICgpIHdpdGhcbiAgICB8IGV4biAtPiBDb3VsZF9ub3RfY29uc3RydWN0IChFeG4uc2V4cF9vZl90IGV4bilcbiAgOztcblxuICBsZXQgb2ZfaW5mbyBpbmZvID0gcHJvdGVjdCAoZnVuICgpIC0+IExhenkuZm9yY2UgaW5mbylcbiAgbGV0IHRvX2luZm8gdCA9IGxhenkgdFxuZW5kXG5cbm9wZW4gTWVzc2FnZVxuXG50eXBlIHQgPSBNZXNzYWdlLnQgTGF6eS50XG5cbmxldCBpbnZhcmlhbnQgXyA9ICgpXG5sZXQgdG9fbWVzc2FnZSA9IE1lc3NhZ2Uub2ZfaW5mb1xubGV0IG9mX21lc3NhZ2UgPSBNZXNzYWdlLnRvX2luZm9cblxuKCogSXQgaXMgT0sgdG8gdXNlIFtNZXNzYWdlLnRvX3NleHBfaHVtXSwgd2hpY2ggaXMgbm90IHN0YWJsZSwgYmVjYXVzZSBbdF9vZl9zZXhwXSBiZWxvd1xuICAgY2FuIGhhbmRsZSBhbnkgc2V4cC4gKilcbmxldCBzZXhwX29mX3QgdCA9IE1lc3NhZ2UudG9fc2V4cF9odW0gKHRvX21lc3NhZ2UgdClcbmxldCB0X29mX3NleHAgc2V4cCA9IGxhenkgKE1lc3NhZ2UuU2V4cCBzZXhwKVxubGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0geyB1bnR5cGVkID0gQW55IFwiSW5mby50XCIgfVxubGV0IGNvbXBhcmUgdDEgdDIgPSBTZXhwLmNvbXBhcmUgKHNleHBfb2ZfdCB0MSkgKHNleHBfb2ZfdCB0MilcbmxldCBlcXVhbCB0MSB0MiA9IFNleHAuZXF1YWwgKHNleHBfb2ZfdCB0MSkgKHNleHBfb2ZfdCB0MilcbmxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gU2V4cC5oYXNoX2ZvbGRfdCBzdGF0ZSAoc2V4cF9vZl90IHQpXG5sZXQgaGFzaCB0ID0gSGFzaC5ydW4gaGFzaF9mb2xkX3QgdFxuXG5sZXQgdG9fc3RyaW5nX2h1bSB0ID1cbiAgbWF0Y2ggdG9fbWVzc2FnZSB0IHdpdGhcbiAgfCBTdHJpbmcgcyAtPiBzXG4gIHwgbWVzc2FnZSAtPiBTZXhwLnRvX3N0cmluZ19odW0gKE1lc3NhZ2UudG9fc2V4cF9odW0gbWVzc2FnZSlcbjs7XG5cbmxldCB0b19zdHJpbmdfaHVtX2RlcHJlY2F0ZWQgdCA9IE1lc3NhZ2UudG9fc3RyaW5nX2h1bV9kZXByZWNhdGVkICh0b19tZXNzYWdlIHQpXG5sZXQgdG9fc3RyaW5nX21hY2ggdCA9IFNleHAudG9fc3RyaW5nX21hY2ggKHNleHBfb2ZfdCB0KVxubGV0IG9mX2xhenkgbCA9IGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBTdHJpbmcgKExhenkuZm9yY2UgbCkpKVxubGV0IG9mX2xhenlfc2V4cCBsID0gbGF6eSAocHJvdGVjdCAoZnVuICgpIC0+IFNleHAgKExhenkuZm9yY2UgbCkpKVxubGV0IG9mX2xhenlfdCBsYXp5X3QgPSBMYXp5LmpvaW4gbGF6eV90XG5sZXQgb2Zfc3RyaW5nIG1lc3NhZ2UgPSBMYXp5LmZyb21fdmFsIChTdHJpbmcgbWVzc2FnZSlcbmxldCBjcmVhdGVmIGZvcm1hdCA9IFByaW50Zi5rc3ByaW50ZiBvZl9zdHJpbmcgZm9ybWF0XG5sZXQgb2ZfdGh1bmsgZiA9IGxhenkgKHByb3RlY3QgKGZ1biAoKSAtPiBTdHJpbmcgKGYgKCkpKSlcblxubGV0IGNyZWF0ZSA/aGVyZSA/c3RyaWN0IHRhZyB4IHNleHBfb2ZfeCA9XG4gIG1hdGNoIHN0cmljdCB3aXRoXG4gIHwgTm9uZSAtPiBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gVGFnX3NleHAgKHRhZywgc2V4cF9vZl94IHgsIGhlcmUpKSlcbiAgfCBTb21lICgpIC0+IG9mX21lc3NhZ2UgKFRhZ19zZXhwICh0YWcsIHNleHBfb2ZfeCB4LCBoZXJlKSlcbjs7XG5cbmxldCBjcmVhdGVfcyBzZXhwID0gTGF6eS5mcm9tX3ZhbCAoU2V4cCBzZXhwKVxubGV0IHRhZyB0IH50YWcgPSBsYXp5IChUYWdfdCAodGFnLCB0b19tZXNzYWdlIHQpKVxuXG5sZXQgdGFnX3NfbGF6eSB0IH50YWcgPVxuICBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gVGFnX2FyZyAoXCJcIiwgTGF6eS5mb3JjZSB0YWcsIHRvX21lc3NhZ2UgdCkpKVxuOztcblxubGV0IHRhZ19zIHQgfnRhZyA9IHRhZ19zX2xhenkgdCB+dGFnOihMYXp5LmZyb21fdmFsIHRhZylcblxubGV0IHRhZ19hcmcgdCB0YWcgeCBzZXhwX29mX3ggPVxuICBsYXp5IChwcm90ZWN0IChmdW4gKCkgLT4gVGFnX2FyZyAodGFnLCBzZXhwX29mX3ggeCwgdG9fbWVzc2FnZSB0KSkpXG47O1xuXG5sZXQgb2ZfbGlzdCA/dHJ1bmNfYWZ0ZXIgdHMgPSBsYXp5IChPZl9saXN0ICh0cnVuY19hZnRlciwgTGlzdC5tYXAgdHMgfmY6dG9fbWVzc2FnZSkpXG5cbmV4Y2VwdGlvbiBFeG4gb2YgdFxuXG5sZXQgKCkgPVxuICAoKiBXZSBpbnN0YWxsIGEgY3VzdG9tIGV4bi1jb252ZXJ0ZXIgcmF0aGVyIHRoYW4gdXNlXG4gICAgIFtleGNlcHRpb24gRXhuIG9mIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdIC4uLiBbQEBAZW5kXV0gdG8gZWxpbWluYXRlIHRoZSBleHRyYVxuICAgICB3cmFwcGluZyBvZiBcIihFeG4gLi4uKVwiLiAqKVxuICBTZXhwbGliMC5TZXhwX2NvbnYuRXhuX2NvbnZlcnRlci5hZGQgWyVleHRlbnNpb25fY29uc3RydWN0b3IgRXhuXSAoZnVuY3Rpb25cbiAgICB8IEV4biB0IC0+IHNleHBfb2ZfdCB0XG4gICAgfCBfIC0+XG4gICAgICAoKiBSZWFjaGluZyB0aGlzIGJyYW5jaCBpbmRpY2F0ZXMgYSBidWcgaW4gc2V4cGxpYi4gKilcbiAgICAgIGFzc2VydCBmYWxzZSlcbjs7XG5cbmxldCB0b19leG4gdCA9XG4gIGlmIG5vdCAoTGF6eS5pc192YWwgdClcbiAgdGhlbiBFeG4gdFxuICBlbHNlIChcbiAgICBtYXRjaCBMYXp5LmZvcmNlIHQgd2l0aFxuICAgIHwgTWVzc2FnZS5FeG4gZXhuIC0+IGV4blxuICAgIHwgXyAtPiBFeG4gdClcbjs7XG5cbmxldCBvZl9leG4gP2JhY2t0cmFjZSBleG4gPVxuICBsZXQgYmFja3RyYWNlID1cbiAgICBtYXRjaCBiYWNrdHJhY2Ugd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIGBHZXQgLT4gU29tZSAoQ2FtbC5QcmludGV4Yy5nZXRfYmFja3RyYWNlICgpKVxuICAgIHwgU29tZSAoYFRoaXMgcykgLT4gU29tZSBzXG4gIGluXG4gIG1hdGNoIGV4biwgYmFja3RyYWNlIHdpdGhcbiAgfCBFeG4gdCwgTm9uZSAtPiB0XG4gIHwgRXhuIHQsIFNvbWUgYmFja3RyYWNlIC0+IGxhenkgKFdpdGhfYmFja3RyYWNlICh0b19tZXNzYWdlIHQsIGJhY2t0cmFjZSkpXG4gIHwgXywgTm9uZSAtPiBMYXp5LmZyb21fdmFsIChNZXNzYWdlLkV4biBleG4pXG4gIHwgXywgU29tZSBiYWNrdHJhY2UgLT4gbGF6eSAoV2l0aF9iYWNrdHJhY2UgKFNleHAgKEV4bi5zZXhwX29mX3QgZXhuKSwgYmFja3RyYWNlKSlcbjs7XG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW5mb1wiXG4gICAgbGV0IHBwIHBwZiB0ID0gQ2FtbC5Gb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiAodG9fc3RyaW5nX2h1bSB0KVxuICBlbmQpXG5cbm1vZHVsZSBJbnRlcm5hbF9yZXByID0gTWVzc2FnZVxuXG4iLCIoKiBUaGlzIG1vZHVsZSBpcyB0cnlpbmcgdG8gbWluaW1pemUgZGVwZW5kZW5jaWVzIG9uIG1vZHVsZXMgaW4gQ29yZSwgc28gYXMgdG8gYWxsb3dcbiAgIFtFcnJvcl0gYW5kIFtPcl9lcnJvcl0gdG8gYmUgdXNlZCBpbiB2YXJpb3VzIHBsYWNlcy4gIFBsZWFzZSBhdm9pZCBhZGRpbmcgbmV3XG4gICBkZXBlbmRlbmNpZXMuICopXG5cbm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbmZvXG5cbmxldCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBBbnkgXCJFcnJvci50XCIgfVxubGV0IHJhaXNlIHQgPSByYWlzZSAodG9fZXhuIHQpXG5sZXQgcmFpc2VfcyBzZXhwID0gcmFpc2UgKGNyZWF0ZV9zIHNleHApXG5sZXQgdG9faW5mbyB0ID0gdFxubGV0IG9mX2luZm8gdCA9IHRcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3Rlcl9wcCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5FcnJvclwiXG4gICAgbGV0IHBwID0gcHBcbiAgZW5kKVxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEludmFyaWFudF9pbnRmXG5cbmxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG5sZXQgaW52YXJpYW50IGhlcmUgdCBzZXhwX29mX3QgZiA6IHVuaXQgPVxuICB0cnkgZiAoKSB3aXRoXG4gIHwgZXhuIC0+XG4gICAgcmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJpbnZhcmlhbnQgZmFpbGVkXCJcbiAgICAgICAgIFsgXCJcIiwgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdCBoZXJlXG4gICAgICAgICA7IFwiZXhuXCIsIHNleHBfb2ZfZXhuIGV4blxuICAgICAgICAgOyBcIlwiLCBzZXhwX29mX3QgdFxuICAgICAgICAgXSlcbjs7XG5cbmxldCBjaGVja19maWVsZCB0IGYgZmllbGQgPVxuICB0cnkgZiAoRmllbGQuZ2V0IGZpZWxkIHQpIHdpdGhcbiAgfCBleG4gLT5cbiAgICByYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcInByb2JsZW0gd2l0aCBmaWVsZFwiXG4gICAgICAgICBbIFwiZmllbGRcIiwgc2V4cF9vZl9zdHJpbmcgKEZpZWxkLm5hbWUgZmllbGQpOyBcImV4blwiLCBzZXhwX29mX2V4biBleG4gXSlcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuaW5jbHVkZSAoXG4gIFJlc3VsdCA6XG4gICAgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBSZXN1bHRcbiAgZW5kXG4gIHdpdGggbW9kdWxlIEVycm9yIDo9IFJlc3VsdC5FcnJvcilcblxudHlwZSAnYSB0ID0gKCdhLCBFcnJvci50KSBSZXN1bHQudFxuW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBjb21wYXJlIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHQgLT4gJ2EgdCAtPiBpbnQgPVxuICBmdW4gX2NtcF9fYSBhX18wMDFfIGJfXzAwMl8gLT4gUmVzdWx0LmNvbXBhcmUgX2NtcF9fYSBFcnJvci5jb21wYXJlIGFfXzAwMV8gYl9fMDAyX1xuOztcblxubGV0IGVxdWFsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbCA9XG4gIGZ1biBfY21wX19hIGFfXzAwN18gYl9fMDA4XyAtPiBSZXN1bHQuZXF1YWwgX2NtcF9fYSBFcnJvci5lcXVhbCBhX18wMDdfIGJfXzAwOF9cbjs7XG5cbmxldCBoYXNoX2ZvbGRfdCA6XG4gICdhLlxuICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gIC0+ICdhIHRcbiAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gID1cbiAgZnVuIF9oYXNoX2ZvbGRfYSBoc3YgYXJnIC0+IFJlc3VsdC5oYXNoX2ZvbGRfdCBfaGFzaF9mb2xkX2EgRXJyb3IuaGFzaF9mb2xkX3QgaHN2IGFyZ1xuOztcblxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9XG4gIGZ1biBfb2ZfYV9fMDEzXyB4X18wMTVfIC0+IFJlc3VsdC50X29mX3NleHAgX29mX2FfXzAxM18gRXJyb3IudF9vZl9zZXhwIHhfXzAxNV9cbjs7XG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAxNl8geF9fMDE3XyAtPiBSZXN1bHQuc2V4cF9vZl90IF9vZl9hX18wMTZfIEVycm9yLnNleHBfb2ZfdCB4X18wMTdfXG47O1xuXG5sZXQgKHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBSZXN1bHQudF9zZXhwX2dyYW1tYXIgXydhX3NleHBfZ3JhbW1hciBFcnJvci50X3NleHBfZ3JhbW1hclxuOztcblxuW0BAQGVuZF1cblxubGV0IGludmFyaWFudCBpbnZhcmlhbnRfYSB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgT2sgYSAtPiBpbnZhcmlhbnRfYSBhXG4gIHwgRXJyb3IgZXJyb3IgLT4gRXJyb3IuaW52YXJpYW50IGVycm9yXG47O1xuXG5pbmNsdWRlIEFwcGxpY2F0aXZlLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgICBsZXQgYXBwbHkgZiB4ID1cbiAgICAgIFJlc3VsdC5jb21iaW5lIGYgeCB+b2s6KGZ1biBmIHggLT4gZiB4KSB+ZXJyOihmdW4gZTEgZTIgLT4gRXJyb3Iub2ZfbGlzdCBbIGUxOyBlMiBdKVxuICAgIDs7XG5cbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgZW5kKVxuXG5tb2R1bGUgTGV0X3N5bnRheCA9IHN0cnVjdFxuICBsZXQgcmV0dXJuID0gcmV0dXJuXG5cbiAgaW5jbHVkZSBNb25hZF9pbmZpeFxuXG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBtYXAgPSBtYXBcbiAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBsZXQgYm90aCA9IGJvdGhcblxuICAgICgqIGZyb20gQXBwbGljYXRpdmUuTWFrZSAqKVxuICAgIG1vZHVsZSBPcGVuX29uX3JocyA9IHN0cnVjdCBlbmRcbiAgZW5kXG5lbmRcblxubGV0IG9rID0gUmVzdWx0Lm9rXG5sZXQgaXNfb2sgPSBSZXN1bHQuaXNfb2tcbmxldCBpc19lcnJvciA9IFJlc3VsdC5pc19lcnJvclxuXG5sZXQgdHJ5X3dpdGggPyhiYWNrdHJhY2UgPSBmYWxzZSkgZiA9XG4gIHRyeSBPayAoZiAoKSkgd2l0aFxuICB8IGV4biAtPiBFcnJvciAoRXJyb3Iub2ZfZXhuIGV4biA/YmFja3RyYWNlOihpZiBiYWNrdHJhY2UgdGhlbiBTb21lIGBHZXQgZWxzZSBOb25lKSlcbjs7XG5cbmxldCB0cnlfd2l0aF9qb2luID9iYWNrdHJhY2UgZiA9IGpvaW4gKHRyeV93aXRoID9iYWNrdHJhY2UgZilcblxubGV0IG9rX2V4biA9IGZ1bmN0aW9uXG4gIHwgT2sgeCAtPiB4XG4gIHwgRXJyb3IgZXJyIC0+IEVycm9yLnJhaXNlIGVyclxuOztcblxubGV0IG9mX2V4biA/YmFja3RyYWNlIGV4biA9IEVycm9yIChFcnJvci5vZl9leG4gP2JhY2t0cmFjZSBleG4pXG5cbmxldCBvZl9leG5fcmVzdWx0ID9iYWNrdHJhY2UgPSBmdW5jdGlvblxuICB8IE9rIF8gYXMgeiAtPiB6XG4gIHwgRXJyb3IgZXhuIC0+IG9mX2V4biA/YmFja3RyYWNlIGV4blxuOztcblxubGV0IGVycm9yID9oZXJlID9zdHJpY3QgbWVzc2FnZSBhIHNleHBfb2ZfYSA9XG4gIEVycm9yIChFcnJvci5jcmVhdGUgP2hlcmUgP3N0cmljdCBtZXNzYWdlIGEgc2V4cF9vZl9hKVxuOztcblxubGV0IGVycm9yX3Mgc2V4cCA9IEVycm9yIChFcnJvci5jcmVhdGVfcyBzZXhwKVxubGV0IGVycm9yX3N0cmluZyBtZXNzYWdlID0gRXJyb3IgKEVycm9yLm9mX3N0cmluZyBtZXNzYWdlKVxubGV0IGVycm9yZiBmb3JtYXQgPSBQcmludGYua3NwcmludGYgZXJyb3Jfc3RyaW5nIGZvcm1hdFxubGV0IHRhZyB0IH50YWcgPSBSZXN1bHQubWFwX2Vycm9yIHQgfmY6KEVycm9yLnRhZyB+dGFnKVxubGV0IHRhZ19zIHQgfnRhZyA9IFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooRXJyb3IudGFnX3MgfnRhZylcbmxldCB0YWdfc19sYXp5IHQgfnRhZyA9IFJlc3VsdC5tYXBfZXJyb3IgdCB+ZjooRXJyb3IudGFnX3NfbGF6eSB+dGFnKVxuXG5sZXQgdGFnX2FyZyB0IG1lc3NhZ2UgYSBzZXhwX29mX2EgPVxuICBSZXN1bHQubWFwX2Vycm9yIHQgfmY6KGZ1biBlIC0+IEVycm9yLnRhZ19hcmcgZSBtZXNzYWdlIGEgc2V4cF9vZl9hKVxuOztcblxubGV0IHVuaW1wbGVtZW50ZWQgcyA9IGVycm9yIFwidW5pbXBsZW1lbnRlZFwiIHMgc2V4cF9vZl9zdHJpbmdcbmxldCBjb21iaW5lX2Vycm9ycyBsID0gUmVzdWx0Lm1hcF9lcnJvciAoUmVzdWx0LmNvbWJpbmVfZXJyb3JzIGwpIH5mOkVycm9yLm9mX2xpc3RcbmxldCBjb21iaW5lX2Vycm9yc191bml0IGwgPSBSZXN1bHQubWFwIChjb21iaW5lX2Vycm9ycyBsKSB+ZjooZnVuIChfIDogdW5pdCBsaXN0KSAtPiAoKSlcblxubGV0IGZpbHRlcl9va19hdF9sZWFzdF9vbmUgbCA9XG4gIGxldCBvaywgZXJycyA9IExpc3QucGFydGl0aW9uX21hcCBsIH5mOlJlc3VsdC50b19laXRoZXIgaW5cbiAgbWF0Y2ggb2sgd2l0aFxuICB8IFtdIC0+IEVycm9yIChFcnJvci5vZl9saXN0IGVycnMpXG4gIHwgXyAtPiBPayBva1xuOztcblxubGV0IGZpbmRfb2sgbCA9XG4gIG1hdGNoIExpc3QuZmluZF9tYXAgbCB+ZjpSZXN1bHQub2sgd2l0aFxuICB8IFNvbWUgeCAtPiBPayB4XG4gIHwgTm9uZSAtPlxuICAgIEVycm9yXG4gICAgICAoRXJyb3Iub2ZfbGlzdFxuICAgICAgICAgKExpc3QubWFwIGwgfmY6KGZ1bmN0aW9uXG4gICAgICAgICAgICB8IE9rIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICB8IEVycm9yIGVyciAtPiBlcnIpKSlcbjs7XG5cbmxldCBmaW5kX21hcF9vayBsIH5mID1cbiAgV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgRXJyb3JcbiAgICAgIChFcnJvci5vZl9saXN0XG4gICAgICAgICAoTGlzdC5tYXAgbCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICAgICAgbWF0Y2ggZiBlbHQgd2l0aFxuICAgICAgICAgICAgfCBPayBfIGFzIHggLT4gcmV0dXJuIHhcbiAgICAgICAgICAgIHwgRXJyb3IgZXJyIC0+IGVycikpKSlcbjs7XG5cbmxldCBtYXAgPSBSZXN1bHQubWFwXG5sZXQgaXRlciA9IFJlc3VsdC5pdGVyXG5sZXQgaXRlcl9lcnJvciA9IFJlc3VsdC5pdGVyX2Vycm9yXG4iLCIoKiBUaGlzIGlzIGJyb2tlbiBvZmYgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIFNpZ24gYW5kIENvbXBhcmFibGUuICopXG5cbm9wZW4hIEltcG9ydFxuXG50eXBlIHQgPVxuICB8IE5lZ1xuICB8IFplcm9cbiAgfCBQb3NcbltAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXIsIGNvbXBhcmUsIGhhc2gsIGVudW1lcmF0ZV1cblxubGV0IHRfb2Zfc2V4cCA9XG4gIChsZXQgZXJyb3Jfc291cmNlX18wMDNfID0gXCJzaWduMC5tbC50XCIgaW5cbiAgIGZ1bmN0aW9uXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJuZWdcIiB8IFwiTmVnXCIpIC0+IE5lZ1xuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiemVyb1wiIHwgXCJaZXJvXCIpIC0+IFplcm9cbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgLT4gUG9zXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwicG9zXCIgfCBcIlBvc1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDJfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDAyXyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgfCBzZXhwX18wMDJfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwMl9cbiAgICAgICAgICAgICAgICAgICA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuOztcblxubGV0IHNleHBfb2ZfdCA9XG4gIChmdW5jdGlvblxuICAgIHwgTmVnIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5lZ1wiXG4gICAgfCBaZXJvIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlplcm9cIlxuICAgIHwgUG9zIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlBvc1wiXG4gICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTmVnXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJaZXJvXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJQb3NcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxubGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG5sZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gIChmdW4gaHN2IGFyZyAtPlxuICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICB8IE5lZyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDBcbiAgICAgfCBaZXJvIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMVxuICAgICB8IFBvcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDJcbiAgICAgICAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG47O1xuXG5sZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gIGxldCBmdW5jIGFyZyA9XG4gICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmdldF9oYXNoX3ZhbHVlXG4gICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICBoYXNoX2ZvbGRfdCBoc3YgYXJnKVxuICBpblxuICBmdW4geCAtPiBmdW5jIHhcbjs7XG5cbmxldCBhbGwgPSAoWyBOZWc7IFplcm87IFBvcyBdIDogdCBsaXN0KVxuXG5bQEBAZW5kXVxuXG5tb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gIGxldCAoIDwgKSAoeCA6IHQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogdCkgeSA9IFBvbHkuKCA8PSApIHggeVxuICBsZXQgKCA8PiApICh4IDogdCkgeSA9IFBvbHkuKCA8PiApIHggeVxuICBsZXQgKCA9ICkgKHggOiB0KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogdCkgeSA9IFBvbHkuKCA+ICkgeCB5XG4gIGxldCAoID49ICkgKHggOiB0KSB5ID0gUG9seS4oID49ICkgeCB5XG4gIGxldCBhc2NlbmRpbmcgKHggOiB0KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogdCkgeSA9IFBvbHkuZGVzY2VuZGluZyB4IHlcbiAgbGV0IGNvbXBhcmUgKHggOiB0KSB5ID0gUG9seS5jb21wYXJlIHggeVxuICBsZXQgZXF1YWwgKHggOiB0KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IHQpIHkgPSBpZiB4ID49IHkgdGhlbiB4IGVsc2UgeVxuICBsZXQgbWluICh4IDogdCkgeSA9IGlmIHggPD0geSB0aGVuIHggZWxzZSB5XG5lbmRcblxubGV0IG9mX3N0cmluZyBzID0gdF9vZl9zZXhwIChzZXhwX29mX3N0cmluZyBzKVxubGV0IHRvX3N0cmluZyB0ID0gc3RyaW5nX29mX3NleHAgKHNleHBfb2ZfdCB0KVxuXG5sZXQgdG9faW50ID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gLTFcbiAgfCBaZXJvIC0+IDBcbiAgfCBQb3MgLT4gMVxuOztcblxubGV0IF8gPSBoYXNoXG5cbigqIElnbm9yZSB0aGUgaGFzaCBmdW5jdGlvbiBwcm9kdWNlZCBieSBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaF0gKilcbmxldCBoYXNoID0gdG9faW50XG5sZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuU2lnblwiXG5sZXQgb2ZfaW50IG4gPSBpZiBuIDwgMCB0aGVuIE5lZyBlbHNlIGlmIG4gPSAwIHRoZW4gWmVybyBlbHNlIFBvc1xuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIENvbXBhcmFibGVfaW50ZlxuXG5tb2R1bGUgV2l0aF96ZXJvIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgemVybyA6IHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgb3BlbiBUXG5cbiAgbGV0IGlzX3Bvc2l0aXZlIHQgPSBjb21wYXJlIHQgemVybyA+IDBcbiAgbGV0IGlzX25vbl9uZWdhdGl2ZSB0ID0gY29tcGFyZSB0IHplcm8gPj0gMFxuICBsZXQgaXNfbmVnYXRpdmUgdCA9IGNvbXBhcmUgdCB6ZXJvIDwgMFxuICBsZXQgaXNfbm9uX3Bvc2l0aXZlIHQgPSBjb21wYXJlIHQgemVybyA8PSAwXG4gIGxldCBzaWduIHQgPSBTaWduMC5vZl9pbnQgKGNvbXBhcmUgdCB6ZXJvKVxuZW5kXG5cbm1vZHVsZSBQb2x5IChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpID1cbnN0cnVjdFxuICBtb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gc3RydWN0XG4gICAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgbGV0IHNleHBfb2ZfdCA9IChULnNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgUG9seVxuICBlbmRcblxuICBpbmNsdWRlIFBvbHlcblxuICBsZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxuICBsZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAgIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuICA7O1xuXG4gIGxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICAgaWYgbWluID4gbWF4XG4gICAgdGhlblxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICAgIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgOztcblxuICBtb2R1bGUgQyA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUpXG4gIGVuZFxuXG4gIGluY2x1ZGUgQ1xuZW5kXG5cbmxldCBndCBjbXAgYSBiID0gY21wIGEgYiA+IDBcbmxldCBsdCBjbXAgYSBiID0gY21wIGEgYiA8IDBcbmxldCBnZXEgY21wIGEgYiA9IGNtcCBhIGIgPj0gMFxubGV0IGxlcSBjbXAgYSBiID0gY21wIGEgYiA8PSAwXG5sZXQgZXF1YWwgY21wIGEgYiA9IGNtcCBhIGIgPSAwXG5sZXQgbm90X2VxdWFsIGNtcCBhIGIgPSBjbXAgYSBiIDw+IDBcbmxldCBtaW4gY21wIHQgdCcgPSBpZiBsZXEgY21wIHQgdCcgdGhlbiB0IGVsc2UgdCdcbmxldCBtYXggY21wIHQgdCcgPSBpZiBnZXEgY21wIHQgdCcgdGhlbiB0IGVsc2UgdCdcblxubW9kdWxlIEluZml4IChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG4gIGVuZCkgOiBJbmZpeCB3aXRoIHR5cGUgdCA6PSBULnQgPSBzdHJ1Y3RcbiAgbGV0ICggPiApIGEgYiA9IGd0IFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPCApIGEgYiA9IGx0IFQuY29tcGFyZSBhIGJcbiAgbGV0ICggPj0gKSBhIGIgPSBnZXEgVC5jb21wYXJlIGEgYlxuICBsZXQgKCA8PSApIGEgYiA9IGxlcSBULmNvbXBhcmUgYSBiXG4gIGxldCAoID0gKSBhIGIgPSBlcXVhbCBULmNvbXBhcmUgYSBiXG4gIGxldCAoIDw+ICkgYSBiID0gbm90X2VxdWFsIFQuY29tcGFyZSBhIGJcbmVuZFxuXG5tb2R1bGUgUG9seW1vcnBoaWNfY29tcGFyZSAoVCA6IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZV1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgICBbQEBAZW5kXVxuICBlbmQpIDogUG9seW1vcnBoaWNfY29tcGFyZSB3aXRoIHR5cGUgdCA6PSBULnQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBJbmZpeCAoVClcblxuICBsZXQgY29tcGFyZSA9IFQuY29tcGFyZVxuICBsZXQgZXF1YWwgPSAoID0gKVxuICBsZXQgbWluIHQgdCcgPSBtaW4gY29tcGFyZSB0IHQnXG4gIGxldCBtYXggdCB0JyA9IG1heCBjb21wYXJlIHQgdCdcbmVuZFxuXG5tb2R1bGUgTWFrZV91c2luZ19jb21wYXJhdG9yIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuICBlbmQpIDogUyB3aXRoIHR5cGUgdCA6PSBULnQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gVC5jb21wYXJhdG9yX3dpdG5lc3MgPSBzdHJ1Y3RcbiAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBjb21wYXJlID0gY29tcGFyYXRvci5jb21wYXJlXG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBtb2R1bGUgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlID0gUG9seW1vcnBoaWNfY29tcGFyZSAoVClcbiAgaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYXNjZW5kaW5nID0gY29tcGFyZVxuICBsZXQgZGVzY2VuZGluZyB0IHQnID0gY29tcGFyZSB0JyB0XG4gIGxldCBiZXR3ZWVuIHQgfmxvdyB+aGlnaCA9IGxvdyA8PSB0ICYmIHQgPD0gaGlnaFxuICBsZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG4gIGxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICAgIGFzc2VydCAobWluIDw9IG1heCk7XG4gICAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG4gIDs7XG5cbiAgbGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgICBpZiBtaW4gPiBtYXhcbiAgICB0aGVuXG4gICAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG4gICAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuICA7O1xuZW5kXG5cbm1vZHVsZSBNYWtlIChUIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSA9XG4gIE1ha2VfdXNpbmdfY29tcGFyYXRvciAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG4gICAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG4gIGVuZClcblxubW9kdWxlIEluaGVyaXQgKEMgOiBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmVdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kKSAoVCA6IHNpZ1xuICAgICAgICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgICAgICAgW0BAQGVuZF1cblxuICAgICAgICAgIHZhbCBjb21wb25lbnQgOiB0IC0+IEMudFxuICAgICAgICBlbmQpID1cbiAgTWFrZSAoc3RydWN0XG4gICAgdHlwZSB0ID0gVC50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgbGV0IHNleHBfb2ZfdCA9IChULnNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjb21wYXJlIHQgdCcgPSBDLmNvbXBhcmUgKFQuY29tcG9uZW50IHQpIChULmNvbXBvbmVudCB0JylcbiAgZW5kKVxuXG4oKiBjb21wYXJlIFt4XSBhbmQgW3ldIGxleGljb2dyYXBoaWNhbGx5IHVzaW5nIGZ1bmN0aW9ucyBpbiB0aGUgbGlzdCBbY21wc10gKilcbmxldCBsZXhpY29ncmFwaGljIGNtcHMgeCB5ID1cbiAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICB8IGNtcCA6OiBjbXBzIC0+XG4gICAgICBsZXQgcmVzID0gY21wIHggeSBpblxuICAgICAgaWYgcmVzID0gMCB0aGVuIGxvb3AgY21wcyBlbHNlIHJlc1xuICAgIHwgW10gLT4gMFxuICBpblxuICBsb29wIGNtcHNcbjs7XG5cbmxldCBsaWZ0IGNtcCB+ZiB4IHkgPSBjbXAgKGYgeCkgKGYgeSlcbmxldCByZXZlcnNlIGNtcCB4IHkgPSBjbXAgeSB4XG4iLCJvcGVuISBJbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNoYWJsZS5LZXkgKilcbm1vZHVsZSB0eXBlIEtleSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuXG4gICgqKiBWYWx1ZXMgcmV0dXJuZWQgYnkgW2hhc2hdIG11c3QgYmUgbm9uLW5lZ2F0aXZlLiAgQW4gZXhjZXB0aW9uIHdpbGwgYmUgcmFpc2VkIGluIHRoZVxuICAgICAgY2FzZSB0aGF0IFtoYXNoXSByZXR1cm5zIGEgbmVnYXRpdmUgdmFsdWUuICopXG4gIHZhbCBoYXNoIDogdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgSGFzaGFibGUgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID1cbiAgICB7IGhhc2ggOiAnYSAtPiBpbnRcbiAgICA7IGNvbXBhcmUgOiAnYSAtPiAnYSAtPiBpbnRcbiAgICA7IHNleHBfb2ZfdCA6ICdhIC0+IFNleHAudFxuICAgIH1cblxuICAoKiogVGhpcyBmdW5jdGlvbiBpcyBzb3VuZCBidXQgbm90IGNvbXBsZXRlLCBtZWFuaW5nIHRoYXQgaWYgaXQgcmV0dXJucyBbdHJ1ZV0gdGhlbiBpdCdzXG4gICAgICBzYWZlIHRvIHVzZSB0aGUgdHdvIGludGVyY2hhbmdlYWJseS4gIElmIGl0J3MgW2ZhbHNlXSwgeW91IGhhdmUgbm8gZ3VhcmFudGVlcy4gIEZvclxuICAgICAgZXhhbXBsZTpcblxuICAgICAge1tcbiAgICAgICAgPiB1dG9wXG4gICAgICAgIG9wZW4gQ29yZTs7XG4gICAgICAgIGxldCBlcXVhbCAoYSA6ICdhIEhhc2h0YmxfaW50Zi5IYXNoYWJsZS50KSBiID1cbiAgICAgICAgICBwaHlzX2VxdWFsIGEgYlxuICAgICAgICAgIHx8IChwaHlzX2VxdWFsIGEuaGFzaCBiLmhhc2hcbiAgICAgICAgICAgICAgJiYgcGh5c19lcXVhbCBhLmNvbXBhcmUgYi5jb21wYXJlXG4gICAgICAgICAgICAgICYmIHBoeXNfZXF1YWwgYS5zZXhwX29mX3QgYi5zZXhwX29mX3QpXG4gICAgICAgIDs7XG4gICAgICAgIGxldCBhID0gSGFzaHRibF9pbnRmLkhhc2hhYmxlLnsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90ID0gSW50LnNleHBfb2ZfdCB9OztcbiAgICAgICAgbGV0IGIgPSBIYXNodGJsX2ludGYuSGFzaGFibGUueyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgPSBJbnQuc2V4cF9vZl90IH07O1xuICAgICAgICBlcXVhbCBhIGI7OyAgKCogZmFsc2U/ISAqKVxuICAgICAgXX1cbiAgKilcbiAgbGV0IGVxdWFsIGEgYiA9XG4gICAgcGh5c19lcXVhbCBhIGJcbiAgICB8fCAocGh5c19lcXVhbCBhLmhhc2ggYi5oYXNoXG4gICAgICAgICYmIHBoeXNfZXF1YWwgYS5jb21wYXJlIGIuY29tcGFyZVxuICAgICAgICAmJiBwaHlzX2VxdWFsIGEuc2V4cF9vZl90IGIuc2V4cF9vZl90KVxuICA7O1xuXG4gIGxldCBoYXNoX3BhcmFtID0gQ2FtbC5IYXNodGJsLmhhc2hfcGFyYW1cbiAgbGV0IGhhc2ggPSBDYW1sLkhhc2h0YmwuaGFzaFxuICBsZXQgcG9seSA9IHsgaGFzaDsgY29tcGFyZSA9IFBvbHkuY29tcGFyZTsgc2V4cF9vZl90ID0gKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgfVxuXG4gIGxldCBvZl9rZXkgKHR5cGUgYSkgKG1vZHVsZSBLZXkgOiBLZXkgd2l0aCB0eXBlIHQgPSBhKSA9XG4gICAgeyBoYXNoID0gS2V5Lmhhc2g7IGNvbXBhcmUgPSBLZXkuY29tcGFyZTsgc2V4cF9vZl90ID0gS2V5LnNleHBfb2ZfdCB9XG4gIDs7XG5cbiAgbGV0IHRvX2tleSAodHlwZSBhKSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9ID1cbiAgICAobW9kdWxlIHN0cnVjdFxuICAgICAgdHlwZSB0ID0gYVxuXG4gICAgICBsZXQgaGFzaCA9IGhhc2hcbiAgICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICAgICAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICAgIGVuZCA6IEtleVxuICAgICAgd2l0aCB0eXBlIHQgPSBhKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgSGFzaGFibGVcblxubW9kdWxlIHR5cGUgSGFzaGFibGUgPSBzaWdcbiAgdHlwZSAnYSB0ID0gJ2EgSGFzaGFibGUudCA9XG4gICAgeyBoYXNoIDogJ2EgLT4gaW50XG4gICAgOyBjb21wYXJlIDogJ2EgLT4gJ2EgLT4gaW50XG4gICAgOyBzZXhwX29mX3QgOiAnYSAtPiBTZXhwLnRcbiAgICB9XG5cbiAgdmFsIGVxdWFsIDogJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgdmFsIHBvbHkgOiAnYSB0XG4gIHZhbCBvZl9rZXkgOiAobW9kdWxlIEtleSB3aXRoIHR5cGUgdCA9ICdhKSAtPiAnYSB0XG4gIHZhbCB0b19rZXkgOiAnYSB0IC0+IChtb2R1bGUgS2V5IHdpdGggdHlwZSB0ID0gJ2EpXG4gIHZhbCBoYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiAnYSAtPiBpbnRcbiAgdmFsIGhhc2ggOiAnYSAtPiBpbnRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIElkZW50aWZpYWJsZV9pbnRmXG5cbm1vZHVsZSBNYWtlIChUIDogQXJnKSA9IHN0cnVjdFxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG4gIGluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKFQpXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuZW5kXG5cbm1vZHVsZSBNYWtlX3VzaW5nX2NvbXBhcmF0b3IgKFQgOiBBcmdfd2l0aF9jb21wYXJhdG9yKSA9IHN0cnVjdFxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhYmxlLk1ha2VfdXNpbmdfY29tcGFyYXRvciAoVClcbiAgaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoVClcblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSB1bml0IFtAQGRlcml2aW5nX2lubGluZSBlbnVtZXJhdGUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgYWxsID0gKFsgKCkgXSA6IHQgbGlzdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX3VuaXRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX3VuaXQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKHVuaXRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfdW5pdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSB1bml0X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGNvbXBhcmUgXyBfID0gMFxuXG4gIGxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgXCIoKVwiIC0+ICgpXG4gICAgfCBfIC0+IGZhaWx3aXRoIFwiQmFzZS5Vbml0Lm9mX3N0cmluZzogKCkgZXhwZWN0ZWRcIlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgKCkgPSBcIigpXCJcbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLlVuaXRcIlxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoVClcblxubGV0IGludmFyaWFudCAoKSA9ICgpXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbjBcblxubGV0IGdldF9wb3NfbGVuID9wb3MgP2xlbiAoKSB+dG90YWxfbGVuZ3RoID1cbiAgdHJ5IFJlc3VsdC5PayAoZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoKSB3aXRoXG4gIHwgSW52YWxpZF9hcmd1bWVudCBzIC0+IE9yX2Vycm9yLmVycm9yX3N0cmluZyBzXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cbigqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgYSBzZWFyY2ggZm9yIHRoZSBmaXJzdCAocmVzcC4gbGFzdCkgZWxlbWVudFxuICAgc2F0aXNmeWluZyBhIHByZWRpY2F0ZSwgYXNzdW1pbmcgdGhhdCB0aGUgcHJlZGljYXRlIGlzIGluY3JlYXNpbmcgb25cbiAgIHRoZSBjb250YWluZXIsIG1lYW5pbmcgdGhhdCwgaWYgdGhlIGNvbnRhaW5lciBpcyBbdTEuLi51bl0sIHRoZXJlIGV4aXN0cyBhXG4gICBrIHN1Y2ggdGhhdCBwKHUxKT0uLi4uPXAodWspID0gZmFsc2UgYW5kIHAodWsrMSk9Li4uLj1wKHVuKT0gdHJ1ZS5cbiAgIElmIHRoaXMgayA9IDEgKHJlc3AgbiksIGZpbmRfbGFzdF9ub3Rfc2F0aXNmeWluZyAocmVzcCBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcpXG4gICB3aWxsIHJldHVybiBOb25lLiAqKVxuXG5sZXQgcmVjIGxpbmVhcl9zZWFyY2hfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZCA9XG4gIGlmIGxvID4gaGlcbiAgdGhlbiBOb25lXG4gIGVsc2UgaWYgcHJlZCAoZ2V0IHQgbG8pXG4gIHRoZW4gU29tZSBsb1xuICBlbHNlIGxpbmVhcl9zZWFyY2hfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvOihsbyArIDEpIH5oaSB+cHJlZFxuOztcblxuKCogVGFrZXMgYSBjb250YWluZXIgW3RdLCBhIHByZWRpY2F0ZSBbcHJlZF0gYW5kIHR3byBpbmRpY2VzIFtsbyA8IGhpXSwgc3VjaCB0aGF0XG4gICBbcHJlZF0gaXMgaW5jcmVhc2luZyBvbiBbdF0gYmV0d2VlbiBbbG9dIGFuZCBbaGldLlxuXG4gICByZXR1cm4gYSByYW5nZSAobG8sIGhpKSB3aGVyZTpcbiAgIC0gbG8gYW5kIGhpIGFyZSBjbG9zZSBlbm91Z2ggdG9nZXRoZXIgZm9yIGEgbGluZWFyIHNlYXJjaFxuICAgLSBJZiBbcHJlZF0gaXMgbm90IGNvbnN0YW50bHkgW2ZhbHNlXSBvbiBbdF0gYmV0d2VlbiBbbG9dIGFuZCBbaGldLCB0aGUgZmlyc3QgZWxlbWVudFxuICAgICBvbiB3aGljaCBbcHJlZF0gaXMgW3RydWVdIGlzIGJldHdlZW4gW2xvXSBhbmQgW2hpXS4gKilcbigqIEludmFyaWFudDogdGhlIGZpcnN0IGVsZW1lbnQgc2F0aXNmeWluZyBbcHJlZF0sIGlmIGl0IGV4aXN0cyBpcyBiZXR3ZWVuIFtsb10gYW5kIFtoaV0gKilcbmxldCByZWMgZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGkgfnByZWQgPVxuICAoKiBXYXJuaW5nOiB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IHRlcm1pbmF0ZSBpZiB0aGUgY29uc3RhbnQgKGN1cnJlbnRseSA4KSBpc1xuICAgICBzZXQgPD0gMSAqKVxuICBpZiBoaSAtIGxvIDw9IDhcbiAgdGhlbiBsbywgaGlcbiAgZWxzZSAoXG4gICAgbGV0IG1pZCA9IGxvICsgKChoaSAtIGxvKSAvIDIpIGluXG4gICAgaWYgcHJlZCAoZ2V0IHQgbWlkKVxuICAgICgqIElOVkFSSUFOVCBjaGVjazogaXQgbWVhbnMgdGhlIGZpcnN0IHNhdGlzZnlpbmcgZWxlbWVudCBpcyBiZXR3ZWVuIFtsb10gYW5kIFttaWRdICopXG4gICAgdGhlblxuICAgICAgZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbyB+aGk6bWlkIH5wcmVkXG4gICAgICAoKiBJTlZBUklBTlQgY2hlY2s6IGl0IG1lYW5zIHRoZSBmaXJzdCBzYXRpc2Z5aW5nIGVsZW1lbnQsIGlmIGl0IGV4aXN0cyxcbiAgICAgICAgIGlzIGJldHdlZW4gW21pZCsxXSBhbmQgW2hpXSAqKVxuICAgIGVsc2UgZmluZF9yYW5nZV9uZWFyX2ZpcnN0X3NhdGlzZnlpbmcgdCB+Z2V0IH5sbzoobWlkICsgMSkgfmhpIH5wcmVkKVxuOztcblxubGV0IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQgPVxuICBsZXQgcG9zLCBsZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggdClcbiAgaW5cbiAgbGV0IGxvID0gcG9zIGluXG4gIGxldCBoaSA9IHBvcyArIGxlbiAtIDEgaW5cbiAgbGV0IGxvLCBoaSA9IGZpbmRfcmFuZ2VfbmVhcl9maXJzdF9zYXRpc2Z5aW5nIHQgfmdldCB+bG8gfmhpIH5wcmVkIGluXG4gIGxpbmVhcl9zZWFyY2hfZmlyc3Rfc2F0aXNmeWluZyB0IH5nZXQgfmxvIH5oaSB+cHJlZFxuOztcblxuKCogVGFrZXMgYW4gYXJyYXkgd2l0aCBzaGFwZSBbdHJ1ZSwuLi50cnVlLGZhbHNlLC4uLmZhbHNlXSAoaS5lLiwgdGhlIF9yZXZlcnNlXyBvZiB3aGF0XG4gICBpcyBkZXNjcmliZWQgYWJvdmUpIGFuZCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB0cnVlIG9yIE5vbmUgaWYgdGhlcmUgYXJlIG5vXG4gICB0cnVlKilcbmxldCBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+cHJlZCB+Z2V0IH5sZW5ndGggPVxuICBsZXQgcG9zLCBsZW4gPVxuICAgIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uZ2V0X3Bvc19sZW5fZXhuICgpID9wb3MgP2xlbiB+dG90YWxfbGVuZ3RoOihsZW5ndGggdClcbiAgaW5cbiAgaWYgbGVuID0gMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgKCogVGhlIGxhc3Qgc2F0aXNmeWluZyBpcyB0aGUgb25lIGp1c3QgYmVmb3JlIHRoZSBmaXJzdCBub3Qgc2F0aXNmeWluZyAqKVxuICAgIG1hdGNoIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB+cG9zIH5sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KEZuLm5vbiBwcmVkKSB3aXRoXG4gICAgfCBOb25lIC0+IFNvbWUgKHBvcyArIGxlbiAtIDEpXG4gICAgKCogVGhpcyBtZWFucyB0aGF0IGFsbCBlbGVtZW50cyBzYXRpc2Z5IHByZWQuXG4gICAgICAgVGhlcmUgaXMgYXQgbGVhc3QgYW4gZWxlbWVudCBhcyAobGVuID4gMCkgKilcbiAgICB8IFNvbWUgaSB3aGVuIGkgPSBwb3MgLT4gTm9uZSAoKiBubyBlbGVtZW50IHNhdGlzZmllcyBwcmVkICopXG4gICAgfCBTb21lIGkgLT4gU29tZSAoaSAtIDEpKVxuOztcblxubGV0IGJpbmFyeV9zZWFyY2ggP3BvcyA/bGVuIHQgfmxlbmd0aCB+Z2V0IH5jb21wYXJlIGhvdyB2ID1cbiAgbWF0Y2ggaG93IHdpdGhcbiAgfCBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW4gLT5cbiAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDwgMClcbiAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gLT5cbiAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnByZWQ6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApXG4gIHwgYEZpcnN0X2VxdWFsX3RvIC0+XG4gICAgKG1hdGNoXG4gICAgICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMClcbiAgICAgd2l0aFxuICAgICB8IFNvbWUgeCB3aGVuIGNvbXBhcmUgKGdldCB0IHgpIHYgPSAwIC0+IFNvbWUgeFxuICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgfCBgTGFzdF9lcXVhbF90byAtPlxuICAgIChtYXRjaFxuICAgICAgIGZpbmRfbGFzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPD0gMClcbiAgICAgd2l0aFxuICAgICB8IFNvbWUgeCB3aGVuIGNvbXBhcmUgKGdldCB0IHgpIHYgPSAwIC0+IFNvbWUgeFxuICAgICB8IE5vbmUgfCBTb21lIF8gLT4gTm9uZSlcbiAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMClcbiAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuIC0+XG4gICAgZmluZF9maXJzdF9zYXRpc2Z5aW5nID9wb3MgP2xlbiB0IH5nZXQgfmxlbmd0aCB+cHJlZDooZnVuIHggLT4gY29tcGFyZSB4IHYgPiAwKVxuOztcblxubGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID9wb3MgP2xlbiB0IH5sZW5ndGggfmdldCB+c2VnbWVudF9vZiBob3cgPVxuICBsZXQgaXNfbGVmdCB4ID1cbiAgICBtYXRjaCBzZWdtZW50X29mIHggd2l0aFxuICAgIHwgYExlZnQgLT4gdHJ1ZVxuICAgIHwgYFJpZ2h0IC0+IGZhbHNlXG4gIGluXG4gIGxldCBpc19yaWdodCB4ID0gbm90IChpc19sZWZ0IHgpIGluXG4gIG1hdGNoIGhvdyB3aXRoXG4gIHwgYExhc3Rfb25fbGVmdCAtPiBmaW5kX2xhc3Rfc2F0aXNmeWluZyA/cG9zID9sZW4gdCB+bGVuZ3RoIH5nZXQgfnByZWQ6aXNfbGVmdFxuICB8IGBGaXJzdF9vbl9yaWdodCAtPiBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgP3BvcyA/bGVuIHQgfmxlbmd0aCB+Z2V0IH5wcmVkOmlzX3JpZ2h0XG47O1xuIiwiKCoqIE1vZHVsZSB0eXBlcyBmb3IgYSBbYmluYXJ5X3NlYXJjaF0gZnVuY3Rpb24gZm9yIGEgc2VxdWVuY2UsIGFuZCBmdW5jdG9ycyBmb3IgYnVpbGRpbmdcbiAgICBbYmluYXJ5X3NlYXJjaF0gZnVuY3Rpb25zLiAqKVxuXG5vcGVuISBJbXBvcnRcblxuKCoqIEFuIFtJbmRleGFibGVdIHR5cGUgaXMgYSBmaW5pdGUgc2VxdWVuY2Ugb2YgZWxlbWVudHMgaW5kZXhlZCBieSBjb25zZWN1dGl2ZSBpbnRlZ2Vyc1xuICAgIFswXSAuLi4gW2xlbmd0aCB0IC0gMV0uICBbZ2V0XSBhbmQgW2xlbmd0aF0gbXVzdCBiZSBPKDEpIGZvciB0aGUgcmVzdWx0aW5nXG4gICAgW2JpbmFyeV9zZWFyY2hdIHRvIGJlIGxnKG4pLiAqKVxubW9kdWxlIHR5cGUgSW5kZXhhYmxlID0gc2lnXG4gIHR5cGUgZWx0XG4gIHR5cGUgdFxuXG4gIHZhbCBnZXQgOiB0IC0+IGludCAtPiBlbHRcbiAgdmFsIGxlbmd0aCA6IHQgLT4gaW50XG5lbmRcblxubW9kdWxlIHR5cGUgSW5kZXhhYmxlMSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgZ2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2FcbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgV2hpY2hfdGFyZ2V0X2J5X2tleSA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIFsgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuICgqKiAgICAgICAge3YgfCA8IGVsdCBYIHwgICAgICAgICAgICAgICAgICAgICAgIHZ9ICopXG4gICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gKCoqICAgICB7diB8ICAgICAgPD0gZWx0ICAgICAgIFggfCAgICAgICAgICAgdn0gKilcbiAgICB8IGBMYXN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8ICAgPSBlbHQgWCB8ICAgICAgICAgICB2fSAqKVxuICAgIHwgYEZpcnN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgWCA9IGVsdCAgIHwgICAgICAgICAgIHZ9ICopXG4gICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvICgqKiB7diAgICAgICAgICAgfCBYICAgICAgID49IGVsdCAgICAgIHwgdn0gKilcbiAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gKCoqICAgIHt2ICAgICAgICAgICAgICAgICAgICAgICB8IFggPiBlbHQgfCB2fSAqKVxuICAgIF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGVudW1lcmF0ZV1cblxuICBsZXQgYWxsID1cbiAgICAoWyBgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW5cbiAgICAgOyBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG9cbiAgICAgOyBgTGFzdF9lcXVhbF90b1xuICAgICA7IGBGaXJzdF9lcXVhbF90b1xuICAgICA7IGBGaXJzdF9ncmVhdGVyX3RoYW5fb3JfZXF1YWxfdG9cbiAgICAgOyBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuXG4gICAgIF1cbiAgICAgOiB0IGxpc3QpXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICBbIGBMYXN0X29uX2xlZnRcbiAgICB8IGBGaXJzdF9vbl9yaWdodFxuICAgIF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGVudW1lcmF0ZV1cblxuICBsZXQgYWxsID0gKFsgYExhc3Rfb25fbGVmdDsgYEZpcnN0X29uX3JpZ2h0IF0gOiB0IGxpc3QpXG5cbiAgW0BAQGVuZF1cbmVuZFxuXG50eXBlICgndCwgJ2VsdCwgJ2tleSkgYmluYXJ5X3NlYXJjaCA9XG4gID9wb3M6aW50XG4gIC0+ID9sZW46aW50XG4gIC0+ICd0XG4gIC0+IGNvbXBhcmU6KCdlbHQgLT4gJ2tleSAtPiBpbnQpXG4gIC0+IFdoaWNoX3RhcmdldF9ieV9rZXkudFxuICAtPiAna2V5XG4gIC0+IGludCBvcHRpb25cblxudHlwZSAoJ3QsICdlbHQpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID1cbiAgP3BvczppbnRcbiAgLT4gP2xlbjppbnRcbiAgLT4gJ3RcbiAgLT4gc2VnbWVudF9vZjooJ2VsdCAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gIC0+IFdoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgLT4gaW50IG9wdGlvblxuXG5tb2R1bGUgdHlwZSBTID0gc2lnXG4gIHR5cGUgZWx0XG4gIHR5cGUgdFxuXG4gICgqKiBTZWUgW0JpbmFyeV9zZWFyY2guYmluYXJ5X3NlYXJjaF0gaW4gYmluYXJ5X3NlYXJjaC5tbCAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaCA6ICh0LCBlbHQsICdrZXkpIGJpbmFyeV9zZWFyY2hcblxuICAoKiogU2VlIFtCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSBpbiBiaW5hcnlfc2VhcmNoLm1sICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA6ICh0LCBlbHQpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG5lbmRcblxubW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2ggOiAoJ2EgdCwgJ2EsICdrZXkpIGJpbmFyeV9zZWFyY2hcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIDogKCdhIHQsICdhKSBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuZW5kXG5cbm1vZHVsZSB0eXBlIEJpbmFyeV9zZWFyY2hhYmxlID0gc2lnXG4gIG1vZHVsZSB0eXBlIFMgPSBTXG4gIG1vZHVsZSB0eXBlIFMxID0gUzFcbiAgbW9kdWxlIHR5cGUgSW5kZXhhYmxlID0gSW5kZXhhYmxlXG4gIG1vZHVsZSB0eXBlIEluZGV4YWJsZTEgPSBJbmRleGFibGUxXG5cbiAgbW9kdWxlIFdoaWNoX3RhcmdldF9ieV9rZXkgPSBXaGljaF90YXJnZXRfYnlfa2V5XG4gIG1vZHVsZSBXaGljaF90YXJnZXRfYnlfc2VnbWVudCA9IFdoaWNoX3RhcmdldF9ieV9zZWdtZW50XG5cbiAgdHlwZSBub25yZWMgKCd0LCAnZWx0LCAna2V5KSBiaW5hcnlfc2VhcmNoID0gKCd0LCAnZWx0LCAna2V5KSBiaW5hcnlfc2VhcmNoXG4gIHR5cGUgbm9ucmVjICgndCwgJ2VsdCkgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgPSAoJ3QsICdlbHQpIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG5cbiAgbW9kdWxlIE1ha2UgKFQgOiBJbmRleGFibGUpIDogUyB3aXRoIHR5cGUgdCA6PSBULnQgd2l0aCB0eXBlIGVsdCA6PSBULmVsdFxuICBtb2R1bGUgTWFrZTEgKFQgOiBJbmRleGFibGUxKSA6IFMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIFQudFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQmluYXJ5X3NlYXJjaGFibGVfaW50ZlxuXG5tb2R1bGUgdHlwZSBBcmcgPSBzaWdcbiAgdHlwZSAnYSBlbHRcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhIGVsdFxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlbiAoVCA6IEFyZykgPSBzdHJ1Y3RcbiAgbGV0IGdldCA9IFQuZ2V0XG4gIGxldCBsZW5ndGggPSBULmxlbmd0aFxuXG4gIGxldCBiaW5hcnlfc2VhcmNoID9wb3MgP2xlbiB0IH5jb21wYXJlIGhvdyB2ID1cbiAgICBCaW5hcnlfc2VhcmNoLmJpbmFyeV9zZWFyY2ggP3BvcyA/bGVuIHQgfmdldCB+bGVuZ3RoIH5jb21wYXJlIGhvdyB2XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkID9wb3MgP2xlbiB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgQmluYXJ5X3NlYXJjaC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCA/cG9zID9sZW4gdCB+Z2V0IH5sZW5ndGggfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UgKFQgOiBJbmRleGFibGUpID0gTWFrZV9nZW4gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgdHlwZSAnYSBlbHQgPSBULmVsdFxuICAgIHR5cGUgJ2EgdCA9IFQudFxuICBlbmQpXG5cbm1vZHVsZSBNYWtlMSAoVCA6IEluZGV4YWJsZTEpID0gTWFrZV9nZW4gKHN0cnVjdFxuICAgIHR5cGUgJ2EgZWx0ID0gJ2FcbiAgICB0eXBlICdhIHQgPSAnYSBULnRcblxuICAgIGxldCBnZXQgPSBULmdldFxuICAgIGxldCBsZW5ndGggPSBULmxlbmd0aFxuICBlbmQpXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQmxpdF9pbnRmXG5cbm1vZHVsZSB0eXBlIFNlcXVlbmNlX2dlbiA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgbGVuZ3RoIDogXyB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBNYWtlX2dlblxuICAgIChTcmMgOiBTZXF1ZW5jZV9nZW4pIChEc3QgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlIFNlcXVlbmNlX2dlblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIGNyZWF0ZV9saWtlIDogbGVuOmludCAtPiAnYSBTcmMudCAtPiAnYSB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsIHVuc2FmZV9ibGl0IDogKCdhIFNyYy50LCAnYSB0KSBibGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCkgPVxuc3RydWN0XG4gIGxldCB1bnNhZmVfYmxpdCA9IERzdC51bnNhZmVfYmxpdFxuXG4gIGxldCBibGl0IH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuXG4gICAgICB+cG9zOnNyY19wb3NcbiAgICAgIH5sZW5cbiAgICAgIH50b3RhbF9sZW5ndGg6KFNyYy5sZW5ndGggc3JjKTtcbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuXG4gICAgICB+cG9zOmRzdF9wb3NcbiAgICAgIH5sZW5cbiAgICAgIH50b3RhbF9sZW5ndGg6KERzdC5sZW5ndGggZHN0KTtcbiAgICBpZiBsZW4gPiAwIHRoZW4gdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW5cbiAgOztcblxuICBsZXQgYmxpdG9cbiAgICAgICAgfnNyY1xuICAgICAgICA/KHNyY19wb3MgPSAwKVxuICAgICAgICA/KHNyY19sZW4gPSBTcmMubGVuZ3RoIHNyYyAtIHNyY19wb3MpXG4gICAgICAgIH5kc3RcbiAgICAgICAgPyhkc3RfcG9zID0gMClcbiAgICAgICAgKClcbiAgICA9XG4gICAgYmxpdCB+c3JjIH5zcmNfcG9zIH5sZW46c3JjX2xlbiB+ZHN0IH5kc3RfcG9zXG4gIDs7XG5cbiAgKCogW3N1Yl0gYW5kIFtzdWJvXSBlbnN1cmUgdGhhdCBldmVyeSBwb3NpdGlvbiBvZiB0aGUgY3JlYXRlZCBzZXF1ZW5jZSBpcyBwb3B1bGF0ZWQgYnlcbiAgICAgYW4gZWxlbWVudCBvZiB0aGUgc291cmNlIGFycmF5LiAgVGh1cyBldmVyeSBlbGVtZW50IG9mIFtkc3RdIGJlbG93IGlzIHdlbGxcbiAgICAgZGVmaW5lZC4gKilcbiAgbGV0IHN1YiBzcmMgfnBvcyB+bGVuID1cbiAgICBPcmRlcmVkX2NvbGxlY3Rpb25fY29tbW9uLmNoZWNrX3Bvc19sZW5fZXhuIH5wb3MgfmxlbiB+dG90YWxfbGVuZ3RoOihTcmMubGVuZ3RoIHNyYyk7XG4gICAgbGV0IGRzdCA9IERzdC5jcmVhdGVfbGlrZSB+bGVuIHNyYyBpblxuICAgIGlmIGxlbiA+IDAgdGhlbiB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zOnBvcyB+ZHN0IH5kc3RfcG9zOjAgfmxlbjtcbiAgICBkc3RcbiAgOztcblxuICBsZXQgc3VibyA/KHBvcyA9IDApID9sZW4gc3JjID1cbiAgICBzdWJcbiAgICAgIHNyY1xuICAgICAgfnBvc1xuICAgICAgfmxlbjpcbiAgICAgICAgKG1hdGNoIGxlbiB3aXRoXG4gICAgICAgICB8IFNvbWUgaSAtPiBpXG4gICAgICAgICB8IE5vbmUgLT4gU3JjLmxlbmd0aCBzcmMgLSBwb3MpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2UxIChTZXF1ZW5jZSA6IHNpZ1xuICAgIGluY2x1ZGUgU2VxdWVuY2VfZ2VuXG5cbiAgICB2YWwgY3JlYXRlX2xpa2UgOiBsZW46aW50IC0+ICdhIHQgLT4gJ2EgdFxuICAgIHZhbCB1bnNhZmVfYmxpdCA6ICgnYSB0LCAnYSB0KSBibGl0XG4gIGVuZCkgPVxuICBNYWtlX2dlbiAoU2VxdWVuY2UpIChTZXF1ZW5jZSlcblxubW9kdWxlIE1ha2UxX2dlbmVyaWMgKFNlcXVlbmNlIDogU2VxdWVuY2UxKSA9IE1ha2VfZ2VuIChTZXF1ZW5jZSkgKFNlcXVlbmNlKVxuXG5tb2R1bGUgTWFrZSAoU2VxdWVuY2UgOiBzaWdcbiAgICBpbmNsdWRlIFNlcXVlbmNlXG5cbiAgICB2YWwgY3JlYXRlIDogbGVuOmludCAtPiB0XG4gICAgdmFsIHVuc2FmZV9ibGl0IDogKHQsIHQpIGJsaXRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFNlcXVlbmNlID0gc3RydWN0XG4gICAgdHlwZSAnYSB0ID0gU2VxdWVuY2UudFxuXG4gICAgb3BlbiBTZXF1ZW5jZVxuXG4gICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gXyA9IGNyZWF0ZSB+bGVuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gIGVuZFxuXG4gIGluY2x1ZGUgTWFrZV9nZW4gKFNlcXVlbmNlKSAoU2VxdWVuY2UpXG5lbmRcblxubW9kdWxlIE1ha2VfZGlzdGluY3RcbiAgICAoU3JjIDogU2VxdWVuY2UpIChEc3QgOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGUgU2VxdWVuY2VcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsIGNyZWF0ZSA6IGxlbjppbnQgLT4gdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsIHVuc2FmZV9ibGl0IDogKFNyYy50LCB0KSBibGl0XG4gICAgICAgICAgICAgICAgICAgICAgZW5kKSA9XG4gIE1ha2VfZ2VuXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gU3JjLnRcblxuICAgICAgb3BlbiBTcmNcblxuICAgICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBEc3QudFxuXG4gICAgICBvcGVuIERzdFxuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgICBsZXQgY3JlYXRlX2xpa2UgfmxlbiBfID0gY3JlYXRlIH5sZW5cbiAgICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gICAgZW5kKVxuXG5tb2R1bGUgTWFrZV90b19zdHJpbmcgKFQgOiBzaWdcbiAgICB0eXBlIHRcbiAgZW5kKVxuICAgIChUb19ieXRlcyA6IFNfZGlzdGluY3Qgd2l0aCB0eXBlIHNyYyA6PSBULnQgd2l0aCB0eXBlIGRzdCA6PSBieXRlcykgPVxuc3RydWN0XG4gIG9wZW4gVG9fYnl0ZXNcblxuICBsZXQgc3ViIHNyYyB+cG9zIH5sZW4gPVxuICAgIEJ5dGVzMC51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOihzdWIgc3JjIH5wb3MgfmxlbilcbiAgOztcblxuICBsZXQgc3VibyA/cG9zID9sZW4gc3JjID1cbiAgICBCeXRlczAudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTooc3VibyA/cG9zID9sZW4gc3JjKVxuICA7O1xuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxuaW5jbHVkZSAoXG5zdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludCA9IGNvbXBhcmVfb3B0aW9uXG5cbiAgbGV0IGhhc2hfZm9sZF90IDpcbiAgICAnYS5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAnYSB0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIGhhc2hfZm9sZF9vcHRpb25cbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgICBvcHRpb25fb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIHNleHBfb2Zfb3B0aW9uXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBvcHRpb25fc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kIDpcbnNpZ1xuICB0eXBlICdhIHQgPSAnYSBvcHRpb24gW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgaW5jbHVkZSBQcHhfaGFzaF9saWIuSGFzaGFibGUuUzEgd2l0aCB0eXBlICdhIHQgOj0gJ2EgdFxuICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZClcblxudHlwZSAnYSB0ID0gJ2Egb3B0aW9uID1cbiAgfCBOb25lXG4gIHwgU29tZSBvZiAnYVxuXG5sZXQgaXNfbm9uZSA9IGZ1bmN0aW9uXG4gIHwgTm9uZSAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3NvbWUgPSBmdW5jdGlvblxuICB8IFNvbWUgXyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IHZhbHVlX21hcCBvIH5kZWZhdWx0IH5mID1cbiAgbWF0Y2ggbyB3aXRoXG4gIHwgU29tZSB4IC0+IGYgeFxuICB8IE5vbmUgLT4gZGVmYXVsdFxuOztcblxubGV0IGl0ZXIgbyB+ZiA9XG4gIG1hdGNoIG8gd2l0aFxuICB8IE5vbmUgLT4gKClcbiAgfCBTb21lIGEgLT4gZiBhXG47O1xuXG5sZXQgaW52YXJpYW50IGYgdCA9IGl0ZXIgdCB+ZlxuXG5sZXQgY2FsbCB4IH5mID1cbiAgbWF0Y2ggZiB3aXRoXG4gIHwgTm9uZSAtPiAoKVxuICB8IFNvbWUgZiAtPiBmIHhcbjs7XG5cbmxldCB2YWx1ZSB0IH5kZWZhdWx0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBkZWZhdWx0XG4gIHwgU29tZSB4IC0+IHhcbjs7XG5cbmxldCB2YWx1ZV9leG4gP2hlcmUgP2Vycm9yID9tZXNzYWdlIHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTb21lIHggLT4geFxuICB8IE5vbmUgLT5cbiAgICBsZXQgZXJyb3IgPVxuICAgICAgbWF0Y2ggaGVyZSwgZXJyb3IsIG1lc3NhZ2Ugd2l0aFxuICAgICAgfCBOb25lLCBOb25lLCBOb25lIC0+IEVycm9yLm9mX3N0cmluZyBcIk9wdGlvbi52YWx1ZV9leG4gTm9uZVwiXG4gICAgICB8IE5vbmUsIE5vbmUsIFNvbWUgbSAtPiBFcnJvci5vZl9zdHJpbmcgbVxuICAgICAgfCBOb25lLCBTb21lIGUsIE5vbmUgLT4gZVxuICAgICAgfCBOb25lLCBTb21lIGUsIFNvbWUgbSAtPiBFcnJvci50YWcgZSB+dGFnOm1cbiAgICAgIHwgU29tZSBwLCBOb25lLCBOb25lIC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZSBcIk9wdGlvbi52YWx1ZV9leG5cIiBwIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMC5zZXhwX29mX3RcbiAgICAgIHwgU29tZSBwLCBOb25lLCBTb21lIG0gLT4gRXJyb3IuY3JlYXRlIG0gcCBTb3VyY2VfY29kZV9wb3NpdGlvbjAuc2V4cF9vZl90XG4gICAgICB8IFNvbWUgcCwgU29tZSBlLCBfIC0+XG4gICAgICAgIEVycm9yLmNyZWF0ZVxuICAgICAgICAgICh2YWx1ZSBtZXNzYWdlIH5kZWZhdWx0OlwiXCIpXG4gICAgICAgICAgKGUsIHApXG4gICAgICAgICAgKHNleHBfb2ZfcGFpciBFcnJvci5zZXhwX29mX3QgU291cmNlX2NvZGVfcG9zaXRpb24wLnNleHBfb2ZfdClcbiAgICBpblxuICAgIEVycm9yLnJhaXNlIGVycm9yXG47O1xuXG5sZXQgdmFsdWVfb3JfdGh1bmsgbyB+ZGVmYXVsdCA9XG4gIG1hdGNoIG8gd2l0aFxuICB8IFNvbWUgeCAtPiB4XG4gIHwgTm9uZSAtPiBkZWZhdWx0ICgpXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gW3x8XVxuICB8IFNvbWUgeCAtPiBbfCB4IHxdXG47O1xuXG5sZXQgdG9fbGlzdCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBbXVxuICB8IFNvbWUgeCAtPiBbIHggXVxuOztcblxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZTpfID0gdFxubGV0IG1heF9lbHQgdCB+Y29tcGFyZTpfID0gdFxuXG5sZXQgc3VtICh0eXBlIGEpIChtb2R1bGUgTSA6IENvbnRhaW5lci5TdW1tYWJsZSB3aXRoIHR5cGUgdCA9IGEpIHQgfmYgPVxuICB2YWx1ZV9tYXAgdCB+ZGVmYXVsdDpNLnplcm8gfmZcbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHggLT4gZiB4XG47O1xuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IGZhbHNlXG4gIHwgU29tZSB4IC0+IGYgeFxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBmYWxzZVxuICB8IFNvbWUgYScgLT4gZXF1YWwgYSBhJ1xuOztcblxubGV0IGxlbmd0aCB0ID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiAwXG4gIHwgU29tZSBfIC0+IDFcbjs7XG5cbmxldCBpc19lbXB0eSA9IGlzX25vbmVcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IE5vbmUgLT4gaW5pdFxuICB8IFNvbWUgeCAtPiBmIGluaXQgeFxuOztcblxubGV0IGNvdW50IHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IDBcbiAgfCBTb21lIGEgLT4gaWYgZiBhIHRoZW4gMSBlbHNlIDBcbjs7XG5cbmxldCBmaW5kIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHggLT4gaWYgZiB4IHRoZW4gdCBlbHNlIE5vbmVcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBhIC0+IGYgYVxuOztcblxubGV0IGVxdWFsIGYgdCB0JyA9XG4gIG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOb25lLCBOb25lIC0+IHRydWVcbiAgfCBTb21lIHgsIFNvbWUgeCcgLT4gZiB4IHgnXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IHNvbWUgeCA9IFNvbWUgeFxuXG5sZXQgZmlyc3Rfc29tZSB4IHkgPVxuICBtYXRjaCB4IHdpdGhcbiAgfCBTb21lIF8gLT4geFxuICB8IE5vbmUgLT4geVxuOztcblxubGV0IHNvbWVfaWYgY29uZCB4ID0gaWYgY29uZCB0aGVuIFNvbWUgeCBlbHNlIE5vbmVcblxubGV0IG1lcmdlIGEgYiB+ZiA9XG4gIG1hdGNoIGEsIGIgd2l0aFxuICB8IE5vbmUsIHggfCB4LCBOb25lIC0+IHhcbiAgfCBTb21lIGEsIFNvbWUgYiAtPiBTb21lIChmIGEgYilcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNvbWUgdiBhcyBvIHdoZW4gZiB2IC0+IG9cbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCB0cnlfd2l0aCBmID1cbiAgbWF0Y2ggZiAoKSB3aXRoXG4gIHwgeCAtPiBTb21lIHhcbiAgfCBleGNlcHRpb24gXyAtPiBOb25lXG47O1xuXG5sZXQgdHJ5X3dpdGhfam9pbiBmID1cbiAgbWF0Y2ggZiAoKSB3aXRoXG4gIHwgeCAtPiB4XG4gIHwgZXhjZXB0aW9uIF8gLT4gTm9uZVxuOztcblxubGV0IG1hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBhIC0+IFNvbWUgKGYgYSlcbjs7XG5cbmxldCBhcHBseSBmIHggPVxuICBtYXRjaCBmIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIGYgLT4gbWFwIH5mIHhcbjs7XG5cbm1vZHVsZSBNb25hZF9hcmcgPSBzdHJ1Y3RcbiAgdHlwZSAnYSB0ID0gJ2Egb3B0aW9uXG5cbiAgbGV0IHJldHVybiB4ID0gU29tZSB4XG4gIGxldCBhcHBseSA9IGFwcGx5XG4gIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuXG4gIGxldCBiaW5kIG8gfmYgPVxuICAgIG1hdGNoIG8gd2l0aFxuICAgIHwgTm9uZSAtPiBOb25lXG4gICAgfCBTb21lIHggLT4gZiB4XG4gIDs7XG5lbmRcblxuaW5jbHVkZSBNb25hZC5NYWtlIChNb25hZF9hcmcpXG5pbmNsdWRlIEFwcGxpY2F0aXZlLk1ha2UgKE1vbmFkX2FyZylcblxubGV0IGZvbGRfcmVzdWx0IHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF9yZXN1bHQgfmZvbGQgfmluaXQgfmYgdFxubGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZVxuXG5tb2R1bGUgT2Zfc2V4cGFibGVcbiAgICAoU2V4cGFibGUgOiBTKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGUgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX3NleHBhYmxlIDogdCAtPiBTZXhwYWJsZS50XG4gICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX3NleHBhYmxlIDogU2V4cGFibGUudCAtPiB0XG4gICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTIHdpdGggdHlwZSB0IDo9IE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgdCA9IFNleHBhYmxlLnNleHBfb2ZfdCAoTS50b19zZXhwYWJsZSB0KVxuZW5kXG5cbm1vZHVsZSBPZl9zZXhwYWJsZTFcbiAgICAoU2V4cGFibGUgOiBTMSkgKE0gOiBzaWdcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSAnYSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX3NleHBhYmxlIDogJ2EgdCAtPiAnYSBTZXhwYWJsZS50XG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCBvZl9zZXhwYWJsZSA6ICdhIFNleHBhYmxlLnQgLT4gJ2EgdFxuICAgICAgICAgICAgICAgICAgICAgZW5kKSA6IFMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID1cbiAgICBsZXQgcyA9IFNleHBhYmxlLnRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IFNleHBhYmxlLnNleHBfb2ZfdCBzZXhwX29mX2EgKE0udG9fc2V4cGFibGUgdClcbmVuZFxuXG5tb2R1bGUgT2Zfc2V4cGFibGUyXG4gICAgKFNleHBhYmxlIDogUzIpIChNIDogc2lnXG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgICAgICAgICAgICAgICAgICAgIHZhbCB0b19zZXhwYWJsZSA6ICgnYSwgJ2IpIHQgLT4gKCdhLCAnYikgU2V4cGFibGUudFxuICAgICAgICAgICAgICAgICAgICAgICB2YWwgb2Zfc2V4cGFibGUgOiAoJ2EsICdiKSBTZXhwYWJsZS50IC0+ICgnYSwgJ2IpIHRcbiAgICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBhX29mX3NleHAgYl9vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgc2V4cCBpblxuICAgIHRyeSBNLm9mX3NleHBhYmxlIHMgd2l0aFxuICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIHQgPVxuICAgIFNleHBhYmxlLnNleHBfb2ZfdCBzZXhwX29mX2Egc2V4cF9vZl9iIChNLnRvX3NleHBhYmxlIHQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE9mX3NleHBhYmxlM1xuICAgIChTZXhwYWJsZSA6IFMzKSAoTSA6IHNpZ1xuICAgICAgICAgICAgICAgICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIHRvX3NleHBhYmxlIDogKCdhLCAnYiwgJ2MpIHQgLT4gKCdhLCAnYiwgJ2MpIFNleHBhYmxlLnRcbiAgICAgICAgICAgICAgICAgICAgICAgdmFsIG9mX3NleHBhYmxlIDogKCdhLCAnYiwgJ2MpIFNleHBhYmxlLnQgLT4gKCdhLCAnYiwgJ2MpIHRcbiAgICAgICAgICAgICAgICAgICAgIGVuZCkgOiBTMyB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIE0udCA9IHN0cnVjdFxuICBsZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgY19vZl9zZXhwIHNleHAgPVxuICAgIGxldCBzID0gU2V4cGFibGUudF9vZl9zZXhwIGFfb2Zfc2V4cCBiX29mX3NleHAgY19vZl9zZXhwIHNleHAgaW5cbiAgICB0cnkgTS5vZl9zZXhwYWJsZSBzIHdpdGhcbiAgICB8IGV4biAtPiBvZl9zZXhwX2Vycm9yX2V4biBleG4gc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHNleHBfb2ZfYiBzZXhwX29mX2MgdCA9XG4gICAgU2V4cGFibGUuc2V4cF9vZl90IHNleHBfb2ZfYSBzZXhwX29mX2Igc2V4cF9vZl9jIChNLnRvX3NleHBhYmxlIHQpXG4gIDs7XG5lbmRcblxubW9kdWxlIE9mX3N0cmluZ2FibGUgKE0gOiBTdHJpbmdhYmxlLlMpIDogUyB3aXRoIHR5cGUgdCA6PSBNLnQgPSBzdHJ1Y3RcbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID1cbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IFNleHAuQXRvbSBzIC0+XG4gICAgICAodHJ5IE0ub2Zfc3RyaW5nIHMgd2l0aFxuICAgICAgIHwgZXhuIC0+IG9mX3NleHBfZXJyb3JfZXhuIGV4biBzZXhwKVxuICAgIHwgU2V4cC5MaXN0IF8gLT5cbiAgICAgIG9mX3NleHBfZXJyb3JcbiAgICAgICAgXCJTZXhwYWJsZS5PZl9zdHJpbmdhYmxlLnRfb2Zfc2V4cCBleHBlY3RlZCBhbiBhdG9tLCBidXQgZ290IGEgbGlzdFwiXG4gICAgICAgIHNleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKE0udG9fc3RyaW5nIHQpXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBFaXRoZXJfaW50ZlxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBFaXRoZXIwXG5cbmxldCBzd2FwID0gZnVuY3Rpb25cbiAgfCBGaXJzdCB4IC0+IFNlY29uZCB4XG4gIHwgU2Vjb25kIHggLT4gRmlyc3QgeFxuOztcblxubGV0IGlzX2ZpcnN0ID0gZnVuY3Rpb25cbiAgfCBGaXJzdCBfIC0+IHRydWVcbiAgfCBTZWNvbmQgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX3NlY29uZCA9IGZ1bmN0aW9uXG4gIHwgRmlyc3QgXyAtPiBmYWxzZVxuICB8IFNlY29uZCBfIC0+IHRydWVcbjs7XG5cbmxldCB2YWx1ZSAoRmlyc3QgeCB8IFNlY29uZCB4KSA9IHhcblxubGV0IHZhbHVlX21hcCB0IH5maXJzdCB+c2Vjb25kID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRmlyc3QgeCAtPiBmaXJzdCB4XG4gIHwgU2Vjb25kIHggLT4gc2Vjb25kIHhcbjs7XG5cbmxldCBpdGVyID0gdmFsdWVfbWFwXG5cbmxldCBtYXAgdCB+Zmlyc3QgfnNlY29uZCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEZpcnN0IHggLT4gRmlyc3QgKGZpcnN0IHgpXG4gIHwgU2Vjb25kIHggLT4gU2Vjb25kIChzZWNvbmQgeClcbjs7XG5cbmxldCBmaXJzdCB4ID0gRmlyc3QgeFxubGV0IHNlY29uZCB4ID0gU2Vjb25kIHhcblxubGV0IGVxdWFsIGVxMSBlcTIgdDEgdDIgPVxuICBtYXRjaCB0MSwgdDIgd2l0aFxuICB8IEZpcnN0IHgsIEZpcnN0IHkgLT4gZXExIHggeVxuICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBlcTIgeCB5XG4gIHwgRmlyc3QgXywgU2Vjb25kIF8gfCBTZWNvbmQgXywgRmlyc3QgXyAtPiBmYWxzZVxuOztcblxubGV0IGludmFyaWFudCBmIHMgPSBmdW5jdGlvblxuICB8IEZpcnN0IHggLT4gZiB4XG4gIHwgU2Vjb25kIHkgLT4gcyB5XG47O1xuXG5tb2R1bGUgTWFrZV9mb2N1c2VkIChNIDogc2lnXG4gICAgdHlwZSAoKydhLCArJ2IpIHRcblxuICAgIHZhbCByZXR1cm4gOiAnYSAtPiAoJ2EsIF8pIHRcbiAgICB2YWwgb3RoZXIgOiAnYiAtPiAoXywgJ2IpIHRcbiAgICB2YWwgZWl0aGVyIDogKCdhLCAnYikgdCAtPiByZXR1cm46KCdhIC0+ICdjKSAtPiBvdGhlcjooJ2IgLT4gJ2MpIC0+ICdjXG5cbiAgICB2YWwgY29tYmluZVxuICAgICAgOiAgKCdhLCAnZCkgdFxuICAgICAgLT4gKCdiLCAnZCkgdFxuICAgICAgLT4gZjooJ2EgLT4gJ2IgLT4gJ2MpXG4gICAgICAtPiBvdGhlcjooJ2QgLT4gJ2QgLT4gJ2QpXG4gICAgICAtPiAoJ2MsICdkKSB0XG5cbiAgICB2YWwgYmluZCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2EgLT4gKCdjLCAnYikgdCkgLT4gKCdjLCAnYikgdFxuICBlbmQpID1cbnN0cnVjdFxuICBpbmNsdWRlIE1cbiAgb3BlbiBXaXRoX3JldHVyblxuXG4gIGxldCBtYXAgdCB+ZiA9IGJpbmQgdCB+ZjooZnVuIHggLT4gcmV0dXJuIChmIHgpKVxuXG4gIGluY2x1ZGUgTW9uYWQuTWFrZTIgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICAgICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgICAgbGV0IGJpbmQgPSBiaW5kXG4gICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICBlbmQpXG5cbiAgbW9kdWxlIEFwcCA9IEFwcGxpY2F0aXZlLk1ha2UyIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSB0XG5cbiAgICAgIGxldCByZXR1cm4gPSByZXR1cm5cbiAgICAgIGxldCBhcHBseSB0MSB0MiA9IGJpbmQgdDEgfmY6KGZ1biBmIC0+IGJpbmQgdDIgfmY6KGZ1biB4IC0+IHJldHVybiAoZiB4KSkpXG4gICAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICBlbmQpXG5cbiAgaW5jbHVkZSBBcHBcblxuICBsZXQgY29tYmluZV9hbGwgPVxuICAgIGxldCByZWMgb3RoZXJfbG9vcCBmIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IG90aGVyIGFjY1xuICAgICAgfCB0IDo6IHRzIC0+XG4gICAgICAgIGVpdGhlclxuICAgICAgICAgIHRcbiAgICAgICAgICB+cmV0dXJuOihmdW4gXyAtPiBvdGhlcl9sb29wIGYgYWNjIHRzKVxuICAgICAgICAgIH5vdGhlcjooZnVuIG8gLT4gb3RoZXJfbG9vcCBmIChmIGFjYyBvKSB0cylcbiAgICBpblxuICAgIGxldCByZWMgcmV0dXJuX2xvb3AgZiBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXR1cm4gKExpc3QucmV2IGFjYylcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICBlaXRoZXJcbiAgICAgICAgICB0XG4gICAgICAgICAgfnJldHVybjooZnVuIHggLT4gcmV0dXJuX2xvb3AgZiAoeCA6OiBhY2MpIHRzKVxuICAgICAgICAgIH5vdGhlcjooZnVuIG8gLT4gb3RoZXJfbG9vcCBmIG8gdHMpXG4gICAgaW5cbiAgICBmdW4gdHMgfmYgLT4gcmV0dXJuX2xvb3AgZiBbXSB0c1xuICA7O1xuXG4gIGxldCBjb21iaW5lX2FsbF91bml0ID1cbiAgICBsZXQgcmVjIG90aGVyX2xvb3AgZiBhY2MgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBvdGhlciBhY2NcbiAgICAgIHwgdCA6OiB0cyAtPlxuICAgICAgICBlaXRoZXJcbiAgICAgICAgICB0XG4gICAgICAgICAgfnJldHVybjooZnVuICgpIC0+IG90aGVyX2xvb3AgZiBhY2MgdHMpXG4gICAgICAgICAgfm90aGVyOihmdW4gbyAtPiBvdGhlcl9sb29wIGYgKGYgYWNjIG8pIHRzKVxuICAgIGluXG4gICAgbGV0IHJlYyByZXR1cm5fbG9vcCBmID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuICgpXG4gICAgICB8IHQgOjogdHMgLT5cbiAgICAgICAgZWl0aGVyIHQgfnJldHVybjooZnVuICgpIC0+IHJldHVybl9sb29wIGYgdHMpIH5vdGhlcjooZnVuIG8gLT4gb3RoZXJfbG9vcCBmIG8gdHMpXG4gICAgaW5cbiAgICBmdW4gdHMgfmYgLT4gcmV0dXJuX2xvb3AgZiB0c1xuICA7O1xuXG4gIGxldCB0b19vcHRpb24gdCA9IGVpdGhlciB0IH5yZXR1cm46T3B0aW9uLnNvbWUgfm90aGVyOihmdW4gXyAtPiBOb25lKVxuICBsZXQgdmFsdWUgdCB+ZGVmYXVsdCA9IGVpdGhlciB0IH5yZXR1cm46Rm4uaWQgfm90aGVyOihmdW4gXyAtPiBkZWZhdWx0KVxuXG4gIGxldCB3aXRoX3JldHVybiBmID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHJldCAtPiBvdGhlciAoZiAoV2l0aF9yZXR1cm4ucHJlcGVuZCByZXQgfmY6cmV0dXJuKSkpXG4gIDs7XG5lbmRcblxubW9kdWxlIEZpcnN0ID0gTWFrZV9mb2N1c2VkIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdiKSB0ID0gKCdhLCAnYikgdFxuXG4gICAgbGV0IHJldHVybiA9IGZpcnN0XG4gICAgbGV0IG90aGVyID0gc2Vjb25kXG5cbiAgICBsZXQgZWl0aGVyIHQgfnJldHVybiB+b3RoZXIgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEZpcnN0IHggLT4gcmV0dXJuIHhcbiAgICAgIHwgU2Vjb25kIHkgLT4gb3RoZXIgeVxuICAgIDs7XG5cbiAgICBsZXQgY29tYmluZSB0MSB0MiB+ZiB+b3RoZXIgPVxuICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgIHwgRmlyc3QgeCwgRmlyc3QgeSAtPiBGaXJzdCAoZiB4IHkpXG4gICAgICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBTZWNvbmQgKG90aGVyIHggeSlcbiAgICAgIHwgU2Vjb25kIHgsIF8gfCBfLCBTZWNvbmQgeCAtPiBTZWNvbmQgeFxuICAgIDs7XG5cbiAgICBsZXQgYmluZCB0IH5mID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBGaXJzdCB4IC0+IGYgeFxuICAgICAgKCogUmV1c2UgdGhlIHZhbHVlIGluIG9yZGVyIHRvIGF2b2lkIGFsbG9jYXRpb24uICopXG4gICAgICB8IFNlY29uZCBfIGFzIHkgLT4geVxuICAgIDs7XG4gIGVuZClcblxubW9kdWxlIFNlY29uZCA9IE1ha2VfZm9jdXNlZCAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYiwgJ2EpIHRcblxuICAgIGxldCByZXR1cm4gPSBzZWNvbmRcbiAgICBsZXQgb3RoZXIgPSBmaXJzdFxuXG4gICAgbGV0IGVpdGhlciB0IH5yZXR1cm4gfm90aGVyID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBTZWNvbmQgeSAtPiByZXR1cm4geVxuICAgICAgfCBGaXJzdCB4IC0+IG90aGVyIHhcbiAgICA7O1xuXG4gICAgbGV0IGNvbWJpbmUgdDEgdDIgfmYgfm90aGVyID1cbiAgICAgIG1hdGNoIHQxLCB0MiB3aXRoXG4gICAgICB8IFNlY29uZCB4LCBTZWNvbmQgeSAtPiBTZWNvbmQgKGYgeCB5KVxuICAgICAgfCBGaXJzdCB4LCBGaXJzdCB5IC0+IEZpcnN0IChvdGhlciB4IHkpXG4gICAgICB8IEZpcnN0IHgsIF8gfCBfLCBGaXJzdCB4IC0+IEZpcnN0IHhcbiAgICA7O1xuXG4gICAgbGV0IGJpbmQgdCB+ZiA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgU2Vjb25kIHggLT4gZiB4XG4gICAgICAoKiBSZXVzZSB0aGUgdmFsdWUgaW4gb3JkZXIgdG8gYXZvaWQgYWxsb2NhdGlvbiwgbGlrZSBbRmlyc3QuYmluZF0gYWJvdmUuICopXG4gICAgICB8IEZpcnN0IF8gYXMgeSAtPiB5XG4gICAgOztcbiAgZW5kKVxuXG5tb2R1bGUgRXhwb3J0ID0gc3RydWN0XG4gIHR5cGUgKCdmLCAncykgX2VpdGhlciA9ICgnZiwgJ3MpIHQgPVxuICAgIHwgRmlyc3Qgb2YgJ2ZcbiAgICB8IFNlY29uZCBvZiAnc1xuZW5kXG4iLCJpbmNsdWRlIEluZGV4ZWRfY29udGFpbmVyX2ludGZcblxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxubGV0IGl0ZXJpIH5mb2xkIHQgfmYgPVxuICBpZ25vcmVcbiAgICAoZm9sZCB0IH5pbml0OjAgfmY6KGZ1biBpIHggLT5cbiAgICAgICBmIGkgeDtcbiAgICAgICBpICsgMSlcbiAgICAgOiBpbnQpXG47O1xuXG5sZXQgZm9sZGkgfmZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgZm9sZCB0IH5pbml0IH5mOihmdW4gYWNjIHYgLT5cbiAgICBsZXQgYWNjID0gZiAhaSBhY2MgdiBpblxuICAgIGkgOj0gIWkgKyAxO1xuICAgIGFjYylcbjs7XG5cbmxldCBjb3VudGkgfmZvbGRpIHQgfmYgPSBmb2xkaSB0IH5pbml0OjAgfmY6KGZ1biBpIG4gYSAtPiBpZiBmIGkgYSB0aGVuIG4gKyAxIGVsc2UgbilcblxubGV0IGV4aXN0c2kgfml0ZXJpIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSBjIH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgZmFsc2UpXG47O1xuXG5sZXQgZm9yX2FsbGkgfml0ZXJpIGMgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSBjIH5mOihmdW4gaSB4IC0+IGlmIG5vdCAoZiBpIHgpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgZmluZF9tYXBpIH5pdGVyaSB0IH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgdCB+ZjooZnVuIGkgeCAtPlxuICAgICAgbWF0Y2ggZiBpIHggd2l0aFxuICAgICAgfCBOb25lIC0+ICgpXG4gICAgICB8IFNvbWUgXyBhcyByZXMgLT4gci5yZXR1cm4gcmVzKTtcbiAgICBOb25lKVxuOztcblxubGV0IGZpbmRpIH5pdGVyaSBjIH5mID1cbiAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgaXRlcmkgYyB+ZjooZnVuIGkgeCAtPiBpZiBmIGkgeCB0aGVuIHIucmV0dXJuIChTb21lIChpLCB4KSkpO1xuICAgIE5vbmUpXG47O1xuXG5tb2R1bGUgTWFrZV9nZW4gKFQgOiBzaWdcbiAgICBpbmNsdWRlIENvbnRhaW5lcl9pbnRmLk1ha2VfZ2VuX2FyZ1xuXG4gICAgdmFsIGl0ZXJpIDogWyBgRGVmaW5lX3VzaW5nX2ZvbGQgfCBgQ3VzdG9tIG9mICgnYSB0LCAnYSBlbHQpIGl0ZXJpIF1cbiAgICB2YWwgZm9sZGkgOiBbIGBEZWZpbmVfdXNpbmdfZm9sZCB8IGBDdXN0b20gb2YgKCdhIHQsICdhIGVsdCwgXykgZm9sZGkgXVxuICBlbmQpIDogR2VuZXJpYyB3aXRoIHR5cGUgJ2EgdCA6PSAnYSBULnQgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBULmVsdCA9IHN0cnVjdFxuICBpbmNsdWRlIENvbnRhaW5lci5NYWtlX2dlbiAoVClcblxuICBsZXQgaXRlcmkgPVxuICAgIG1hdGNoIFQuaXRlcmkgd2l0aFxuICAgIHwgYEN1c3RvbSBpdGVyaSAtPiBpdGVyaVxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IH5mIC0+IGl0ZXJpIH5mb2xkIHQgfmZcbiAgOztcblxuICBsZXQgZm9sZGkgPVxuICAgIG1hdGNoIFQuZm9sZGkgd2l0aFxuICAgIHwgYEN1c3RvbSBmb2xkaSAtPiBmb2xkaVxuICAgIHwgYERlZmluZV91c2luZ19mb2xkIC0+IGZ1biB0IH5pbml0IH5mIC0+IGZvbGRpIH5mb2xkIHQgfmluaXQgfmZcbiAgOztcblxuICBsZXQgY291bnRpIHQgfmYgPSBjb3VudGkgfmZvbGRpIHQgfmZcbiAgbGV0IGV4aXN0c2kgdCB+ZiA9IGV4aXN0c2kgfml0ZXJpIHQgfmZcbiAgbGV0IGZvcl9hbGxpIHQgfmYgPSBmb3JfYWxsaSB+aXRlcmkgdCB+ZlxuICBsZXQgZmluZF9tYXBpIHQgfmYgPSBmaW5kX21hcGkgfml0ZXJpIHQgfmZcbiAgbGV0IGZpbmRpIHQgfmYgPSBmaW5kaSB+aXRlcmkgdCB+ZlxuZW5kXG5cbm1vZHVsZSBNYWtlIChUIDogTWFrZV9hcmcpID0gc3RydWN0XG4gIG1vZHVsZSBDID0gQ29udGFpbmVyLk1ha2UgKFQpXG5cbiAgKCogTm90IHBhcnQgb2YgW0NvbnRhaW5lci5HZW5lcmljXS4gKilcbiAgbGV0IG1lbSA9IEMubWVtXG5cbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAnYSB0ID0gJ2EgVC50XG4gICAgICB0eXBlICdhIGVsdCA9ICdhXG4gICAgZW5kKVxuZW5kXG5cbm1vZHVsZSBNYWtlMCAoVCA6IE1ha2UwX2FyZykgPSBzdHJ1Y3RcbiAgbW9kdWxlIEMgPSBDb250YWluZXIuTWFrZTAgKFQpXG5cbiAgKCogTm90IHBhcnQgb2YgW0NvbnRhaW5lci5HZW5lcmljXS4gKilcbiAgbGV0IG1lbSA9IEMubWVtXG5cbiAgaW5jbHVkZSBNYWtlX2dlbiAoc3RydWN0XG4gICAgICBpbmNsdWRlIFRcblxuICAgICAgdHlwZSAnYSB0ID0gVC50XG4gICAgICB0eXBlICdhIGVsdCA9IFQuRWx0LnRcbiAgICBlbmQpXG5lbmRcbiIsIm9wZW4hIEltcG9ydFxub3BlbiBDb250YWluZXJfaW50Zi5FeHBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIExpc3QgPSBMaXN0MVxuXG5tb2R1bGUgU3RlcCA9IHN0cnVjdFxuICAoKiAnYSBpcyBhbiBpdGVtIGluIHRoZSBzZXF1ZW5jZSwgJ3MgaXMgdGhlIHN0YXRlIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSByZW1haW5kZXIgb2ZcbiAgICAgdGhlIHNlcXVlbmNlICopXG4gIHR5cGUgKCdhLCAncykgdCA9XG4gICAgfCBEb25lXG4gICAgfCBTa2lwIG9mICdzXG4gICAgfCBZaWVsZCBvZiAnYSAqICdzXG4gIFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdhICdzLlxuICAgICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdzIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2EsICdzKSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biAodHlwZSBhX18wMDlfIHNfXzAxMF8pXG4gICAgICAgIDogICgoYV9fMDA5XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IChzX18wMTBfIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgICAgIC0+IChhX18wMDlfLCBzX18wMTBfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICAgIGZ1biBfb2ZfYV9fMDAxXyBfb2Zfc19fMDAyXyAtPiBmdW5jdGlvblxuICAgICAgICB8IERvbmUgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiRG9uZVwiXG4gICAgICAgIHwgU2tpcCBhcmcwX18wMDNfIC0+XG4gICAgICAgICAgbGV0IHJlczBfXzAwNF8gPSBfb2Zfc19fMDAyXyBhcmcwX18wMDNfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiU2tpcFwiOyByZXMwX18wMDRfIF1cbiAgICAgICAgfCBZaWVsZCAoYXJnMF9fMDA1XywgYXJnMV9fMDA2XykgLT5cbiAgICAgICAgICBsZXQgcmVzMF9fMDA3XyA9IF9vZl9hX18wMDFfIGFyZzBfXzAwNV9cbiAgICAgICAgICBhbmQgcmVzMV9fMDA4XyA9IF9vZl9zX18wMDJfIGFyZzFfXzAwNl8gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJZaWVsZFwiOyByZXMwX18wMDdfOyByZXMxX18wMDhfIF1cbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbm9wZW4gU3RlcFxuXG4oKiAnYSBpcyBhbiBpdGVtIGluIHRoZSBzZXF1ZW5jZSwgJ3MgaXMgdGhlIHN0YXRlIHRoYXQgd2lsbCBwcm9kdWNlIHRoZSByZW1haW5kZXIgb2YgdGhlXG4gICBzZXF1ZW5jZSAqKVxudHlwZSArXyB0ID0gU2VxdWVuY2UgOiAncyAqICgncyAtPiAoJ2EsICdzKSBTdGVwLnQpIC0+ICdhIHRcbnR5cGUgJ2Egc2VxdWVuY2UgPSAnYSB0XG5cbm1vZHVsZSBFeHBlcnQgPSBzdHJ1Y3RcbiAgbGV0IG5leHRfc3RlcCAoU2VxdWVuY2UgKHMsIGYpKSA9XG4gICAgbWF0Y2ggZiBzIHdpdGhcbiAgICB8IERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCBzIC0+IFNraXAgKFNlcXVlbmNlIChzLCBmKSlcbiAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgU2VxdWVuY2UgKHMsIGYpKVxuICA7O1xuXG4gIGxldCBkZWxheWVkX2ZvbGRfc3RlcCBzIH5pbml0IH5mIH5maW5pc2ggPVxuICAgIGxldCByZWMgbG9vcCBzIG5leHQgZmluaXNoIGYgYWNjID1cbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gZmluaXNoIGFjY1xuICAgICAgfCBTa2lwIHMgLT4gZiBhY2MgTm9uZSB+azoobG9vcCBzIG5leHQgZmluaXNoIGYpXG4gICAgICB8IFlpZWxkIChhLCBzKSAtPiBmIGFjYyAoU29tZSBhKSB+azoobG9vcCBzIG5leHQgZmluaXNoIGYpXG4gICAgaW5cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIHMgbmV4dCBmaW5pc2ggZiBpbml0XG4gIDs7XG5lbmRcblxubGV0IHVuZm9sZF9zdGVwIH5pbml0IH5mID0gU2VxdWVuY2UgKGluaXQsIGYpXG5cbmxldCB1bmZvbGQgfmluaXQgfmYgPVxuICB1bmZvbGRfc3RlcCB+aW5pdCB+ZjooZnVuIHMgLT5cbiAgICBtYXRjaCBmIHMgd2l0aFxuICAgIHwgTm9uZSAtPiBTdGVwLkRvbmVcbiAgICB8IFNvbWUgKGEsIHMpIC0+IFN0ZXAuWWllbGQgKGEsIHMpKVxuOztcblxubGV0IHVuZm9sZF93aXRoIHMgfmluaXQgfmYgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoaW5pdCwgcylcbiAgICAgICwgZnVuIChzZWVkLCBzKSAtPlxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChzZWVkLCBzKVxuICAgICAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgICAgIChtYXRjaCBmIHNlZWQgYSB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgICAgIHwgU2tpcCBzZWVkIC0+IFNraXAgKHNlZWQsIHMpXG4gICAgICAgICAgIHwgWWllbGQgKGEsIHNlZWQpIC0+IFlpZWxkIChhLCAoc2VlZCwgcykpKSApXG47O1xuXG5sZXQgdW5mb2xkX3dpdGhfYW5kX2ZpbmlzaCBzIH5pbml0IH5ydW5uaW5nX3N0ZXAgfmlubmVyX2ZpbmlzaGVkIH5maW5pc2hpbmdfc3RlcCA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIGBJbm5lcl9ydW5uaW5nIChpbml0LCBzKVxuICAgICAgLCBmdW4gc3RhdGUgLT5cbiAgICAgICAgbWF0Y2ggc3RhdGUgd2l0aFxuICAgICAgICB8IGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpIC0+XG4gICAgICAgICAgKG1hdGNoIG5leHQgaW5uZXJfc3RhdGUgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gU2tpcCAoYElubmVyX2ZpbmlzaGVkIChpbm5lcl9maW5pc2hlZCBzdGF0ZSkpXG4gICAgICAgICAgIHwgU2tpcCBpbm5lcl9zdGF0ZSAtPiBTa2lwIChgSW5uZXJfcnVubmluZyAoc3RhdGUsIGlubmVyX3N0YXRlKSlcbiAgICAgICAgICAgfCBZaWVsZCAoeCwgaW5uZXJfc3RhdGUpIC0+XG4gICAgICAgICAgICAgKG1hdGNoIHJ1bm5pbmdfc3RlcCBzdGF0ZSB4IHdpdGhcbiAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgfCBTa2lwIHN0YXRlIC0+IFNraXAgKGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpKVxuICAgICAgICAgICAgICB8IFlpZWxkICh5LCBzdGF0ZSkgLT4gWWllbGQgKHksIGBJbm5lcl9ydW5uaW5nIChzdGF0ZSwgaW5uZXJfc3RhdGUpKSkpXG4gICAgICAgIHwgYElubmVyX2ZpbmlzaGVkIHN0YXRlIC0+XG4gICAgICAgICAgKG1hdGNoIGZpbmlzaGluZ19zdGVwIHN0YXRlIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHN0YXRlIC0+IFNraXAgKGBJbm5lcl9maW5pc2hlZCBzdGF0ZSlcbiAgICAgICAgICAgfCBZaWVsZCAoeSwgc3RhdGUpIC0+IFlpZWxkICh5LCBgSW5uZXJfZmluaXNoZWQgc3RhdGUpKSApXG47O1xuXG5sZXQgb2ZfbGlzdCBsID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6bCB+ZjooZnVuY3Rpb25cbiAgICB8IFtdIC0+IERvbmVcbiAgICB8IHggOjogbCAtPiBZaWVsZCAoeCwgbCkpXG47O1xuXG5cbmxldCBmb2xkIHQgfmluaXQgfmYgPVxuICBsZXQgcmVjIGxvb3Agc2VlZCB2IG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICB8IERvbmUgLT4gdlxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyB2IG5leHQgZlxuICAgIHwgWWllbGQgKGEsIHMpIC0+IGxvb3AgcyAoZiB2IGEpIG5leHQgZlxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIGluaXQgbmV4dCBmXG47O1xuXG5sZXQgdG9fbGlzdF9yZXYgdCA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIGwgeCAtPiB4IDo6IGwpXG5cblxubGV0IHRvX2xpc3QgKFNlcXVlbmNlIChzLCBuZXh0KSkgPVxuICBsZXQgc2FmZV90b19saXN0IHQgPSBMaXN0LnJldiAodG9fbGlzdF9yZXYgdCkgaW5cbiAgbGV0IHJlYyB0b19saXN0IHMgbmV4dCBpID1cbiAgICBpZiBpID0gMFxuICAgIHRoZW4gc2FmZV90b19saXN0IChTZXF1ZW5jZSAocywgbmV4dCkpXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgfCBEb25lIC0+IFtdXG4gICAgICB8IFNraXAgcyAtPiB0b19saXN0IHMgbmV4dCBpXG4gICAgICB8IFlpZWxkIChhLCBzKSAtPiBhIDo6IHRvX2xpc3QgcyBuZXh0IChpIC0gMSkpXG4gIGluXG4gIHRvX2xpc3QgcyBuZXh0IDUwMFxuOztcblxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX2EgKHRvX2xpc3QgdClcblxubGV0IHJhbmdlID8oc3RyaWRlID0gMSkgPyhzdGFydCA9IGBpbmNsdXNpdmUpID8oc3RvcCA9IGBleGNsdXNpdmUpIHN0YXJ0X3Ygc3RvcF92ID1cbiAgbGV0IHN0ZXAgPVxuICAgIG1hdGNoIHN0b3Agd2l0aFxuICAgIHwgYGluY2x1c2l2ZSB3aGVuIHN0cmlkZSA+PSAwIC0+XG4gICAgICBmdW4gaSAtPiBpZiBpID4gc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIChpLCBpICsgc3RyaWRlKVxuICAgIHwgYGluY2x1c2l2ZSAtPiBmdW4gaSAtPiBpZiBpIDwgc3RvcF92IHRoZW4gRG9uZSBlbHNlIFlpZWxkIChpLCBpICsgc3RyaWRlKVxuICAgIHwgYGV4Y2x1c2l2ZSB3aGVuIHN0cmlkZSA+PSAwIC0+XG4gICAgICBmdW4gaSAtPiBpZiBpID49IHN0b3BfdiB0aGVuIERvbmUgZWxzZSBZaWVsZCAoaSwgaSArIHN0cmlkZSlcbiAgICB8IGBleGNsdXNpdmUgLT4gZnVuIGkgLT4gaWYgaSA8PSBzdG9wX3YgdGhlbiBEb25lIGVsc2UgWWllbGQgKGksIGkgKyBzdHJpZGUpXG4gIGluXG4gIGxldCBpbml0ID1cbiAgICBtYXRjaCBzdGFydCB3aXRoXG4gICAgfCBgaW5jbHVzaXZlIC0+IHN0YXJ0X3ZcbiAgICB8IGBleGNsdXNpdmUgLT4gc3RhcnRfdiArIHN0cmlkZVxuICBpblxuICB1bmZvbGRfc3RlcCB+aW5pdCB+ZjpzdGVwXG47O1xuXG5sZXQgb2ZfbGF6eSB0X2xhenkgPVxuICB1bmZvbGRfc3RlcCB+aW5pdDp0X2xhenkgfmY6KGZ1biB0X2xhenkgLT5cbiAgICBsZXQgKFNlcXVlbmNlIChzLCBuZXh0KSkgPSBMYXp5LmZvcmNlIHRfbGF6eSBpblxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgcyAtPlxuICAgICAgU2tpcFxuICAgICAgICAobGV0IHYgPSBTZXF1ZW5jZSAocywgbmV4dCkgaW5cbiAgICAgICAgIGxhenkgdilcbiAgICB8IFlpZWxkICh4LCBzKSAtPlxuICAgICAgWWllbGRcbiAgICAgICAgKCB4XG4gICAgICAgICwgbGV0IHYgPSBTZXF1ZW5jZSAocywgbmV4dCkgaW5cbiAgICAgICAgICBsYXp5IHYgKSlcbjs7XG5cbmxldCBtYXAgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIHNlZWRcbiAgICAgICwgZnVuIHNlZWQgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCBzXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChmIGEsIHMpIClcbjs7XG5cbmxldCBtYXBpIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoMCwgcylcbiAgICAgICwgZnVuIChpLCBzKSAtPlxuICAgICAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChpLCBzKVxuICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoZiBpIGEsIChpICsgMSwgcykpIClcbjs7XG5cbmxldCBmb2xkaW5nX21hcCB0IH5pbml0IH5mID1cbiAgdW5mb2xkX3dpdGggdCB+aW5pdCB+ZjooZnVuIGFjYyB4IC0+XG4gICAgbGV0IGFjYywgeCA9IGYgYWNjIHggaW5cbiAgICBZaWVsZCAoeCwgYWNjKSlcbjs7XG5cbmxldCBmb2xkaW5nX21hcGkgdCB+aW5pdCB+ZiA9XG4gIHVuZm9sZF93aXRoIHQgfmluaXQ6KDAsIGluaXQpIH5mOihmdW4gKGksIGFjYykgeCAtPlxuICAgIGxldCBhY2MsIHggPSBmIGkgYWNjIHggaW5cbiAgICBZaWVsZCAoeCwgKGkgKyAxLCBhY2MpKSlcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIHNlZWRcbiAgICAgICwgZnVuIHNlZWQgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCBzXG4gICAgICAgIHwgWWllbGQgKGEsIHMpIHdoZW4gZiBhIC0+IFlpZWxkIChhLCBzKVxuICAgICAgICB8IFlpZWxkIChfLCBzKSAtPiBTa2lwIHMgKVxuOztcblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIG1hcCB+ZjpzbmQgKGZpbHRlciAobWFwaSB0IH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcykpXG47O1xuXG5sZXQgbGVuZ3RoIHQgPVxuICBsZXQgcmVjIGxvb3AgaSBzIG5leHQgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGlcbiAgICB8IFNraXAgcyAtPiBsb29wIGkgcyBuZXh0XG4gICAgfCBZaWVsZCAoXywgcykgLT4gbG9vcCAoaSArIDEpIHMgbmV4dFxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCAwIHNlZWQgbmV4dFxuOztcblxubGV0IHRvX2xpc3RfcmV2X3dpdGhfbGVuZ3RoIHQgPSBmb2xkIHQgfmluaXQ6KFtdLCAwKSB+ZjooZnVuIChsLCBpKSB4IC0+IHggOjogbCwgaSArIDEpXG5cbmxldCB0b19hcnJheSB0ID1cbiAgbGV0IGwsIGxlbiA9IHRvX2xpc3RfcmV2X3dpdGhfbGVuZ3RoIHQgaW5cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IHggOjogbCAtPlxuICAgIGxldCBhID0gQXJyYXkuY3JlYXRlIH5sZW4geCBpblxuICAgIGxldCByZWMgbG9vcCBpIGwgPVxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IFtdIC0+IGFzc2VydCAoaSA9IC0xKVxuICAgICAgfCB4IDo6IGwgLT5cbiAgICAgICAgYS4oaSkgPC0geDtcbiAgICAgICAgbG9vcCAoaSAtIDEpIGxcbiAgICBpblxuICAgIGxvb3AgKGxlbiAtIDIpIGw7XG4gICAgYVxuOztcblxubGV0IGZpbmQgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgWWllbGQgKGEsIF8pIHdoZW4gZiBhIC0+IFNvbWUgYVxuICAgIHwgWWllbGQgKF8sIHMpIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIChtYXRjaCBmIGEgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBsb29wIHMgbmV4dCBmXG4gICAgICAgfCBzb21lX2IgLT4gc29tZV9iKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGkgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IE5vbmVcbiAgICB8IFlpZWxkIChhLCBzKSAtPlxuICAgICAgKG1hdGNoIGYgaSBhIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gbG9vcCBzIG5leHQgZiAoaSArIDEpXG4gICAgICAgfCBzb21lX2IgLT4gc29tZV9iKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgaVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZiAwXG47O1xuXG5sZXQgZm9yX2FsbCB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBZaWVsZCAoYSwgXykgd2hlbiBub3QgKGYgYSkgLT4gZmFsc2VcbiAgICB8IFlpZWxkIChfLCBzKSB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBmXG47O1xuXG5sZXQgZm9yX2FsbGkgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzIG5leHQgZiBpID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiB0cnVlXG4gICAgfCBZaWVsZCAoYSwgXykgd2hlbiBub3QgKGYgaSBhKSAtPiBmYWxzZVxuICAgIHwgWWllbGQgKF8sIHMpIC0+IGxvb3AgcyBuZXh0IGYgKGkgKyAxKVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgaVxuICBpblxuICBtYXRjaCB0IHdpdGhcbiAgfCBTZXF1ZW5jZSAoc2VlZCwgbmV4dCkgLT4gbG9vcCBzZWVkIG5leHQgZiAwXG47O1xuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IGZhbHNlXG4gICAgfCBZaWVsZCAoYSwgXykgd2hlbiBmIGEgLT4gdHJ1ZVxuICAgIHwgWWllbGQgKF8sIHMpIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgaSA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmFsc2VcbiAgICB8IFlpZWxkIChhLCBfKSB3aGVuIGYgaSBhIC0+IHRydWVcbiAgICB8IFlpZWxkIChfLCBzKSAtPiBsb29wIHMgbmV4dCBmIChpICsgMSlcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmIGlcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGYgMFxuOztcblxubGV0IGl0ZXIgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBzZWVkIG5leHQgZiA9XG4gICAgbWF0Y2ggbmV4dCBzZWVkIHdpdGhcbiAgICB8IERvbmUgLT4gKClcbiAgICB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBmXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIGYgYTtcbiAgICAgIGxvb3AgcyBuZXh0IGZcbiAgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+IGxvb3Agc2VlZCBuZXh0IGZcbjs7XG5cbmxldCBpc19lbXB0eSB0ID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gdHJ1ZVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCBfIC0+IGZhbHNlXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dFxuOztcblxubGV0IG1lbSB0IGEgfmVxdWFsID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBhID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBmYWxzZVxuICAgIHwgWWllbGQgKGIsIF8pIHdoZW4gZXF1YWwgYSBiIC0+IHRydWVcbiAgICB8IFlpZWxkIChfLCBzKSB8IFNraXAgcyAtPiBsb29wIHMgbmV4dCBhXG4gIGluXG4gIG1hdGNoIHQgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPiBsb29wIHNlZWQgbmV4dCBhXG47O1xuXG5sZXQgZW1wdHkgPSBTZXF1ZW5jZSAoKCksIGZ1biAoKSAtPiBEb25lKVxuXG5sZXQgYmluZCB0IH5mID1cbiAgdW5mb2xkX3N0ZXBcbiAgICB+ZjooZnVuY3Rpb25cbiAgICAgIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpLCByZXN0IC0+XG4gICAgICAgIChtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICAgfCBEb25lIC0+XG4gICAgICAgICAgIChtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgICAgIHwgU2VxdWVuY2UgKHNlZWQsIG5leHQpIC0+XG4gICAgICAgICAgICAgIChtYXRjaCBuZXh0IHNlZWQgd2l0aFxuICAgICAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGVtcHR5LCBTZXF1ZW5jZSAocywgbmV4dCkpXG4gICAgICAgICAgICAgICB8IFlpZWxkIChhLCBzKSAtPiBTa2lwIChmIGEsIFNlcXVlbmNlIChzLCBuZXh0KSkpKVxuICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoU2VxdWVuY2UgKHMsIG5leHQpLCByZXN0KVxuICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIChTZXF1ZW5jZSAocywgbmV4dCksIHJlc3QpKSkpXG4gICAgfmluaXQ6KGVtcHR5LCB0KVxuOztcblxubGV0IHJldHVybiB4ID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6KFNvbWUgeCkgfmY6KGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IERvbmVcbiAgICB8IFNvbWUgeCAtPiBZaWVsZCAoeCwgTm9uZSkpXG47O1xuXG5pbmNsdWRlIE1vbmFkLk1ha2UgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICBsZXQgbWFwID0gYEN1c3RvbSBtYXBcbiAgICBsZXQgYmluZCA9IGJpbmRcbiAgICBsZXQgcmV0dXJuID0gcmV0dXJuXG4gIGVuZClcblxubGV0IG50aCBzIG4gPVxuICBpZiBuIDwgMFxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHJlYyBsb29wIGkgcyBuZXh0ID1cbiAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICB8IERvbmUgLT4gTm9uZVxuICAgICAgfCBTa2lwIHMgLT4gbG9vcCBpIHMgbmV4dFxuICAgICAgfCBZaWVsZCAoYSwgcykgLT4gaWYgcGh5c19lcXVhbCBpIDAgdGhlbiBTb21lIGEgZWxzZSBsb29wIChpIC0gMSkgcyBuZXh0XG4gICAgaW5cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIG4gcyBuZXh0KVxuOztcblxubGV0IG50aF9leG4gcyBuID1cbiAgaWYgbiA8IDBcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIlNlcXVlbmNlLm50aFwiXG4gIGVsc2UgKFxuICAgIG1hdGNoIG50aCBzIG4gd2l0aFxuICAgIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLm50aFwiXG4gICAgfCBTb21lIHggLT4geClcbjs7XG5cbm1vZHVsZSBNZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudCA9IHN0cnVjdFxuICB0eXBlICgnYSwgJ2IpIHQgPVxuICAgIHwgTGVmdCBvZiAnYVxuICAgIHwgUmlnaHQgb2YgJ2JcbiAgICB8IEJvdGggb2YgJ2EgKiAnYlxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlIDpcbiAgICAnYSAnYi4gKCdhIC0+ICdhIC0+IGludCkgLT4gKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICAgID1cbiAgICBmdW4gX2NtcF9fYSBfY21wX19iIGFfXzAxMV8gYl9fMDEyXyAtPlxuICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAxMV8gYl9fMDEyX1xuICAgIHRoZW4gMFxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggYV9fMDExXywgYl9fMDEyXyB3aXRoXG4gICAgICB8IExlZnQgX2FfXzAxM18sIExlZnQgX2JfXzAxNF8gLT4gX2NtcF9fYSBfYV9fMDEzXyBfYl9fMDE0X1xuICAgICAgfCBMZWZ0IF8sIF8gLT4gLTFcbiAgICAgIHwgXywgTGVmdCBfIC0+IDFcbiAgICAgIHwgUmlnaHQgX2FfXzAxNV8sIFJpZ2h0IF9iX18wMTZfIC0+IF9jbXBfX2IgX2FfXzAxNV8gX2JfXzAxNl9cbiAgICAgIHwgUmlnaHQgXywgXyAtPiAtMVxuICAgICAgfCBfLCBSaWdodCBfIC0+IDFcbiAgICAgIHwgQm90aCAoX2FfXzAxN18sIF9hX18wMTlfKSwgQm90aCAoX2JfXzAxOF8sIF9iX18wMjBfKSAtPlxuICAgICAgICAobWF0Y2ggX2NtcF9fYSBfYV9fMDE3XyBfYl9fMDE4XyB3aXRoXG4gICAgICAgICB8IDAgLT4gX2NtcF9fYiBfYV9fMDE5XyBfYl9fMDIwX1xuICAgICAgICAgfCBuIC0+IG4pKVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfdFxuICAgIDogdHlwZSBhIGIuXG4gICAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGEgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgICAgLT4gKFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBiIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgICAgLT4gKGEsIGIpIHRcbiAgICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBmdW4gX2hhc2hfZm9sZF9hIF9oYXNoX2ZvbGRfYiBoc3YgYXJnIC0+XG4gICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICAgfCBMZWZ0IF9hMCAtPlxuICAgICAgICBsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwIGluXG4gICAgICAgIGxldCBoc3YgPSBoc3YgaW5cbiAgICAgICAgX2hhc2hfZm9sZF9hIGhzdiBfYTBcbiAgICAgIHwgUmlnaHQgX2EwIC0+XG4gICAgICAgIGxldCBoc3YgPSBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDEgaW5cbiAgICAgICAgbGV0IGhzdiA9IGhzdiBpblxuICAgICAgICBfaGFzaF9mb2xkX2IgaHN2IF9hMFxuICAgICAgfCBCb3RoIChfYTAsIF9hMSkgLT5cbiAgICAgICAgbGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMiBpblxuICAgICAgICBsZXQgaHN2ID1cbiAgICAgICAgICBsZXQgaHN2ID0gaHN2IGluXG4gICAgICAgICAgX2hhc2hfZm9sZF9hIGhzdiBfYTBcbiAgICAgICAgaW5cbiAgICAgICAgX2hhc2hfZm9sZF9iIGhzdiBfYTFcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAnYSAnYi5cbiAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKVxuICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ2IpXG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKCdhLCAnYikgdFxuICAgID1cbiAgICBmdW4gKHR5cGUgYV9fMDQ0XyBiX18wNDVfKVxuICAgICAgICA6ICAoKFNleHBsaWIwLlNleHAudCAtPiBhX18wNDRfKSAtPiAoU2V4cGxpYjAuU2V4cC50IC0+IGJfXzA0NV8pXG4gICAgICAgICAgICAtPiBTZXhwbGliMC5TZXhwLnQgLT4gKGFfXzA0NF8sIGJfXzA0NV8pIHQpIC0+XG4gICAgICBsZXQgZXJyb3Jfc291cmNlX18wMjVfID0gXCJzZXF1ZW5jZS5tbC5NZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudC50XCIgaW5cbiAgICAgIGZ1biBfb2ZfYV9fMDIxXyBfb2ZfYl9fMDIyXyAtPiBmdW5jdGlvblxuICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwibGVmdFwiIHwgXCJMZWZ0XCIpIGFzIF90YWdfXzAyOF8pIDo6IHNleHBfYXJnc19fMDI5XykgYXNcbiAgICAgICAgICBfc2V4cF9fMDI3XyAtPlxuICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzAyOV8gd2l0aFxuICAgICAgICAgICB8IFsgYXJnMF9fMDMwXyBdIC0+XG4gICAgICAgICAgICAgbGV0IHJlczBfXzAzMV8gPSBfb2ZfYV9fMDIxXyBhcmcwX18wMzBfIGluXG4gICAgICAgICAgICAgTGVmdCByZXMwX18wMzFfXG4gICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDI1X1xuICAgICAgICAgICAgICAgX3RhZ19fMDI4X1xuICAgICAgICAgICAgICAgX3NleHBfXzAyN18pXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tICgoXCJyaWdodFwiIHwgXCJSaWdodFwiKSBhcyBfdGFnX18wMzNfKSA6OiBzZXhwX2FyZ3NfXzAzNF8pIGFzXG4gICAgICAgICAgX3NleHBfXzAzMl8gLT5cbiAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMzRfIHdpdGhcbiAgICAgICAgICAgfCBbIGFyZzBfXzAzNV8gXSAtPlxuICAgICAgICAgICAgIGxldCByZXMwX18wMzZfID0gX29mX2JfXzAyMl8gYXJnMF9fMDM1XyBpblxuICAgICAgICAgICAgIFJpZ2h0IHJlczBfXzAzNl9cbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMjVfXG4gICAgICAgICAgICAgICBfdGFnX18wMzNfXG4gICAgICAgICAgICAgICBfc2V4cF9fMDMyXylcbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImJvdGhcIiB8IFwiQm90aFwiKSBhcyBfdGFnX18wMzhfKSA6OiBzZXhwX2FyZ3NfXzAzOV8pIGFzXG4gICAgICAgICAgX3NleHBfXzAzN18gLT5cbiAgICAgICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMzlfIHdpdGhcbiAgICAgICAgICAgfCBbIGFyZzBfXzA0MF87IGFyZzFfXzA0MV8gXSAtPlxuICAgICAgICAgICAgIGxldCByZXMwX18wNDJfID0gX29mX2FfXzAyMV8gYXJnMF9fMDQwX1xuICAgICAgICAgICAgIGFuZCByZXMxX18wNDNfID0gX29mX2JfXzAyMl8gYXJnMV9fMDQxXyBpblxuICAgICAgICAgICAgIEJvdGggKHJlczBfXzA0Ml8sIHJlczFfXzA0M18pXG4gICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDI1X1xuICAgICAgICAgICAgICAgX3RhZ19fMDM4X1xuICAgICAgICAgICAgICAgX3NleHBfXzAzN18pXG4gICAgICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImxlZnRcIiB8IFwiTGVmdFwiKSBhcyBzZXhwX18wMjZfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI2X1xuICAgICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJyaWdodFwiIHwgXCJSaWdodFwiKSBhcyBzZXhwX18wMjZfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfdGFrZXNfYXJncyBlcnJvcl9zb3VyY2VfXzAyNV8gc2V4cF9fMDI2X1xuICAgICAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJib3RoXCIgfCBcIkJvdGhcIikgYXMgc2V4cF9fMDI2XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNl9cbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAyNF8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNF9cbiAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDI0XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDI1XyBzZXhwX18wMjRfXG4gICAgICAgIHwgc2V4cF9fMDI0XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMjVfIHNleHBfXzAyNF9cbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnYSAnYi5cbiAgICAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIC0+ICgnYiAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gKHR5cGUgYV9fMDU2XyBiX18wNTdfKVxuICAgICAgICA6ICAoKGFfXzA1Nl8gLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAoYl9fMDU3XyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAgICAgICAtPiAoYV9fMDU2XywgYl9fMDU3XykgdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gICAgICBmdW4gX29mX2FfXzA0Nl8gX29mX2JfXzA0N18gLT4gZnVuY3Rpb25cbiAgICAgICAgfCBMZWZ0IGFyZzBfXzA0OF8gLT5cbiAgICAgICAgICBsZXQgcmVzMF9fMDQ5XyA9IF9vZl9hX18wNDZfIGFyZzBfXzA0OF8gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJMZWZ0XCI7IHJlczBfXzA0OV8gXVxuICAgICAgICB8IFJpZ2h0IGFyZzBfXzA1MF8gLT5cbiAgICAgICAgICBsZXQgcmVzMF9fMDUxXyA9IF9vZl9iX18wNDdfIGFyZzBfXzA1MF8gaW5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJSaWdodFwiOyByZXMwX18wNTFfIF1cbiAgICAgICAgfCBCb3RoIChhcmcwX18wNTJfLCBhcmcxX18wNTNfKSAtPlxuICAgICAgICAgIGxldCByZXMwX18wNTRfID0gX29mX2FfXzA0Nl8gYXJnMF9fMDUyX1xuICAgICAgICAgIGFuZCByZXMxX18wNTVfID0gX29mX2JfXzA0N18gYXJnMV9fMDUzXyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkJvdGhcIjsgcmVzMF9fMDU0XzsgcmVzMV9fMDU1XyBdXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgXydiX3NleHBfZ3JhbW1hciAtPlxuICAgICAgeyB1bnR5cGVkID1cbiAgICAgICAgICBWYXJpYW50XG4gICAgICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgIFsgTm9fdGFnXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiTGVmdFwiXG4gICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydhX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJSaWdodFwiXG4gICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgTGlzdF9jbGF1c2UgeyBhcmdzID0gQ29ucyAoXydiX3NleHBfZ3JhbW1hci51bnR5cGVkLCBFbXB0eSkgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lID0gXCJCb3RoXCJcbiAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICB7IGFyZ3MgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIF8nYV9zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIENvbnMgKF8nYl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubGV0IG1lcmdlX3dpdGhfZHVwbGljYXRlcyAoU2VxdWVuY2UgKHMxLCBuZXh0MSkpIChTZXF1ZW5jZSAoczIsIG5leHQyKSkgfmNvbXBhcmUgPVxuICBsZXQgdW5zaGFkb3dlZF9jb21wYXJlID0gY29tcGFyZSBpblxuICBsZXQgb3BlbiBNZXJnZV93aXRoX2R1cGxpY2F0ZXNfZWxlbWVudCBpblxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBTa2lwIHMxLCBzMiAtPiBTa2lwIChuZXh0MSBzMSwgczIpXG4gICAgfCBzMSwgU2tpcCBzMiAtPiBTa2lwIChzMSwgbmV4dDIgczIpXG4gICAgfCAoWWllbGQgKGEsIHMxJykgYXMgczEpLCAoWWllbGQgKGIsIHMyJykgYXMgczIpIC0+XG4gICAgICBsZXQgY29tcGFyaXNvbiA9IHVuc2hhZG93ZWRfY29tcGFyZSBhIGIgaW5cbiAgICAgIGlmIGNvbXBhcmlzb24gPCAwXG4gICAgICB0aGVuIFlpZWxkIChMZWZ0IGEsIChTa2lwIHMxJywgczIpKVxuICAgICAgZWxzZSBpZiBjb21wYXJpc29uID0gMFxuICAgICAgdGhlbiBZaWVsZCAoQm90aCAoYSwgYiksIChTa2lwIHMxJywgU2tpcCBzMicpKVxuICAgICAgZWxzZSBZaWVsZCAoUmlnaHQgYiwgKHMxLCBTa2lwIHMyJykpXG4gICAgfCBEb25lLCBEb25lIC0+IERvbmVcbiAgICB8IFlpZWxkIChhLCBzMSksIERvbmUgLT4gWWllbGQgKExlZnQgYSwgKFNraXAgczEsIERvbmUpKVxuICAgIHwgRG9uZSwgWWllbGQgKGIsIHMyKSAtPiBZaWVsZCAoUmlnaHQgYiwgKERvbmUsIFNraXAgczIpKVxuICBpblxuICBTZXF1ZW5jZSAoKFNraXAgczEsIFNraXAgczIpLCBuZXh0KVxuOztcblxubGV0IG1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZCBzMSBzMiB+Y29tcGFyZSA9XG4gIG1hcCAobWVyZ2Vfd2l0aF9kdXBsaWNhdGVzIHMxIHMyIH5jb21wYXJlKSB+ZjooZnVuY3Rpb25cbiAgICB8IExlZnQgeCB8IFJpZ2h0IHggfCBCb3RoICh4LCBfKSAtPiB4KVxuOztcblxubGV0IChtZXJnZSBbQGRlcHJlY2F0ZWRcbiAgICAgICBcIltzaW5jZSAyMDIxLTA3XSBGb3IgaWRlbnRpY2FsIGJlaGF2aW9yLCB1c2UgXFxcbiAgICAgICAgW1NlcXVlbmNlLm1lcmdlX2RlZHVwZWRfYW5kX3NvcnRlZF0sIGJ1dCBjb25zaWRlciB1c2luZyBcXFxuICAgICAgICBbU2VxdWVuY2UubWVyZ2Vfc29ydGVkXSBpbnN0ZWFkLlwiXSlcbiAgPVxuICBtZXJnZV9kZWR1cGVkX2FuZF9zb3J0ZWRcbjs7XG5cbmxldCBtZXJnZV9zb3J0ZWQgKFNlcXVlbmNlIChzMSwgbmV4dDEpKSAoU2VxdWVuY2UgKHMyLCBuZXh0MikpIH5jb21wYXJlID1cbiAgbGV0IG5leHQgPSBmdW5jdGlvblxuICAgIHwgU2tpcCBzMSwgczIgLT4gU2tpcCAobmV4dDEgczEsIHMyKVxuICAgIHwgczEsIFNraXAgczIgLT4gU2tpcCAoczEsIG5leHQyIHMyKVxuICAgIHwgKFlpZWxkIChhLCBzMScpIGFzIHMxKSwgKFlpZWxkIChiLCBzMicpIGFzIHMyKSAtPlxuICAgICAgbGV0IGNvbXBhcmlzb24gPSBjb21wYXJlIGEgYiBpblxuICAgICAgaWYgY29tcGFyaXNvbiA8PSAwIHRoZW4gWWllbGQgKGEsIChTa2lwIHMxJywgczIpKSBlbHNlIFlpZWxkIChiLCAoczEsIFNraXAgczInKSlcbiAgICB8IERvbmUsIERvbmUgLT4gRG9uZVxuICAgIHwgWWllbGQgKGEsIHMxKSwgRG9uZSAtPiBZaWVsZCAoYSwgKFNraXAgczEsIERvbmUpKVxuICAgIHwgRG9uZSwgWWllbGQgKGIsIHMyKSAtPiBZaWVsZCAoYiwgKERvbmUsIFNraXAgczIpKVxuICBpblxuICBTZXF1ZW5jZSAoKFNraXAgczEsIFNraXAgczIpLCBuZXh0KVxuOztcblxubGV0IGhkIHMgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIChhLCBfKSAtPiBTb21lIGFcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuZXh0XG47O1xuXG5sZXQgaGRfZXhuIHMgPVxuICBtYXRjaCBoZCBzIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiaGRfZXhuXCJcbiAgfCBTb21lIGEgLT4gYVxuOztcblxubGV0IHRsIHMgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0ID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzIG5leHRcbiAgICB8IFlpZWxkIChfLCBhKSAtPiBTb21lIGFcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgKG1hdGNoIGxvb3AgcyBuZXh0IHdpdGhcbiAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgfCBTb21lIHMgLT4gU29tZSAoU2VxdWVuY2UgKHMsIG5leHQpKSlcbjs7XG5cbmxldCB0bF9lYWdlcmx5X2V4biBzID1cbiAgbWF0Y2ggdGwgcyB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLnRsX2V4blwiXG4gIHwgU29tZSBzIC0+IHNcbjs7XG5cbmxldCBsaWZ0X2lkZW50aXR5IG5leHQgcyA9XG4gIG1hdGNoIG5leHQgcyB3aXRoXG4gIHwgRG9uZSAtPiBEb25lXG4gIHwgU2tpcCBzIC0+IFNraXAgKGBJZGVudGl0eSBzKVxuICB8IFlpZWxkIChhLCBzKSAtPiBZaWVsZCAoYSwgYElkZW50aXR5IHMpXG47O1xuXG5sZXQgbmV4dCBzID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0XG4gICAgfCBZaWVsZCAoYSwgcykgLT4gU29tZSAoYSwgU2VxdWVuY2UgKHMsIG5leHQpKVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG5leHRcbjs7XG5cbmxldCBmaWx0ZXJfb3B0IHMgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBzXG4gICAgICAsIGZ1biBzIC0+XG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgc1xuICAgICAgICB8IFlpZWxkIChOb25lLCBzKSAtPiBTa2lwIHNcbiAgICAgICAgfCBZaWVsZCAoU29tZSBhLCBzKSAtPiBZaWVsZCAoYSwgcykgKVxuOztcblxubGV0IGZpbHRlcl9tYXAgcyB+ZiA9IGZpbHRlcl9vcHQgKG1hcCBzIH5mKVxubGV0IGZpbHRlcl9tYXBpIHMgfmYgPSBmaWx0ZXJfbWFwIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKVxuXG5sZXQgc3BsaXRfbiBzIG4gPVxuICBsZXQgcmVjIGxvb3AgcyBpIGFjY3VtIG5leHQgPVxuICAgIGlmIGkgPD0gMFxuICAgIHRoZW4gTGlzdC5yZXYgYWNjdW0sIFNlcXVlbmNlIChzLCBuZXh0KVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBMaXN0LnJldiBhY2N1bSwgZW1wdHlcbiAgICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBpIGFjY3VtIG5leHRcbiAgICAgIHwgWWllbGQgKGEsIHMpIC0+IGxvb3AgcyAoaSAtIDEpIChhIDo6IGFjY3VtKSBuZXh0KVxuICBpblxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT4gbG9vcCBzIG4gW10gbmV4dFxuOztcblxubGV0IGNodW5rc19leG4gdCBuID1cbiAgaWYgbiA8PSAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJTZXF1ZW5jZS5jaHVua3NfZXhuXCJcbiAgZWxzZVxuICAgIHVuZm9sZF9zdGVwIH5pbml0OnQgfmY6KGZ1biB0IC0+XG4gICAgICBtYXRjaCBzcGxpdF9uIHQgbiB3aXRoXG4gICAgICB8IFtdLCBfZW1wdHkgLT4gRG9uZVxuICAgICAgfCAoXyA6OiBfIGFzIHhzKSwgdCAtPiBZaWVsZCAoeHMsIHQpKVxuOztcblxubGV0IGZpbmRpIHMgfmYgPSBmaW5kIChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gKGksIHMpIC0+IGYgaSBzKVxuXG5sZXQgZmluZF9leG4gcyB+ZiA9XG4gIG1hdGNoIGZpbmQgcyB+ZiB3aXRoXG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNlcXVlbmNlLmZpbmRfZXhuXCJcbiAgfCBTb21lIHggLT4geFxuOztcblxubGV0IGFwcGVuZCBzMSBzMiA9XG4gIG1hdGNoIHMxLCBzMiB3aXRoXG4gIHwgU2VxdWVuY2UgKHMxLCBuZXh0MSksIFNlcXVlbmNlIChzMiwgbmV4dDIpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYEZpcnN0X2xpc3QgczFcbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBgRmlyc3RfbGlzdCBzMSAtPlxuICAgICAgICAgIChtYXRjaCBuZXh0MSBzMSB3aXRoXG4gICAgICAgICAgIHwgRG9uZSAtPiBTa2lwIChgU2Vjb25kX2xpc3QgczIpXG4gICAgICAgICAgIHwgU2tpcCBzMSAtPiBTa2lwIChgRmlyc3RfbGlzdCBzMSlcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgczEpIC0+IFlpZWxkIChhLCBgRmlyc3RfbGlzdCBzMSkpXG4gICAgICAgIHwgYFNlY29uZF9saXN0IHMyIC0+XG4gICAgICAgICAgKG1hdGNoIG5leHQyIHMyIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHMyIC0+IFNraXAgKGBTZWNvbmRfbGlzdCBzMilcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgczIpIC0+IFlpZWxkIChhLCBgU2Vjb25kX2xpc3QgczIpKSApXG47O1xuXG5sZXQgY29uY2F0X21hcCBzIH5mID0gYmluZCBzIH5mXG5sZXQgY29uY2F0IHMgPSBjb25jYXRfbWFwIHMgfmY6Rm4uaWRcbmxldCBjb25jYXRfbWFwaSBzIH5mID0gY29uY2F0X21hcCAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcylcblxubGV0IHppcCAoU2VxdWVuY2UgKHMxLCBuZXh0MSkpIChTZXF1ZW5jZSAoczIsIG5leHQyKSkgPVxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBZaWVsZCAoYSwgczEpLCBZaWVsZCAoYiwgczIpIC0+IFlpZWxkICgoYSwgYiksIChTa2lwIHMxLCBTa2lwIHMyKSlcbiAgICB8IERvbmUsIF8gfCBfLCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgczEsIHMyIC0+IFNraXAgKG5leHQxIHMxLCBzMilcbiAgICB8IHMxLCBTa2lwIHMyIC0+IFNraXAgKHMxLCBuZXh0MiBzMilcbiAgaW5cbiAgU2VxdWVuY2UgKChTa2lwIHMxLCBTa2lwIHMyKSwgbmV4dClcbjs7XG5cbmxldCB6aXBfZnVsbCAoU2VxdWVuY2UgKHMxLCBuZXh0MSkpIChTZXF1ZW5jZSAoczIsIG5leHQyKSkgPVxuICBsZXQgbmV4dCA9IGZ1bmN0aW9uXG4gICAgfCBZaWVsZCAoYSwgczEpLCBZaWVsZCAoYiwgczIpIC0+IFlpZWxkIChgQm90aCAoYSwgYiksIChTa2lwIHMxLCBTa2lwIHMyKSlcbiAgICB8IERvbmUsIERvbmUgLT4gRG9uZVxuICAgIHwgU2tpcCBzMSwgczIgLT4gU2tpcCAobmV4dDEgczEsIHMyKVxuICAgIHwgczEsIFNraXAgczIgLT4gU2tpcCAoczEsIG5leHQyIHMyKVxuICAgIHwgRG9uZSwgWWllbGQgKGIsIHMyKSAtPiBZaWVsZCAoYFJpZ2h0IGIsIChEb25lLCBuZXh0MiBzMikpXG4gICAgfCBZaWVsZCAoYSwgczEpLCBEb25lIC0+IFlpZWxkIChgTGVmdCBhLCAobmV4dDEgczEsIERvbmUpKVxuICBpblxuICBTZXF1ZW5jZSAoKFNraXAgczEsIFNraXAgczIpLCBuZXh0KVxuOztcblxubGV0IGJvdW5kZWRfbGVuZ3RoIChTZXF1ZW5jZSAoc2VlZCwgbmV4dCkpIH5hdF9tb3N0ID1cbiAgbGV0IHJlYyBsb29wIGkgc2VlZCBuZXh0ID1cbiAgICBpZiBpID4gYXRfbW9zdFxuICAgIHRoZW4gYEdyZWF0ZXJcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIG5leHQgc2VlZCB3aXRoXG4gICAgICB8IERvbmUgLT4gYElzIGlcbiAgICAgIHwgU2tpcCBzZWVkIC0+IGxvb3AgaSBzZWVkIG5leHRcbiAgICAgIHwgWWllbGQgKF8sIHNlZWQpIC0+IGxvb3AgKGkgKyAxKSBzZWVkIG5leHQpXG4gIGluXG4gIGxvb3AgMCBzZWVkIG5leHRcbjs7XG5cbmxldCBsZW5ndGhfaXNfYm91bmRlZF9ieSA/KG1pbiA9IC0xKSA/bWF4IHQgPVxuICBsZXQgbGVuZ3RoX2lzX2F0X2xlYXN0IChTZXF1ZW5jZSAocywgbmV4dCkpID1cbiAgICBsZXQgcmVjIGxvb3AgcyBhY2MgPVxuICAgICAgaWYgYWNjID49IG1pblxuICAgICAgdGhlbiB0cnVlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IGZhbHNlXG4gICAgICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBhY2NcbiAgICAgICAgfCBZaWVsZCAoXywgcykgLT4gbG9vcCBzIChhY2MgKyAxKSlcbiAgICBpblxuICAgIGxvb3AgcyAwXG4gIGluXG4gIG1hdGNoIG1heCB3aXRoXG4gIHwgTm9uZSAtPiBsZW5ndGhfaXNfYXRfbGVhc3QgdFxuICB8IFNvbWUgbWF4IC0+XG4gICAgKG1hdGNoIGJvdW5kZWRfbGVuZ3RoIHQgfmF0X21vc3Q6bWF4IHdpdGhcbiAgICAgfCBgSXMgbGVuIHdoZW4gbGVuID49IG1pbiAtPiB0cnVlXG4gICAgIHwgXyAtPiBmYWxzZSlcbjs7XG5cbmxldCBpdGVyaSBzIH5mID0gaXRlciAobWFwaSBzIH5mOihmdW4gaSBzIC0+IGksIHMpKSB+ZjooZnVuIChpLCBzKSAtPiBmIGkgcylcblxubGV0IGZvbGRpIHMgfmluaXQgfmYgPVxuICBmb2xkIH5pbml0IChtYXBpIHMgfmY6KGZ1biBpIHMgLT4gaSwgcykpIH5mOihmdW4gYWNjIChpLCBzKSAtPiBmIGkgYWNjIHMpXG47O1xuXG5sZXQgcmVkdWNlIHMgfmYgPVxuICBtYXRjaCBuZXh0IHMgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgKGEsIHMpIC0+IFNvbWUgKGZvbGQgcyB+aW5pdDphIH5mKVxuOztcblxubGV0IHJlZHVjZV9leG4gcyB+ZiA9XG4gIG1hdGNoIHJlZHVjZSBzIH5mIHdpdGhcbiAgfCBOb25lIC0+IGZhaWx3aXRoIFwiU2VxdWVuY2UucmVkdWNlX2V4blwiXG4gIHwgU29tZSByZXMgLT4gcmVzXG47O1xuXG5sZXQgZ3JvdXAgKFNlcXVlbmNlIChzLCBuZXh0KSkgfmJyZWFrID1cbiAgdW5mb2xkX3N0ZXBcbiAgICB+aW5pdDooU29tZSAoW10sIHMpKVxuICAgIH5mOihmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IERvbmVcbiAgICAgIHwgU29tZSAoYWNjLCBzKSAtPlxuICAgICAgICAobWF0Y2ggYWNjLCBuZXh0IHMgd2l0aFxuICAgICAgICAgfCBfLCBTa2lwIHMgLT4gU2tpcCAoU29tZSAoYWNjLCBzKSlcbiAgICAgICAgIHwgW10sIERvbmUgLT4gRG9uZVxuICAgICAgICAgfCBhY2MsIERvbmUgLT4gWWllbGQgKExpc3QucmV2IGFjYywgTm9uZSlcbiAgICAgICAgIHwgW10sIFlpZWxkIChjdXIsIHMpIC0+IFNraXAgKFNvbWUgKFsgY3VyIF0sIHMpKVxuICAgICAgICAgfCAocHJldiA6OiBfIGFzIGFjYyksIFlpZWxkIChjdXIsIHMpIC0+XG4gICAgICAgICAgIGlmIGJyZWFrIHByZXYgY3VyXG4gICAgICAgICAgIHRoZW4gWWllbGQgKExpc3QucmV2IGFjYywgU29tZSAoWyBjdXIgXSwgcykpXG4gICAgICAgICAgIGVsc2UgU2tpcCAoU29tZSAoY3VyIDo6IGFjYywgcykpKSlcbjs7XG5cbmxldCBmaW5kX2NvbnNlY3V0aXZlX2R1cGxpY2F0ZSAoU2VxdWVuY2UgKHMsIG5leHQpKSB+ZXF1YWwgPVxuICBsZXQgcmVjIGxvb3AgbGFzdF9lbHQgcyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gTm9uZVxuICAgIHwgU2tpcCBzIC0+IGxvb3AgbGFzdF9lbHQgc1xuICAgIHwgWWllbGQgKGEsIHMpIC0+XG4gICAgICAobWF0Y2ggbGFzdF9lbHQgd2l0aFxuICAgICAgIHwgU29tZSBiIHdoZW4gZXF1YWwgYSBiIC0+IFNvbWUgKGIsIGEpXG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IGxvb3AgKFNvbWUgYSkgcylcbiAgaW5cbiAgbG9vcCBOb25lIHNcbjs7XG5cbmxldCByZW1vdmVfY29uc2VjdXRpdmVfZHVwbGljYXRlcyBzIH5lcXVhbCA9XG4gIHVuZm9sZF93aXRoIHMgfmluaXQ6Tm9uZSB+ZjooZnVuIHByZXYgYSAtPlxuICAgIG1hdGNoIHByZXYgd2l0aFxuICAgIHwgU29tZSBiIHdoZW4gZXF1YWwgYSBiIC0+IFNraXAgKFNvbWUgYSlcbiAgICB8IE5vbmUgfCBTb21lIF8gLT4gWWllbGQgKGEsIFNvbWUgYSkpXG47O1xuXG5sZXQgY291bnQgcyB+ZiA9IGxlbmd0aCAoZmlsdGVyIHMgfmYpXG5sZXQgY291bnRpIHQgfmYgPSBsZW5ndGggKGZpbHRlcmkgdCB+ZilcbmxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcbmxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5sZXQgbWF4X2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1heF9lbHQgfmZvbGQgdCB+Y29tcGFyZVxuXG5sZXQgaW5pdCBuIH5mID1cbiAgdW5mb2xkX3N0ZXAgfmluaXQ6MCB+ZjooZnVuIGkgLT4gaWYgaSA+PSBuIHRoZW4gRG9uZSBlbHNlIFlpZWxkIChmIGksIGkgKyAxKSlcbjs7XG5cbmxldCBzdWIgcyB+cG9zIH5sZW4gPVxuICBpZiBwb3MgPCAwIHx8IGxlbiA8IDAgdGhlbiBmYWlsd2l0aCBcIlNlcXVlbmNlLnN1YlwiO1xuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoMCwgcylcbiAgICAgICwgZnVuIChpLCBzKSAtPlxuICAgICAgICBpZiBpIC0gcG9zID49IGxlblxuICAgICAgICB0aGVuIERvbmVcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGksIHMpXG4gICAgICAgICAgfCBZaWVsZCAoYSwgcykgd2hlbiBpID49IHBvcyAtPiBZaWVsZCAoYSwgKGkgKyAxLCBzKSlcbiAgICAgICAgICB8IFlpZWxkIChfLCBzKSAtPiBTa2lwIChpICsgMSwgcykpIClcbjs7XG5cbmxldCB0YWtlIHMgbGVuID1cbiAgaWYgbGVuIDwgMCB0aGVuIGZhaWx3aXRoIFwiU2VxdWVuY2UudGFrZVwiO1xuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCAoMCwgcylcbiAgICAgICwgZnVuIChpLCBzKSAtPlxuICAgICAgICBpZiBpID49IGxlblxuICAgICAgICB0aGVuIERvbmVcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKGksIHMpXG4gICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIChpICsgMSwgcykpKSApXG47O1xuXG5sZXQgZHJvcCBzIGxlbiA9XG4gIGlmIGxlbiA8IDAgdGhlbiBmYWlsd2l0aCBcIlNlcXVlbmNlLmRyb3BcIjtcbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggKDAsIHMpXG4gICAgICAsIGZ1biAoaSwgcykgLT5cbiAgICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoaSwgcylcbiAgICAgICAgfCBZaWVsZCAoYSwgcykgd2hlbiBpID49IGxlbiAtPiBZaWVsZCAoYSwgKGkgKyAxLCBzKSlcbiAgICAgICAgfCBZaWVsZCAoXywgcykgLT4gU2tpcCAoaSArIDEsIHMpIClcbjs7XG5cbmxldCB0YWtlX3doaWxlIHMgfmYgPVxuICBtYXRjaCBzIHdpdGhcbiAgfCBTZXF1ZW5jZSAocywgbmV4dCkgLT5cbiAgICBTZXF1ZW5jZVxuICAgICAgKCBzXG4gICAgICAsIGZ1biBzIC0+XG4gICAgICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgICAgIHwgRG9uZSAtPiBEb25lXG4gICAgICAgIHwgU2tpcCBzIC0+IFNraXAgc1xuICAgICAgICB8IFlpZWxkIChhLCBzKSB3aGVuIGYgYSAtPiBZaWVsZCAoYSwgcylcbiAgICAgICAgfCBZaWVsZCAoXywgXykgLT4gRG9uZSApXG47O1xuXG5sZXQgZHJvcF93aGlsZSBzIH5mID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYERyb3BwaW5nIHNcbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBgRHJvcHBpbmcgcyAtPlxuICAgICAgICAgIChtYXRjaCBuZXh0IHMgd2l0aFxuICAgICAgICAgICB8IERvbmUgLT4gRG9uZVxuICAgICAgICAgICB8IFNraXAgcyAtPiBTa2lwIChgRHJvcHBpbmcgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgcykgd2hlbiBmIGEgLT4gU2tpcCAoYERyb3BwaW5nIHMpXG4gICAgICAgICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCBgSWRlbnRpdHkgcykpXG4gICAgICAgIHwgYElkZW50aXR5IHMgLT4gbGlmdF9pZGVudGl0eSBuZXh0IHMgKVxuOztcblxubGV0IHNoaWZ0X3JpZ2h0IHMgeCA9XG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzZWVkLCBuZXh0KSAtPlxuICAgIFNlcXVlbmNlXG4gICAgICAoIGBDb25zaW5nIChzZWVkLCB4KVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IGBDb25zaW5nIChzZWVkLCB4KSAtPiBZaWVsZCAoeCwgYElkZW50aXR5IHNlZWQpXG4gICAgICAgIHwgYElkZW50aXR5IHMgLT4gbGlmdF9pZGVudGl0eSBuZXh0IHMgKVxuOztcblxubGV0IHNoaWZ0X3JpZ2h0X3dpdGhfbGlzdCBzIGwgPSBhcHBlbmQgKG9mX2xpc3QgbCkgc1xubGV0IHNoaWZ0X2xlZnQgPSBkcm9wXG5cbm1vZHVsZSBJbmZpeCA9IHN0cnVjdFxuICBsZXQgKCBAICkgPSBhcHBlbmRcbmVuZFxuXG5sZXQgaW50ZXJzcGVyc2UgcyB+c2VwID1cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+XG4gICAgU2VxdWVuY2VcbiAgICAgICggYEluaXQgc1xuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IGBJbml0IHMgLT5cbiAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoYEluaXQgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKGEsIGBSdW5uaW5nIHMpKVxuICAgICAgICB8IGBSdW5uaW5nIHMgLT5cbiAgICAgICAgICAobWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgICAgICAgfCBEb25lIC0+IERvbmVcbiAgICAgICAgICAgfCBTa2lwIHMgLT4gU2tpcCAoYFJ1bm5pbmcgcylcbiAgICAgICAgICAgfCBZaWVsZCAoYSwgcykgLT4gWWllbGQgKHNlcCwgYFB1dHRpbmcgKGEsIHMpKSlcbiAgICAgICAgfCBgUHV0dGluZyAoYSwgcykgLT4gWWllbGQgKGEsIGBSdW5uaW5nIHMpIClcbjs7XG5cbmxldCByZXBlYXQgeCA9IHVuZm9sZF9zdGVwIH5pbml0OnggfmY6KGZ1biB4IC0+IFlpZWxkICh4LCB4KSlcblxubGV0IGN5Y2xlX2xpc3RfZXhuIHhzID1cbiAgaWYgTGlzdC5pc19lbXB0eSB4cyB0aGVuIGludmFsaWRfYXJnIFwiU2VxdWVuY2UuY3ljbGVfbGlzdF9leG5cIjtcbiAgbGV0IHMgPSBvZl9saXN0IHhzIGluXG4gIGNvbmNhdF9tYXAgfmY6KGZ1biAoKSAtPiBzKSAocmVwZWF0ICgpKVxuOztcblxubGV0IGNhcnRlc2lhbl9wcm9kdWN0IHNhIHNiID0gY29uY2F0X21hcCBzYSB+ZjooZnVuIGEgLT4gemlwIChyZXBlYXQgYSkgc2IpXG5sZXQgc2luZ2xldG9uIHggPSByZXR1cm4geFxuXG5sZXQgZGVsYXllZF9mb2xkIHMgfmluaXQgfmYgfmZpbmlzaCA9XG4gIEV4cGVydC5kZWxheWVkX2ZvbGRfc3RlcCBzIH5pbml0IH5maW5pc2ggfmY6KGZ1biBhY2Mgb3B0aW9uIH5rIC0+XG4gICAgbWF0Y2ggb3B0aW9uIHdpdGhcbiAgICB8IE5vbmUgLT4gayBhY2NcbiAgICB8IFNvbWUgYSAtPiBmIGFjYyBhIH5rKVxuOztcblxubGV0IGZvbGRfbSB+YmluZCB+cmV0dXJuIHQgfmluaXQgfmYgPVxuICBFeHBlcnQuZGVsYXllZF9mb2xkX3N0ZXBcbiAgICB0XG4gICAgfmluaXRcbiAgICB+ZjooZnVuIGFjYyBvcHRpb24gfmsgLT5cbiAgICAgIG1hdGNoIG9wdGlvbiB3aXRoXG4gICAgICB8IE5vbmUgLT4gYmluZCAocmV0dXJuIGFjYykgfmY6a1xuICAgICAgfCBTb21lIGEgLT4gYmluZCAoZiBhY2MgYSkgfmY6aylcbiAgICB+ZmluaXNoOnJldHVyblxuOztcblxubGV0IGl0ZXJfbSB+YmluZCB+cmV0dXJuIHQgfmYgPVxuICBFeHBlcnQuZGVsYXllZF9mb2xkX3N0ZXBcbiAgICB0XG4gICAgfmluaXQ6KClcbiAgICB+ZjooZnVuICgpIG9wdGlvbiB+ayAtPlxuICAgICAgbWF0Y2ggb3B0aW9uIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBiaW5kIChyZXR1cm4gKCkpIH5mOmtcbiAgICAgIHwgU29tZSBhIC0+IGJpbmQgKGYgYSkgfmY6aylcbiAgICB+ZmluaXNoOnJldHVyblxuOztcblxubGV0IGZvbGRfdW50aWwgcyB+aW5pdCB+ZiB+ZmluaXNoID1cbiAgbGV0IHJlYyBsb29wIHMgbmV4dCBmIGFjYyA9XG4gICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICB8IERvbmUgLT4gZmluaXNoIGFjY1xuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgYWNjXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIChtYXRjaCAoZiBhY2MgYSA6ICgnYSwgJ2IpIENvbnRpbnVlX29yX3N0b3AudCkgd2l0aFxuICAgICAgIHwgU3RvcCB4IC0+IHhcbiAgICAgICB8IENvbnRpbnVlIGFjYyAtPiBsb29wIHMgbmV4dCBmIGFjYylcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuZXh0IGYgaW5pdFxuOztcblxubGV0IGZvbGRfcmVzdWx0IHMgfmluaXQgfmYgPVxuICBsZXQgcmVjIGxvb3AgcyBuZXh0IGYgYWNjID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBSZXN1bHQucmV0dXJuIGFjY1xuICAgIHwgU2tpcCBzIC0+IGxvb3AgcyBuZXh0IGYgYWNjXG4gICAgfCBZaWVsZCAoYSwgcykgLT5cbiAgICAgIChtYXRjaCAoZiBhY2MgYSA6IChfLCBfKSBSZXN1bHQudCkgd2l0aFxuICAgICAgIHwgRXJyb3IgXyBhcyBlIC0+IGVcbiAgICAgICB8IE9rIGFjYyAtPiBsb29wIHMgbmV4dCBmIGFjYylcbiAgaW5cbiAgbWF0Y2ggcyB3aXRoXG4gIHwgU2VxdWVuY2UgKHMsIG5leHQpIC0+IGxvb3AgcyBuZXh0IGYgaW5pdFxuOztcblxubGV0IGZvcmNlX2VhZ2VybHkgdCA9IG9mX2xpc3QgKHRvX2xpc3QgdClcblxubGV0IG1lbW9pemUgKHR5cGUgYSkgKFNlcXVlbmNlIChzLCBuZXh0KSkgPVxuICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBUIG9mIChhLCB0KSBTdGVwLnQgTGF6eS50XG4gIGVuZFxuICBpblxuICBsZXQgcmVjIG1lbW9pemUgcyA9IE0uVCAobGF6eSAoZmluZF9zdGVwIHMpKVxuICBhbmQgZmluZF9zdGVwIHMgPVxuICAgIG1hdGNoIG5leHQgcyB3aXRoXG4gICAgfCBEb25lIC0+IERvbmVcbiAgICB8IFNraXAgcyAtPiBmaW5kX3N0ZXAgc1xuICAgIHwgWWllbGQgKGEsIHMpIC0+IFlpZWxkIChhLCBtZW1vaXplIHMpXG4gIGluXG4gIFNlcXVlbmNlIChtZW1vaXplIHMsIGZ1biAoTS5UIGwpIC0+IExhenkuZm9yY2UgbClcbjs7XG5cbmxldCBkcm9wX2VhZ2VybHkgcyBsZW4gPVxuICBsZXQgcmVjIGxvb3AgaSB+bGVuIHMgbmV4dCA9XG4gICAgaWYgaSA+PSBsZW5cbiAgICB0aGVuIFNlcXVlbmNlIChzLCBuZXh0KVxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggbmV4dCBzIHdpdGhcbiAgICAgIHwgRG9uZSAtPiBlbXB0eVxuICAgICAgfCBTa2lwIHMgLT4gbG9vcCBpIH5sZW4gcyBuZXh0XG4gICAgICB8IFlpZWxkIChfLCBzKSAtPiBsb29wIChpICsgMSkgfmxlbiBzIG5leHQpXG4gIGluXG4gIG1hdGNoIHMgd2l0aFxuICB8IFNlcXVlbmNlIChzLCBuZXh0KSAtPiBsb29wIDAgfmxlbiBzIG5leHRcbjs7XG5cbmxldCBkcm9wX3doaWxlX29wdGlvbiAoU2VxdWVuY2UgKHMsIG5leHQpKSB+ZiA9XG4gIGxldCByZWMgbG9vcCBzID1cbiAgICBtYXRjaCBuZXh0IHMgd2l0aFxuICAgIHwgRG9uZSAtPiBOb25lXG4gICAgfCBTa2lwIHMgLT4gbG9vcCBzXG4gICAgfCBZaWVsZCAoeCwgcykgLT4gaWYgZiB4IHRoZW4gbG9vcCBzIGVsc2UgU29tZSAoeCwgU2VxdWVuY2UgKHMsIG5leHQpKVxuICBpblxuICBsb29wIHNcbjs7XG5cbmxldCBjb21wYXJlIGNvbXBhcmVfYSB0MSB0MiA9XG4gIFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIGl0ZXIgKHppcF9mdWxsIHQxIHQyKSB+ZjooZnVuY3Rpb25cbiAgICAgIHwgYExlZnQgXyAtPiByLnJldHVybiAxXG4gICAgICB8IGBSaWdodCBfIC0+IHIucmV0dXJuICgtMSlcbiAgICAgIHwgYEJvdGggKHYxLCB2MikgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2EgdjEgdjIgaW5cbiAgICAgICAgaWYgYyA8PiAwIHRoZW4gci5yZXR1cm4gYyk7XG4gICAgMClcbjs7XG5cbmxldCBlcXVhbCBlcXVhbF9hIHQxIHQyID1cbiAgZm9yX2FsbCAoemlwX2Z1bGwgdDEgdDIpIH5mOihmdW5jdGlvblxuICAgIHwgYEJvdGggKGExLCBhMikgLT4gZXF1YWxfYSBhMSBhMlxuICAgIHwgYExlZnQgXyB8IGBSaWdodCBfIC0+IGZhbHNlKVxuOztcblxubGV0IHJvdW5kX3JvYmluIGxpc3QgPVxuICBsZXQgbmV4dCAodG9kb19zdGFjaywgZG9uZV9zdGFjaykgPVxuICAgIG1hdGNoIHRvZG9fc3RhY2sgd2l0aFxuICAgIHwgU2VxdWVuY2UgKHMsIGYpIDo6IHRvZG9fc3RhY2sgLT5cbiAgICAgIChtYXRjaCBmIHMgd2l0aFxuICAgICAgIHwgWWllbGQgKHgsIHMpIC0+IFlpZWxkICh4LCAodG9kb19zdGFjaywgU2VxdWVuY2UgKHMsIGYpIDo6IGRvbmVfc3RhY2spKVxuICAgICAgIHwgU2tpcCBzIC0+IFNraXAgKFNlcXVlbmNlIChzLCBmKSA6OiB0b2RvX3N0YWNrLCBkb25lX3N0YWNrKVxuICAgICAgIHwgRG9uZSAtPiBTa2lwICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrKSlcbiAgICB8IFtdIC0+IGlmIExpc3QuaXNfZW1wdHkgZG9uZV9zdGFjayB0aGVuIERvbmUgZWxzZSBTa2lwIChMaXN0LnJldiBkb25lX3N0YWNrLCBbXSlcbiAgaW5cbiAgbGV0IHN0YXRlID0gbGlzdCwgW10gaW5cbiAgU2VxdWVuY2UgKHN0YXRlLCBuZXh0KVxuOztcblxubGV0IGludGVybGVhdmUgKFNlcXVlbmNlIChzMSwgZjEpKSA9XG4gIGxldCBuZXh0ICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrLCBzMSkgPVxuICAgIG1hdGNoIHRvZG9fc3RhY2sgd2l0aFxuICAgIHwgU2VxdWVuY2UgKHMyLCBmMikgOjogdG9kb19zdGFjayAtPlxuICAgICAgKG1hdGNoIGYyIHMyIHdpdGhcbiAgICAgICB8IFlpZWxkICh4LCBzMikgLT4gWWllbGQgKHgsICh0b2RvX3N0YWNrLCBTZXF1ZW5jZSAoczIsIGYyKSA6OiBkb25lX3N0YWNrLCBzMSkpXG4gICAgICAgfCBTa2lwIHMyIC0+IFNraXAgKHRvZG9fc3RhY2ssIFNlcXVlbmNlIChzMiwgZjIpIDo6IGRvbmVfc3RhY2ssIHMxKVxuICAgICAgIHwgRG9uZSAtPiBTa2lwICh0b2RvX3N0YWNrLCBkb25lX3N0YWNrLCBzMSkpXG4gICAgfCBbXSAtPlxuICAgICAgKG1hdGNoIGYxIHMxLCBkb25lX3N0YWNrIHdpdGhcbiAgICAgICB8IFlpZWxkICh0LCBzMSksIF8gLT4gU2tpcCAoTGlzdC5yZXYgKHQgOjogZG9uZV9zdGFjayksIFtdLCBzMSlcbiAgICAgICB8IFNraXAgczEsIF8gLT4gU2tpcCAoTGlzdC5yZXYgZG9uZV9zdGFjaywgW10sIHMxKVxuICAgICAgIHwgRG9uZSwgXyA6OiBfIC0+IFNraXAgKExpc3QucmV2IGRvbmVfc3RhY2ssIFtdLCBzMSlcbiAgICAgICB8IERvbmUsIFtdIC0+IERvbmUpXG4gIGluXG4gIGxldCBzdGF0ZSA9IFtdLCBbXSwgczEgaW5cbiAgU2VxdWVuY2UgKHN0YXRlLCBuZXh0KVxuOztcblxubGV0IGludGVybGVhdmVkX2NhcnRlc2lhbl9wcm9kdWN0IHMxIHMyID1cbiAgbWFwIHMxIH5mOihmdW4geDEgLT4gbWFwIHMyIH5mOihmdW4geDIgLT4geDEsIHgyKSkgfD4gaW50ZXJsZWF2ZVxuOztcblxubGV0IG9mX3NlcSAoc2VxIDogXyBDYW1sLlNlcS50KSA9XG4gIHVuZm9sZF9zdGVwIH5pbml0OnNlcSB+ZjooZnVuIHNlcSAtPlxuICAgIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBOaWwgLT4gRG9uZVxuICAgIHwgQ29ucyAoaGQsIHRsKSAtPiBZaWVsZCAoaGQsIHRsKSlcbjs7XG5cbmxldCB0b19zZXEgKFNlcXVlbmNlIChzdGF0ZSwgbmV4dCkpID1cbiAgbGV0IHJlYyBsb29wIHN0YXRlID1cbiAgICBtYXRjaCBuZXh0IHN0YXRlIHdpdGhcbiAgICB8IERvbmUgLT4gQ2FtbC5TZXEuTmlsXG4gICAgfCBTa2lwIHN0YXRlIC0+IGxvb3Agc3RhdGVcbiAgICB8IFlpZWxkIChoZCwgc3RhdGUpIC0+IENhbWwuU2VxLkNvbnMgKGhkLCBmdW4gKCkgLT4gbG9vcCBzdGF0ZSlcbiAgaW5cbiAgZnVuICgpIC0+IGxvb3Agc3RhdGVcbjs7XG5cbm1vZHVsZSBHZW5lcmF0b3IgPSBzdHJ1Y3RcbiAgdHlwZSAnZWx0IHN0ZXBzID0gV3JhcCBvZiAoJ2VsdCwgdW5pdCAtPiAnZWx0IHN0ZXBzKSBTdGVwLnRcblxuICBsZXQgdW53cmFwIChXcmFwIHN0ZXApID0gc3RlcFxuXG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSAoJ2EsICdlbHQpIHQgPSAoJ2EgLT4gJ2VsdCBzdGVwcykgLT4gJ2VsdCBzdGVwc1xuXG4gICAgbGV0IHJldHVybiB4IGsgPSBrIHhcblxuICAgIGxldCBiaW5kIG0gfmYgayA9XG4gICAgICBtIChmdW4gYSAtPlxuICAgICAgICBsZXQgbScgPSBmIGEgaW5cbiAgICAgICAgbScgaylcbiAgICA7O1xuXG4gICAgbGV0IG1hcCBtIH5mIGsgPSBtIChmdW4gYSAtPiBrIChmIGEpKVxuICAgIGxldCBtYXAgPSBgQ3VzdG9tIG1hcFxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBNb25hZC5NYWtlMiAoVClcblxuICBsZXQgeWllbGQgZSBrID0gV3JhcCAoWWllbGQgKGUsIGspKVxuICBsZXQgdG9fc3RlcHMgdCA9IHQgKGZ1biAoKSAtPiBXcmFwIERvbmUpXG5cbiAgbGV0IG9mX3NlcXVlbmNlIHNlcXVlbmNlID1cbiAgICBkZWxheWVkX2ZvbGRcbiAgICAgIHNlcXVlbmNlXG4gICAgICB+aW5pdDooKVxuICAgICAgfmY6KGZ1biAoKSB4IH5rIGYgLT4gV3JhcCAoWWllbGQgKHgsIGZ1biAoKSAtPiBrICgpIGYpKSlcbiAgICAgIH5maW5pc2g6cmV0dXJuXG4gIDs7XG5cbiAgbGV0IHJ1biB0ID1cbiAgICBsZXQgaW5pdCAoKSA9IHRvX3N0ZXBzIHQgaW5cbiAgICBsZXQgZiB0aHVuayA9IHVud3JhcCAodGh1bmsgKCkpIGluXG4gICAgdW5mb2xkX3N0ZXAgfmluaXQgfmZcbiAgOztcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIEFycmF5MFxuXG50eXBlICdhIHQgPSAnYSBhcnJheSBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9hcnJheVxubGV0IHRfb2Zfc2V4cCA6ICdhLiAoU2V4cGxpYjAuU2V4cC50IC0+ICdhKSAtPiBTZXhwbGliMC5TZXhwLnQgLT4gJ2EgdCA9IGFycmF5X29mX3NleHBcbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPSBzZXhwX29mX2FycmF5XG5cbmxldCAodF9zZXhwX2dyYW1tYXIgOiAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCAtPiAnYSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IGFycmF5X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG47O1xuXG5bQEBAZW5kXVxuXG4oKiBUaGlzIG1vZHVsZSBpbXBsZW1lbnRzIGEgbmV3IGluLXBsYWNlLCBjb25zdGFudCBoZWFwIHNvcnRpbmcgYWxnb3JpdGhtIHRvIHJlcGxhY2UgdGhlXG4gICBvbmUgdXNlZCBieSB0aGUgc3RhbmRhcmQgbGlicmFyaWVzLiAgSXRzIG9ubHkgcHVycG9zZSBpcyB0byBiZSBmYXN0ZXIgKGhvcGVmdWxseVxuICAgc3RyaWN0bHkgZmFzdGVyKSB0aGFuIHRoZSBiYXNlIHNvcnQgYW5kIHN0YWJsZV9zb3J0LlxuXG4gICBBdCBhIGhpZ2ggbGV2ZWwgdGhlIGFsZ29yaXRobSBpczpcbiAgIC0gcGljayB0d28gcGl2b3QgcG9pbnRzIGJ5OlxuICAgLSBwaWNrIDUgYXJiaXRyYXJ5IGVsZW1lbnRzIGZyb20gdGhlIGFycmF5XG4gICAtIHNvcnQgdGhlbSB3aXRoaW4gdGhlIGFycmF5XG4gICAtIHRha2UgdGhlIGVsZW1lbnRzIG9uIGVpdGhlciBzaWRlIG9mIHRoZSBtaWRkbGUgZWxlbWVudCBvZiB0aGUgc29ydCBhcyB0aGUgcGl2b3RzXG4gICAtIHNvcnQgdGhlIGFycmF5IHdpdGg6XG4gICAtIGFsbCBlbGVtZW50cyBsZXNzIHRoYW4gcGl2b3QxIHRvIHRoZSBsZWZ0IChyYW5nZSAxKVxuICAgLSBhbGwgZWxlbWVudHMgPj0gcGl2b3QxIGFuZCA8PSBwaXZvdDIgaW4gdGhlIG1pZGRsZSAocmFuZ2UgMilcbiAgIC0gYWxsIGVsZW1lbnRzID4gcGl2b3QyIHRvIHRoZSByaWdodCAocmFuZ2UgMylcbiAgIC0gaWYgcGl2b3QxIGFuZCBwaXZvdDIgYXJlIGVxdWFsLCB0aGVuIHRoZSBtaWRkbGUgcmFuZ2UgaXMgc29ydGVkLCBzbyBpZ25vcmUgaXRcbiAgIC0gcmVjdXJzZSBpbnRvIHJhbmdlIDEsIDIgKGlmIHBpdm90MSBhbmQgcGl2b3QyIGFyZSB1bmVxdWFsKSwgYW5kIDNcbiAgIC0gZHVyaW5nIHJlY3Vyc2lvbiB0aGVyZSBhcmUgdHdvIGluZmxlY3Rpb24gcG9pbnRzOlxuICAgLSBpZiB0aGUgc2l6ZSBvZiB0aGUgY3VycmVudCByYW5nZSBpcyBzbWFsbCwgdXNlIGluc2VydGlvbiBzb3J0IHRvIHNvcnQgaXRcbiAgIC0gaWYgdGhlIHN0YWNrIGRlcHRoIGlzIGxhcmdlLCBzb3J0IHRoZSByYW5nZSB3aXRoIGhlYXAtc29ydCB0byBhdm9pZCBuXjIgd29yc3QtY2FzZVxuICAgICBiZWhhdmlvclxuXG4gICBTZWUgdGhlIGZvbGxvd2luZyBmb3IgbW9yZSBpbmZvcm1hdGlvbjpcbiAgIC0gXCJEdWFsLVBpdm90IFF1aWNrc29ydFwiIGJ5IFZsYWRpbWlyIFlhcm9zbGF2c2tpeS5cbiAgICAgQXZhaWxhYmxlIGF0XG4gICAgIGh0dHA6Ly93d3cua3JpY2hlLmNvbS5hci9yb290L3Byb2dyYW1taW5nL3NwYWNlVGltZUNvbXBsZXhpdHkvRHVhbFBpdm90UXVpY2tzb3J0LnBkZlxuICAgLSBcIlF1aWNrc29ydCBpcyBPcHRpbWFsXCIgYnkgU2VkZ2V3aWNrIGFuZCBCZW50bGV5LlxuICAgICBTbGlkZXMgYXQgaHR0cDovL3d3dy5jcy5wcmluY2V0b24uZWR1L35ycy90YWxrcy9RdWlja3NvcnRJc09wdGltYWwucGRmXG4gICAtIGh0dHA6Ly93d3cuc29ydGluZy1hbGdvcml0aG1zLmNvbS9xdWljay1zb3J0LTMtd2F5ICopXG5cbm1vZHVsZSBTb3J0ID0gc3RydWN0XG4gICgqIEZvciB0aGUgc2FrZSBvZiBzcGVlZCB3ZSBjb3VsZCB1c2UgdW5zYWZlIGdldC9zZXQgdGhyb3VnaG91dCwgYnV0IHNwZWVkIHRlc3RzIGRvbid0XG4gICAgIHNob3cgYSBzaWduaWZpY2FudCBpbXByb3ZlbWVudC4gKilcbiAgbGV0IGdldCA9IGdldFxuICBsZXQgc2V0ID0gc2V0XG5cbiAgbGV0IHN3YXAgYXJyIGkgaiA9XG4gICAgbGV0IHRtcCA9IGdldCBhcnIgaSBpblxuICAgIHNldCBhcnIgaSAoZ2V0IGFyciBqKTtcbiAgICBzZXQgYXJyIGogdG1wXG4gIDs7XG5cbiAgbW9kdWxlIHR5cGUgU29ydCA9IHNpZ1xuICAgIHZhbCBzb3J0XG4gICAgICA6ICAnYSB0XG4gICAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgICAtPiBsZWZ0OmludCAoKiBsZWZ0bW9zdCBpbmRleCBvZiBzdWItYXJyYXkgdG8gc29ydCAqKVxuICAgICAgLT4gcmlnaHQ6aW50ICgqIHJpZ2h0bW9zdCBpbmRleCBvZiBzdWItYXJyYXkgdG8gc29ydCAqKVxuICAgICAgLT4gdW5pdFxuICBlbmRcblxuICAoKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0luc2VydGlvbl9zb3J0ICopXG4gIG1vZHVsZSBJbnNlcnRpb25fc29ydCA6IFNvcnQgPSBzdHJ1Y3RcbiAgICBsZXQgc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgICgqIGxvb3AgaW52YXJpYW50OlxuICAgICAgICAgW2Fycl0gaXMgc29ydGVkIGZyb20gW2xlZnRdIHRvIFtwb3MgLSAxXSwgaW5jbHVzaXZlICopXG4gICAgICBmb3IgcG9zID0gbGVmdCArIDEgdG8gcmlnaHQgZG9cbiAgICAgICAgKCogbG9vcCBpbnZhcmlhbnRzOlxuICAgICAgICAgICAxLiAgdGhlIHN1YmFycmF5IGFycltsZWZ0IC4uIGktMV0gaXMgc29ydGVkXG4gICAgICAgICAgIDIuICB0aGUgc3ViYXJyYXkgYXJyW2krMSAuLiBwb3NdIGlzIHNvcnRlZCBhbmQgY29udGFpbnMgb25seSBlbGVtZW50cyA+IHZcbiAgICAgICAgICAgMy4gIGFycltpXSBtYXkgYmUgdGhvdWdodCBvZiBhcyBjb250YWluaW5nIHZcblxuICAgICAgICAgICBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhbGxvY2F0ZSBhIGNsb3N1cmUsIGJ1dCBpcyBsZWZ0IGluIHRoZSBmb3JcbiAgICAgICAgICAgbG9vcCBmb3IgdGhlIHJlYWRhYmlsaXR5IG9mIHRoZSBkb2N1bWVudGF0aW9uLiAqKVxuICAgICAgICBsZXQgcmVjIGxvb3AgYXJyIH5sZWZ0IH5jb21wYXJlIGkgdiA9XG4gICAgICAgICAgbGV0IGlfbmV4dCA9IGkgLSAxIGluXG4gICAgICAgICAgaWYgaV9uZXh0ID49IGxlZnQgJiYgY29tcGFyZSAoZ2V0IGFyciBpX25leHQpIHYgPiAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBzZXQgYXJyIGkgKGdldCBhcnIgaV9uZXh0KTtcbiAgICAgICAgICAgIGxvb3AgYXJyIH5sZWZ0IH5jb21wYXJlIGlfbmV4dCB2KVxuICAgICAgICAgIGVsc2UgaVxuICAgICAgICBpblxuICAgICAgICBsZXQgdiA9IGdldCBhcnIgcG9zIGluXG4gICAgICAgIGxldCBmaW5hbF9wb3MgPSBsb29wIGFyciB+bGVmdCB+Y29tcGFyZSBwb3MgdiBpblxuICAgICAgICBzZXQgYXJyIGZpbmFsX3BvcyB2XG4gICAgICBkb25lXG4gICAgOztcbiAgZW5kXG5cbiAgKCogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZWFwc29ydCAqKVxuICBtb2R1bGUgSGVhcF9zb3J0IDogU29ydCA9IHN0cnVjdFxuICAgICgqIGxvb3AgaW52YXJpYW50OlxuICAgICAgIHJvb3QncyBjaGlsZHJlbiBhcmUgYm90aCBlaXRoZXIgcm9vdHMgb2YgbWF4LWhlYXBzIG9yID4gcmlnaHQgKilcbiAgICBsZXQgcmVjIGhlYXBpZnkgYXJyIH5jb21wYXJlIHJvb3QgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCByZWxhdGl2ZV9yb290ID0gcm9vdCAtIGxlZnQgaW5cbiAgICAgIGxldCBsZWZ0X2NoaWxkID0gKDIgKiByZWxhdGl2ZV9yb290KSArIGxlZnQgKyAxIGluXG4gICAgICBsZXQgcmlnaHRfY2hpbGQgPSAoMiAqIHJlbGF0aXZlX3Jvb3QpICsgbGVmdCArIDIgaW5cbiAgICAgIGxldCBsYXJnZXN0ID1cbiAgICAgICAgaWYgbGVmdF9jaGlsZCA8PSByaWdodCAmJiBjb21wYXJlIChnZXQgYXJyIGxlZnRfY2hpbGQpIChnZXQgYXJyIHJvb3QpID4gMFxuICAgICAgICB0aGVuIGxlZnRfY2hpbGRcbiAgICAgICAgZWxzZSByb290XG4gICAgICBpblxuICAgICAgbGV0IGxhcmdlc3QgPVxuICAgICAgICBpZiByaWdodF9jaGlsZCA8PSByaWdodCAmJiBjb21wYXJlIChnZXQgYXJyIHJpZ2h0X2NoaWxkKSAoZ2V0IGFyciBsYXJnZXN0KSA+IDBcbiAgICAgICAgdGhlbiByaWdodF9jaGlsZFxuICAgICAgICBlbHNlIGxhcmdlc3RcbiAgICAgIGluXG4gICAgICBpZiBsYXJnZXN0IDw+IHJvb3RcbiAgICAgIHRoZW4gKFxuICAgICAgICBzd2FwIGFyciByb290IGxhcmdlc3Q7XG4gICAgICAgIGhlYXBpZnkgYXJyIH5jb21wYXJlIGxhcmdlc3QgfmxlZnQgfnJpZ2h0KVxuICAgIDs7XG5cbiAgICBsZXQgYnVpbGRfaGVhcCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgICgqIEVsZW1lbnRzIGluIHRoZSBzZWNvbmQgaGFsZiBvZiB0aGUgYXJyYXkgYXJlIGFscmVhZHkgaGVhcHMgb2Ygc2l6ZSAxLiAgV2UgbW92ZVxuICAgICAgICAgdGhyb3VnaCB0aGUgZmlyc3QgaGFsZiBvZiB0aGUgYXJyYXkgZnJvbSBiYWNrIHRvIGZyb250IGV4YW1pbmluZyB0aGUgZWxlbWVudCBhdFxuICAgICAgICAgaGFuZCwgYW5kIHRoZSBsZWZ0IGFuZCByaWdodCBjaGlsZHJlbiwgZml4aW5nIHRoZSBoZWFwIHByb3BlcnR5IGFzIHdlIGdvLiAqKVxuICAgICAgZm9yIGkgPSAobGVmdCArIHJpZ2h0KSAvIDIgZG93bnRvIGxlZnQgZG9cbiAgICAgICAgaGVhcGlmeSBhcnIgfmNvbXBhcmUgaSB+bGVmdCB+cmlnaHRcbiAgICAgIGRvbmVcbiAgICA7O1xuXG4gICAgbGV0IHNvcnQgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBidWlsZF9oZWFwIGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHQ7XG4gICAgICAoKiBsb29wIGludmFyaWFudHM6XG4gICAgICAgICAxLiAgdGhlIHN1YmFycmF5IGFycltsZWZ0IC4uLiBpXSBpcyBhIG1heC1oZWFwIEhcbiAgICAgICAgIDIuICB0aGUgc3ViYXJyYXkgYXJyW2krMSAuLi4gcmlnaHRdIGlzIHNvcnRlZCAoY2FsbCBpdCBTKVxuICAgICAgICAgMy4gIGV2ZXJ5IGVsZW1lbnQgb2YgSCBpcyBsZXNzIHRoYW4gZXZlcnkgZWxlbWVudCBvZiBTICopXG4gICAgICBmb3IgaSA9IHJpZ2h0IGRvd250byBsZWZ0ICsgMSBkb1xuICAgICAgICBzd2FwIGFyciBsZWZ0IGk7XG4gICAgICAgIGhlYXBpZnkgYXJyIH5jb21wYXJlIGxlZnQgfmxlZnQgfnJpZ2h0OihpIC0gMSlcbiAgICAgIGRvbmVcbiAgICA7O1xuICBlbmRcblxuICAoKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ludHJvc29ydCAqKVxuICBtb2R1bGUgSW50cm9fc29ydCA6IHNpZ1xuICAgIGluY2x1ZGUgU29ydFxuXG4gICAgdmFsIGZpdmVfZWxlbWVudF9zb3J0XG4gICAgICA6ICAnYSB0XG4gICAgICAtPiBjb21wYXJlOignYSAtPiAnYSAtPiBpbnQpXG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gaW50XG4gICAgICAtPiBpbnRcbiAgICAgIC0+IGludFxuICAgICAgLT4gdW5pdFxuICBlbmQgPSBzdHJ1Y3RcbiAgICBsZXQgZml2ZV9lbGVtZW50X3NvcnQgYXJyIH5jb21wYXJlIG0xIG0yIG0zIG00IG01ID1cbiAgICAgIGxldCBjb21wYXJlX2FuZF9zd2FwIGkgaiA9XG4gICAgICAgIGlmIGNvbXBhcmUgKGdldCBhcnIgaSkgKGdldCBhcnIgaikgPiAwIHRoZW4gc3dhcCBhcnIgaSBqXG4gICAgICBpblxuICAgICAgKCogT3B0aW1hbCA1LWVsZW1lbnQgc29ydGluZyBuZXR3b3JrOlxuXG4gICAgICAgICB7dlxuICAgICAgICAgICAgMS0tby0tLS0tby0tLS0tby0tLS0tLS0tLS0tLS0tMVxuICAgICAgICAgICAgICAgfCAgICAgfCAgICAgfFxuICAgICAgICAgICAgMi0tby0tLS0tfC0tby0tfC0tLS0tby0tby0tLS0tMlxuICAgICAgICAgICAgICAgICAgICAgfCAgfCAgfCAgICAgfCAgfFxuICAgICAgICAgICAgMy0tLS0tLS0tby0tby0tfC0tby0tfC0tby0tLS0tM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgfFxuICAgICAgICAgICAgNC0tLS0tby0tLS0tLS0tby0tby0tfC0tLS0tby0tNFxuICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfCAgICAgfFxuICAgICAgICAgICAgNS0tLS0tby0tLS0tLS0tLS0tLS0tby0tLS0tby0tNVxuICAgICAgICAgIHZ9ICopXG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0xIG0yO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtNCBtNTtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTEgbTM7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG0zO1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMSBtNDtcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTMgbTQ7XG4gICAgICBjb21wYXJlX2FuZF9zd2FwIG0yIG01O1xuICAgICAgY29tcGFyZV9hbmRfc3dhcCBtMiBtMztcbiAgICAgIGNvbXBhcmVfYW5kX3N3YXAgbTQgbTVcbiAgICA7O1xuXG4gICAgKCogY2hvb3NlIHBpdm90cyBmb3IgdGhlIGFycmF5IGJ5IHNvcnRpbmcgNSBlbGVtZW50cyBhbmQgZXhhbWluaW5nIHRoZSBjZW50ZXIgdGhyZWVcbiAgICAgICBlbGVtZW50cy4gIFRoZSBnb2FsIGlzIHRvIGNob29zZSB0d28gcGl2b3RzIHRoYXQgd2lsbCBlaXRoZXI6XG4gICAgICAgLSBicmVhayB0aGUgcmFuZ2UgdXAgaW50byAzIGV2ZW4gcGFydGl0aW9uc1xuICAgICAgICAgb3JcbiAgICAgICAtIGVsaW1pbmF0ZSBhIGNvbW1vbmx5IGFwcGVhcmluZyBlbGVtZW50IGJ5IHNvcnRpbmcgaXQgaW50byB0aGUgY2VudGVyIHBhcnRpdGlvblxuICAgICAgICAgYnkgaXRzZWxmXG4gICAgICAgICBUbyB0aGlzIGVuZCB3ZSBsb29rIGF0IHRoZSBjZW50ZXIgMyBlbGVtZW50cyBvZiB0aGUgNSBhbmQgcmV0dXJuIHBhaXJzIG9mIGVxdWFsXG4gICAgICAgICBlbGVtZW50cyBvciB0aGUgd2lkZXN0IHJhbmdlICopXG4gICAgbGV0IGNob29zZV9waXZvdHMgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgc2l4dGggPSAocmlnaHQgLSBsZWZ0KSAvIDYgaW5cbiAgICAgIGxldCBtMSA9IGxlZnQgKyBzaXh0aCBpblxuICAgICAgbGV0IG0yID0gbTEgKyBzaXh0aCBpblxuICAgICAgbGV0IG0zID0gbTIgKyBzaXh0aCBpblxuICAgICAgbGV0IG00ID0gbTMgKyBzaXh0aCBpblxuICAgICAgbGV0IG01ID0gbTQgKyBzaXh0aCBpblxuICAgICAgZml2ZV9lbGVtZW50X3NvcnQgYXJyIH5jb21wYXJlIG0xIG0yIG0zIG00IG01O1xuICAgICAgbGV0IG0yX3ZhbCA9IGdldCBhcnIgbTIgaW5cbiAgICAgIGxldCBtM192YWwgPSBnZXQgYXJyIG0zIGluXG4gICAgICBsZXQgbTRfdmFsID0gZ2V0IGFyciBtNCBpblxuICAgICAgaWYgY29tcGFyZSBtMl92YWwgbTNfdmFsID0gMFxuICAgICAgdGhlbiBtMl92YWwsIG0zX3ZhbCwgdHJ1ZVxuICAgICAgZWxzZSBpZiBjb21wYXJlIG0zX3ZhbCBtNF92YWwgPSAwXG4gICAgICB0aGVuIG0zX3ZhbCwgbTRfdmFsLCB0cnVlXG4gICAgICBlbHNlIG0yX3ZhbCwgbTRfdmFsLCBmYWxzZVxuICAgIDs7XG5cbiAgICBsZXQgZHVhbF9waXZvdF9wYXJ0aXRpb24gYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCA9XG4gICAgICBsZXQgcGl2b3QxLCBwaXZvdDIsIHBpdm90c19lcXVhbCA9IGNob29zZV9waXZvdHMgYXJyIH5jb21wYXJlIH5sZWZ0IH5yaWdodCBpblxuICAgICAgKCogbG9vcCBpbnZhcmlhbnRzOlxuICAgICAgICAgMS4gIGxlZnQgPD0gbCA8IHIgPD0gcmlnaHRcbiAgICAgICAgIDIuICBsIDw9IHAgPD0gclxuICAgICAgICAgMy4gIGwgPD0geCA8IHAgICAgIGltcGxpZXMgYXJyW3hdID49IHBpdm90MVxuICAgICAgICAgYW5kIGFyclt4XSA8PSBwaXZvdDJcbiAgICAgICAgIDQuICBsZWZ0IDw9IHggPCBsICBpbXBsaWVzIGFyclt4XSA8IHBpdm90MVxuICAgICAgICAgNS4gIHIgPCB4IDw9IHJpZ2h0IGltcGxpZXMgYXJyW3hdID4gcGl2b3QyICopXG4gICAgICBsZXQgcmVjIGxvb3AgbCBwIHIgPVxuICAgICAgICBsZXQgcHYgPSBnZXQgYXJyIHAgaW5cbiAgICAgICAgaWYgY29tcGFyZSBwdiBwaXZvdDEgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIHN3YXAgYXJyIHAgbDtcbiAgICAgICAgICBjb250IChsICsgMSkgKHAgKyAxKSByKVxuICAgICAgICBlbHNlIGlmIGNvbXBhcmUgcHYgcGl2b3QyID4gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICAoKiBsb29wIGludmFyaWFudHM6ICBzYW1lIGFzIHRob3NlIG9mIHRoZSBvdXRlciBsb29wICopXG4gICAgICAgICAgbGV0IHJlYyBzY2FuX2JhY2t3YXJkcyByID1cbiAgICAgICAgICAgIGlmIHIgPiBwICYmIGNvbXBhcmUgKGdldCBhcnIgcikgcGl2b3QyID4gMCB0aGVuIHNjYW5fYmFja3dhcmRzIChyIC0gMSkgZWxzZSByXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgciA9IHNjYW5fYmFja3dhcmRzIHIgaW5cbiAgICAgICAgICBzd2FwIGFyciByIHA7XG4gICAgICAgICAgY29udCBsIHAgKHIgLSAxKSlcbiAgICAgICAgZWxzZSBjb250IGwgKHAgKyAxKSByXG4gICAgICBhbmQgY29udCBsIHAgciA9IGlmIHAgPiByIHRoZW4gbCwgciBlbHNlIGxvb3AgbCBwIHIgaW5cbiAgICAgIGxldCBsLCByID0gY29udCBsZWZ0IGxlZnQgcmlnaHQgaW5cbiAgICAgIGwsIHIsIHBpdm90c19lcXVhbFxuICAgIDs7XG5cbiAgICBsZXQgcmVjIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBsZW4gPSByaWdodCAtIGxlZnQgKyAxIGluXG4gICAgICAoKiBUaGlzIHRha2VzIGNhcmUgb2Ygc29tZSBlZGdlIGNhc2VzLCBzdWNoIGFzIGxlZnQgPiByaWdodCBvciB2ZXJ5IHNob3J0IGFycmF5cyxcbiAgICAgICAgIHNpbmNlIEluc2VydGlvbl9zb3J0LnNvcnQgaGFuZGxlcyB0aGVzZSBjYXNlcyBwcm9wZXJseS4gIFRodXMgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAgbWFrZSBzdXJlIHRoYXQgbGVmdCBhbmQgcmlnaHQgYXJlIHZhbGlkIGluIHJlY3Vyc2l2ZSBjYWxscy4gKilcbiAgICAgIGlmIGxlbiA8PSAzMlxuICAgICAgdGhlbiBJbnNlcnRpb25fc29ydC5zb3J0IGFyciB+Y29tcGFyZSB+bGVmdCB+cmlnaHRcbiAgICAgIGVsc2UgaWYgbWF4X2RlcHRoIDwgMFxuICAgICAgdGhlbiBIZWFwX3NvcnQuc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0XG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IG1heF9kZXB0aCA9IG1heF9kZXB0aCAtIDEgaW5cbiAgICAgICAgbGV0IGwsIHIsIG1pZGRsZV9zb3J0ZWQgPSBkdWFsX3Bpdm90X3BhcnRpdGlvbiBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0IGluXG4gICAgICAgIGludHJvX3NvcnQgYXJyIH5tYXhfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0OihsIC0gMSk7XG4gICAgICAgIGlmIG5vdCBtaWRkbGVfc29ydGVkIHRoZW4gaW50cm9fc29ydCBhcnIgfm1heF9kZXB0aCB+Y29tcGFyZSB+bGVmdDpsIH5yaWdodDpyO1xuICAgICAgICBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoIH5jb21wYXJlIH5sZWZ0OihyICsgMSkgfnJpZ2h0KVxuICAgIDs7XG5cbiAgICBsZXQgc29ydCBhcnIgfmNvbXBhcmUgfmxlZnQgfnJpZ2h0ID1cbiAgICAgIGxldCBoZWFwX3NvcnRfc3dpdGNoX2RlcHRoID1cbiAgICAgICAgKCogV2UgYmFpbCBvdXQgdG8gaGVhcCBzb3J0IGF0IGEgcmVjdXJzaW9uIGRlcHRoIG9mIDMyLiBHTlUgaW50cm9zb3J0IHVzZXMgMmxnKG4pLlxuICAgICAgICAgICBUaGUgZXhwZWN0ZWQgcmVjdXJzaW9uIGRlcHRoIGZvciBwZXJmZWN0IDMtd2F5IHNwbGl0cyBpcyBsb2dfMyhuKS5cblxuICAgICAgICAgICBVc2luZyAzMiBtZWFucyBhIGJhbGFuY2VkIDMtd2F5IHNwbGl0IHdvdWxkIHdvcmsgdXAgdG8gM14zMiBlbGVtZW50cyAocm91Z2hseVxuICAgICAgICAgICAyXjUwIG9yIDEwXjE1KS4gR05VIHJlYWNoZXMgYSBkZXB0aCBvZiAzMiBhdCA2NTUzNiBlbGVtZW50cy5cblxuICAgICAgICAgICBGb3Igc21hbGwgYXJyYXlzLCB0aGlzIG1ha2VzIHVzIGxlc3MgbGlrZWx5IHRvIGJhaWwgb3V0IHRvIGhlYXAgc29ydCwgYnV0IHRoZVxuICAgICAgICAgICAzMipOIGNvc3QgYmVmb3JlIHdlIGRvIGlzIG5vdCB0aGF0IG11Y2guXG5cbiAgICAgICAgICAgRm9yIGxhcmdlIGFycmF5cywgdGhpcyBtZWFucyB3ZSBhcmUgbW9yZSBsaWtlbHkgdG8gYmFpbCBvdXQgdG8gaGVhcCBzb3J0IGF0XG4gICAgICAgICAgIHNvbWUgcG9pbnQgaWYgd2UgZ2V0IHNvbWUgYmFkIHNwbGl0cyBvciBpZiB0aGUgYXJyYXkgaXMgaHVnZS4gQnV0IHRoYXQncyBvbmx5IGFcbiAgICAgICAgICAgY29uc3RhbnQgZmFjdG9yIGNvc3QgaW4gdGhlIGZpbmFsIHN0YWdlcyBvZiByZWN1cnNpb24uXG5cbiAgICAgICAgICAgQWxsIGluIGFsbCwgdGhpcyBzZWVtcyB0byBiZSBhIHNtYWxsIHRyYWRlb2ZmIGFuZCBhdm9pZHMgcGF5aW5nIGEgY29zdCB0b1xuICAgICAgICAgICBjb21wdXRlIGEgbG9nYXJpdGhtIGF0IHRoZSBzdGFydC4gKilcbiAgICAgICAgMzJcbiAgICAgIGluXG4gICAgICBpbnRyb19zb3J0IGFyciB+bWF4X2RlcHRoOmhlYXBfc29ydF9zd2l0Y2hfZGVwdGggfmNvbXBhcmUgfmxlZnQgfnJpZ2h0XG4gICAgOztcbiAgZW5kXG5lbmRcblxubGV0IHNvcnQgP3BvcyA/bGVuIGFyciB+Y29tcGFyZSA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCBhcnIpXG4gIGluXG4gIFNvcnQuSW50cm9fc29ydC5zb3J0IGFyciB+Y29tcGFyZSB+bGVmdDpwb3MgfnJpZ2h0Oihwb3MgKyBsZW4gLSAxKVxuOztcblxubGV0IHRvX2FycmF5IHQgPSB0XG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXQgaXNfc29ydGVkIHQgfmNvbXBhcmUgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPiAwICYmICFyZXN1bHQgZG9cbiAgICBsZXQgZWx0X2kgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICBsZXQgZWx0X2lfbWludXNfMSA9IHVuc2FmZV9nZXQgdCAoIWkgLSAxKSBpblxuICAgIGlmIGNvbXBhcmUgZWx0X2lfbWludXNfMSBlbHRfaSA+IDAgdGhlbiByZXN1bHQgOj0gZmFsc2U7XG4gICAgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBpc19zb3J0ZWRfc3RyaWN0bHkgdCB+Y29tcGFyZSA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+IDAgJiYgIXJlc3VsdCBkb1xuICAgIGxldCBlbHRfaSA9IHVuc2FmZV9nZXQgdCAhaSBpblxuICAgIGxldCBlbHRfaV9taW51c18xID0gdW5zYWZlX2dldCB0ICghaSAtIDEpIGluXG4gICAgaWYgY29tcGFyZSBlbHRfaV9taW51c18xIGVsdF9pID49IDAgdGhlbiByZXN1bHQgOj0gZmFsc2U7XG4gICAgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBtZXJnZSBhMSBhMiB+Y29tcGFyZSA9XG4gIGxldCBsMSA9IEFycmF5Lmxlbmd0aCBhMSBpblxuICBsZXQgbDIgPSBBcnJheS5sZW5ndGggYTIgaW5cbiAgaWYgbDEgPSAwXG4gIHRoZW4gY29weSBhMlxuICBlbHNlIGlmIGwyID0gMFxuICB0aGVuIGNvcHkgYTFcbiAgZWxzZSBpZiBjb21wYXJlICh1bnNhZmVfZ2V0IGEyIDApICh1bnNhZmVfZ2V0IGExIChsMSAtIDEpKSA+PSAwXG4gIHRoZW4gYXBwZW5kIGExIGEyXG4gIGVsc2UgaWYgY29tcGFyZSAodW5zYWZlX2dldCBhMSAwKSAodW5zYWZlX2dldCBhMiAobDIgLSAxKSkgPiAwXG4gIHRoZW4gYXBwZW5kIGEyIGExXG4gIGVsc2UgKFxuICAgIGxldCBsZW4gPSBsMSArIGwyIGluXG4gICAgbGV0IG1lcmdlZCA9IGNyZWF0ZSB+bGVuICh1bnNhZmVfZ2V0IGExIDApIGluXG4gICAgbGV0IGExX2luZGV4ID0gcmVmIDAgaW5cbiAgICBsZXQgYTJfaW5kZXggPSByZWYgMCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICBsZXQgdXNlX2ExID1cbiAgICAgICAgaWYgbDEgPSAhYTFfaW5kZXhcbiAgICAgICAgdGhlbiBmYWxzZVxuICAgICAgICBlbHNlIGlmIGwyID0gIWEyX2luZGV4XG4gICAgICAgIHRoZW4gdHJ1ZVxuICAgICAgICBlbHNlIGNvbXBhcmUgKHVuc2FmZV9nZXQgYTEgIWExX2luZGV4KSAodW5zYWZlX2dldCBhMiAhYTJfaW5kZXgpIDw9IDBcbiAgICAgIGluXG4gICAgICBpZiB1c2VfYTFcbiAgICAgIHRoZW4gKFxuICAgICAgICB1bnNhZmVfc2V0IG1lcmdlZCBpICh1bnNhZmVfZ2V0IGExICFhMV9pbmRleCk7XG4gICAgICAgIGExX2luZGV4IDo9ICFhMV9pbmRleCArIDEpXG4gICAgICBlbHNlIChcbiAgICAgICAgdW5zYWZlX3NldCBtZXJnZWQgaSAodW5zYWZlX2dldCBhMiAhYTJfaW5kZXgpO1xuICAgICAgICBhMl9pbmRleCA6PSAhYTJfaW5kZXggKyAxKVxuICAgIGRvbmU7XG4gICAgbWVyZ2VkKVxuOztcblxubGV0IGNvcHlfbWF0cml4ID0gbWFwIH5mOmNvcHlcblxubGV0IGZvbGRpbmdfbWFwIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwIHQgfmY6KGZ1biB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmICFhY2MgeCBpblxuICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgIHkpXG47O1xuXG5sZXQgZm9sZF9tYXAgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXAgdCB+ZjooZnVuIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiAhYWNjIHggaW5cbiAgICAgIGFjYyA6PSBuZXdfYWNjO1xuICAgICAgeSlcbiAgaW5cbiAgIWFjYywgcmVzdWx0XG47O1xuXG5sZXQgZm9sZF9yZXN1bHQgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3Jlc3VsdCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfdW50aWwgfmZvbGQgfmluaXQgfmYgdFxubGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxubGV0IHN1bSBtIHQgfmYgPSBDb250YWluZXIuc3VtIH5mb2xkIG0gdCB+ZlxubGV0IG1pbl9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5taW5fZWx0IH5mb2xkIHQgfmNvbXBhcmVcbmxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG5cbmxldCBmb2xkaSB0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBhY2MgOj0gZiBpICFhY2MgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lO1xuICAhYWNjXG47O1xuXG5sZXQgZm9sZGluZ19tYXBpIHQgfmluaXQgfmYgPVxuICBsZXQgYWNjID0gcmVmIGluaXQgaW5cbiAgbWFwaSB0IH5mOihmdW4gaSB4IC0+XG4gICAgbGV0IG5ld19hY2MsIHkgPSBmIGkgIWFjYyB4IGluXG4gICAgYWNjIDo9IG5ld19hY2M7XG4gICAgeSlcbjs7XG5cbmxldCBmb2xkX21hcGkgdCB+aW5pdCB+ZiA9XG4gIGxldCBhY2MgPSByZWYgaW5pdCBpblxuICBsZXQgcmVzdWx0ID1cbiAgICBtYXBpIHQgfmY6KGZ1biBpIHggLT5cbiAgICAgIGxldCBuZXdfYWNjLCB5ID0gZiBpICFhY2MgeCBpblxuICAgICAgYWNjIDo9IG5ld19hY2M7XG4gICAgICB5KVxuICBpblxuICAhYWNjLCByZXN1bHRcbjs7XG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGRpIHQgfmluaXQ6MCB+ZjooZnVuIGlkeCBjb3VudCBhIC0+IGlmIGYgaWR4IGEgdGhlbiBjb3VudCArIDEgZWxzZSBjb3VudClcbjs7XG5cbmxldCBjb25jYXRfbWFwIHQgfmYgPSBjb25jYXQgKHRvX2xpc3QgKG1hcCB+ZiB0KSlcbmxldCBjb25jYXRfbWFwaSB0IH5mID0gY29uY2F0ICh0b19saXN0IChtYXBpIH5mIHQpKVxuXG5sZXQgcmV2X2lucGxhY2UgdCA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgbGV0IGogPSByZWYgKGxlbmd0aCB0IC0gMSkgaW5cbiAgd2hpbGUgIWkgPCAhaiBkb1xuICAgIHN3YXAgdCAhaSAhajtcbiAgICBpbmNyIGk7XG4gICAgZGVjciBqXG4gIGRvbmVcbjs7XG5cbmxldCByZXYgdCA9XG4gIGxldCB0ID0gY29weSB0IGluXG4gIHJldl9pbnBsYWNlIHQ7XG4gIHRcbjs7XG5cbmxldCBvZl9saXN0X3JldiBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IGEgOjogbCAtPlxuICAgIGxldCBsZW4gPSAxICsgTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCB0ID0gY3JlYXRlIH5sZW4gYSBpblxuICAgIGxldCByID0gcmVmIGwgaW5cbiAgICAoKiBXZSBzdGFydCBhdCBbbGVuIC0gMl0gYmVjYXVzZSB3ZSBhbHJlYWR5IHB1dCBbYV0gYXQgW3QuKGxlbiAtIDEpXS4gKilcbiAgICBmb3IgaSA9IGxlbiAtIDIgZG93bnRvIDAgZG9cbiAgICAgIG1hdGNoICFyIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IGEgOjogbCAtPlxuICAgICAgICB0LihpKSA8LSBhO1xuICAgICAgICByIDo9IGxcbiAgICBkb25lO1xuICAgIHRcbjs7XG5cbigqIFtvZl9saXN0X21hcF0gYW5kIFtvZl9saXN0X3Jldl9tYXBdIGFyZSBiYXNlZCBvbiBmdW5jdGlvbnMgZnJvbSB0aGUgT0NhbWxcbiAgIGRpc3RyaWJ1dGlvbi4gKilcblxubGV0IG9mX2xpc3RfbWFwIHhzIH5mID1cbiAgbWF0Y2ggeHMgd2l0aFxuICB8IFtdIC0+IFt8fF1cbiAgfCBoZCA6OiB0bCAtPlxuICAgIGxldCBhID0gY3JlYXRlIH5sZW46KDEgKyBMaXN0Lmxlbmd0aCB0bCkgKGYgaGQpIGluXG4gICAgbGV0IHJlYyBmaWxsIGkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBhXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIHVuc2FmZV9zZXQgYSBpIChmIGhkKTtcbiAgICAgICAgZmlsbCAoaSArIDEpIHRsXG4gICAgaW5cbiAgICBmaWxsIDEgdGxcbjs7XG5cbmxldCBvZl9saXN0X21hcGkgeHMgfmYgPVxuICBtYXRjaCB4cyB3aXRoXG4gIHwgW10gLT4gW3x8XVxuICB8IGhkIDo6IHRsIC0+XG4gICAgbGV0IGEgPSBjcmVhdGUgfmxlbjooMSArIExpc3QubGVuZ3RoIHRsKSAoZiAwIGhkKSBpblxuICAgIGxldCByZWMgZmlsbCBhIGkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiBhXG4gICAgICB8IGhkIDo6IHRsIC0+XG4gICAgICAgIHVuc2FmZV9zZXQgYSBpIChmIGkgaGQpO1xuICAgICAgICBmaWxsIGEgKGkgKyAxKSB0bFxuICAgIGluXG4gICAgZmlsbCBhIDEgdGxcbjs7XG5cbmxldCBvZl9saXN0X3Jldl9tYXAgeHMgfmYgPVxuICBsZXQgdCA9IG9mX2xpc3RfbWFwIHhzIH5mIGluXG4gIHJldl9pbnBsYWNlIHQ7XG4gIHRcbjs7XG5cbmxldCBvZl9saXN0X3Jldl9tYXBpIHhzIH5mID1cbiAgbGV0IHQgPSBvZl9saXN0X21hcGkgeHMgfmYgaW5cbiAgcmV2X2lucGxhY2UgdDtcbiAgdFxuOztcblxubGV0IGZpbHRlcl9tYXBpIHQgfmYgPVxuICBsZXQgciA9IHJlZiBbfHxdIGluXG4gIGxldCBrID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIG1hdGNoIGYgaSAodW5zYWZlX2dldCB0IGkpIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYSAtPlxuICAgICAgaWYgIWsgPSAwIHRoZW4gciA6PSBjcmVhdGUgfmxlbjoobGVuZ3RoIHQpIGE7XG4gICAgICB1bnNhZmVfc2V0ICFyICFrIGE7XG4gICAgICBpbmNyIGtcbiAgZG9uZTtcbiAgaWYgIWsgPSBsZW5ndGggdCB0aGVuICFyIGVsc2UgaWYgIWsgPiAwIHRoZW4gc3ViIH5wb3M6MCB+bGVuOiFrICFyIGVsc2UgW3x8XVxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biBfaSBhIC0+IGYgYSlcbmxldCBmaWx0ZXJfb3B0IHQgPSBmaWx0ZXJfbWFwIHQgfmY6Rm4uaWRcblxubGV0IHJhaXNlX2xlbmd0aF9taXNtYXRjaCBuYW1lIG4xIG4yID1cbiAgaW52YWxpZF9hcmdmIFwibGVuZ3RoIG1pc21hdGNoIGluICVzOiAlZCA8PiAlZFwiIG5hbWUgbjEgbjIgKClcbltAQGNvbGRdIFtAQGlubGluZSBuZXZlcl0gW0BAbG9jYWwgbmV2ZXJdIFtAQHNwZWNpYWxpc2UgbmV2ZXJdXG47O1xuXG5sZXQgY2hlY2tfbGVuZ3RoMl9leG4gbmFtZSB0MSB0MiA9XG4gIGxldCBuMSA9IGxlbmd0aCB0MSBpblxuICBsZXQgbjIgPSBsZW5ndGggdDIgaW5cbiAgaWYgbjEgPD4gbjIgdGhlbiByYWlzZV9sZW5ndGhfbWlzbWF0Y2ggbmFtZSBuMSBuMlxuOztcblxubGV0IGl0ZXIyX2V4biB0MSB0MiB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuaXRlcjJfZXhuXCIgdDEgdDI7XG4gIGl0ZXJpIHQxIH5mOihmdW4gaSB4MSAtPiBmIHgxICh1bnNhZmVfZ2V0IHQyIGkpKVxuOztcblxubGV0IG1hcDJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5tYXAyX2V4blwiIHQxIHQyO1xuICBpbml0IChsZW5ndGggdDEpIH5mOihmdW4gaSAtPiBmICh1bnNhZmVfZ2V0IHQxIGkpICh1bnNhZmVfZ2V0IHQyIGkpKVxuOztcblxubGV0IGZvbGQyX2V4biB0MSB0MiB+aW5pdCB+ZiA9XG4gIGNoZWNrX2xlbmd0aDJfZXhuIFwiQXJyYXkuZm9sZDJfZXhuXCIgdDEgdDI7XG4gIGZvbGRpIHQxIH5pbml0IH5mOihmdW4gaSBhYyB4IC0+IGYgYWMgeCAodW5zYWZlX2dldCB0MiBpKSlcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcl9tYXAgdCB+ZjooZnVuIHggLT4gaWYgZiB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcbmxldCBmaWx0ZXJpIHQgfmYgPSBmaWx0ZXJfbWFwaSB0IH5mOihmdW4gaSB4IC0+IGlmIGYgaSB4IHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcblxuXG5sZXQgZXhpc3RzIHQgfmYgPVxuICBsZXQgaSA9IHJlZiAobGVuZ3RoIHQgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICh1bnNhZmVfZ2V0IHQgIWkpIHRoZW4gcmVzdWx0IDo9IHRydWUgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGV4aXN0c2kgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgZmFsc2UgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiBub3QgIXJlc3VsdCBkb1xuICAgIGlmIGYgIWkgKHVuc2FmZV9nZXQgdCAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgbWVtIHQgYSB+ZXF1YWwgPSBleGlzdHMgdCB+ZjooZXF1YWwgYSlcblxubGV0IGZvcl9hbGwgdCB+ZiA9XG4gIGxldCBpID0gcmVmIChsZW5ndGggdCAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgKHVuc2FmZV9nZXQgdCAhaSkpIHRoZW4gcmVzdWx0IDo9IGZhbHNlIGVsc2UgZGVjciBpXG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbmxldCBmb3JfYWxsaSB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIChsZW5ndGggLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIHRydWUgaW5cbiAgd2hpbGUgIWkgPj0gMCAmJiAhcmVzdWx0IGRvXG4gICAgaWYgbm90IChmICFpICh1bnNhZmVfZ2V0IHQgIWkpKSB0aGVuIHJlc3VsdCA6PSBmYWxzZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZXhpc3RzMl9leG4gdDEgdDIgfmYgPVxuICBjaGVja19sZW5ndGgyX2V4biBcIkFycmF5LmV4aXN0czJfZXhuXCIgdDEgdDI7XG4gIGxldCBpID0gcmVmIChsZW5ndGggdDEgLSAxKSBpblxuICBsZXQgcmVzdWx0ID0gcmVmIGZhbHNlIGluXG4gIHdoaWxlICFpID49IDAgJiYgbm90ICFyZXN1bHQgZG9cbiAgICBpZiBmICh1bnNhZmVfZ2V0IHQxICFpKSAodW5zYWZlX2dldCB0MiAhaSkgdGhlbiByZXN1bHQgOj0gdHJ1ZSBlbHNlIGRlY3IgaVxuICBkb25lO1xuICAhcmVzdWx0XG47O1xuXG5sZXQgZm9yX2FsbDJfZXhuIHQxIHQyIH5mID1cbiAgY2hlY2tfbGVuZ3RoMl9leG4gXCJBcnJheS5mb3JfYWxsMl9leG5cIiB0MSB0MjtcbiAgbGV0IGkgPSByZWYgKGxlbmd0aCB0MSAtIDEpIGluXG4gIGxldCByZXN1bHQgPSByZWYgdHJ1ZSBpblxuICB3aGlsZSAhaSA+PSAwICYmICFyZXN1bHQgZG9cbiAgICBpZiBub3QgKGYgKHVuc2FmZV9nZXQgdDEgIWkpICh1bnNhZmVfZ2V0IHQyICFpKSkgdGhlbiByZXN1bHQgOj0gZmFsc2UgZWxzZSBkZWNyIGlcbiAgZG9uZTtcbiAgIXJlc3VsdFxuOztcblxubGV0IGVxdWFsIGVxdWFsIHQxIHQyID0gbGVuZ3RoIHQxID0gbGVuZ3RoIHQyICYmIGZvcl9hbGwyX2V4biB0MSB0MiB+ZjplcXVhbFxuXG5cbmxldCBtYXBfaW5wbGFjZSB0IH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgdCBpIChmICh1bnNhZmVfZ2V0IHQgaSkpXG4gIGRvbmVcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gZmluZGlfaW50ZXJuYWwgdCB+ZiB+aWZfZm91bmQgfmlmX25vdF9mb3VuZCA9XG4gIGxldCBsZW5ndGggPSBsZW5ndGggdCBpblxuICBpZiBsZW5ndGggPSAwXG4gIHRoZW4gaWZfbm90X2ZvdW5kICgpXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgZm91bmQgPSByZWYgZmFsc2UgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgKHVuc2FmZV9nZXQgdCAwKSBpblxuICAgIHdoaWxlIChub3QgIWZvdW5kKSAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICBpZiBmICFpIHZhbHVlXG4gICAgICB0aGVuIChcbiAgICAgICAgdmFsdWVfZm91bmQgOj0gdmFsdWU7XG4gICAgICAgIGZvdW5kIDo9IHRydWUpXG4gICAgICBlbHNlIGluY3IgaVxuICAgIGRvbmU7XG4gICAgaWYgIWZvdW5kIHRoZW4gaWZfZm91bmQgfmk6IWkgfnZhbHVlOiF2YWx1ZV9mb3VuZCBlbHNlIGlmX25vdF9mb3VuZCAoKSlcbjs7XG5cbmxldCBmaW5kaSB0IH5mID1cbiAgZmluZGlfaW50ZXJuYWxcbiAgICB0XG4gICAgfmZcbiAgICB+aWZfZm91bmQ6KGZ1biB+aSB+dmFsdWUgLT4gU29tZSAoaSwgdmFsdWUpKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biAoKSAtPiBOb25lKVxuOztcblxubGV0IGZpbmRpX2V4biB0IH5mID1cbiAgZmluZGlfaW50ZXJuYWxcbiAgICB0XG4gICAgfmZcbiAgICB+aWZfZm91bmQ6KGZ1biB+aSB+dmFsdWUgLT4gaSwgdmFsdWUpXG4gICAgfmlmX25vdF9mb3VuZDooZnVuICgpIC0+IHJhaXNlIChOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRpX2V4bjogbm90IGZvdW5kXCIpKSlcbjs7XG5cbmxldCBmaW5kX2V4biB0IH5mID1cbiAgZmluZGlfaW50ZXJuYWxcbiAgICB0XG4gICAgfmY6KGZ1biBfaSB4IC0+IGYgeClcbiAgICB+aWZfZm91bmQ6KGZ1biB+aTpfIH52YWx1ZSAtPiB2YWx1ZSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4gKCkgLT4gcmFpc2UgKE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZF9leG46IG5vdCBmb3VuZFwiKSkpXG47O1xuXG5sZXQgZmluZCB0IH5mID0gT3B0aW9uLm1hcCAoZmluZGkgdCB+ZjooZnVuIF9pIHggLT4gZiB4KSkgfmY6KGZ1biAoX2ksIHgpIC0+IHgpXG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgTm9uZSBpblxuICAgIHdoaWxlIE9wdGlvbi5pc19ub25lICF2YWx1ZV9mb3VuZCAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICB2YWx1ZV9mb3VuZCA6PSBmIHZhbHVlO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICAhdmFsdWVfZm91bmQpXG47O1xuXG5sZXQgZmluZF9tYXBfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiQXJyYXkuZmluZF9tYXBfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGZpbmRfbWFwX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcCB0IH5mIHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2Ugbm90X2ZvdW5kXG4gICAgfCBTb21lIHggLT4geFxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGZpbmRfbWFwX2V4blxuOztcblxubGV0IGZpbmRfbWFwaSB0IH5mID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDBcbiAgdGhlbiBOb25lXG4gIGVsc2UgKFxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBsZXQgdmFsdWVfZm91bmQgPSByZWYgTm9uZSBpblxuICAgIHdoaWxlIE9wdGlvbi5pc19ub25lICF2YWx1ZV9mb3VuZCAmJiAhaSA8IGxlbmd0aCBkb1xuICAgICAgbGV0IHZhbHVlID0gdW5zYWZlX2dldCB0ICFpIGluXG4gICAgICB2YWx1ZV9mb3VuZCA6PSBmICFpIHZhbHVlO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICAhdmFsdWVfZm91bmQpXG47O1xuXG5sZXQgZmluZF9tYXBpX2V4biA9XG4gIGxldCBub3RfZm91bmQgPSBOb3RfZm91bmRfcyAoQXRvbSBcIkFycmF5LmZpbmRfbWFwaV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgZmluZF9tYXBpX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kX21hcGkgdCB+ZiB3aXRoXG4gICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgIHwgU29tZSB4IC0+IHhcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICBmaW5kX21hcGlfZXhuXG47O1xuXG5sZXQgZmluZF9jb25zZWN1dGl2ZV9kdXBsaWNhdGUgdCB+ZXF1YWwgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGlmIG4gPD0gMVxuICB0aGVuIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHJlc3VsdCA9IHJlZiBOb25lIGluXG4gICAgbGV0IGkgPSByZWYgMSBpblxuICAgIGxldCBwcmV2ID0gcmVmICh1bnNhZmVfZ2V0IHQgMCkgaW5cbiAgICB3aGlsZSAhaSA8IG4gZG9cbiAgICAgIGxldCBjdXIgPSB1bnNhZmVfZ2V0IHQgIWkgaW5cbiAgICAgIGlmIGVxdWFsIGN1ciAhcHJldlxuICAgICAgdGhlbiAoXG4gICAgICAgIHJlc3VsdCA6PSBTb21lICghcHJldiwgY3VyKTtcbiAgICAgICAgaSA6PSBuKVxuICAgICAgZWxzZSAoXG4gICAgICAgIHByZXYgOj0gY3VyO1xuICAgICAgICBpbmNyIGkpXG4gICAgZG9uZTtcbiAgICAhcmVzdWx0KVxuOztcblxubGV0IHJlZHVjZSB0IH5mID1cbiAgaWYgbGVuZ3RoIHQgPSAwXG4gIHRoZW4gTm9uZVxuICBlbHNlIChcbiAgICBsZXQgciA9IHJlZiAodW5zYWZlX2dldCB0IDApIGluXG4gICAgZm9yIGkgPSAxIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgICAgciA6PSBmICFyICh1bnNhZmVfZ2V0IHQgaSlcbiAgICBkb25lO1xuICAgIFNvbWUgIXIpXG47O1xuXG5sZXQgcmVkdWNlX2V4biB0IH5mID1cbiAgbWF0Y2ggcmVkdWNlIHQgfmYgd2l0aFxuICB8IE5vbmUgLT4gaW52YWxpZF9hcmcgXCJBcnJheS5yZWR1Y2VfZXhuXCJcbiAgfCBTb21lIHYgLT4gdlxuOztcblxubGV0IHBlcm11dGUgPSBBcnJheV9wZXJtdXRlLnBlcm11dGVcblxubGV0IHJhbmRvbV9lbGVtZW50X2V4biA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSB0ID1cbiAgaWYgaXNfZW1wdHkgdFxuICB0aGVuIGZhaWx3aXRoIFwiQXJyYXkucmFuZG9tX2VsZW1lbnRfZXhuOiBlbXB0eSBhcnJheVwiXG4gIGVsc2UgdC4oUmFuZG9tLlN0YXRlLmludCByYW5kb21fc3RhdGUgKGxlbmd0aCB0KSlcbjs7XG5cbmxldCByYW5kb21fZWxlbWVudCA/KHJhbmRvbV9zdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSB0ID1cbiAgdHJ5IFNvbWUgKHJhbmRvbV9lbGVtZW50X2V4biB+cmFuZG9tX3N0YXRlIHQpIHdpdGhcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCB6aXAgdDEgdDIgPVxuICBpZiBsZW5ndGggdDEgPD4gbGVuZ3RoIHQyIHRoZW4gTm9uZSBlbHNlIFNvbWUgKG1hcDJfZXhuIHQxIHQyIH5mOihmdW4geDEgeDIgLT4geDEsIHgyKSlcbjs7XG5cbmxldCB6aXBfZXhuIHQxIHQyID1cbiAgaWYgbGVuZ3RoIHQxIDw+IGxlbmd0aCB0MlxuICB0aGVuIGZhaWx3aXRoIFwiQXJyYXkuemlwX2V4blwiXG4gIGVsc2UgbWFwMl9leG4gdDEgdDIgfmY6KGZ1biB4MSB4MiAtPiB4MSwgeDIpXG47O1xuXG5sZXQgdW56aXAgdCA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiBbfHxdLCBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCB4LCB5ID0gdC4oMCkgaW5cbiAgICBsZXQgcmVzMSA9IGNyZWF0ZSB+bGVuOm4geCBpblxuICAgIGxldCByZXMyID0gY3JlYXRlIH5sZW46biB5IGluXG4gICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICBsZXQgeCwgeSA9IHQuKGkpIGluXG4gICAgICByZXMxLihpKSA8LSB4O1xuICAgICAgcmVzMi4oaSkgPC0geVxuICAgIGRvbmU7XG4gICAgcmVzMSwgcmVzMilcbjs7XG5cbmxldCBzb3J0ZWRfY29weSB0IH5jb21wYXJlID1cbiAgbGV0IHQxID0gY29weSB0IGluXG4gIHNvcnQgdDEgfmNvbXBhcmU7XG4gIHQxXG47O1xuXG5sZXQgcGFydGl0aW9uaV90ZiB0IH5mID1cbiAgbGV0IGJvdGggPSBtYXBpIHQgfmY6KGZ1biBpIHggLT4gaWYgZiBpIHggdGhlbiBFaXRoZXIuRmlyc3QgeCBlbHNlIEVpdGhlci5TZWNvbmQgeCkgaW5cbiAgbGV0IHRydWVzID1cbiAgICBmaWx0ZXJfbWFwIGJvdGggfmY6KGZ1bmN0aW9uXG4gICAgICB8IEZpcnN0IHggLT4gU29tZSB4XG4gICAgICB8IFNlY29uZCBfIC0+IE5vbmUpXG4gIGluXG4gIGxldCBmYWxzZXMgPVxuICAgIGZpbHRlcl9tYXAgYm90aCB+ZjooZnVuY3Rpb25cbiAgICAgIHwgRmlyc3QgXyAtPiBOb25lXG4gICAgICB8IFNlY29uZCB4IC0+IFNvbWUgeClcbiAgaW5cbiAgdHJ1ZXMsIGZhbHNlc1xuOztcblxubGV0IHBhcnRpdGlvbl90ZiB0IH5mID0gcGFydGl0aW9uaV90ZiB0IH5mOihmdW4gX2kgeCAtPiBmIHgpXG5sZXQgbGFzdCB0ID0gdC4obGVuZ3RoIHQgLSAxKVxuXG4oKiBDb252ZXJ0IHRvIGEgc2VxdWVuY2UgYnV0IGRvZXMgbm90IGF0dGVtcHQgdG8gcHJvdGVjdCBhZ2FpbnN0IG1vZGlmaWNhdGlvblxuICAgaW4gdGhlIGFycmF5LiAqKVxubGV0IHRvX3NlcXVlbmNlX211dGFibGUgdCA9XG4gIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OjAgfmY6KGZ1biBpIC0+XG4gICAgaWYgaSA+PSBsZW5ndGggdCB0aGVuIFNlcXVlbmNlLlN0ZXAuRG9uZSBlbHNlIFNlcXVlbmNlLlN0ZXAuWWllbGQgKHQuKGkpLCBpICsgMSkpXG47O1xuXG5sZXQgdG9fc2VxdWVuY2UgdCA9IHRvX3NlcXVlbmNlX211dGFibGUgKGNvcHkgdClcblxubGV0IGNhcnRlc2lhbl9wcm9kdWN0IHQxIHQyID1cbiAgaWYgaXNfZW1wdHkgdDEgfHwgaXNfZW1wdHkgdDJcbiAgdGhlbiBbfHxdXG4gIGVsc2UgKFxuICAgIGxldCBuMSA9IGxlbmd0aCB0MSBpblxuICAgIGxldCBuMiA9IGxlbmd0aCB0MiBpblxuICAgIGxldCB0ID0gY3JlYXRlIH5sZW46KG4xICogbjIpICh0MS4oMCksIHQyLigwKSkgaW5cbiAgICBsZXQgciA9IHJlZiAwIGluXG4gICAgZm9yIGkxID0gMCB0byBuMSAtIDEgZG9cbiAgICAgIGZvciBpMiA9IDAgdG8gbjIgLSAxIGRvXG4gICAgICAgIHQuKCFyKSA8LSB0MS4oaTEpLCB0Mi4oaTIpO1xuICAgICAgICBpbmNyIHJcbiAgICAgIGRvbmVcbiAgICBkb25lO1xuICAgIHQpXG47O1xuXG5sZXQgdHJhbnNwb3NlIHR0ID1cbiAgaWYgbGVuZ3RoIHR0ID0gMFxuICB0aGVuIFNvbWUgW3x8XVxuICBlbHNlIChcbiAgICBsZXQgd2lkdGggPSBsZW5ndGggdHQgaW5cbiAgICBsZXQgZGVwdGggPSBsZW5ndGggdHQuKDApIGluXG4gICAgaWYgZXhpc3RzIHR0IH5mOihmdW4gdCAtPiBsZW5ndGggdCA8PiBkZXB0aClcbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIFNvbWUgKGluaXQgZGVwdGggfmY6KGZ1biBkIC0+IGluaXQgd2lkdGggfmY6KGZ1biB3IC0+IHR0Lih3KS4oZCkpKSkpXG47O1xuXG5sZXQgdHJhbnNwb3NlX2V4biB0dCA9XG4gIG1hdGNoIHRyYW5zcG9zZSB0dCB3aXRoXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZyBcIkFycmF5LnRyYW5zcG9zZV9leG5cIlxuICB8IFNvbWUgdHQnIC0+IHR0J1xuOztcblxuaW5jbHVkZSBCaW5hcnlfc2VhcmNoYWJsZS5NYWtlMSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBnZXQgPSBnZXRcbiAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gIGVuZClcblxuaW5jbHVkZSBCbGl0Lk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuXG4gICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gdCA9XG4gICAgICBpZiBsZW4gPSAwXG4gICAgICB0aGVuIFt8fF1cbiAgICAgIGVsc2UgKFxuICAgICAgICBhc3NlcnQgKGxlbmd0aCB0ID4gMCk7XG4gICAgICAgIGNyZWF0ZSB+bGVuIHQuKDApKVxuICAgIDs7XG5cbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmQpXG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9IGl0ZXIgdCB+ZjppbnZhcmlhbnRfYVxuXG5tb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICBtb2R1bGUgU29ydCA9IFNvcnRcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgSW50ID0gSW50MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuXG4oKiBXZSBtYWludGFpbiB0aGUgcHJvcGVydHkgdGhhdCBhbGwgdmFsdWVzIG9mIHR5cGUgW3RdIGRvIG5vdCBoYXZlIHRoZSB0YWdcbiAgIFtkb3VibGVfYXJyYXlfdGFnXS4gIFNvbWUgZnVuY3Rpb25zIGJlbG93IGFzc3VtZSB0aGlzIGluIG9yZGVyIHRvIGF2b2lkIHRlc3RpbmcgdGhlXG4gICB0YWcsIGFuZCB3aWxsIHNlZ2ZhdWx0IGlmIHRoaXMgcHJvcGVydHkgZG9lc24ndCBob2xkLiAqKVxudHlwZSB0ID0gQ2FtbC5PYmoudCBhcnJheVxuXG5sZXQgaW52YXJpYW50IHQgPSBhc3NlcnQgKENhbWwuT2JqLnRhZyAoQ2FtbC5PYmoucmVwciB0KSA8PiBDYW1sLk9iai5kb3VibGVfYXJyYXlfdGFnKVxubGV0IGxlbmd0aCA9IEFycmF5Lmxlbmd0aCAoKiB3b3VsZCBjaGVjayBmb3IgZmxvYXQgYXJyYXlzIGluIDMyIGJpdCwgYnV0IHdoYXRldmVyICopXG5cbmxldCBzZXhwX29mX3QgdCA9XG4gIFNleHAuQXRvbVxuICAgIChTdHJpbmcuY29uY2F0IH5zZXA6XCJcIiBbIFwiPE9ial9hcnJheS50IG9mIGxlbmd0aCBcIjsgSW50LnRvX3N0cmluZyAobGVuZ3RoIHQpOyBcIj5cIiBdKVxuOztcblxubGV0IHplcm9fb2JqID0gQ2FtbC5PYmoucmVwciAoMCA6IGludClcblxuKCogV2UgY2FsbCBbQXJyYXkuY3JlYXRlXSB3aXRoIGEgdmFsdWUgdGhhdCBpcyBub3QgYSBmbG9hdCBzbyB0aGF0IHRoZSBhcnJheSBkb2Vzbid0IGdldFxuICAgdGFnZ2VkIHdpdGggW0RvdWJsZV9hcnJheV90YWddLiAqKVxubGV0IGNyZWF0ZV96ZXJvIH5sZW4gPSBBcnJheS5jcmVhdGUgfmxlbiB6ZXJvX29ialxubGV0IGVtcHR5ID0gW3x8XVxuXG50eXBlIG5vdF9hX2Zsb2F0ID1cbiAgfCBOb3RfYV9mbG9hdF8wXG4gIHwgTm90X2FfZmxvYXRfMSBvZiBpbnRcblxubGV0IF9ub3RfYV9mbG9hdF8wID0gTm90X2FfZmxvYXRfMFxubGV0IF9ub3RfYV9mbG9hdF8xID0gTm90X2FfZmxvYXRfMSA0MlxuXG5sZXQgZ2V0IHQgaSA9XG4gICgqIE1ha2UgdGhlIGNvbXBpbGVyIGJlbGlldmUgW3RdIGlzIGFuIGFycmF5IG5vdCBjb250YWluaW5nIGZsb2F0cyBzbyBpdCBkb2VzIG5vdCBjaGVja1xuICAgICBpZiBbdF0gaXMgdGFnZ2VkIHdpdGggW0RvdWJsZV9hcnJheV90YWddLiAgSXQgaXMgTk9UIG9rIHRvIHVzZSBbaW50IGFycmF5XSBzaW5jZSAoaWZcbiAgICAgdGhpcyBmdW5jdGlvbiBpcyBpbmxpbmVkIGFuZCB0aGUgYXJyYXkgY29udGFpbnMgaW4taGVhcCBib3hlZCB2YWx1ZXMpIHdyb25nIHJlZ2lzdGVyXG4gICAgIHR5cGluZyBtYXkgcmVzdWx0LCBsZWFkaW5nIHRvIGEgZmFpbHVyZSB0byByZWdpc3RlciBuZWNlc3NhcnkgR0Mgcm9vdHMuICopXG4gIENhbWwuT2JqLnJlcHIgKChDYW1sLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpLihpKSA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfZ2V0IHQgaSA9XG4gICgqIE1ha2UgdGhlIGNvbXBpbGVyIGJlbGlldmUgW3RdIGlzIGFuIGFycmF5IG5vdCBjb250YWluaW5nIGZsb2F0cyBzbyBpdCBkb2VzIG5vdCBjaGVja1xuICAgICBpZiBbdF0gaXMgdGFnZ2VkIHdpdGggW0RvdWJsZV9hcnJheV90YWddLiAqKVxuICBDYW1sLk9iai5yZXByXG4gICAgKEFycmF5LnVuc2FmZV9nZXQgKENhbWwuT2JqLm1hZ2ljICh0IDogdCkgOiBub3RfYV9mbG9hdCBhcnJheSkgaSA6IG5vdF9hX2Zsb2F0KVxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9iaiA9XG4gICgqIFNhbWUgY29tbWVudCBhcyBbdW5zYWZlX2dldF0uIFN5cy5vcGFxdWVfaWRlbnRpdHkgcHJldmVudHMgdGhlIGNvbXBpbGVyIGZyb21cbiAgICAgcG90ZW50aWFsbHkgd3JvbmdseSBndWVzc2luZyB0aGUgdHlwZSBvZiB0aGUgYXJyYXkgYmFzZWQgb24gdGhlIHR5cGUgb2YgZWxlbWVudCwgdGhhdFxuICAgICBpcyBwcmV2ZW50IHRoZSBpbXBsaWNhdGlvbjogKE9iai50YWcgb2JqID0gT2JqLmRvdWJsZV90YWcpID0+IChPYmoudGFnIHQgPVxuICAgICBPYmouZG91YmxlX2FycmF5X3RhZykgd2hpY2ggZmxhbWJkYSBoYXMgdHJpZWQgaW4gdGhlIHBhc3QgKGF0IGxlYXN0IHRoYXQncyBhc3N1bWluZ1xuICAgICB0aGUgY29tcGlsZXIgcmVzcGVjdHMgU3lzLm9wYXF1ZV9pZGVudGl0eSwgd2hpY2ggaXMgbm90IGFsd2F5cyB0aGUgY2FzZSkuICopXG4gIEFycmF5LnVuc2FmZV9zZXRcbiAgICAoQ2FtbC5PYmoubWFnaWMgKHQgOiB0KSA6IG5vdF9hX2Zsb2F0IGFycmF5KVxuICAgIGlcbiAgICAoQ2FtbC5PYmoub2JqIChTeXMub3BhcXVlX2lkZW50aXR5IG9iaikgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9iaiA9XG4gICgqIHNhbWUgYXMgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IGJ1dCBzYWZlICopXG4gIChDYW1sLk9iai5tYWdpYyAodCA6IHQpIDogbm90X2FfZmxvYXQgYXJyYXkpLihpKVxuICA8LSAoQ2FtbC5PYmoub2JqIChTeXMub3BhcXVlX2lkZW50aXR5IG9iaikgOiBub3RfYV9mbG9hdClcbjs7XG5cbmxldFtAaW5saW5lIGFsd2F5c10gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgaW50ID1cbiAgKCogVGhpcyBza2lwcyBbY2FtbF9tb2RpZnldLCB3aGljaCBpcyBPSyBpZiBib3RoIHRoZSBvbGQgYW5kIG5ldyB2YWx1ZXMgYXJlIGludGVnZXJzLiAqKVxuICBBcnJheS51bnNhZmVfc2V0IChDYW1sLk9iai5tYWdpYyAodCA6IHQpIDogaW50IGFycmF5KSBpIChTeXMub3BhcXVlX2lkZW50aXR5IGludClcbjs7XG5cbigqIEZvciBbc2V0XSBhbmQgW3Vuc2FmZV9zZXRdLCBpZiBhIHBvaW50ZXIgaXMgaW52b2x2ZWQsIHdlIGZpcnN0IGRvIGEgcGh5c2ljYWwtZXF1YWxpdHlcbiAgIHRlc3QgdG8gc2VlIGlmIHRoZSBwb2ludGVyIGlzIGNoYW5naW5nLiAgSWYgbm90LCB3ZSBkb24ndCBuZWVkIHRvIGRvIHRoZSBbc2V0XSwgd2hpY2hcbiAgIHNhdmVzIGEgY2FsbCB0byBbY2FtbF9tb2RpZnldLiAgV2UgdGhpbmsgdGhpcyBwaHlzaWNhbC1lcXVhbGl0eSB0ZXN0IGlzIHdvcnRoIGl0XG4gICBiZWNhdXNlIGl0IGlzIHZlcnkgY2hlYXAgKGJvdGggdmFsdWVzIGFyZSBhbHJlYWR5IGF2YWlsYWJsZSBmcm9tIHRoZSBbaXNfaW50XSB0ZXN0KVxuICAgYW5kIGJlY2F1c2UgW2NhbWxfbW9kaWZ5XSBpcyBleHBlbnNpdmUuICopXG5cbmxldCBzZXQgdCBpIG9iaiA9XG4gICgqIFdlIHVzZSBbZ2V0XSBmaXJzdCBidXQgdGhlbiB3ZSB1c2UgW0FycmF5LnVuc2FmZV9zZXRdIHNpbmNlIHdlIGtub3cgdGhhdCBbaV0gaXNcbiAgICAgdmFsaWQuICopXG4gIGxldCBvbGRfb2JqID0gZ2V0IHQgaSBpblxuICBpZiBDYW1sLk9iai5pc19pbnQgb2xkX29iaiAmJiBDYW1sLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKENhbWwuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2UgaWYgbm90IChwaHlzX2VxdWFsIG9sZF9vYmogb2JqKVxuICB0aGVuIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgb2JqXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIHVuc2FmZV9zZXQgdCBpIG9iaiA9XG4gIGxldCBvbGRfb2JqID0gdW5zYWZlX2dldCB0IGkgaW5cbiAgaWYgQ2FtbC5PYmouaXNfaW50IG9sZF9vYmogJiYgQ2FtbC5PYmouaXNfaW50IG9ialxuICB0aGVuIHVuc2FmZV9zZXRfaW50X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgdCBpIChDYW1sLk9iai5vYmogb2JqIDogaW50KVxuICBlbHNlIGlmIG5vdCAocGh5c19lcXVhbCBvbGRfb2JqIG9iailcbiAgdGhlbiB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0W0BpbmxpbmUgYWx3YXlzXSB1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayB0IGkgb2JqID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBDYW1sLk9iai5pc19pbnQgb2xkX29iaiAmJiBDYW1sLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKENhbWwuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2UgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSBvYmpcbjs7XG5cbmxldCBzd2FwIHQgaSBqID1cbiAgbGV0IGEgPSBnZXQgdCBpIGluXG4gIGxldCBiID0gZ2V0IHQgaiBpblxuICB1bnNhZmVfc2V0IHQgaSBiO1xuICB1bnNhZmVfc2V0IHQgaiBhXG47O1xuXG5sZXQgY3JlYXRlIH5sZW4geCA9XG4gICgqIElmIHdlIGNhbiwgdXNlIFtBcnJheS5jcmVhdGVdIGRpcmVjdGx5LiAqKVxuICBpZiBDYW1sLk9iai50YWcgeCA8PiBDYW1sLk9iai5kb3VibGVfdGFnXG4gIHRoZW4gQXJyYXkuY3JlYXRlIH5sZW4geFxuICBlbHNlIChcbiAgICAoKiBPdGhlcndpc2UgdXNlIFtjcmVhdGVfemVyb10gYW5kIHNldCB0aGUgY29udGVudHMgKilcbiAgICBsZXQgdCA9IGNyZWF0ZV96ZXJvIH5sZW4gaW5cbiAgICBsZXQgeCA9IFN5cy5vcGFxdWVfaWRlbnRpdHkgeCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHhcbiAgICBkb25lO1xuICAgIHQpXG47O1xuXG5sZXQgc2luZ2xldG9uIG9iaiA9IGNyZWF0ZSB+bGVuOjEgb2JqXG5cbigqIFByZS1jb25kaXRpb246IHQuKGkpIGlzIGFuIGludGVnZXIuICopXG5sZXQgdW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IHQgaSBvYmogPVxuICBpZiBDYW1sLk9iai5pc19pbnQgb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgKENhbWwuT2JqLm9iaiBvYmogOiBpbnQpXG4gIGVsc2VcbiAgICAoKiBbdC4oaSldIGlzIGFuIGludGVnZXIgYW5kIFtvYmpdIGlzIG5vdCwgc28gd2UgZG8gbm90IG5lZWQgdG8gY2hlY2sgaWYgdGhleSBhcmVcbiAgICAgICBlcXVhbC4gKilcbiAgICB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIG9ialxuOztcblxubGV0IHVuc2FmZV9zZXRfaW50IHQgaSBpbnQgPVxuICBsZXQgb2xkX29iaiA9IHVuc2FmZV9nZXQgdCBpIGluXG4gIGlmIENhbWwuT2JqLmlzX2ludCBvbGRfb2JqXG4gIHRoZW4gdW5zYWZlX3NldF9pbnRfYXNzdW1pbmdfY3VycmVudGx5X2ludCB0IGkgaW50XG4gIGVsc2UgdW5zYWZlX3NldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoQ2FtbC5PYmoucmVwciBpbnQpXG47O1xuXG5sZXQgdW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgdCBpID1cbiAgbGV0IG9sZF9vYmogPSB1bnNhZmVfZ2V0IHQgaSBpblxuICBpZiBub3QgKENhbWwuT2JqLmlzX2ludCBvbGRfb2JqKSB0aGVuIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSB0IGkgKENhbWwuT2JqLnJlcHIgMClcbjs7XG5cbigqKiBbdW5zYWZlX2JsaXRdIGlzIGxpa2UgW0FycmF5LmJsaXRdLCBleGNlcHQgaXQgdXNlcyBvdXIgb3duIGZvci1sb29wIHRvIGF2b2lkXG4gICAgY2FtbF9tb2RpZnkgd2hlbiBwb3NzaWJsZS4gIEl0cyBwZXJmb3JtYW5jZSBpcyBzdGlsbCBub3QgY29tcGFyYWJsZSB0byBhIG1lbWNweS4gKilcbmxldCB1bnNhZmVfYmxpdCB+c3JjIH5zcmNfcG9zIH5kc3QgfmRzdF9wb3MgfmxlbiA9XG4gICgqIFdoZW4gW3BoeXNfZXF1YWwgc3JjIGRzdF0sIHdlIG5lZWQgdG8gY2hlY2sgd2hldGhlciBbZHN0X3BvcyA8IHNyY19wb3NdIGFuZCBoYXZlIHRoZVxuICAgICBmb3IgbG9vcCBnbyBpbiB0aGUgcmlnaHQgZGlyZWN0aW9uIHNvIHRoYXQgd2UgZG9uJ3Qgb3ZlcndyaXRlIGRhdGEgdGhhdCB3ZSBzdGlsbCBuZWVkXG4gICAgIHRvIHJlYWQuICBXaGVuIFtub3QgKHBoeXNfZXF1YWwgc3JjIGRzdCldLCBkb2luZyB0aGlzIGlzIGhhcm1sZXNzLiAgRnJvbSBhXG4gICAgIG1lbW9yeS1wZXJmb3JtYW5jZSBwZXJzcGVjdGl2ZSwgaXQgZG9lc24ndCBtYXR0ZXIgd2hldGhlciBvbmUgbG9vcHMgdXAgb3IgZG93bi5cbiAgICAgQ29uc3RhbnQtc3RyaWRlIGFjY2VzcywgZm9yd2FyZCBvciBiYWNrd2FyZCwgc2hvdWxkIGJlIGluZGlzdGluZ3Vpc2hhYmxlIChhdCBsZWFzdCBvblxuICAgICBhbiBpbnRlbCBpNykuICBTbywgd2UgZG9uJ3QgZG8gYSBjaGVjayBmb3IgW3BoeXNfZXF1YWwgc3JjIGRzdF0gYW5kIGFsd2F5cyBsb29wIHVwIGluXG4gICAgIHRoYXQgY2FzZS4gKilcbiAgaWYgZHN0X3BvcyA8IHNyY19wb3NcbiAgdGhlblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICB1bnNhZmVfc2V0IGRzdCAoZHN0X3BvcyArIGkpICh1bnNhZmVfZ2V0IHNyYyAoc3JjX3BvcyArIGkpKVxuICAgIGRvbmVcbiAgZWxzZVxuICAgIGZvciBpID0gbGVuIC0gMSBkb3dudG8gMCBkb1xuICAgICAgdW5zYWZlX3NldCBkc3QgKGRzdF9wb3MgKyBpKSAodW5zYWZlX2dldCBzcmMgKHNyY19wb3MgKyBpKSlcbiAgICBkb25lXG47O1xuXG5pbmNsdWRlIEJsaXQuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCBjcmVhdGUgPSBjcmVhdGVfemVyb1xuICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICBsZXQgdW5zYWZlX2JsaXQgPSB1bnNhZmVfYmxpdFxuICBlbmQpXG5cbmxldCBjb3B5IHNyYyA9XG4gIGxldCBkc3QgPSBjcmVhdGVfemVybyB+bGVuOihsZW5ndGggc3JjKSBpblxuICBibGl0byB+c3JjIH5kc3QgKCk7XG4gIGRzdFxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBXQVJOSU5HOlxuICAgV2UgdXNlIG5vbi1tZW1vcnktc2FmZSB0aGluZ3MgdGhyb3VnaG91dCB0aGUgW1RydXN0ZWRdIG1vZHVsZS5cbiAgIE1vc3Qgb2YgaXQgaXMgb25seSBzYWZlIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIHR5cGUgc2lnbmF0dXJlIChlLmcuIGV4cG9zaW5nXG4gICBbdmFsIGNvcHkgOiAnYSB0IC0+ICdiIHRdIHdvdWxkIGJlIGEgYmlnIG1pc3Rha2UpLiAqKVxubW9kdWxlIFRydXN0ZWQgOiBzaWdcbiAgdHlwZSAnYSB0XG5cbiAgdmFsIGVtcHR5IDogJ2EgdFxuICB2YWwgdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIDogbGVuOmludCAtPiAnYSB0XG4gIHZhbCBjcmVhdGVfb2JqX2FycmF5IDogbGVuOmludCAtPiAnYSB0XG4gIHZhbCBjcmVhdGUgOiBsZW46aW50IC0+ICdhIC0+ICdhIHRcbiAgdmFsIHNpbmdsZXRvbiA6ICdhIC0+ICdhIHRcbiAgdmFsIGdldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCBzZXQgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCBzd2FwIDogXyB0IC0+IGludCAtPiBpbnQgLT4gdW5pdFxuICB2YWwgdW5zYWZlX2dldCA6ICdhIHQgLT4gaW50IC0+ICdhXG4gIHZhbCB1bnNhZmVfc2V0IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgdW5zYWZlX3NldF9vbWl0X3BoeXNfZXF1YWxfY2hlY2sgOiAnYSB0IC0+IGludCAtPiAnYSAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X2ludCA6ICdhIHQgLT4gaW50IC0+IGludCAtPiB1bml0XG4gIHZhbCB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IDogJ2EgdCAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfYXNzdW1pbmdfY3VycmVudGx5X2ludCA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHVuc2FmZV9zZXRfd2l0aF9jYW1sX21vZGlmeSA6ICdhIHQgLT4gaW50IC0+ICdhIC0+IHVuaXRcbiAgdmFsIHNldF93aXRoX2NhbWxfbW9kaWZ5IDogJ2EgdCAtPiBpbnQgLT4gJ2EgLT4gdW5pdFxuICB2YWwgbGVuZ3RoIDogJ2EgdCAtPiBpbnRcbiAgdmFsIHVuc2FmZV9ibGl0IDogKCdhIHQsICdhIHQpIEJsaXQuYmxpdFxuICB2YWwgY29weSA6ICdhIHQgLT4gJ2EgdFxuICB2YWwgdW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgOiBfIHQgLT4gaW50IC0+IHVuaXRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSBPYmpfYXJyYXkudFxuXG4gIGxldCBlbXB0eSA9IE9ial9hcnJheS5lbXB0eVxuICBsZXQgdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW4gPSBPYmpfYXJyYXkuY3JlYXRlX3plcm8gfmxlblxuICBsZXQgY3JlYXRlX29ial9hcnJheSB+bGVuID0gT2JqX2FycmF5LmNyZWF0ZV96ZXJvIH5sZW5cbiAgbGV0IGNyZWF0ZSB+bGVuIHggPSBPYmpfYXJyYXkuY3JlYXRlIH5sZW4gKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHNpbmdsZXRvbiB4ID0gT2JqX2FycmF5LnNpbmdsZXRvbiAoQ2FtbC5PYmoucmVwciB4KVxuICBsZXQgc3dhcCB0IGkgaiA9IE9ial9hcnJheS5zd2FwIHQgaSBqXG4gIGxldCBnZXQgYXJyIGkgPSBDYW1sLk9iai5vYmogKE9ial9hcnJheS5nZXQgYXJyIGkpXG4gIGxldCBzZXQgYXJyIGkgeCA9IE9ial9hcnJheS5zZXQgYXJyIGkgKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHVuc2FmZV9nZXQgYXJyIGkgPSBDYW1sLk9iai5vYmogKE9ial9hcnJheS51bnNhZmVfZ2V0IGFyciBpKVxuICBsZXQgdW5zYWZlX3NldCBhcnIgaSB4ID0gT2JqX2FycmF5LnVuc2FmZV9zZXQgYXJyIGkgKENhbWwuT2JqLnJlcHIgeClcbiAgbGV0IHVuc2FmZV9zZXRfaW50IGFyciBpIHggPSBPYmpfYXJyYXkudW5zYWZlX3NldF9pbnQgYXJyIGkgeFxuXG4gIGxldCB1bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X2ludF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIHhcbiAgOztcblxuICBsZXQgdW5zYWZlX3NldF9hc3N1bWluZ19jdXJyZW50bHlfaW50IGFyciBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X2Fzc3VtaW5nX2N1cnJlbnRseV9pbnQgYXJyIGkgKENhbWwuT2JqLnJlcHIgeClcbiAgOztcblxuICBsZXQgbGVuZ3RoID0gT2JqX2FycmF5Lmxlbmd0aFxuICBsZXQgdW5zYWZlX2JsaXQgPSBPYmpfYXJyYXkudW5zYWZlX2JsaXRcbiAgbGV0IGNvcHkgPSBPYmpfYXJyYXkuY29weVxuXG4gIGxldCB1bnNhZmVfc2V0X29taXRfcGh5c19lcXVhbF9jaGVjayB0IGkgeCA9XG4gICAgT2JqX2FycmF5LnVuc2FmZV9zZXRfb21pdF9waHlzX2VxdWFsX2NoZWNrIHQgaSAoQ2FtbC5PYmoucmVwciB4KVxuICA7O1xuXG4gIGxldCB1bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIHggPVxuICAgIE9ial9hcnJheS51bnNhZmVfc2V0X3dpdGhfY2FtbF9tb2RpZnkgdCBpIChDYW1sLk9iai5yZXByIHgpXG4gIDs7XG5cbiAgbGV0IHNldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSB4ID0gT2JqX2FycmF5LnNldF93aXRoX2NhbWxfbW9kaWZ5IHQgaSAoQ2FtbC5PYmoucmVwciB4KVxuICBsZXQgdW5zYWZlX2NsZWFyX2lmX3BvaW50ZXIgPSBPYmpfYXJyYXkudW5zYWZlX2NsZWFyX2lmX3BvaW50ZXJcbmVuZFxuXG5pbmNsdWRlIFRydXN0ZWRcblxubGV0IGludmFyaWFudCB0ID0gYXNzZXJ0IChDYW1sLk9iai50YWcgKENhbWwuT2JqLnJlcHIgdCkgPD4gQ2FtbC5PYmouZG91YmxlX2FycmF5X3RhZylcblxubGV0IGluaXQgbCB+ZiA9XG4gIGlmIGwgPCAwXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJVbmlmb3JtX2FycmF5LmluaXRcIlxuICBlbHNlIChcbiAgICBsZXQgcmVzID0gdW5zYWZlX2NyZWF0ZV91bmluaXRpYWxpemVkIH5sZW46bCBpblxuICAgIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgICAgdW5zYWZlX3NldCByZXMgaSAoZiBpKVxuICAgIGRvbmU7XG4gICAgcmVzKVxuOztcblxubGV0IG9mX2FycmF5IGFyciA9IGluaXQgfmY6KEFycmF5LnVuc2FmZV9nZXQgYXJyKSAoQXJyYXkubGVuZ3RoIGFycilcbmxldCBtYXAgYSB+ZiA9IGluaXQgfmY6KGZ1biBpIC0+IGYgKHVuc2FmZV9nZXQgYSBpKSkgKGxlbmd0aCBhKVxubGV0IG1hcGkgYSB+ZiA9IGluaXQgfmY6KGZ1biBpIC0+IGYgaSAodW5zYWZlX2dldCBhIGkpKSAobGVuZ3RoIGEpXG5cbmxldCBpdGVyIGEgfmYgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIGEgLSAxIGRvXG4gICAgZiAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmVcbjs7XG5cbmxldCBpdGVyaSBhIH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBhIC0gMSBkb1xuICAgIGYgaSAodW5zYWZlX2dldCBhIGkpXG4gIGRvbmVcbjs7XG5cbmxldCBmb2xkaSBhIH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGZvciBpID0gMCB0byBsZW5ndGggYSAtIDEgZG9cbiAgICBhY2MgOj0gZiBpICFhY2MgKHVuc2FmZV9nZXQgYSBpKVxuICBkb25lO1xuICAhYWNjXG47O1xuXG5sZXQgdG9fbGlzdCB0ID0gTGlzdC5pbml0IH5mOihnZXQgdCkgKGxlbmd0aCB0KVxuXG5sZXQgb2ZfbGlzdCBsID1cbiAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIGwgaW5cbiAgbGV0IHJlcyA9IHVuc2FmZV9jcmVhdGVfdW5pbml0aWFsaXplZCB+bGVuIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgeCAtPiBzZXQgcmVzIGkgeCk7XG4gIHJlc1xuOztcblxuKCogSXQgaXMgbm90IHNhZmUgZm9yIFt0b19hcnJheV0gdG8gYmUgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGJlY2F1c2Ugd2UgaGF2ZSBjb2RlIHRoYXRcbiAgIHJlbGllcyBvbiBbZmxvYXQgYXJyYXldcyBiZWluZyB1bmJveGVkLCBmb3IgZXhhbXBsZSBpbiBbYmluX3dyaXRlX2FycmF5XS4gKilcbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCAobGVuZ3RoIHQpIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcblxubGV0IGV4aXN0cyB0IH5mID1cbiAgbGV0IHJlYyBsb29wIHQgfmYgaSA9XG4gICAgaWYgaSA8IDAgdGhlbiBmYWxzZSBlbHNlIGYgKHVuc2FmZV9nZXQgdCBpKSB8fCBsb29wIHQgfmYgKGkgLSAxKVxuICBpblxuICBsb29wIHQgfmYgKGxlbmd0aCB0IC0gMSlcbjs7XG5cbmxldCBmb3JfYWxsIHQgfmYgPVxuICBsZXQgcmVjIGxvb3AgdCB+ZiBpID0gaWYgaSA8IDAgdGhlbiB0cnVlIGVsc2UgZiAodW5zYWZlX2dldCB0IGkpICYmIGxvb3AgdCB+ZiAoaSAtIDEpIGluXG4gIGxvb3AgdCB+ZiAobGVuZ3RoIHQgLSAxKVxuOztcblxubGV0IG1hcDJfZXhuIHQxIHQyIH5mID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0MSBpblxuICBpZiBsZW5ndGggdDIgPD4gbGVuIHRoZW4gaW52YWxpZF9hcmcgXCJBcnJheS5tYXAyX2V4blwiO1xuICBpbml0IGxlbiB+ZjooZnVuIGkgLT4gZiAodW5zYWZlX2dldCB0MSBpKSAodW5zYWZlX2dldCB0MiBpKSlcbjs7XG5cbmxldCB0X3NleHBfZ3JhbW1hciAodHlwZSBlbHQpIChncmFtbWFyIDogZWx0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGVsdCB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSAoQXJyYXkudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG5cbmluY2x1ZGVcbiAgU2V4cGFibGUuT2Zfc2V4cGFibGUxXG4gICAgKEFycmF5KVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICdhIHQgPSAnYSB0XG5cbiAgICAgIGxldCB0b19zZXhwYWJsZSA9IHRvX2FycmF5XG4gICAgICBsZXQgb2Zfc2V4cGFibGUgPSBvZl9hcnJheVxuICAgIGVuZClcblxuaW5jbHVkZSBCbGl0Lk1ha2UxIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuXG4gICAgbGV0IGNyZWF0ZV9saWtlIH5sZW4gdCA9XG4gICAgICBpZiBsZW4gPSAwXG4gICAgICB0aGVuIGVtcHR5XG4gICAgICBlbHNlIChcbiAgICAgICAgYXNzZXJ0IChsZW5ndGggdCA+IDApO1xuICAgICAgICBjcmVhdGUgfmxlbiAoZ2V0IHQgMCkpXG4gICAgOztcblxuICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0XG4gIGVuZClcblxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCByID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHIgOj0gZiAhciAodW5zYWZlX2dldCB0IGkpXG4gIGRvbmU7XG4gICFyXG47O1xuXG5sZXQgbWluX2VsdCB0IH5jb21wYXJlID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdCB+Y29tcGFyZVxubGV0IG1heF9lbHQgdCB+Y29tcGFyZSA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHQgfmNvbXBhcmVcblxuKCogVGhpcyBpcyB0aGUgc2FtZSBhcyB0aGUgcHB4X2NvbXBhcmUgW2NvbXBhcmVfYXJyYXldIGJ1dCB1c2VzIG91ciBbdW5zYWZlX2dldF0gYW5kIFtsZW5ndGhdLiAqKVxubGV0IGNvbXBhcmUgY29tcGFyZV9lbHQgYSBiID1cbiAgaWYgcGh5c19lcXVhbCBhIGJcbiAgdGhlbiAwXG4gIGVsc2UgKFxuICAgIGxldCBsZW5fYSA9IGxlbmd0aCBhIGluXG4gICAgbGV0IGxlbl9iID0gbGVuZ3RoIGIgaW5cbiAgICBsZXQgcmV0ID0gY29tcGFyZSBsZW5fYSBsZW5fYiBpblxuICAgIGlmIHJldCA8PiAwXG4gICAgdGhlbiByZXRcbiAgICBlbHNlIChcbiAgICAgIGxldCByZWMgbG9vcCBpID1cbiAgICAgICAgaWYgaSA9IGxlbl9hXG4gICAgICAgIHRoZW4gMFxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgbCA9IHVuc2FmZV9nZXQgYSBpXG4gICAgICAgICAgYW5kIHIgPSB1bnNhZmVfZ2V0IGIgaSBpblxuICAgICAgICAgIGxldCByZXMgPSBjb21wYXJlX2VsdCBsIHIgaW5cbiAgICAgICAgICBpZiByZXMgPD4gMCB0aGVuIHJlcyBlbHNlIGxvb3AgKGkgKyAxKSlcbiAgICAgIGluXG4gICAgICBsb29wIDApKVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGNlaWwgPSBDYW1sLmNlaWxcbmxldCBmbG9vciA9IENhbWwuZmxvb3JcbmxldCBtb2RfZmxvYXQgPSBDYW1sLm1vZF9mbG9hdFxubGV0IG1vZGYgPSBDYW1sLm1vZGZcbmxldCBmbG9hdF9vZl9zdHJpbmcgPSBDYW1sLmZsb2F0X29mX3N0cmluZ1xubGV0IG5hbiA9IENhbWwubmFuXG5sZXQgaW5maW5pdHkgPSBDYW1sLmluZmluaXR5XG5sZXQgbmVnX2luZmluaXR5ID0gQ2FtbC5uZWdfaW5maW5pdHlcbmxldCBtYXhfZmluaXRlX3ZhbHVlID0gQ2FtbC5tYXhfZmxvYXRcbmxldCBlcHNpbG9uX2Zsb2F0ID0gQ2FtbC5lcHNpbG9uX2Zsb2F0XG5sZXQgY2xhc3NpZnlfZmxvYXQgPSBDYW1sLmNsYXNzaWZ5X2Zsb2F0XG5sZXQgYWJzX2Zsb2F0ID0gQ2FtbC5hYnNfZmxvYXRcbmxldCBpc19pbnRlZ2VyID0gQ2FtbC5GbG9hdC5pc19pbnRlZ2VyXG5sZXQgKCAqKiApID0gQ2FtbC4oICoqIClcblxubGV0ICggJS4gKSBhIGIgPVxuICAoKiBSYWlzZSBpbiBjYXNlIG9mIGEgbmVnYXRpdmUgbW9kdWx1cywgYXMgZG9lcyBJbnQuKCAlICkuICopXG4gIGlmIGIgPCAwLlxuICB0aGVuIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCIlZiAlJSAlZiBpbiBmbG9hdDAubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCIgYSBiICgpO1xuICBsZXQgbSA9IENhbWwubW9kX2Zsb2F0IGEgYiBpblxuICAoKiBQcm9kdWNlIGEgbm9uLW5lZ2F0aXZlIHJlc3VsdCBpbiBhbmFsb2d5IHdpdGggSW50LiggJSApLiAqKVxuICBpZiBtIDwgMC4gdGhlbiBtICsuIGIgZWxzZSBtXG47O1xuXG4oKiBUaGUgYml0cyBvZiBJTlJJQSdzIFtQZXJ2YXNpdmVzXSB0aGF0IHdlIGp1c3Qgd2FudCB0byBleHBvc2UgaW4gW0Zsb2F0XS4gTW9zdCBhcmVcbiAgIGFscmVhZHkgZGVwcmVjYXRlZCBpbiBbUGVydmFzaXZlc10sIGFuZCBldmVudHVhbGx5IGFsbCBvZiB0aGVtIHNob3VsZCBiZS4gKilcbmluY2x1ZGUgKFxuICBDYW1sIDpcbiAgc2lnXG4gICAgZXh0ZXJuYWwgZnJleHAgOiBmbG9hdCAtPiBmbG9hdCAqIGludCA9IFwiY2FtbF9mcmV4cF9mbG9hdFwiXG5cbiAgICBleHRlcm5hbCBsZGV4cFxuICAgICAgOiAgKGZsb2F0W0B1bmJveGVkXSlcbiAgICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICAgIC0+IChmbG9hdFtAdW5ib3hlZF0pXG4gICAgICA9IFwiY2FtbF9sZGV4cF9mbG9hdFwiIFwiY2FtbF9sZGV4cF9mbG9hdF91bmJveGVkXCJcbiAgICBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgbG9nMTAgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9sb2cxMF9mbG9hdFwiIFwibG9nMTBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgZXhwbTEgOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9leHBtMV9mbG9hdFwiIFwiY2FtbF9leHBtMVwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGxvZzFwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfbG9nMXBfZmxvYXRcIiBcImNhbWxfbG9nMXBcIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBjb3B5c2lnbiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2NvcHlzaWduX2Zsb2F0XCIgXCJjYW1sX2NvcHlzaWduXCJcbiAgICBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuXG4gICAgZXh0ZXJuYWwgY29zIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zX2Zsb2F0XCIgXCJjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIHNpbiA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3Npbl9mbG9hdFwiIFwic2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCB0YW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5fZmxvYXRcIiBcInRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgYWNvcyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2Fjb3NfZmxvYXRcIiBcImFjb3NcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIGFzaW4gOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF9hc2luX2Zsb2F0XCIgXCJhc2luXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBhdGFuIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfYXRhbl9mbG9hdFwiIFwiYXRhblwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBhdGFuMiA6IGZsb2F0IC0+IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2F0YW4yX2Zsb2F0XCIgXCJhdGFuMlwiXG4gICAgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cblxuICAgIGV4dGVybmFsIGh5cG90IDogZmxvYXQgLT4gZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfaHlwb3RfZmxvYXRcIiBcImNhbWxfaHlwb3RcIlxuICAgIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG5cbiAgICBleHRlcm5hbCBjb3NoIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfY29zaF9mbG9hdFwiIFwiY29zaFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgc2luaCA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX3NpbmhfZmxvYXRcIiBcInNpbmhcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIHRhbmggOiBmbG9hdCAtPiBmbG9hdCA9IFwiY2FtbF90YW5oX2Zsb2F0XCIgXCJ0YW5oXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgICBleHRlcm5hbCBzcXJ0IDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfc3FydF9mbG9hdFwiIFwic3FydFwiIFtAQHVuYm94ZWRdIFtAQG5vYWxsb2NdXG4gICAgZXh0ZXJuYWwgZXhwIDogZmxvYXQgLT4gZmxvYXQgPSBcImNhbWxfZXhwX2Zsb2F0XCIgXCJleHBcIiBbQEB1bmJveGVkXSBbQEBub2FsbG9jXVxuICAgIGV4dGVybmFsIGxvZyA6IGZsb2F0IC0+IGZsb2F0ID0gXCJjYW1sX2xvZ19mbG9hdFwiIFwibG9nXCIgW0BAdW5ib3hlZF0gW0BAbm9hbGxvY11cbiAgZW5kKVxuXG4oKiBXZSBuZWVkIHRoaXMgaW5kaXJlY3Rpb24gYmVjYXVzZSB0aGVzZSBhcmUgZXhwb3NlZCBhcyBcInZhbFwiIGluc3RlYWQgb2YgXCJleHRlcm5hbFwiICopXG5sZXQgZnJleHAgPSBmcmV4cFxubGV0IGxkZXhwID0gbGRleHBcbmxldCBpc19uYW4geCA9ICh4IDogZmxvYXQpIDw+IHhcblxuKCogQW4gb3JkZXItcHJlc2VydmluZyBiaWplY3Rpb24gYmV0d2VlbiBhbGwgZmxvYXRzIGV4Y2VwdCBmb3IgTmFOcywgYW5kIDk5Ljk1JSBvZlxuICAgaW50NjRzLlxuXG4gICBOb3RlIHdlIGRvbid0IGRpc3Rpbmd1aXNoIDAuIGFuZCAtMC4gYXMgc2VwYXJhdGUgdmFsdWVzIGhlcmUsIHRoZXkgYm90aCBtYXAgdG8gMEwsIHdoaWNoXG4gICBtYXBzIGJhY2sgdG8gMC5cblxuICAgVGhpcyBzaG91bGQgd29yayBib3RoIG9uIGxpdHRsZS1lbmRpYW4gYW5kIGhpZ2gtZW5kaWFuIENQVXMuICBXaWtpcGVkaWEgc2F5czogXCJvblxuICAgbW9kZXJuIHN0YW5kYXJkIGNvbXB1dGVycyAoaS5lLiwgaW1wbGVtZW50aW5nIElFRUUgNzU0KSwgb25lIG1heSBpbiBwcmFjdGljZSBzYWZlbHlcbiAgIGFzc3VtZSB0aGF0IHRoZSBlbmRpYW5uZXNzIGlzIHRoZSBzYW1lIGZvciBmbG9hdGluZyBwb2ludCBudW1iZXJzIGFzIGZvciBpbnRlZ2Vyc1wiXG4gICAoaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbmRpYW5uZXNzI0Zsb2F0aW5nLXBvaW50X2FuZF9lbmRpYW5uZXNzKS5cbiopXG5sZXQgdG9faW50NjRfcHJlc2VydmVfb3JkZXIgdCA9XG4gIGlmIGlzX25hbiB0XG4gIHRoZW4gTm9uZVxuICBlbHNlIGlmIHQgPSAwLlxuICB0aGVuICgqIGFsc28gaW5jbHVkZXMgLTAuICopXG4gICAgU29tZSAwTFxuICBlbHNlIGlmIHQgPiAwLlxuICB0aGVuIFNvbWUgKENhbWwuSW50NjQuYml0c19vZl9mbG9hdCB0KVxuICBlbHNlIFNvbWUgKENhbWwuSW50NjQubmVnIChDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgKC0udCkpKVxuOztcblxubGV0IHRvX2ludDY0X3ByZXNlcnZlX29yZGVyX2V4biB4ID0gT3B0aW9uLnZhbHVlX2V4biAodG9faW50NjRfcHJlc2VydmVfb3JkZXIgeClcblxubGV0IG9mX2ludDY0X3ByZXNlcnZlX29yZGVyIHggPVxuICBpZiBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIHggMExcbiAgdGhlbiBDYW1sLkludDY0LmZsb2F0X29mX2JpdHMgeFxuICBlbHNlIH4tLihDYW1sLkludDY0LmZsb2F0X29mX2JpdHMgKENhbWwuSW50NjQubmVnIHgpKVxuOztcblxubGV0IG9uZV91bHAgZGlyIHQgPVxuICBtYXRjaCB0b19pbnQ2NF9wcmVzZXJ2ZV9vcmRlciB0IHdpdGhcbiAgfCBOb25lIC0+IENhbWwubmFuXG4gIHwgU29tZSB4IC0+XG4gICAgb2ZfaW50NjRfcHJlc2VydmVfb3JkZXJcbiAgICAgIChDYW1sLkludDY0LmFkZFxuICAgICAgICAgeFxuICAgICAgICAgKG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgfCBgVXAgLT4gMUxcbiAgICAgICAgICB8IGBEb3duIC0+IC0xTCkpXG47O1xuXG4oKiBbdXBwZXJfYm91bmRfZm9yX2ludF0gYW5kIFtsb3dlcl9ib3VuZF9mb3JfaW50XSBhcmUgZm9yIGNhbGN1bGF0aW5nIHRoZSBtYXgvbWluIGZsb2F0XG4gICB0aGF0IGZpdHMgaW4gYSBnaXZlbi1zaXplIGludGVnZXIgd2hlbiByb3VuZGVkIHRvd2FyZHMgMCAodXNpbmcgW2ludF9vZl9mbG9hdF0pLlxuXG4gICBtYXhfaW50L21pbl9pbnQgZGVwZW5kIG9uIFtudW1fYml0c10sIGUuZy4gKy8tIDJeMzAsICsvLSAyXjYyIGlmIDMxLWJpdCwgNjMtYml0XG4gICAocmVzcGVjdGl2ZWx5KSB3aGlsZSBmbG9hdCBpcyBJRUVFIHN0YW5kYXJkIGZvciBkb3VibGUgKDUyIHNpZ25pZmljYW50IGJpdHMpLlxuXG4gICBJbiBhbGwgY2FzZXMsIHdlIHdhbnQgdG8gZ3VhcmFudGVlIHRoYXRcbiAgIFtsb3dlcl9ib3VuZF9mb3JfaW50IDw9IHggPD0gdXBwZXJfYm91bmRfZm9yX2ludF1cbiAgIGlmZiBbaW50X29mX2Zsb2F0IHhdIGZpdHMgaW4gYW4gaW50IHdpdGggW251bV9iaXRzXSBiaXRzLlxuXG4gICBbMiAqKiAobnVtX2JpdHMgLSAxKV0gaXMgdGhlIGZpcnN0IGZsb2F0IGdyZWF0ZXIgdGhhdCBtYXhfaW50LCB3ZSB1c2UgdGhlIHByZWNlZGluZ1xuICAgZmxvYXQgYXMgdXBwZXIgYm91bmQuXG5cbiAgIFstICgyICoqIChudW1fYml0cyAtIDEpKV0gaXMgZXF1YWwgdG8gbWluX2ludC5cbiAgIEZvciBsb3dlciBib3VuZCB3ZSBsb29rIGZvciB0aGUgc21hbGxlc3QgZmxvYXQgW2ZdIHNhdGlzZnlpbmcgW2YgPiBtaW5faW50IC0gMV0gc28gdGhhdFxuICAgW2ZdIHJvdW5kcyB0b3dhcmQgemVybyB0byBbbWluX2ludF1cblxuICAgU28gaW4gcGFydGljdWxhciB3ZSB3aWxsIGhhdmU6XG4gICBbbG93ZXJfYm91bmRfZm9yX2ludCB4IDw9IC0gKDIgKiogKDEteCkpXVxuICAgW3VwcGVyX2JvdW5kX2Zvcl9pbnQgeCAgPCAgICAyICoqICgxLXgpIF1cbiopXG5sZXQgdXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0cyA9XG4gIGxldCBleHAgPSBDYW1sLmZsb2F0X29mX2ludCAobnVtX2JpdHMgLSAxKSBpblxuICBvbmVfdWxwIGBEb3duICgyLiAqKiBleHApXG47O1xuXG5sZXQgaXNfeF9taW51c19vbmVfZXhhY3QgeCA9XG4gICgqIFt4ID0geCAtLiAxLl0gZG9lcyBub3Qgd29yayB3aXRoIHg4NyBmbG9hdGluZyBwb2ludCBhcml0aG1ldGljIGJhY2tlbmQgKHdoaWNoIGlzIHVzZWRcbiAgICAgb24gMzItYml0IG9jYW1sKSBiZWNhdXNlIG9mIDgwLWJpdCByZWdpc3RlciBwcmVjaXNpb24gb2YgaW50ZXJtZWRpYXRlIGNvbXB1dGF0aW9ucy5cblxuICAgICBBbiBhbHRlcm5hdGl2ZSB3YXkgb2YgY29tcHV0aW5nIHRoaXM6IFt4IC0uIG9uZV91bHAgYERvd24geCA8PSAxLl0gaXMgYWxzbyBwcm9uZSB0b1xuICAgICB0aGUgc2FtZSBwcmVjaXNpb24gaXNzdWVzOiB5b3UgbmVlZCB0byBtYWtlIHN1cmUgW3hdIGlzIDY0LWJpdC5cbiAgKilcbiAgbGV0IG9wZW4gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIG5vdCAoQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0IHggPSBDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgKHggLS4gMS4pKVxuOztcblxubGV0IGxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHMgPVxuICBsZXQgZXhwID0gQ2FtbC5mbG9hdF9vZl9pbnQgKG51bV9iaXRzIC0gMSkgaW5cbiAgbGV0IG1pbl9pbnRfYXNfZmxvYXQgPSB+LS4oMi4gKiogZXhwKSBpblxuICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gIGlmIG51bV9iaXRzIC0gMSA8IDUzICgqIDUzID0gI2JpdHMgaW4gdGhlIGZsb2F0J3MgbWFudGlzc2Egd2l0aCBzaWduIGluY2x1ZGVkICopXG4gIHRoZW4gKFxuICAgICgqIFRoZSBzbWFsbGVzdCBmbG9hdCB0aGF0IHJvdW5kcyB0b3dhcmRzIHplcm8gdG8gW21pbl9pbnRdIGlzXG4gICAgICAgW21pbl9pbnQgLSAxICsgZXBzaWxvbl0gKilcbiAgICBhc3NlcnQgKGlzX3hfbWludXNfb25lX2V4YWN0IG1pbl9pbnRfYXNfZmxvYXQpO1xuICAgIG9uZV91bHAgYFVwIChtaW5faW50X2FzX2Zsb2F0IC0uIDEuKSlcbiAgZWxzZSAoXG4gICAgKCogW21pbl9pbnRfYXNfZmxvYXRdIGlzIGFscmVhZHkgdGhlIHNtYWxsZXN0IGZsb2F0IFtmXSBzYXRpc2Z5aW5nIFtmID4gbWluX2ludCAtIDFdLiAqKVxuICAgIGFzc2VydCAobm90IChpc194X21pbnVzX29uZV9leGFjdCBtaW5faW50X2FzX2Zsb2F0KSk7XG4gICAgbWluX2ludF9hc19mbG9hdClcbjs7XG5cbigqIEZsb2F0IGNsYW1waW5nIGlzIHN0cnVjdHVyZWQgc2xpZ2h0bHkgZGlmZmVyZW50bHkgdGhhbiBjbGFtcGluZyBmb3Igb3RoZXIgdHlwZXMsIHNvXG4gICB0aGF0IHdlIGdldCB0aGUgYmVoYXZpb3Igb2YgW2NsYW1wX3VuY2hlY2tlZCBuYW4gfm1pbiB+bWF4ID0gbmFuXSAoZm9yIGFueSBbbWluXSBhbmRcbiAgIFttYXhdKSBmb3IgZnJlZS5cbiopXG5sZXQgY2xhbXBfdW5jaGVja2VkICh0IDogZmxvYXQpIH5taW4gfm1heCA9XG4gIGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiBtYXggPCB0IHRoZW4gbWF4IGVsc2UgdFxuOztcblxubGV0IGJveCA9XG4gICgqIFByZXZlbnQgcG90ZW50aWFsIGNvbnN0YW50IGZvbGRpbmcgb2YgWysuIDAuXSBpbiB0aGUgbmVhciBvY2FtbG9wdCBmdXR1cmUuICopXG4gIGxldCB4ID0gU3lzMC5vcGFxdWVfaWRlbnRpdHkgMC4gaW5cbiAgZnVuIGYgLT4gZiArLiB4XG47O1xuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcbm1vZHVsZSBBcnJheSA9IEFycmF5MFxubW9kdWxlIFN0cmluZyA9IFN0cmluZzBcbmluY2x1ZGUgQ2hhcjBcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gY2hhciBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlID0gKGNvbXBhcmVfY2hhciA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9jaGFyXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9jaGFyIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChjaGFyX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2NoYXIgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gY2hhcl9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCB0b19zdHJpbmcgdCA9IFN0cmluZy5tYWtlIDEgdFxuXG4gIGxldCBvZl9zdHJpbmcgcyA9XG4gICAgbWF0Y2ggU3RyaW5nLmxlbmd0aCBzIHdpdGhcbiAgICB8IDEgLT4gcy5bMF1cbiAgICB8IF8gLT4gZmFpbHdpdGhmIFwiQ2hhci5vZl9zdHJpbmc6ICVTXCIgcyAoKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgVFxuXG5pbmNsdWRlIElkZW50aWZpYWJsZS5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5DaGFyXCJcbiAgZW5kKVxuXG5sZXQgcHAgZm10IGMgPSBDYW1sLkZvcm1hdC5mcHJpbnRmIGZtdCBcIiVDXCIgY1xuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBDaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGFsbCA9IEFycmF5LmluaXQgMjU2IH5mOnVuc2FmZV9vZl9pbnQgfD4gQXJyYXkudG9fbGlzdFxuXG5sZXQgaXNfbG93ZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfdXBwZXJjYXNlID0gZnVuY3Rpb25cbiAgfCAnQScgLi4gJ1onIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfcHJpbnQgPSBmdW5jdGlvblxuICB8ICcgJyAuLiAnficgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc193aGl0ZXNwYWNlID0gZnVuY3Rpb25cbiAgfCAnXFx0JyB8ICdcXG4nIHwgJ1xcMDExJyAoKiB2ZXJ0aWNhbCB0YWIgKikgfCAnXFwwMTInICgqIGZvcm0gZmVlZCAqKSB8ICdcXHInIHwgJyAnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgaXNfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19hbHBoYSA9IGZ1bmN0aW9uXG4gIHwgJ2EnIC4uICd6JyB8ICdBJyAuLiAnWicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbigqIFdyaXRpbmcgdGhlc2Ugb3V0LCBpbnN0ZWFkIG9mIGNhbGxpbmcgW2lzX2FscGhhXSBhbmQgW2lzX2RpZ2l0XSwgcmVkdWNlc1xuICAgcnVudGltZSBieSBhcHByb3guIDMwJSAqKVxubGV0IGlzX2FscGhhbnVtID0gZnVuY3Rpb25cbiAgfCAnYScgLi4gJ3onIHwgJ0EnIC4uICdaJyB8ICcwJyAuLiAnOScgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBnZXRfZGlnaXRfdW5zYWZlIHQgPSB0b19pbnQgdCAtIHRvX2ludCAnMCdcblxubGV0IGdldF9kaWdpdF9leG4gdCA9XG4gIGlmIGlzX2RpZ2l0IHRcbiAgdGhlbiBnZXRfZGlnaXRfdW5zYWZlIHRcbiAgZWxzZSBmYWlsd2l0aGYgXCJDaGFyLmdldF9kaWdpdF9leG4gJUM6IG5vdCBhIGRpZ2l0XCIgdCAoKVxuOztcblxubGV0IGdldF9kaWdpdCB0ID0gaWYgaXNfZGlnaXQgdCB0aGVuIFNvbWUgKGdldF9kaWdpdF91bnNhZmUgdCkgZWxzZSBOb25lXG5cbmxldCBpc19oZXhfZGlnaXQgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnYScgLi4gJ2YnIHwgJ0EnIC4uICdGJyAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuOztcblxubGV0IGlzX2hleF9kaWdpdF9sb3dlciA9IGZ1bmN0aW9uXG4gIHwgJzAnIC4uICc5JyB8ICdhJyAuLiAnZicgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBpc19oZXhfZGlnaXRfdXBwZXIgPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgfCAnQScgLi4gJ0YnIC0+IHRydWVcbiAgfCBfIC0+IGZhbHNlXG47O1xuXG5sZXQgZ2V0X2hleF9kaWdpdF9leG4gPSBmdW5jdGlvblxuICB8ICcwJyAuLiAnOScgYXMgdCAtPiB0b19pbnQgdCAtIHRvX2ludCAnMCdcbiAgfCAnYScgLi4gJ2YnIGFzIHQgLT4gdG9faW50IHQgLSB0b19pbnQgJ2EnICsgMTBcbiAgfCAnQScgLi4gJ0YnIGFzIHQgLT4gdG9faW50IHQgLSB0b19pbnQgJ0EnICsgMTBcbiAgfCB0IC0+XG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJDaGFyLmdldF9oZXhfZGlnaXRfZXhuOiBub3QgYSBoZXhhZGVjaW1hbCBkaWdpdFwiXG4gICAgICAgICBbIFwiY2hhclwiLCBzZXhwX29mX3QgdCBdKVxuOztcblxubGV0IGdldF9oZXhfZGlnaXQgdCA9IGlmIGlzX2hleF9kaWdpdCB0IHRoZW4gU29tZSAoZ2V0X2hleF9kaWdpdF9leG4gdCkgZWxzZSBOb25lXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGxldCAoID49ICkgPSAoID49IClcbiAgbGV0ICggPD0gKSA9ICggPD0gKVxuICBsZXQgKCA9ICkgPSAoID0gKVxuICBsZXQgKCA+ICkgPSAoID4gKVxuICBsZXQgKCA8ICkgPSAoIDwgKVxuICBsZXQgKCA8PiApID0gKCA8PiApXG5lbmRcblxubW9kdWxlIENhc2VsZXNzID0gc3RydWN0XG4gIG1vZHVsZSBUID0gc3RydWN0XG4gICAgdHlwZSB0ID0gY2hhciBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgbGV0IHRfb2Zfc2V4cCA9IChjaGFyX29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfY2hhciA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IGNoYXJfc2V4cF9ncmFtbWFyXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGNvbXBhcmUgYzEgYzIgPSBjb21wYXJlIChsb3dlcmNhc2UgYzEpIChsb3dlcmNhc2UgYzIpXG4gICAgbGV0IGhhc2hfZm9sZF90IHN0YXRlIHQgPSBoYXNoX2ZvbGRfY2hhciBzdGF0ZSAobG93ZXJjYXNlIHQpXG4gICAgbGV0IGhhc2ggdCA9IEhhc2gucnVuIGhhc2hfZm9sZF90IHRcbiAgZW5kXG5cbiAgaW5jbHVkZSBUXG4gIGluY2x1ZGUgQ29tcGFyYWJsZS5NYWtlIChUKVxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBDaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwibW9kdWxlIExpc3QgPSBMaXN0XG5cbm1vZHVsZSBFbnVtZXJhYmxlID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIFMgPSBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBhbGwgOiB0IGxpc3RcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzEgPSBzaWdcbiAgICB0eXBlICdhIHRcblxuICAgIHZhbCBhbGwgOiAnYSBsaXN0IC0+ICdhIHQgbGlzdFxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBTMiA9IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdFxuXG4gICAgdmFsIGFsbCA6ICdhIGxpc3QgLT4gJ2IgbGlzdCAtPiAoJ2EsICdiKSB0IGxpc3RcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgUzMgPSBzaWdcbiAgICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgICB2YWwgYWxsIDogJ2EgbGlzdCAtPiAnYiBsaXN0IC0+ICdjIGxpc3QgLT4gKCdhLCAnYiwgJ2MpIHQgbGlzdFxuICBlbmRcbmVuZFxuIiwib3BlbiEgSW1wb3J0MC5JbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5tb2R1bGUgQnl0ZXMgPSBCeXRlczBcbm1vZHVsZSBTdHJpbmcgPSBTdHJpbmcwXG5cbigqIENvbnN0cnVjdCBhIGJ5dGUgc3RyaW5nIG9mIGxlbmd0aCAyNTYsIG1hcHBpbmcgZXZlcnkgaW5wdXQgY2hhcmFjdGVyIGNvZGUgdG9cbiAgIGl0cyBjb3JyZXNwb25kaW5nIG91dHB1dCBjaGFyYWN0ZXIuXG5cbiAgIEJlbmNobWFya3MgaW5kaWNhdGUgdGhhdCB0aGlzIGlzIGZhc3RlciB0aGFuIHRoZSBsYW1iZGEgKGluY2x1ZGluZyBjb3N0IG9mXG4gICB0aGlzIGZ1bmN0aW9uKSwgZXZlbiBpZiB0YXJnZXQvcmVwbGFjZW1lbnQgYXJlIGp1c3QgMiBjaGFyYWN0ZXJzIGVhY2guXG5cbiAgIFJldHVybiBOb25lIGlmIHRoZSB0cmFuc2xhdGlvbiBtYXAgaXMgZXF1aXZhbGVudCB0byBqdXN0IHRoZSBpZGVudGl0eS4gKilcbmxldCB0cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50ID1cbiAgbGV0IHRyX21hcCA9IEJ5dGVzLmNyZWF0ZSAyNTYgaW5cbiAgZm9yIGkgPSAwIHRvIDI1NSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdHJfbWFwIGkgKENoYXIub2ZfaW50X2V4biBpKVxuICBkb25lO1xuICBmb3IgaSA9IDAgdG8gbWluIChTdHJpbmcubGVuZ3RoIHRhcmdldCkgKFN0cmluZy5sZW5ndGggcmVwbGFjZW1lbnQpIC0gMSBkb1xuICAgIGxldCBpbmRleCA9IENoYXIudG9faW50IChTdHJpbmcudW5zYWZlX2dldCB0YXJnZXQgaSkgaW5cbiAgICBCeXRlcy51bnNhZmVfc2V0IHRyX21hcCBpbmRleCAoU3RyaW5nLnVuc2FmZV9nZXQgcmVwbGFjZW1lbnQgaSlcbiAgZG9uZTtcbiAgbGV0IGxhc3RfcmVwbGFjZW1lbnQgPSBTdHJpbmcudW5zYWZlX2dldCByZXBsYWNlbWVudCAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCAtIDEpIGluXG4gIGZvclxuICAgIGkgPSBtaW4gKFN0cmluZy5sZW5ndGggdGFyZ2V0KSAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCkgdG8gU3RyaW5nLmxlbmd0aCB0YXJnZXQgLSAxXG4gIGRvXG4gICAgbGV0IGluZGV4ID0gQ2hhci50b19pbnQgKFN0cmluZy51bnNhZmVfZ2V0IHRhcmdldCBpKSBpblxuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdHJfbWFwIGluZGV4IGxhc3RfcmVwbGFjZW1lbnRcbiAgZG9uZTtcbiAgbGV0IHJlYyBoYXZlX2FueV9kaWZmZXJlbnQgdHJfbWFwIGkgPVxuICAgIGlmIGkgPSAyNTZcbiAgICB0aGVuIGZhbHNlXG4gICAgZWxzZSBpZiBDaGFyLiggPD4gKSAoQnl0ZXMwLnVuc2FmZV9nZXQgdHJfbWFwIGkpIChDaGFyLm9mX2ludF9leG4gaSlcbiAgICB0aGVuIHRydWVcbiAgICBlbHNlIGhhdmVfYW55X2RpZmZlcmVudCB0cl9tYXAgKGkgKyAxKVxuICBpblxuICAoKiBxdWljayBjaGVjayBvbiB0aGUgZmlyc3QgdGFyZ2V0IGNoYXJhY3RlciB3aGljaCB3aWxsIDk5JSBiZSB0cnVlICopXG4gIGxldCBmaXJzdF90YXJnZXQgPSB0YXJnZXQuWzBdIGluXG4gIGlmIENoYXIuKCA8PiApIChCeXRlczAudW5zYWZlX2dldCB0cl9tYXAgKENoYXIudG9faW50IGZpcnN0X3RhcmdldCkpIGZpcnN0X3RhcmdldFxuICB8fCBoYXZlX2FueV9kaWZmZXJlbnQgdHJfbWFwIDBcbiAgdGhlbiBTb21lIChCeXRlczAudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0cl9tYXApXG4gIGVsc2UgTm9uZVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHQgPSAnYVxuXG5sZXQgc3RhZ2UgPSBGbi5pZFxubGV0IHVuc3RhZ2UgPSBGbi5pZFxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcbmluY2x1ZGUgU3RyaW5nMFxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG4oKiBUaGlzIGFsaWFzIGlzIG5lY2Vzc2FyeSBkZXNwaXRlIFtTdHJpbmcwXSBkZWZpbmluZyBbQnl0ZXMgPSBCeXRlczBdLCBpbiBvcmRlciB0b1xuICAgY29udmluY2Ugb2NhbWxkZXAgdGhhdCB0aGlzIGZpbGUgZG9lc24ndCBkZXBlbmQgb24gYnl0ZXMubWwuICopXG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcbmxldCBzdGFnZSA9IFN0YWdlZC5zdGFnZVxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBzdHJpbmcgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX3N0cmluZ1xuXG4gIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IGhhc2hfc3RyaW5nIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChzdHJpbmdfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2Zfc3RyaW5nIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAodF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IHN0cmluZ19zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cbiAgbGV0IGNvbXBhcmUgPSBjb21wYXJlXG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcblxudHlwZSBlbHQgPSBjaGFyXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5cbigqIFRoaXMgaXMgY29waWVkL2FkYXB0ZWQgZnJvbSAnYmxpdC5tbCcuXG4gICBbc3ViXSwgW3N1Ym9dIGNvdWxkIGJlIGltcGxlbWVudGVkIHVzaW5nIFtCbGl0Lk1ha2UoQnl0ZXMpXSBwbHVzIHVuc2FmZSBjYXN0cyB0by9mcm9tXG4gICBzdHJpbmcgYnV0IHdlcmUgaW5saW5lZCBoZXJlIHRvIGF2b2lkIHVzaW5nIFtCeXRlcy51bnNhZmVfb2Zfc3RyaW5nXSBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuKilcbmxldCBzdWIgc3JjIH5wb3MgfmxlbiA9XG4gIGlmIHBvcyA9IDAgJiYgbGVuID0gU3RyaW5nLmxlbmd0aCBzcmNcbiAgdGhlbiBzcmNcbiAgZWxzZSAoXG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5jaGVja19wb3NfbGVuX2V4biB+cG9zIH5sZW4gfnRvdGFsX2xlbmd0aDoobGVuZ3RoIHNyYyk7XG4gICAgaWYgbGVuID0gMFxuICAgIHRoZW4gXCJcIlxuICAgIGVsc2UgKFxuICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSBsZW4gaW5cbiAgICAgIEJ5dGVzLnVuc2FmZV9ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOnBvcyB+ZHN0IH5kc3RfcG9zOjAgfmxlbjtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6ZHN0KSlcbjs7XG5cbmxldCBzdWJvID8ocG9zID0gMCkgP2xlbiBzcmMgPVxuICBzdWJcbiAgICBzcmNcbiAgICB+cG9zXG4gICAgfmxlbjpcbiAgICAgIChtYXRjaCBsZW4gd2l0aFxuICAgICAgIHwgU29tZSBpIC0+IGlcbiAgICAgICB8IE5vbmUgLT4gbGVuZ3RoIHNyYyAtIHBvcylcbjs7XG5cbmxldCByZWMgY29udGFpbnNfdW5zYWZlIHQgfnBvcyB+ZW5kXyBjaGFyID1cbiAgcG9zIDwgZW5kX1xuICAmJiAoQ2hhci5lcXVhbCAodW5zYWZlX2dldCB0IHBvcykgY2hhciB8fCBjb250YWluc191bnNhZmUgdCB+cG9zOihwb3MgKyAxKSB+ZW5kXyBjaGFyKVxuOztcblxubGV0IGNvbnRhaW5zID8ocG9zID0gMCkgP2xlbiB0IGNoYXIgPVxuICBsZXQgdG90YWxfbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCB0IGluXG4gIGxldCBsZW4gPSBPcHRpb24udmFsdWUgbGVuIH5kZWZhdWx0Oih0b3RhbF9sZW5ndGggLSBwb3MpIGluXG4gIE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb24uY2hlY2tfcG9zX2xlbl9leG4gfnBvcyB+bGVuIH50b3RhbF9sZW5ndGg7XG4gIGNvbnRhaW5zX3Vuc2FmZSB0IH5wb3MgfmVuZF86KHBvcyArIGxlbikgY2hhclxuOztcblxubGV0IGlzX2VtcHR5IHQgPSBsZW5ndGggdCA9IDBcblxubGV0IHJlYyBpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCBzdHJpbmcgfnBvcyB+bGVuIH5ub3RfZm91bmQgY2hhciA9XG4gIGlmIHBvcyA+PSBsZW5cbiAgdGhlbiByYWlzZSBub3RfZm91bmRcbiAgZWxzZSBpZiBDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHN0cmluZyBwb3MpIGNoYXJcbiAgdGhlbiBwb3NcbiAgZWxzZSBpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCBzdHJpbmcgfnBvczoocG9zICsgMSkgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbjs7XG5cbmxldCBpbmRleF9leG5faW50ZXJuYWwgdCB+bm90X2ZvdW5kIGNoYXIgPVxuICBpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCB0IH5wb3M6MCB+bGVuOihsZW5ndGggdCkgfm5vdF9mb3VuZCBjaGFyXG47O1xuXG5sZXQgaW5kZXhfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLmluZGV4X2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCBpbmRleF9leG4gdCBjaGFyID0gaW5kZXhfZXhuX2ludGVybmFsIHQgfm5vdF9mb3VuZCBjaGFyIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgaW5kZXhfZXhuXG47O1xuXG5sZXQgaW5kZXhfZnJvbV9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcuaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgaW5kZXhfZnJvbV9leG4gdCBwb3MgY2hhciA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgaWYgcG9zIDwgMCB8fCBwb3MgPiBsZW5cbiAgICB0aGVuIGludmFsaWRfYXJnIFwiU3RyaW5nLmluZGV4X2Zyb21fZXhuXCJcbiAgICBlbHNlIGluZGV4X2Zyb21fZXhuX2ludGVybmFsIHQgfnBvcyB+bGVuIH5ub3RfZm91bmQgY2hhclxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGluZGV4X2Zyb21fZXhuXG47O1xuXG5sZXQgcmVjIHJpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCBzdHJpbmcgfnBvcyB+bGVuIH5ub3RfZm91bmQgY2hhciA9XG4gIGlmIHBvcyA8IDBcbiAgdGhlbiByYWlzZSBub3RfZm91bmRcbiAgZWxzZSBpZiBDaGFyLmVxdWFsICh1bnNhZmVfZ2V0IHN0cmluZyBwb3MpIGNoYXJcbiAgdGhlbiBwb3NcbiAgZWxzZSByaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgc3RyaW5nIH5wb3M6KHBvcyAtIDEpIH5sZW4gfm5vdF9mb3VuZCBjaGFyXG47O1xuXG5sZXQgcmluZGV4X2V4bl9pbnRlcm5hbCB0IH5ub3RfZm91bmQgY2hhciA9XG4gIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICByaW5kZXhfZnJvbV9leG5faW50ZXJuYWwgdCB+cG9zOihsZW4gLSAxKSB+bGVuIH5ub3RfZm91bmQgY2hhclxuOztcblxubGV0IHJpbmRleF9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcucmluZGV4X2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCByaW5kZXhfZXhuIHQgY2hhciA9IHJpbmRleF9leG5faW50ZXJuYWwgdCB+bm90X2ZvdW5kIGNoYXIgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICByaW5kZXhfZXhuXG47O1xuXG5sZXQgcmluZGV4X2Zyb21fZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLnJpbmRleF9mcm9tX2V4bjogbm90IGZvdW5kXCIpIGluXG4gIGxldCByaW5kZXhfZnJvbV9leG4gdCBwb3MgY2hhciA9XG4gICAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gICAgaWYgcG9zIDwgLTEgfHwgcG9zID49IGxlblxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJTdHJpbmcucmluZGV4X2Zyb21fZXhuXCJcbiAgICBlbHNlIHJpbmRleF9mcm9tX2V4bl9pbnRlcm5hbCB0IH5wb3MgfmxlbiB+bm90X2ZvdW5kIGNoYXJcbiAgaW5cbiAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICByaW5kZXhfZnJvbV9leG5cbjs7XG5cbmxldCBpbmRleCB0IGNoYXIgPVxuICB0cnkgU29tZSAoaW5kZXhfZXhuIHQgY2hhcikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcmluZGV4IHQgY2hhciA9XG4gIHRyeSBTb21lIChyaW5kZXhfZXhuIHQgY2hhcikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgaW5kZXhfZnJvbSB0IHBvcyBjaGFyID1cbiAgdHJ5IFNvbWUgKGluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIpIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubGV0IHJpbmRleF9mcm9tIHQgcG9zIGNoYXIgPVxuICB0cnkgU29tZSAocmluZGV4X2Zyb21fZXhuIHQgcG9zIGNoYXIpIHdpdGhcbiAgfCBOb3RfZm91bmRfcyBfIHwgQ2FtbC5Ob3RfZm91bmQgLT4gTm9uZVxuOztcblxubW9kdWxlIFNlYXJjaF9wYXR0ZXJuMCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgcGF0dGVybiA6IHN0cmluZ1xuICAgIDsgY2FzZV9zZW5zaXRpdmUgOiBib29sXG4gICAgOyBrbXBfYXJyYXkgOiBpbnQgYXJyYXlcbiAgICB9XG5cbiAgbGV0IHNleHBfb2ZfdCB7IHBhdHRlcm47IGNhc2Vfc2Vuc2l0aXZlOyBrbXBfYXJyYXkgPSBfIH0gOiBTZXhwLnQgPVxuICAgIExpc3RcbiAgICAgIFsgTGlzdCBbIEF0b20gXCJwYXR0ZXJuXCI7IHNleHBfb2Zfc3RyaW5nIHBhdHRlcm4gXVxuICAgICAgOyBMaXN0IFsgQXRvbSBcImNhc2Vfc2Vuc2l0aXZlXCI7IHNleHBfb2ZfYm9vbCBjYXNlX3NlbnNpdGl2ZSBdXG4gICAgICBdXG4gIDs7XG5cbiAgbGV0IHBhdHRlcm4gdCA9IHQucGF0dGVyblxuICBsZXQgY2FzZV9zZW5zaXRpdmUgdCA9IHQuY2FzZV9zZW5zaXRpdmVcblxuICAoKiBGaW5kIG1heCBudW1iZXIgb2YgbWF0Y2hlZCBjaGFyYWN0ZXJzIGF0IFtuZXh0X3RleHRfY2hhcl0sIGdpdmVuIHRoZSBjdXJyZW50XG4gICAgIFttYXRjaGVkX2NoYXJzXS4gVHJ5IHRvIGV4dGVuZCB0aGUgY3VycmVudCBtYXRjaCwgaWYgY2hhcnMgZG9uJ3QgbWF0Y2gsIHRyeSB0byBtYXRjaFxuICAgICBmZXdlciBjaGFycy4gSWYgY2hhcnMgbWF0Y2ggdGhlbiBleHRlbmQgdGhlIG1hdGNoLiAqKVxuICBsZXQga21wX2ludGVybmFsX2xvb3Agfm1hdGNoZWRfY2hhcnMgfm5leHRfdGV4dF9jaGFyIH5wYXR0ZXJuIH5rbXBfYXJyYXkgfmNoYXJfZXF1YWwgPVxuICAgIGxldCBtYXRjaGVkX2NoYXJzID0gcmVmIG1hdGNoZWRfY2hhcnMgaW5cbiAgICB3aGlsZVxuICAgICAgIW1hdGNoZWRfY2hhcnMgPiAwXG4gICAgICAmJiBub3QgKGNoYXJfZXF1YWwgbmV4dF90ZXh0X2NoYXIgKHVuc2FmZV9nZXQgcGF0dGVybiAhbWF0Y2hlZF9jaGFycykpXG4gICAgZG9cbiAgICAgIG1hdGNoZWRfY2hhcnMgOj0gQXJyYXkudW5zYWZlX2dldCBrbXBfYXJyYXkgKCFtYXRjaGVkX2NoYXJzIC0gMSlcbiAgICBkb25lO1xuICAgIGlmIGNoYXJfZXF1YWwgbmV4dF90ZXh0X2NoYXIgKHVuc2FmZV9nZXQgcGF0dGVybiAhbWF0Y2hlZF9jaGFycylcbiAgICB0aGVuIG1hdGNoZWRfY2hhcnMgOj0gIW1hdGNoZWRfY2hhcnMgKyAxO1xuICAgICFtYXRjaGVkX2NoYXJzXG4gIDs7XG5cbiAgbGV0IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSA9XG4gICAgbWF0Y2ggY2FzZV9zZW5zaXRpdmUgd2l0aFxuICAgIHwgdHJ1ZSAtPiBDaGFyLmVxdWFsXG4gICAgfCBmYWxzZSAtPiBDaGFyLkNhc2VsZXNzLmVxdWFsXG4gIDs7XG5cbiAgKCogQ2xhc3NpYyBLTVAgcHJlLXByb2Nlc3Npbmcgb2YgdGhlIHBhdHRlcm46IGJ1aWxkIHRoZSBpbnQgYXJyYXksIHdoaWNoLCBmb3IgZWFjaCBpLFxuICAgICBjb250YWlucyB0aGUgbGVuZ3RoIG9mIHRoZSBsb25nZXN0IG5vbi10cml2aWFsIHByZWZpeCBvZiBzIHdoaWNoIGlzIGVxdWFsIHRvIGEgc3VmZml4XG4gICAgIGVuZGluZyBhdCBzLltpXSAqKVxuICBsZXQgY3JlYXRlIHBhdHRlcm4gfmNhc2Vfc2Vuc2l0aXZlID1cbiAgICBsZXQgbiA9IGxlbmd0aCBwYXR0ZXJuIGluXG4gICAgbGV0IGttcF9hcnJheSA9IEFycmF5LmNyZWF0ZSB+bGVuOm4gKC0xKSBpblxuICAgIGlmIG4gPiAwXG4gICAgdGhlbiAoXG4gICAgICBsZXQgY2hhcl9lcXVhbCA9IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgQXJyYXkudW5zYWZlX3NldCBrbXBfYXJyYXkgMCAwO1xuICAgICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgMCBpblxuICAgICAgZm9yIGkgPSAxIHRvIG4gLSAxIGRvXG4gICAgICAgIG1hdGNoZWRfY2hhcnNcbiAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICB+bWF0Y2hlZF9jaGFyczohbWF0Y2hlZF9jaGFyc1xuICAgICAgICAgICAgIH5uZXh0X3RleHRfY2hhcjoodW5zYWZlX2dldCBwYXR0ZXJuIGkpXG4gICAgICAgICAgICAgfnBhdHRlcm5cbiAgICAgICAgICAgICB+a21wX2FycmF5XG4gICAgICAgICAgICAgfmNoYXJfZXF1YWw7XG4gICAgICAgIEFycmF5LnVuc2FmZV9zZXQga21wX2FycmF5IGkgIW1hdGNoZWRfY2hhcnNcbiAgICAgIGRvbmUpO1xuICAgIHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSB9XG4gIDs7XG5cbiAgKCogQ2xhc3NpYyBLTVA6IHVzZSB0aGUgcHJlLXByb2Nlc3NlZCBwYXR0ZXJuIHRvIG9wdGltaXplIGxvb2stYmVoaW5kcyBvbiBub24tbWF0Y2hlcy5cbiAgICAgV2UgcmV0dXJuIGludCB0byBhdm9pZCBhbGxvY2F0aW9uIGluIFtpbmRleF9leG5dLiAtMSBtZWFucyBubyBtYXRjaC4gKilcbiAgbGV0IGluZGV4X2ludGVybmFsID8ocG9zID0gMCkgeyBwYXR0ZXJuOyBjYXNlX3NlbnNpdGl2ZTsga21wX2FycmF5IH0gfmluXzp0ZXh0ID1cbiAgICBpZiBwb3MgPCAwIHx8IHBvcyA+IGxlbmd0aCB0ZXh0IC0gbGVuZ3RoIHBhdHRlcm5cbiAgICB0aGVuIC0xXG4gICAgZWxzZSAoXG4gICAgICBsZXQgY2hhcl9lcXVhbCA9IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgbGV0IGogPSByZWYgcG9zIGluXG4gICAgICBsZXQgbWF0Y2hlZF9jaGFycyA9IHJlZiAwIGluXG4gICAgICBsZXQgayA9IGxlbmd0aCBwYXR0ZXJuIGluXG4gICAgICBsZXQgbiA9IGxlbmd0aCB0ZXh0IGluXG4gICAgICB3aGlsZSAhaiA8IG4gJiYgIW1hdGNoZWRfY2hhcnMgPCBrIGRvXG4gICAgICAgIGxldCBuZXh0X3RleHRfY2hhciA9IHVuc2FmZV9nZXQgdGV4dCAhaiBpblxuICAgICAgICBtYXRjaGVkX2NoYXJzXG4gICAgICAgIDo9IGttcF9pbnRlcm5hbF9sb29wXG4gICAgICAgICAgICAgfm1hdGNoZWRfY2hhcnM6IW1hdGNoZWRfY2hhcnNcbiAgICAgICAgICAgICB+bmV4dF90ZXh0X2NoYXJcbiAgICAgICAgICAgICB+cGF0dGVyblxuICAgICAgICAgICAgIH5rbXBfYXJyYXlcbiAgICAgICAgICAgICB+Y2hhcl9lcXVhbDtcbiAgICAgICAgaiA6PSAhaiArIDFcbiAgICAgIGRvbmU7XG4gICAgICBpZiAhbWF0Y2hlZF9jaGFycyA9IGsgdGhlbiAhaiAtIGsgZWxzZSAtMSlcbiAgOztcblxuICBsZXQgbWF0Y2hlcyB0IHN0ciA9IGluZGV4X2ludGVybmFsIHQgfmluXzpzdHIgPj0gMFxuXG4gIGxldCBpbmRleCA/cG9zIHQgfmluXyA9XG4gICAgbGV0IHAgPSBpbmRleF9pbnRlcm5hbCA/cG9zIHQgfmluXyBpblxuICAgIGlmIHAgPCAwIHRoZW4gTm9uZSBlbHNlIFNvbWUgcFxuICA7O1xuXG4gIGxldCBpbmRleF9leG4gP3BvcyB0IH5pbl8gPVxuICAgIGxldCBwID0gaW5kZXhfaW50ZXJuYWwgP3BvcyB0IH5pbl8gaW5cbiAgICBpZiBwID49IDBcbiAgICB0aGVuIHBcbiAgICBlbHNlXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJTdWJzdHJpbmcgbm90IGZvdW5kXCIgWyBcInN1YnN0cmluZ1wiLCBzZXhwX29mX3N0cmluZyB0LnBhdHRlcm4gXSlcbiAgOztcblxuICBsZXQgaW5kZXhfYWxsIHsgcGF0dGVybjsgY2FzZV9zZW5zaXRpdmU7IGttcF9hcnJheSB9IH5tYXlfb3ZlcmxhcCB+aW5fOnRleHQgPVxuICAgIGlmIGxlbmd0aCBwYXR0ZXJuID0gMFxuICAgIHRoZW4gTGlzdC5pbml0ICgxICsgbGVuZ3RoIHRleHQpIH5mOkZuLmlkXG4gICAgZWxzZSAoXG4gICAgICBsZXQgY2hhcl9lcXVhbCA9IGdldF9jaGFyX2VxdWFsIH5jYXNlX3NlbnNpdGl2ZSBpblxuICAgICAgbGV0IG1hdGNoZWRfY2hhcnMgPSByZWYgMCBpblxuICAgICAgbGV0IGsgPSBsZW5ndGggcGF0dGVybiBpblxuICAgICAgbGV0IG4gPSBsZW5ndGggdGV4dCBpblxuICAgICAgbGV0IGZvdW5kID0gcmVmIFtdIGluXG4gICAgICBmb3IgaiA9IDAgdG8gbiBkb1xuICAgICAgICBpZiAhbWF0Y2hlZF9jaGFycyA9IGtcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgZm91bmQgOj0gKGogLSBrKSA6OiAhZm91bmQ7XG4gICAgICAgICAgKCogd2UganVzdCBmb3VuZCBhIG1hdGNoIGluIHRoZSBwcmV2aW91cyBpdGVyYXRpb24gKilcbiAgICAgICAgICBtYXRjaCBtYXlfb3ZlcmxhcCB3aXRoXG4gICAgICAgICAgfCB0cnVlIC0+IG1hdGNoZWRfY2hhcnMgOj0gQXJyYXkudW5zYWZlX2dldCBrbXBfYXJyYXkgKGsgLSAxKVxuICAgICAgICAgIHwgZmFsc2UgLT4gbWF0Y2hlZF9jaGFycyA6PSAwKTtcbiAgICAgICAgaWYgaiA8IG5cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IG5leHRfdGV4dF9jaGFyID0gdW5zYWZlX2dldCB0ZXh0IGogaW5cbiAgICAgICAgICBtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgOj0ga21wX2ludGVybmFsX2xvb3BcbiAgICAgICAgICAgICAgIH5tYXRjaGVkX2NoYXJzOiFtYXRjaGVkX2NoYXJzXG4gICAgICAgICAgICAgICB+bmV4dF90ZXh0X2NoYXJcbiAgICAgICAgICAgICAgIH5wYXR0ZXJuXG4gICAgICAgICAgICAgICB+a21wX2FycmF5XG4gICAgICAgICAgICAgICB+Y2hhcl9lcXVhbClcbiAgICAgIGRvbmU7XG4gICAgICBMaXN0LnJldiAhZm91bmQpXG4gIDs7XG5cbiAgbGV0IHJlcGxhY2VfZmlyc3QgP3BvcyB0IH5pbl86cyB+d2l0aF8gPVxuICAgIG1hdGNoIGluZGV4ID9wb3MgdCB+aW5fOnMgd2l0aFxuICAgIHwgTm9uZSAtPiBzXG4gICAgfCBTb21lIGkgLT5cbiAgICAgIGxldCBsZW5fcyA9IGxlbmd0aCBzIGluXG4gICAgICBsZXQgbGVuX3QgPSBsZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgICBsZXQgbGVuX3dpdGggPSBsZW5ndGggd2l0aF8gaW5cbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbl9zICsgbGVuX3dpdGggLSBsZW5fdCkgaW5cbiAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6cyB+c3JjX3BvczowIH5kc3QgfmRzdF9wb3M6MCB+bGVuOmk7XG4gICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOndpdGhfIH5zcmNfcG9zOjAgfmRzdCB+ZHN0X3BvczppIH5sZW46bGVuX3dpdGg7XG4gICAgICBCeXRlcy5ibGl0X3N0cmluZ1xuICAgICAgICB+c3JjOnNcbiAgICAgICAgfnNyY19wb3M6KGkgKyBsZW5fdClcbiAgICAgICAgfmRzdFxuICAgICAgICB+ZHN0X3BvczooaSArIGxlbl93aXRoKVxuICAgICAgICB+bGVuOihsZW5fcyAtIGkgLSBsZW5fdCk7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdFxuICA7O1xuXG5cbiAgbGV0IHJlcGxhY2VfYWxsIHQgfmluXzpzIH53aXRoXyA9XG4gICAgbGV0IG1hdGNoZXMgPSBpbmRleF9hbGwgdCB+bWF5X292ZXJsYXA6ZmFsc2UgfmluXzpzIGluXG4gICAgbWF0Y2ggbWF0Y2hlcyB3aXRoXG4gICAgfCBbXSAtPiBzXG4gICAgfCBfIDo6IF8gLT5cbiAgICAgIGxldCBsZW5fcyA9IGxlbmd0aCBzIGluXG4gICAgICBsZXQgbGVuX3QgPSBsZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgICBsZXQgbGVuX3dpdGggPSBsZW5ndGggd2l0aF8gaW5cbiAgICAgIGxldCBudW1fbWF0Y2hlcyA9IExpc3QubGVuZ3RoIG1hdGNoZXMgaW5cbiAgICAgIGxldCBkc3QgPSBCeXRlcy5jcmVhdGUgKGxlbl9zICsgKChsZW5fd2l0aCAtIGxlbl90KSAqIG51bV9tYXRjaGVzKSkgaW5cbiAgICAgIGxldCBuZXh0X2RzdF9wb3MgPSByZWYgMCBpblxuICAgICAgbGV0IG5leHRfc3JjX3BvcyA9IHJlZiAwIGluXG4gICAgICBMaXN0Lml0ZXIgbWF0Y2hlcyB+ZjooZnVuIGkgLT5cbiAgICAgICAgbGV0IGxlbiA9IGkgLSAhbmV4dF9zcmNfcG9zIGluXG4gICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmM6cyB+c3JjX3BvczohbmV4dF9zcmNfcG9zIH5kc3QgfmRzdF9wb3M6IW5leHRfZHN0X3BvcyB+bGVuO1xuICAgICAgICBCeXRlcy5ibGl0X3N0cmluZ1xuICAgICAgICAgIH5zcmM6d2l0aF9cbiAgICAgICAgICB+c3JjX3BvczowXG4gICAgICAgICAgfmRzdFxuICAgICAgICAgIH5kc3RfcG9zOighbmV4dF9kc3RfcG9zICsgbGVuKVxuICAgICAgICAgIH5sZW46bGVuX3dpdGg7XG4gICAgICAgIG5leHRfZHN0X3BvcyA6PSAhbmV4dF9kc3RfcG9zICsgbGVuICsgbGVuX3dpdGg7XG4gICAgICAgIG5leHRfc3JjX3BvcyA6PSAhbmV4dF9zcmNfcG9zICsgbGVuICsgbGVuX3QpO1xuICAgICAgQnl0ZXMuYmxpdF9zdHJpbmdcbiAgICAgICAgfnNyYzpzXG4gICAgICAgIH5zcmNfcG9zOiFuZXh0X3NyY19wb3NcbiAgICAgICAgfmRzdFxuICAgICAgICB+ZHN0X3BvczohbmV4dF9kc3RfcG9zXG4gICAgICAgIH5sZW46KGxlbl9zIC0gIW5leHRfc3JjX3Bvcyk7XG4gICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdFxuICA7O1xuXG4gIGxldCBzcGxpdF9vbiB0IHMgPVxuICAgIGxldCBwYXR0ZXJuX2xlbiA9IFN0cmluZy5sZW5ndGggdC5wYXR0ZXJuIGluXG4gICAgbGV0IG1hdGNoZXMgPSBpbmRleF9hbGwgdCB+bWF5X292ZXJsYXA6ZmFsc2UgfmluXzpzIGluXG4gICAgTGlzdC5tYXAyX2V4blxuICAgICAgKC1wYXR0ZXJuX2xlbiA6OiBtYXRjaGVzKVxuICAgICAgKG1hdGNoZXMgQCBbIFN0cmluZy5sZW5ndGggcyBdKVxuICAgICAgfmY6KGZ1biBpIGogLT4gc3ViIHMgfnBvczooaSArIHBhdHRlcm5fbGVuKSB+bGVuOihqIC0gaSAtIHBhdHRlcm5fbGVuKSlcbiAgOztcblxuICBtb2R1bGUgUHJpdmF0ZSA9IHN0cnVjdFxuICAgIHR5cGUgcHVibGljID0gdFxuXG4gICAgdHlwZSBub25yZWMgdCA9IHQgPVxuICAgICAgeyBwYXR0ZXJuIDogc3RyaW5nXG4gICAgICA7IGNhc2Vfc2Vuc2l0aXZlIDogYm9vbFxuICAgICAgOyBrbXBfYXJyYXkgOiBpbnQgYXJyYXlcbiAgICAgIH1cbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgZXF1YWwsIHNleHBfb2ZdXG5cbiAgICBsZXQgZXF1YWwgPVxuICAgICAgKGZ1biBhX18wMDJfIGJfXzAwM18gLT5cbiAgICAgICAgIGlmIFBweF9jb21wYXJlX2xpYi5waHlzX2VxdWFsIGFfXzAwMl8gYl9fMDAzX1xuICAgICAgICAgdGhlbiB0cnVlXG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIFBweF9jb21wYXJlX2xpYi4oICYmIClcbiAgICAgICAgICAgICAoZXF1YWxfc3RyaW5nIGFfXzAwMl8ucGF0dGVybiBiX18wMDNfLnBhdHRlcm4pXG4gICAgICAgICAgICAgKFBweF9jb21wYXJlX2xpYi4oICYmIClcbiAgICAgICAgICAgICAgICAoZXF1YWxfYm9vbCBhX18wMDJfLmNhc2Vfc2Vuc2l0aXZlIGJfXzAwM18uY2FzZV9zZW5zaXRpdmUpXG4gICAgICAgICAgICAgICAgKGVxdWFsX2FycmF5IGVxdWFsX2ludCBhX18wMDJfLmttcF9hcnJheSBiX18wMDNfLmttcF9hcnJheSkpXG4gICAgICAgICAgIDogdCAtPiB0IC0+IGJvb2wpXG4gICAgOztcblxuICAgIGxldCBzZXhwX29mX3QgPVxuICAgICAgKGZ1biB7IHBhdHRlcm4gPSBwYXR0ZXJuX18wMDdfXG4gICAgICAgICAgIDsgY2FzZV9zZW5zaXRpdmUgPSBjYXNlX3NlbnNpdGl2ZV9fMDA5X1xuICAgICAgICAgICA7IGttcF9hcnJheSA9IGttcF9hcnJheV9fMDExX1xuICAgICAgICAgICB9IC0+XG4gICAgICAgIGxldCBibmRzX18wMDZfID0gW10gaW5cbiAgICAgICAgbGV0IGJuZHNfXzAwNl8gPVxuICAgICAgICAgIGxldCBhcmdfXzAxMl8gPSBzZXhwX29mX2FycmF5IHNleHBfb2ZfaW50IGttcF9hcnJheV9fMDExXyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcImttcF9hcnJheVwiOyBhcmdfXzAxMl8gXSA6OiBibmRzX18wMDZfXG4gICAgICAgIGluXG4gICAgICAgIGxldCBibmRzX18wMDZfID1cbiAgICAgICAgICBsZXQgYXJnX18wMTBfID0gc2V4cF9vZl9ib29sIGNhc2Vfc2Vuc2l0aXZlX18wMDlfIGluXG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiY2FzZV9zZW5zaXRpdmVcIjsgYXJnX18wMTBfIF1cbiAgICAgICAgICA6OiBibmRzX18wMDZfXG4gICAgICAgIGluXG4gICAgICAgIGxldCBibmRzX18wMDZfID1cbiAgICAgICAgICBsZXQgYXJnX18wMDhfID0gc2V4cF9vZl9zdHJpbmcgcGF0dGVybl9fMDA3XyBpblxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcInBhdHRlcm5cIjsgYXJnX18wMDhfIF0gOjogYm5kc19fMDA2X1xuICAgICAgICBpblxuICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDA2X1xuICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHJlcHJlc2VudGF0aW9uID0gRm4uaWRcbiAgZW5kXG5lbmRcblxubW9kdWxlIFNlYXJjaF9wYXR0ZXJuX2hlbHBlciA9IHN0cnVjdFxuICBtb2R1bGUgU2VhcmNoX3BhdHRlcm4gPSBTZWFyY2hfcGF0dGVybjBcbmVuZFxuXG5vcGVuIFNlYXJjaF9wYXR0ZXJuX2hlbHBlclxuXG5sZXQgc3Vic3RyX2luZGV4X2dlbiB+Y2FzZV9zZW5zaXRpdmUgP3BvcyB0IH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4uaW5kZXggP3BvcyAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKSB+aW5fOnRcbjs7XG5cbmxldCBzdWJzdHJfaW5kZXhfZXhuX2dlbiB+Y2FzZV9zZW5zaXRpdmUgP3BvcyB0IH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4uaW5kZXhfZXhuID9wb3MgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgc3Vic3RyX2luZGV4X2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlIHQgfm1heV9vdmVybGFwIH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4uaW5kZXhfYWxsXG4gICAgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybilcbiAgICB+bWF5X292ZXJsYXBcbiAgICB+aW5fOnRcbjs7XG5cbmxldCBzdWJzdHJfcmVwbGFjZV9maXJzdF9nZW4gfmNhc2Vfc2Vuc2l0aXZlID9wb3MgdCB+cGF0dGVybiA9XG4gIFNlYXJjaF9wYXR0ZXJuLnJlcGxhY2VfZmlyc3QgP3BvcyAoU2VhcmNoX3BhdHRlcm4uY3JlYXRlIH5jYXNlX3NlbnNpdGl2ZSBwYXR0ZXJuKSB+aW5fOnRcbjs7XG5cbmxldCBzdWJzdHJfcmVwbGFjZV9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZSB0IH5wYXR0ZXJuID1cbiAgU2VhcmNoX3BhdHRlcm4ucmVwbGFjZV9hbGwgKFNlYXJjaF9wYXR0ZXJuLmNyZWF0ZSB+Y2FzZV9zZW5zaXRpdmUgcGF0dGVybikgfmluXzp0XG47O1xuXG5sZXQgaXNfc3Vic3RyaW5nX2dlbiB+Y2FzZV9zZW5zaXRpdmUgdCB+c3Vic3RyaW5nID1cbiAgT3B0aW9uLmlzX3NvbWUgKHN1YnN0cl9pbmRleF9nZW4gdCB+cGF0dGVybjpzdWJzdHJpbmcgfmNhc2Vfc2Vuc2l0aXZlKVxuOztcblxubGV0IHN1YnN0cl9pbmRleCA9IHN1YnN0cl9pbmRleF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfaW5kZXhfZXhuID0gc3Vic3RyX2luZGV4X2V4bl9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfaW5kZXhfYWxsID0gc3Vic3RyX2luZGV4X2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBzdWJzdHJfcmVwbGFjZV9maXJzdCA9IHN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiB+Y2FzZV9zZW5zaXRpdmU6dHJ1ZVxubGV0IHN1YnN0cl9yZXBsYWNlX2FsbCA9IHN1YnN0cl9yZXBsYWNlX2FsbF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOnRydWVcbmxldCBpc19zdWJzdHJpbmcgPSBpc19zdWJzdHJpbmdfZ2VuIH5jYXNlX3NlbnNpdGl2ZTp0cnVlXG5cbmxldCBpc19zdWJzdHJpbmdfYXRfZ2VuID1cbiAgbGV0IHJlYyBsb29wIH5zdHIgfnN0cl9wb3MgfnN1YiB+c3ViX3BvcyB+c3ViX2xlbiB+Y2hhcl9lcXVhbCA9XG4gICAgaWYgc3ViX3BvcyA9IHN1Yl9sZW5cbiAgICB0aGVuIHRydWVcbiAgICBlbHNlIGlmIGNoYXJfZXF1YWwgKHVuc2FmZV9nZXQgc3RyIHN0cl9wb3MpICh1bnNhZmVfZ2V0IHN1YiBzdWJfcG9zKVxuICAgIHRoZW4gbG9vcCB+c3RyIH5zdHJfcG9zOihzdHJfcG9zICsgMSkgfnN1YiB+c3ViX3Bvczooc3ViX3BvcyArIDEpIH5zdWJfbGVuIH5jaGFyX2VxdWFsXG4gICAgZWxzZSBmYWxzZVxuICBpblxuICBmdW4gc3RyIH5wb3M6c3RyX3BvcyB+c3Vic3RyaW5nOnN1YiB+Y2hhcl9lcXVhbCAtPlxuICAgIGxldCBzdHJfbGVuID0gbGVuZ3RoIHN0ciBpblxuICAgIGxldCBzdWJfbGVuID0gbGVuZ3RoIHN1YiBpblxuICAgIGlmIHN0cl9wb3MgPCAwIHx8IHN0cl9wb3MgPiBzdHJfbGVuXG4gICAgdGhlblxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiU3RyaW5nLmlzX3N1YnN0cmluZ19hdDogaW52YWxpZCBpbmRleCAlZCBmb3Igc3RyaW5nIG9mIGxlbmd0aCAlZFwiXG4gICAgICAgIHN0cl9wb3NcbiAgICAgICAgc3RyX2xlblxuICAgICAgICAoKTtcbiAgICBzdHJfcG9zICsgc3ViX2xlbiA8PSBzdHJfbGVuXG4gICAgJiYgbG9vcCB+c3RyIH5zdHJfcG9zIH5zdWIgfnN1Yl9wb3M6MCB+c3ViX2xlbiB+Y2hhcl9lcXVhbFxuOztcblxubGV0IGlzX3N1ZmZpeF9nZW4gc3RyaW5nIH5zdWZmaXggfmNoYXJfZXF1YWwgPVxuICBsZXQgc3RyaW5nX2xlbiA9IGxlbmd0aCBzdHJpbmcgaW5cbiAgbGV0IHN1ZmZpeF9sZW4gPSBsZW5ndGggc3VmZml4IGluXG4gIHN0cmluZ19sZW4gPj0gc3VmZml4X2xlblxuICAmJiBpc19zdWJzdHJpbmdfYXRfZ2VuXG4gICAgICAgc3RyaW5nXG4gICAgICAgfnBvczooc3RyaW5nX2xlbiAtIHN1ZmZpeF9sZW4pXG4gICAgICAgfnN1YnN0cmluZzpzdWZmaXhcbiAgICAgICB+Y2hhcl9lcXVhbFxuOztcblxubGV0IGlzX3ByZWZpeF9nZW4gc3RyaW5nIH5wcmVmaXggfmNoYXJfZXF1YWwgPVxuICBsZXQgc3RyaW5nX2xlbiA9IGxlbmd0aCBzdHJpbmcgaW5cbiAgbGV0IHByZWZpeF9sZW4gPSBsZW5ndGggcHJlZml4IGluXG4gIHN0cmluZ19sZW4gPj0gcHJlZml4X2xlblxuICAmJiBpc19zdWJzdHJpbmdfYXRfZ2VuIHN0cmluZyB+cG9zOjAgfnN1YnN0cmluZzpwcmVmaXggfmNoYXJfZXF1YWxcbjs7XG5cbm1vZHVsZSBDYXNlbGVzcyA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IHN0cmluZyBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gICAgbGV0IHRfb2Zfc2V4cCA9IChzdHJpbmdfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICAgIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9zdHJpbmcgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBzdHJpbmdfc2V4cF9ncmFtbWFyXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGNoYXJfY29tcGFyZV9jYXNlbGVzcyBjMSBjMiA9IENoYXIuY29tcGFyZSAoQ2hhci5sb3dlcmNhc2UgYzEpIChDaGFyLmxvd2VyY2FzZSBjMilcblxuICAgIGxldCByZWMgY29tcGFyZV9sb29wIH5wb3MgfnN0cmluZzEgfmxlbjEgfnN0cmluZzIgfmxlbjIgPVxuICAgICAgaWYgcG9zID0gbGVuMVxuICAgICAgdGhlbiBpZiBwb3MgPSBsZW4yIHRoZW4gMCBlbHNlIC0xXG4gICAgICBlbHNlIGlmIHBvcyA9IGxlbjJcbiAgICAgIHRoZW4gMVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBjID0gY2hhcl9jb21wYXJlX2Nhc2VsZXNzICh1bnNhZmVfZ2V0IHN0cmluZzEgcG9zKSAodW5zYWZlX2dldCBzdHJpbmcyIHBvcykgaW5cbiAgICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICAgIHwgMCAtPiBjb21wYXJlX2xvb3AgfnBvczoocG9zICsgMSkgfnN0cmluZzEgfmxlbjEgfnN0cmluZzIgfmxlbjJcbiAgICAgICAgfCBfIC0+IGMpXG4gICAgOztcblxuICAgIGxldCBjb21wYXJlIHN0cmluZzEgc3RyaW5nMiA9XG4gICAgICBpZiBwaHlzX2VxdWFsIHN0cmluZzEgc3RyaW5nMlxuICAgICAgdGhlbiAwXG4gICAgICBlbHNlXG4gICAgICAgIGNvbXBhcmVfbG9vcFxuICAgICAgICAgIH5wb3M6MFxuICAgICAgICAgIH5zdHJpbmcxXG4gICAgICAgICAgfmxlbjE6KFN0cmluZy5sZW5ndGggc3RyaW5nMSlcbiAgICAgICAgICB+c3RyaW5nMlxuICAgICAgICAgIH5sZW4yOihTdHJpbmcubGVuZ3RoIHN0cmluZzIpXG4gICAgOztcblxuICAgIGxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID1cbiAgICAgIGxldCBsZW4gPSBsZW5ndGggdCBpblxuICAgICAgbGV0IHN0YXRlID0gcmVmIChoYXNoX2ZvbGRfaW50IHN0YXRlIGxlbikgaW5cbiAgICAgIGZvciBwb3MgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgc3RhdGUgOj0gaGFzaF9mb2xkX2NoYXIgIXN0YXRlIChDaGFyLmxvd2VyY2FzZSAodW5zYWZlX2dldCB0IHBvcykpXG4gICAgICBkb25lO1xuICAgICAgIXN0YXRlXG4gICAgOztcblxuICAgIGxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG4gICAgbGV0IGlzX3N1ZmZpeCBzIH5zdWZmaXggPSBpc19zdWZmaXhfZ2VuIHMgfnN1ZmZpeCB+Y2hhcl9lcXVhbDpDaGFyLkNhc2VsZXNzLmVxdWFsXG4gICAgbGV0IGlzX3ByZWZpeCBzIH5wcmVmaXggPSBpc19wcmVmaXhfZ2VuIHMgfnByZWZpeCB+Y2hhcl9lcXVhbDpDaGFyLkNhc2VsZXNzLmVxdWFsXG4gICAgbGV0IHN1YnN0cl9pbmRleCA9IHN1YnN0cl9pbmRleF9nZW4gfmNhc2Vfc2Vuc2l0aXZlOmZhbHNlXG4gICAgbGV0IHN1YnN0cl9pbmRleF9leG4gPSBzdWJzdHJfaW5kZXhfZXhuX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX2luZGV4X2FsbCA9IHN1YnN0cl9pbmRleF9hbGxfZ2VuIH5jYXNlX3NlbnNpdGl2ZTpmYWxzZVxuICAgIGxldCBzdWJzdHJfcmVwbGFjZV9maXJzdCA9IHN1YnN0cl9yZXBsYWNlX2ZpcnN0X2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgc3Vic3RyX3JlcGxhY2VfYWxsID0gc3Vic3RyX3JlcGxhY2VfYWxsX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgaXNfc3Vic3RyaW5nID0gaXNfc3Vic3RyaW5nX2dlbiB+Y2FzZV9zZW5zaXRpdmU6ZmFsc2VcbiAgICBsZXQgaXNfc3Vic3RyaW5nX2F0ID0gaXNfc3Vic3RyaW5nX2F0X2dlbiB+Y2hhcl9lcXVhbDpDaGFyLkNhc2VsZXNzLmVxdWFsXG4gIGVuZFxuXG4gIGluY2x1ZGUgVFxuICBpbmNsdWRlIENvbXBhcmFibGUuTWFrZSAoVClcbmVuZFxuXG5sZXQgb2Zfc3RyaW5nID0gRm4uaWRcbmxldCB0b19zdHJpbmcgPSBGbi5pZFxuXG5sZXQgaW5pdCBuIH5mID1cbiAgaWYgbiA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJTdHJpbmcuaW5pdCAlZFwiIG4gKCk7XG4gIGxldCB0ID0gQnl0ZXMuY3JlYXRlIG4gaW5cbiAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgQnl0ZXMuc2V0IHQgaSAoZiBpKVxuICBkb25lO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnRcbjs7XG5cbmxldCB0b19saXN0IHMgPVxuICBsZXQgcmVjIGxvb3AgYWNjIGkgPSBpZiBpIDwgMCB0aGVuIGFjYyBlbHNlIGxvb3AgKHMuW2ldIDo6IGFjYykgKGkgLSAxKSBpblxuICBsb29wIFtdIChsZW5ndGggcyAtIDEpXG47O1xuXG5sZXQgdG9fbGlzdF9yZXYgcyA9XG4gIGxldCBsZW4gPSBsZW5ndGggcyBpblxuICBsZXQgcmVjIGxvb3AgYWNjIGkgPSBpZiBpID0gbGVuIHRoZW4gYWNjIGVsc2UgbG9vcCAocy5baV0gOjogYWNjKSAoaSArIDEpIGluXG4gIGxvb3AgW10gMFxuOztcblxubGV0IHJldiB0ID1cbiAgbGV0IGxlbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgdW5zYWZlX3NldCByZXMgaSAodW5zYWZlX2dldCB0IChsZW4gLSAxIC0gaSkpXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6cmVzXG47O1xuXG4oKiogRWZmaWNpZW50IHN0cmluZyBzcGxpdHRpbmcgKilcblxubGV0IGxzcGxpdDJfZXhuID1cbiAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU3RyaW5nLmxzcGxpdDJfZXhuOiBub3QgZm91bmRcIikgaW5cbiAgbGV0IGxzcGxpdDJfZXhuIGxpbmUgfm9uOmRlbGltID1cbiAgICBsZXQgcG9zID0gaW5kZXhfZXhuX2ludGVybmFsIGxpbmUgfm5vdF9mb3VuZCBkZWxpbSBpblxuICAgIHN1YiBsaW5lIH5wb3M6MCB+bGVuOnBvcywgc3ViIGxpbmUgfnBvczoocG9zICsgMSkgfmxlbjoobGVuZ3RoIGxpbmUgLSBwb3MgLSAxKVxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIGxzcGxpdDJfZXhuXG47O1xuXG5sZXQgcnNwbGl0Ml9leG4gPVxuICBsZXQgbm90X2ZvdW5kID0gTm90X2ZvdW5kX3MgKEF0b20gXCJTdHJpbmcucnNwbGl0Ml9leG46IG5vdCBmb3VuZFwiKSBpblxuICBsZXQgcnNwbGl0Ml9leG4gbGluZSB+b246ZGVsaW0gPVxuICAgIGxldCBwb3MgPSByaW5kZXhfZXhuX2ludGVybmFsIGxpbmUgfm5vdF9mb3VuZCBkZWxpbSBpblxuICAgIHN1YiBsaW5lIH5wb3M6MCB+bGVuOnBvcywgc3ViIGxpbmUgfnBvczoocG9zICsgMSkgfmxlbjoobGVuZ3RoIGxpbmUgLSBwb3MgLSAxKVxuICBpblxuICAoKiBuYW1lZCB0byBwcmVzZXJ2ZSBzeW1ib2wgaW4gY29tcGlsZWQgYmluYXJ5ICopXG4gIHJzcGxpdDJfZXhuXG47O1xuXG5sZXQgbHNwbGl0MiBsaW5lIH5vbiA9XG4gIHRyeSBTb21lIChsc3BsaXQyX2V4biBsaW5lIH5vbikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcnNwbGl0MiBsaW5lIH5vbiA9XG4gIHRyeSBTb21lIChyc3BsaXQyX2V4biBsaW5lIH5vbikgd2l0aFxuICB8IE5vdF9mb3VuZF9zIF8gfCBDYW1sLk5vdF9mb3VuZCAtPiBOb25lXG47O1xuXG5sZXQgcmVjIGNoYXJfbGlzdF9tZW0gbCAoYyA6IGNoYXIpID1cbiAgbWF0Y2ggbCB3aXRoXG4gIHwgW10gLT4gZmFsc2VcbiAgfCBoZCA6OiB0bCAtPiBDaGFyLmVxdWFsIGhkIGMgfHwgY2hhcl9saXN0X21lbSB0bCBjXG47O1xuXG5sZXQgc3BsaXRfZ2VuIHN0ciB+b24gPVxuICBsZXQgaXNfZGVsaW0gPVxuICAgIG1hdGNoIG9uIHdpdGhcbiAgICB8IGBjaGFyIGMnIC0+IGZ1biBjIC0+IENoYXIuZXF1YWwgYyBjJ1xuICAgIHwgYGNoYXJfbGlzdCBsIC0+IGZ1biBjIC0+IGNoYXJfbGlzdF9tZW0gbCBjXG4gIGluXG4gIGxldCBsZW4gPSBsZW5ndGggc3RyIGluXG4gIGxldCByZWMgbG9vcCBhY2MgbGFzdF9wb3MgcG9zID1cbiAgICBpZiBwb3MgPSAtMVxuICAgIHRoZW4gc3ViIHN0ciB+cG9zOjAgfmxlbjpsYXN0X3BvcyA6OiBhY2NcbiAgICBlbHNlIGlmIGlzX2RlbGltIHN0ci5bcG9zXVxuICAgIHRoZW4gKFxuICAgICAgbGV0IHBvczEgPSBwb3MgKyAxIGluXG4gICAgICBsZXQgc3ViX3N0ciA9IHN1YiBzdHIgfnBvczpwb3MxIH5sZW46KGxhc3RfcG9zIC0gcG9zMSkgaW5cbiAgICAgIGxvb3AgKHN1Yl9zdHIgOjogYWNjKSBwb3MgKHBvcyAtIDEpKVxuICAgIGVsc2UgbG9vcCBhY2MgbGFzdF9wb3MgKHBvcyAtIDEpXG4gIGluXG4gIGxvb3AgW10gbGVuIChsZW4gLSAxKVxuOztcblxubGV0IHNwbGl0IHN0ciB+b24gPSBzcGxpdF9nZW4gc3RyIH5vbjooYGNoYXIgb24pXG5sZXQgc3BsaXRfb25fY2hhcnMgc3RyIH5vbjpjaGFycyA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhcl9saXN0IGNoYXJzKVxuXG5sZXQgc3BsaXRfbGluZXMgPVxuICBsZXQgYmFja191cF9hdF9uZXdsaW5lIH50IH5wb3MgfmVvbCA9XG4gICAgcG9zIDo9ICFwb3MgLSBpZiAhcG9zID4gMCAmJiBDaGFyLmVxdWFsIHQuWyFwb3MgLSAxXSAnXFxyJyB0aGVuIDIgZWxzZSAxO1xuICAgIGVvbCA6PSAhcG9zICsgMVxuICBpblxuICBmdW4gdCAtPlxuICAgIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgICBpZiBuID0gMFxuICAgIHRoZW4gW11cbiAgICBlbHNlIChcbiAgICAgICgqIEludmFyaWFudDogWy0xIDw9IHBvcyA8IGVvbF0uICopXG4gICAgICBsZXQgcG9zID0gcmVmIChuIC0gMSkgaW5cbiAgICAgIGxldCBlb2wgPSByZWYgbiBpblxuICAgICAgbGV0IGFjID0gcmVmIFtdIGluXG4gICAgICAoKiBXZSB0cmVhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcgc3BlY2lhbGx5LCBiZWNhdXNlIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGFcbiAgICAgICAgIG5ld2xpbmUsIHdlIGRvbid0IHdhbnQgYW4gZXh0cmEgZW1wdHkgc3RyaW5nIGF0IHRoZSBlbmQgb2YgdGhlIG91dHB1dC4gKilcbiAgICAgIGlmIENoYXIuZXF1YWwgdC5bIXBvc10gJ1xcbicgdGhlbiBiYWNrX3VwX2F0X25ld2xpbmUgfnQgfnBvcyB+ZW9sO1xuICAgICAgd2hpbGUgIXBvcyA+PSAwIGRvXG4gICAgICAgIGlmIENoYXIuKCA8PiApIHQuWyFwb3NdICdcXG4nXG4gICAgICAgIHRoZW4gZGVjciBwb3NcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogQmVjYXVzZSBbcG9zIDwgZW9sXSwgd2Uga25vdyB0aGF0IFtzdGFydCA8PSBlb2xdLiAqKVxuICAgICAgICAgIGxldCBzdGFydCA9ICFwb3MgKyAxIGluXG4gICAgICAgICAgYWMgOj0gc3ViIHQgfnBvczpzdGFydCB+bGVuOighZW9sIC0gc3RhcnQpIDo6ICFhYztcbiAgICAgICAgICBiYWNrX3VwX2F0X25ld2xpbmUgfnQgfnBvcyB+ZW9sKVxuICAgICAgZG9uZTtcbiAgICAgIHN1YiB0IH5wb3M6MCB+bGVuOiFlb2wgOjogIWFjKVxuOztcblxubGV0IGlzX3N1ZmZpeCBzIH5zdWZmaXggPSBpc19zdWZmaXhfZ2VuIHMgfnN1ZmZpeCB+Y2hhcl9lcXVhbDpDaGFyLmVxdWFsXG5sZXQgaXNfcHJlZml4IHMgfnByZWZpeCA9IGlzX3ByZWZpeF9nZW4gcyB+cHJlZml4IH5jaGFyX2VxdWFsOkNoYXIuZXF1YWxcblxubGV0IGlzX3N1YnN0cmluZ19hdCBzIH5wb3MgfnN1YnN0cmluZyA9XG4gIGlzX3N1YnN0cmluZ19hdF9nZW4gcyB+cG9zIH5zdWJzdHJpbmcgfmNoYXJfZXF1YWw6Q2hhci5lcXVhbFxuOztcblxubGV0IHdyYXBfc3ViX24gdCBuIH5uYW1lIH5wb3MgfmxlbiB+b25fZXJyb3IgPVxuICBpZiBuIDwgMFxuICB0aGVuIGludmFsaWRfYXJnIChuYW1lIF4gXCIgZXhwZWN0aW5nIG5vbm5lZ2F0aXZlIGFyZ3VtZW50XCIpXG4gIGVsc2UgKFxuICAgIHRyeSBzdWIgdCB+cG9zIH5sZW4gd2l0aFxuICAgIHwgXyAtPiBvbl9lcnJvcilcbjs7XG5cbmxldCBkcm9wX3ByZWZpeCB0IG4gPVxuICB3cmFwX3N1Yl9uIH5uYW1lOlwiZHJvcF9wcmVmaXhcIiB0IG4gfnBvczpuIH5sZW46KGxlbmd0aCB0IC0gbikgfm9uX2Vycm9yOlwiXCJcbjs7XG5cbmxldCBkcm9wX3N1ZmZpeCB0IG4gPVxuICB3cmFwX3N1Yl9uIH5uYW1lOlwiZHJvcF9zdWZmaXhcIiB0IG4gfnBvczowIH5sZW46KGxlbmd0aCB0IC0gbikgfm9uX2Vycm9yOlwiXCJcbjs7XG5cbmxldCBwcmVmaXggdCBuID0gd3JhcF9zdWJfbiB+bmFtZTpcInByZWZpeFwiIHQgbiB+cG9zOjAgfmxlbjpuIH5vbl9lcnJvcjp0XG5sZXQgc3VmZml4IHQgbiA9IHdyYXBfc3ViX24gfm5hbWU6XCJzdWZmaXhcIiB0IG4gfnBvczoobGVuZ3RoIHQgLSBuKSB+bGVuOm4gfm9uX2Vycm9yOnRcblxubGV0IGxmaW5kaSA/KHBvcyA9IDApIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCByZWMgbG9vcCBpID0gaWYgaSA9IG4gdGhlbiBOb25lIGVsc2UgaWYgZiBpIHQuW2ldIHRoZW4gU29tZSBpIGVsc2UgbG9vcCAoaSArIDEpIGluXG4gIGxvb3AgcG9zXG47O1xuXG5sZXQgZmluZCB0IH5mID1cbiAgbWF0Y2ggbGZpbmRpIHQgfmY6KGZ1biBfIGMgLT4gZiBjKSB3aXRoXG4gIHwgTm9uZSAtPiBOb25lXG4gIHwgU29tZSBpIC0+IFNvbWUgdC5baV1cbjs7XG5cbmxldCBmaW5kX21hcCB0IH5mID1cbiAgbGV0IG4gPSBsZW5ndGggdCBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgaWYgaSA9IG5cbiAgICB0aGVuIE5vbmVcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGYgdC5baV0gd2l0aFxuICAgICAgfCBOb25lIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgfCBTb21lIF8gYXMgcmVzIC0+IHJlcylcbiAgaW5cbiAgbG9vcCAwXG47O1xuXG5sZXQgcmZpbmRpID9wb3MgdCB+ZiA9XG4gIGxldCByZWMgbG9vcCBpID0gaWYgaSA8IDAgdGhlbiBOb25lIGVsc2UgaWYgZiBpIHQuW2ldIHRoZW4gU29tZSBpIGVsc2UgbG9vcCAoaSAtIDEpIGluXG4gIGxldCBwb3MgPVxuICAgIG1hdGNoIHBvcyB3aXRoXG4gICAgfCBTb21lIHBvcyAtPiBwb3NcbiAgICB8IE5vbmUgLT4gbGVuZ3RoIHQgLSAxXG4gIGluXG4gIGxvb3AgcG9zXG47O1xuXG5sZXQgbGFzdF9ub25fZHJvcCB+ZHJvcCB0ID0gcmZpbmRpIHQgfmY6KGZ1biBfIGMgLT4gbm90IChkcm9wIGMpKVxuXG5sZXQgcnN0cmlwID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCA9XG4gIG1hdGNoIGxhc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gIHwgTm9uZSAtPiBcIlwiXG4gIHwgU29tZSBpIC0+IGlmIGkgPSBsZW5ndGggdCAtIDEgdGhlbiB0IGVsc2UgcHJlZml4IHQgKGkgKyAxKVxuOztcblxubGV0IGZpcnN0X25vbl9kcm9wIH5kcm9wIHQgPSBsZmluZGkgdCB+ZjooZnVuIF8gYyAtPiBub3QgKGRyb3AgYykpXG5cbmxldCBsc3RyaXAgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0ID1cbiAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gIHwgTm9uZSAtPiBcIlwiXG4gIHwgU29tZSAwIC0+IHRcbiAgfCBTb21lIG4gLT4gZHJvcF9wcmVmaXggdCBuXG47O1xuXG4oKiBbc3RyaXAgdF0gY291bGQgYmUgaW1wbGVtZW50ZWQgYXMgW2xzdHJpcCAocnN0cmlwIHQpXS4gIFRoZSBpbXBsZW1lbnRhdGlvblxuICAgYmVsb3cgc2F2ZXMgKGF0IGxlYXN0KSBhIGZhY3RvciBvZiB0d28gYWxsb2NhdGlvbiwgYnkgb25seSBhbGxvY2F0aW5nIHRoZVxuICAgZmluYWwgcmVzdWx0LiAgVGhpcyBhbHNvIHNhdmVzIHNvbWUgYW1vdW50IG9mIHRpbWUuICopXG5sZXQgc3RyaXAgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0ID1cbiAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gIGlmIGxlbmd0aCA9IDAgfHwgbm90IChkcm9wIHQuWzBdIHx8IGRyb3AgdC5bbGVuZ3RoIC0gMV0pXG4gIHRoZW4gdFxuICBlbHNlIChcbiAgICBtYXRjaCBmaXJzdF9ub25fZHJvcCB0IH5kcm9wIHdpdGhcbiAgICB8IE5vbmUgLT4gXCJcIlxuICAgIHwgU29tZSBmaXJzdCAtPlxuICAgICAgKG1hdGNoIGxhc3Rfbm9uX2Ryb3AgdCB+ZHJvcCB3aXRoXG4gICAgICAgfCBOb25lIC0+IGFzc2VydCBmYWxzZVxuICAgICAgIHwgU29tZSBsYXN0IC0+IHN1YiB0IH5wb3M6Zmlyc3QgfmxlbjoobGFzdCAtIGZpcnN0ICsgMSkpKVxuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIGxldCBsID0gbGVuZ3RoIHQgaW5cbiAgbGV0IHQnID0gQnl0ZXMuY3JlYXRlIGwgaW5cbiAgZm9yIGkgPSAwIHRvIGwgLSAxIGRvXG4gICAgQnl0ZXMudW5zYWZlX3NldCB0JyBpIChmIGkgdC5baV0pXG4gIGRvbmU7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6dCdcbjs7XG5cbigqIHJlcGVhdGVkIGNvZGUgdG8gYXZvaWQgcmVxdWlyaW5nIGFuIGV4dHJhIGFsbG9jYXRpb24gZm9yIGEgY2xvc3VyZSBvbiBlYWNoIGNhbGwuICopXG5sZXQgbWFwIHQgfmYgPVxuICBsZXQgbCA9IGxlbmd0aCB0IGluXG4gIGxldCB0JyA9IEJ5dGVzLmNyZWF0ZSBsIGluXG4gIGZvciBpID0gMCB0byBsIC0gMSBkb1xuICAgIEJ5dGVzLnVuc2FmZV9zZXQgdCcgaSAoZiB0LltpXSlcbiAgZG9uZTtcbiAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTp0J1xuOztcblxubGV0IHRvX2FycmF5IHMgPSBBcnJheS5pbml0IChsZW5ndGggcykgfmY6KGZ1biBpIC0+IHMuW2ldKVxuXG5sZXQgZXhpc3RzID1cbiAgbGV0IHJlYyBsb29wIHMgaSB+bGVuIH5mID0gaSA8IGxlbiAmJiAoZiBzLltpXSB8fCBsb29wIHMgKGkgKyAxKSB+bGVuIH5mKSBpblxuICBmdW4gcyB+ZiAtPiBsb29wIHMgMCB+bGVuOihsZW5ndGggcykgfmZcbjs7XG5cbmxldCBmb3JfYWxsID1cbiAgbGV0IHJlYyBsb29wIHMgaSB+bGVuIH5mID0gaSA9IGxlbiB8fCAoZiBzLltpXSAmJiBsb29wIHMgKGkgKyAxKSB+bGVuIH5mKSBpblxuICBmdW4gcyB+ZiAtPiBsb29wIHMgMCB+bGVuOihsZW5ndGggcykgfmZcbjs7XG5cbmxldCBmb2xkID1cbiAgbGV0IHJlYyBsb29wIHQgaSBhYyB+ZiB+bGVuID1cbiAgICBpZiBpID0gbGVuIHRoZW4gYWMgZWxzZSBsb29wIHQgKGkgKyAxKSAoZiBhYyB0LltpXSkgfmYgfmxlblxuICBpblxuICBmdW4gdCB+aW5pdCB+ZiAtPiBsb29wIHQgMCBpbml0IH5mIH5sZW46KGxlbmd0aCB0KVxuOztcblxubGV0IGZvbGRpID1cbiAgbGV0IHJlYyBsb29wIHQgaSBhYyB+ZiB+bGVuID1cbiAgICBpZiBpID0gbGVuIHRoZW4gYWMgZWxzZSBsb29wIHQgKGkgKyAxKSAoZiBpIGFjIHQuW2ldKSB+ZiB+bGVuXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCAwIGluaXQgfmYgfmxlbjoobGVuZ3RoIHQpXG47O1xuXG5sZXQgaXRlcmkgdCB+ZiA9XG4gIGZvciBpID0gMCB0byBsZW5ndGggdCAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgdCBpKVxuICBkb25lXG47O1xuXG5sZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG5sZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG5sZXQgbWluX2VsdCB0ID0gQ29udGFpbmVyLm1pbl9lbHQgfmZvbGQgdFxubGV0IG1heF9lbHQgdCA9IENvbnRhaW5lci5tYXhfZWx0IH5mb2xkIHRcbmxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbmxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBDb250YWluZXIuZm9sZF91bnRpbCB+Zm9sZCB+aW5pdCB+ZiB0XG5sZXQgZmluZF9tYXBpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5maW5kX21hcGkgfml0ZXJpIHQgfmZcbmxldCBmaW5kaSB0IH5mID0gSW5kZXhlZF9jb250YWluZXIuZmluZGkgfml0ZXJpIHQgfmZcbmxldCBjb3VudGkgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmNvdW50aSB+Zm9sZGkgdCB+ZlxubGV0IGZvcl9hbGxpIHQgfmYgPSBJbmRleGVkX2NvbnRhaW5lci5mb3JfYWxsaSB+aXRlcmkgdCB+ZlxubGV0IGV4aXN0c2kgdCB+ZiA9IEluZGV4ZWRfY29udGFpbmVyLmV4aXN0c2kgfml0ZXJpIHQgfmZcblxubGV0IG1lbSA9XG4gIGxldCByZWMgbG9vcCB0IGMgfnBvczppIH5sZW4gPVxuICAgIGkgPCBsZW4gJiYgKENoYXIuZXF1YWwgYyAodW5zYWZlX2dldCB0IGkpIHx8IGxvb3AgdCBjIH5wb3M6KGkgKyAxKSB+bGVuKVxuICBpblxuICBmdW4gdCBjIC0+IGxvb3AgdCBjIH5wb3M6MCB+bGVuOihsZW5ndGggdClcbjs7XG5cbmxldCB0ciB+dGFyZ2V0IH5yZXBsYWNlbWVudCBzID1cbiAgaWYgQ2hhci5lcXVhbCB0YXJnZXQgcmVwbGFjZW1lbnRcbiAgdGhlbiBzXG4gIGVsc2UgaWYgbWVtIHMgdGFyZ2V0XG4gIHRoZW4gbWFwIHMgfmY6KGZ1biBjIC0+IGlmIENoYXIuZXF1YWwgYyB0YXJnZXQgdGhlbiByZXBsYWNlbWVudCBlbHNlIGMpXG4gIGVsc2Ugc1xuOztcblxubGV0IHRyX211bHRpIH50YXJnZXQgfnJlcGxhY2VtZW50ID1cbiAgaWYgaXNfZW1wdHkgdGFyZ2V0XG4gIHRoZW4gc3RhZ2UgRm4uaWRcbiAgZWxzZSBpZiBpc19lbXB0eSByZXBsYWNlbWVudFxuICB0aGVuIGludmFsaWRfYXJnIFwidHJfbXVsdGkgcmVwbGFjZW1lbnQgaXMgZW1wdHkgc3RyaW5nXCJcbiAgZWxzZSAoXG4gICAgbWF0Y2ggQnl0ZXNfdHIudHJfY3JlYXRlX21hcCB+dGFyZ2V0IH5yZXBsYWNlbWVudCB3aXRoXG4gICAgfCBOb25lIC0+IHN0YWdlIEZuLmlkXG4gICAgfCBTb21lIHRyX21hcCAtPlxuICAgICAgc3RhZ2UgKGZ1biBzIC0+XG4gICAgICAgIGlmIGV4aXN0cyBzIH5mOihmdW4gYyAtPiBDaGFyLiggPD4gKSBjICh1bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgYykpKVxuICAgICAgICB0aGVuIG1hcCBzIH5mOihmdW4gYyAtPiB1bnNhZmVfZ2V0IHRyX21hcCAoQ2hhci50b19pbnQgYykpXG4gICAgICAgIGVsc2UgcykpXG47O1xuXG4oKiBmYXN0IHZlcnNpb24sIGlmIHdlIGV2ZXIgbmVlZCBpdDpcbiAgIHtbXG4gICAgIGxldCBjb25jYXRfYXJyYXkgfnNlcCBhciA9XG4gICAgICAgbGV0IGFyX2xlbiA9IEFycmF5Lmxlbmd0aCBhciBpblxuICAgICAgIGlmIGFyX2xlbiA9IDAgdGhlbiBcIlwiXG4gICAgICAgZWxzZVxuICAgICAgICAgbGV0IHNlcF9sZW4gPSBsZW5ndGggc2VwIGluXG4gICAgICAgICBsZXQgcmVzX2xlbl9yZWYgPSByZWYgKHNlcF9sZW4gKiAoYXJfbGVuIC0gMSkpIGluXG4gICAgICAgICBmb3IgaSA9IDAgdG8gYXJfbGVuIC0gMSBkb1xuICAgICAgICAgICByZXNfbGVuX3JlZiA6PSAhcmVzX2xlbl9yZWYgKyBsZW5ndGggYXIuKGkpXG4gICAgICAgICBkb25lO1xuICAgICAgICAgbGV0IHJlcyA9IGNyZWF0ZSAhcmVzX2xlbl9yZWYgaW5cbiAgICAgICAgIGxldCBzdHJfMCA9IGFyLigwKSBpblxuICAgICAgICAgbGV0IGxlbl8wID0gbGVuZ3RoIHN0cl8wIGluXG4gICAgICAgICBibGl0IH5zcmM6c3RyXzAgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3BvczowIH5sZW46bGVuXzA7XG4gICAgICAgICBsZXQgcG9zX3JlZiA9IHJlZiBsZW5fMCBpblxuICAgICAgICAgZm9yIGkgPSAxIHRvIGFyX2xlbiAtIDEgZG9cbiAgICAgICAgICAgbGV0IHBvcyA9ICFwb3NfcmVmIGluXG4gICAgICAgICAgIGJsaXQgfnNyYzpzZXAgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3Bvczpwb3MgfmxlbjpzZXBfbGVuO1xuICAgICAgICAgICBsZXQgbmV3X3BvcyA9IHBvcyArIHNlcF9sZW4gaW5cbiAgICAgICAgICAgbGV0IHN0cl9pID0gYXIuKGkpIGluXG4gICAgICAgICAgIGxldCBsZW5faSA9IGxlbmd0aCBzdHJfaSBpblxuICAgICAgICAgICBibGl0IH5zcmM6c3RyX2kgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3BvczpuZXdfcG9zIH5sZW46bGVuX2k7XG4gICAgICAgICAgIHBvc19yZWYgOj0gbmV3X3BvcyArIGxlbl9pXG4gICAgICAgICBkb25lO1xuICAgICAgICAgcmVzXG4gICBdfSAqKVxuXG5sZXQgY29uY2F0X2FycmF5ID9zZXAgYXIgPSBjb25jYXQgP3NlcCAoQXJyYXkudG9fbGlzdCBhcilcbmxldCBjb25jYXRfbWFwID9zZXAgcyB+ZiA9IGNvbmNhdF9hcnJheSA/c2VwIChBcnJheS5tYXAgKHRvX2FycmF5IHMpIH5mKVxuXG4oKiBbZmlsdGVyIHQgZl0gaXMgaW1wbGVtZW50ZWQgYnkgdGhlIGZvbGxvd2luZyBhbGdvcml0aG0uXG5cbiAgIExldCBbbiA9IGxlbmd0aCB0XS5cblxuICAgMS4gRmluZCB0aGUgbG93ZXN0IFtpXSBzdWNoIHRoYXQgW25vdCAoZiB0LltpXSldLlxuXG4gICAyLiBJZiB0aGVyZSBpcyBubyBzdWNoIFtpXSwgdGhlbiByZXR1cm4gW3RdLlxuXG4gICAzLiBJZiB0aGVyZSBpcyBzdWNoIGFuIFtpXSwgYWxsb2NhdGUgYSBzdHJpbmcsIFtvdXRdLCB0byBob2xkIHRoZSByZXN1bHQuICBbb3V0XSBoYXNcbiAgIGxlbmd0aCBbbiAtIDFdLCB3aGljaCBpcyB0aGUgbWF4aW11bSBwb3NzaWJsZSBvdXRwdXQgc2l6ZSBnaXZlbiB0aGF0IHRoZXJlIGlzIGF0IGxlYXN0XG4gICBvbmUgY2hhcmFjdGVyIG5vdCBzYXRpc2Z5aW5nIFtmXS5cblxuICAgNC4gQ29weSBjaGFyYWN0ZXJzIGF0IGluZGljZXMgMCAuLi4gW2kgLSAxXSBmcm9tIFt0XSB0byBbb3V0XS5cblxuICAgNS4gV2FsayB0aHJvdWdoIGNoYXJhY3RlcnMgYXQgaW5kaWNlcyBbaSsxXSAuLi4gW24tMV0gb2YgW3RdLCBjb3B5aW5nIHRob3NlIHRoYXRcbiAgIHNhdGlzZnkgW2ZdIGZyb20gW3RdIHRvIFtvdXRdLlxuXG4gICA2LiBJZiB3ZSBjb21wbGV0ZWx5IGZpbGxlZCBbb3V0XSwgdGhlbiByZXR1cm4gaXQuICBJZiBub3QsIHJldHVybiB0aGUgcHJlZml4IG9mIFtvdXRdXG4gICB0aGF0IHdlIGRpZCBmaWxsIGluLlxuXG4gICBUaGlzIGFsZ29yaXRobSBoYXMgdGhlIHByb3BlcnR5IHRoYXQgaXQgZG9lc24ndCBhbGxvY2F0ZSBhIG5ldyBzdHJpbmcgaWYgdGhlcmUnc1xuICAgbm90aGluZyB0byBmaWx0ZXIsIHdoaWNoIGlzIGEgY29tbW9uIGNhc2UuICopXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBsZXQgbiA9IGxlbmd0aCB0IGluXG4gIGxldCBpID0gcmVmIDAgaW5cbiAgd2hpbGUgIWkgPCBuICYmIGYgdC5bIWldIGRvXG4gICAgaW5jciBpXG4gIGRvbmU7XG4gIGlmICFpID0gblxuICB0aGVuIHRcbiAgZWxzZSAoXG4gICAgbGV0IG91dCA9IEJ5dGVzLmNyZWF0ZSAobiAtIDEpIGluXG4gICAgQnl0ZXMuYmxpdF9zdHJpbmcgfnNyYzp0IH5zcmNfcG9zOjAgfmRzdDpvdXQgfmRzdF9wb3M6MCB+bGVuOiFpO1xuICAgIGxldCBvdXRfcG9zID0gcmVmICFpIGluXG4gICAgaW5jciBpO1xuICAgIHdoaWxlICFpIDwgbiBkb1xuICAgICAgbGV0IGMgPSB0LlshaV0gaW5cbiAgICAgIGlmIGYgY1xuICAgICAgdGhlbiAoXG4gICAgICAgIEJ5dGVzLnNldCBvdXQgIW91dF9wb3MgYztcbiAgICAgICAgaW5jciBvdXRfcG9zKTtcbiAgICAgIGluY3IgaVxuICAgIGRvbmU7XG4gICAgbGV0IG91dCA9IEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0IGluXG4gICAgaWYgIW91dF9wb3MgPSBuIC0gMSB0aGVuIG91dCBlbHNlIHN1YiBvdXQgfnBvczowIH5sZW46IW91dF9wb3MpXG47O1xuXG4oKiByZXBlYXRlZCBjb2RlIHRvIGF2b2lkIHJlcXVpcmluZyBhbiBleHRyYSBhbGxvY2F0aW9uIGZvciBhIGNsb3N1cmUgb24gZWFjaCBjYWxsLiAqKVxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIGxldCBuID0gbGVuZ3RoIHQgaW5cbiAgbGV0IGkgPSByZWYgMCBpblxuICB3aGlsZSAhaSA8IG4gJiYgZiAhaSB0LlshaV0gZG9cbiAgICBpbmNyIGlcbiAgZG9uZTtcbiAgaWYgIWkgPSBuXG4gIHRoZW4gdFxuICBlbHNlIChcbiAgICBsZXQgb3V0ID0gQnl0ZXMuY3JlYXRlIChuIC0gMSkgaW5cbiAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjOnQgfnNyY19wb3M6MCB+ZHN0Om91dCB+ZHN0X3BvczowIH5sZW46IWk7XG4gICAgbGV0IG91dF9wb3MgPSByZWYgIWkgaW5cbiAgICBpbmNyIGk7XG4gICAgd2hpbGUgIWkgPCBuIGRvXG4gICAgICBsZXQgYyA9IHQuWyFpXSBpblxuICAgICAgaWYgZiAhaSBjXG4gICAgICB0aGVuIChcbiAgICAgICAgQnl0ZXMuc2V0IG91dCAhb3V0X3BvcyBjO1xuICAgICAgICBpbmNyIG91dF9wb3MpO1xuICAgICAgaW5jciBpXG4gICAgZG9uZTtcbiAgICBsZXQgb3V0ID0gQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpvdXQgaW5cbiAgICBpZiAhb3V0X3BvcyA9IG4gLSAxIHRoZW4gb3V0IGVsc2Ugc3ViIG91dCB+cG9zOjAgfmxlbjohb3V0X3Bvcylcbjs7XG5cbmxldCBjaG9wX3ByZWZpeCBzIH5wcmVmaXggPVxuICBpZiBpc19wcmVmaXggcyB+cHJlZml4IHRoZW4gU29tZSAoZHJvcF9wcmVmaXggcyAobGVuZ3RoIHByZWZpeCkpIGVsc2UgTm9uZVxuOztcblxubGV0IGNob3BfcHJlZml4X2lmX2V4aXN0cyBzIH5wcmVmaXggPVxuICBpZiBpc19wcmVmaXggcyB+cHJlZml4IHRoZW4gZHJvcF9wcmVmaXggcyAobGVuZ3RoIHByZWZpeCkgZWxzZSBzXG47O1xuXG5sZXQgY2hvcF9wcmVmaXhfZXhuIHMgfnByZWZpeCA9XG4gIG1hdGNoIGNob3BfcHJlZml4IHMgfnByZWZpeCB3aXRoXG4gIHwgU29tZSBzdHIgLT4gc3RyXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZ2YgXCJTdHJpbmcuY2hvcF9wcmVmaXhfZXhuICVTICVTXCIgcyBwcmVmaXggKClcbjs7XG5cbmxldCBjaG9wX3N1ZmZpeCBzIH5zdWZmaXggPVxuICBpZiBpc19zdWZmaXggcyB+c3VmZml4IHRoZW4gU29tZSAoZHJvcF9zdWZmaXggcyAobGVuZ3RoIHN1ZmZpeCkpIGVsc2UgTm9uZVxuOztcblxubGV0IGNob3Bfc3VmZml4X2lmX2V4aXN0cyBzIH5zdWZmaXggPVxuICBpZiBpc19zdWZmaXggcyB+c3VmZml4IHRoZW4gZHJvcF9zdWZmaXggcyAobGVuZ3RoIHN1ZmZpeCkgZWxzZSBzXG47O1xuXG5sZXQgY2hvcF9zdWZmaXhfZXhuIHMgfnN1ZmZpeCA9XG4gIG1hdGNoIGNob3Bfc3VmZml4IHMgfnN1ZmZpeCB3aXRoXG4gIHwgU29tZSBzdHIgLT4gc3RyXG4gIHwgTm9uZSAtPiBpbnZhbGlkX2FyZ2YgXCJTdHJpbmcuY2hvcF9zdWZmaXhfZXhuICVTICVTXCIgcyBzdWZmaXggKClcbjs7XG5cbm1vZHVsZSBGb3JfY29tbW9uX3ByZWZpeF9hbmRfc3VmZml4ID0gc3RydWN0XG4gICgqIFdoZW4gdGFraW5nIGEgc3RyaW5nIHByZWZpeCBvciBzdWZmaXgsIHdlIGV4dHJhY3QgZnJvbSB0aGUgc2hvcnRlc3QgaW5wdXQgYXZhaWxhYmxlXG4gICAgIGluIGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIG9uZSBvZiBvdXIgaW5wdXRzIHdpdGhvdXQgYWxsb2NhdGluZyBhIG5ldyBzdHJpbmcuICopXG5cbiAgbGV0IHNob3J0ZXIgYSBiID0gaWYgbGVuZ3RoIGEgPD0gbGVuZ3RoIGIgdGhlbiBhIGVsc2UgYlxuXG4gIGxldCBzaG9ydGVzdCBsaXN0ID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IFwiXCJcbiAgICB8IGZpcnN0IDo6IHJlc3QgLT4gTGlzdC5mb2xkIHJlc3QgfmluaXQ6Zmlyc3QgfmY6c2hvcnRlclxuICA7O1xuXG4gICgqIE91ciBnZW5lcmljIGFjY2Vzc29ycyBmb3IgY29tbW9uIHByZWZpeC9zdWZmaXggYWJzdHJhY3Qgb3ZlciBbZ2V0X3Bvc10sIHdoaWNoIGlzXG4gICAgIGVpdGhlciBbcG9zX2Zyb21fbGVmdF0gb3IgW3Bvc19mcm9tX3JpZ2h0XS4gKilcblxuICBsZXQgcG9zX2Zyb21fbGVmdCAoXyA6IHQpIChpIDogaW50KSA9IGlcbiAgbGV0IHBvc19mcm9tX3JpZ2h0IHQgaSA9IGxlbmd0aCB0IC0gaSAtIDFcblxuICBsZXQgcmVjIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBhIGIgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXIgPVxuICAgIGlmIGxlbl9zb19mYXIgPj0gbWF4X2xlblxuICAgIHRoZW4gbWF4X2xlblxuICAgIGVsc2UgaWYgQ2hhci5lcXVhbFxuICAgICAgICAgICAgICAodW5zYWZlX2dldCBhIChnZXRfcG9zIGEgbGVuX3NvX2ZhcikpXG4gICAgICAgICAgICAgICh1bnNhZmVfZ2V0IGIgKGdldF9wb3MgYiBsZW5fc29fZmFyKSlcbiAgICB0aGVuIGNvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcCBhIGIgfmdldF9wb3Mgfm1heF9sZW4gfmxlbl9zb19mYXI6KGxlbl9zb19mYXIgKyAxKVxuICAgIGVsc2UgbGVuX3NvX2ZhclxuICA7O1xuXG4gIGxldCBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3BvcyA9XG4gICAgbGV0IG1heF9sZW4gPSBtaW4gKGxlbmd0aCBhKSAobGVuZ3RoIGIpIGluXG4gICAgY29tbW9uX2dlbmVyaWMyX2xlbmd0aF9sb29wIGEgYiB+Z2V0X3BvcyB+bWF4X2xlbiB+bGVuX3NvX2ZhcjowXG4gIDs7XG5cbiAgbGV0IHJlYyBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBmaXJzdCBsaXN0IH5nZXRfcG9zIH5tYXhfbGVuID1cbiAgICBtYXRjaCBsaXN0IHdpdGhcbiAgICB8IFtdIC0+IG1heF9sZW5cbiAgICB8IHNlY29uZCA6OiByZXN0IC0+XG4gICAgICBsZXQgbWF4X2xlbiA9XG4gICAgICAgICgqIFdlIGNhbGwgW2NvbW1vbl9nZW5lcmljMl9sZW5ndGhfbG9vcF0gcmF0aGVyIHRoYW4gW2NvbW1vbl9nZW5lcmljMl9sZW5ndGhdIHNvXG4gICAgICAgICAgIHRoYXQgW21heF9sZW5dIGxpbWl0cyBvdXIgdHJhdmVyc2FsIG9mIFtmaXJzdF0gYW5kIFtzZWNvbmRdLiAqKVxuICAgICAgICBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoX2xvb3AgZmlyc3Qgc2Vjb25kIH5nZXRfcG9zIH5tYXhfbGVuIH5sZW5fc29fZmFyOjBcbiAgICAgIGluXG4gICAgICBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBzZWNvbmQgcmVzdCB+Z2V0X3BvcyB+bWF4X2xlblxuICA7O1xuXG4gIGxldCBjb21tb25fZ2VuZXJpY19sZW5ndGggbGlzdCB+Z2V0X3BvcyA9XG4gICAgbWF0Y2ggbGlzdCB3aXRoXG4gICAgfCBbXSAtPiAwXG4gICAgfCBmaXJzdCA6OiByZXN0IC0+XG4gICAgICAoKiBQcmVjb21wdXRpbmcgW21heF9sZW5dIGJhc2VkIG9uIFtzaG9ydGVzdCBsaXN0XSBzYXZlcyB1cyB3b3JrIGluIGxvbmdlciBzdHJpbmdzLFxuICAgICAgICAgYXQgdGhlIGNvc3Qgb2YgYW4gZXh0cmEgcGFzcyBvdmVyIHRoZSBzcGluZSBvZiBbbGlzdF0uXG5cbiAgICAgICAgIEZvciBleGFtcGxlLCBpZiB5b3UncmUgbG9va2luZyBmb3IgdGhlIGxvbmdlc3QgcHJlZml4IG9mIHRoZSBzdHJpbmdzOlxuXG4gICAgICAgICB7dlxuICAgICAgICAgICAgbGV0IGxvbmdfYSA9IExpc3QuaW5pdCAxMDAwIH5mOihGbi5jb25zdCAnYScpXG4gICAgICAgICAgICBbIGxvbmdfYTsgbG9uZ19hOyAnYWEnIF1cbiAgICAgICAgIHZ9XG5cbiAgICAgICAgIHRoZSBhcHByb2FjaCBiZWxvdyB3aWxsIGp1c3QgY2hlY2sgdGhlIGZpcnN0IHR3byBjaGFyYWN0ZXJzIG9mIGFsbCB0aGUgc3RyaW5ncy5cbiAgICAgICopXG4gICAgICBsZXQgbWF4X2xlbiA9IGxlbmd0aCAoc2hvcnRlc3QgbGlzdCkgaW5cbiAgICAgIGNvbW1vbl9nZW5lcmljX2xlbmd0aF9sb29wIGZpcnN0IHJlc3QgfmdldF9wb3Mgfm1heF9sZW5cbiAgOztcblxuICAoKiBPdXIgZ2VuZXJpYyBhY2Nlc3NvcnMgdGhhdCBwcm9kdWNlIGEgc3RyaW5nIGFic3RyYWN0IG92ZXIgW3Rha2VdLCB3aGljaCBpcyBlaXRoZXJcbiAgICAgW3ByZWZpeF0gb3IgW3N1ZmZpeF0uICopXG5cbiAgbGV0IGNvbW1vbl9nZW5lcmljMiBhIGIgfmdldF9wb3MgfnRha2UgPVxuICAgIGxldCBsZW4gPSBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3BvcyBpblxuICAgICgqIFVzZSB0aGUgc2hvcnRlciBvZiB0aGUgdHdvIHN0cmluZ3MsIHNvIHRoYXQgaWYgdGhlIHNob3J0ZXIgb25lIGlzIHRoZSBzaGFyZWRcbiAgICAgICBwcmVmaXgsIFt0YWtlXSB3b24ndCBhbGxvY2F0ZSBhbm90aGVyIHN0cmluZy4gKilcbiAgICB0YWtlIChzaG9ydGVyIGEgYikgbGVuXG4gIDs7XG5cbiAgbGV0IGNvbW1vbl9nZW5lcmljIGxpc3QgfmdldF9wb3MgfnRha2UgPVxuICAgIG1hdGNoIGxpc3Qgd2l0aFxuICAgIHwgW10gLT4gXCJcIlxuICAgIHwgZmlyc3QgOjogcmVzdCAtPlxuICAgICAgKCogQXMgd2l0aCBbY29tbW9uX2dlbmVyaWNfbGVuZ3RoXSwgd2UgYmFzZSBbbWF4X2xlbl0gb24gW3Nob3J0ZXN0IGxpc3RdLiBXZSBhbHNvXG4gICAgICAgICB1c2UgdGhpcyByZXN1bHQgZm9yIFt0YWtlXSwgYmVsb3csIHRvIHBvdGVudGlhbGx5IGF2b2lkIGFsbG9jYXRpbmcgYSBzdHJpbmcuICopXG4gICAgICBsZXQgcyA9IHNob3J0ZXN0IGxpc3QgaW5cbiAgICAgIGxldCBtYXhfbGVuID0gbGVuZ3RoIHMgaW5cbiAgICAgIGlmIG1heF9sZW4gPSAwXG4gICAgICB0aGVuIFwiXCJcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgbGVuID1cbiAgICAgICAgICAoKiBXZSBjYWxsIGRpcmVjdGx5IGludG8gW2NvbW1vbl9nZW5lcmljX2xlbmd0aF9sb29wXSByYXRoZXIgdGhhblxuICAgICAgICAgICAgIFtjb21tb25fZ2VuZXJpY19sZW5ndGhdIHRvIGF2b2lkIHJlY29tcHV0aW5nIFtzaG9ydGVzdCBsaXN0XS4gKilcbiAgICAgICAgICBjb21tb25fZ2VuZXJpY19sZW5ndGhfbG9vcCBmaXJzdCByZXN0IH5nZXRfcG9zIH5tYXhfbGVuXG4gICAgICAgIGluXG4gICAgICAgIHRha2UgcyBsZW4pXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBzdHJ1Y3RcbiAgb3BlbiBGb3JfY29tbW9uX3ByZWZpeF9hbmRfc3VmZml4XG5cbiAgbGV0IGNvbW1vbl9wcmVmaXggbGlzdCA9IGNvbW1vbl9nZW5lcmljIGxpc3QgfnRha2U6cHJlZml4IH5nZXRfcG9zOnBvc19mcm9tX2xlZnRcbiAgbGV0IGNvbW1vbl9zdWZmaXggbGlzdCA9IGNvbW1vbl9nZW5lcmljIGxpc3QgfnRha2U6c3VmZml4IH5nZXRfcG9zOnBvc19mcm9tX3JpZ2h0XG4gIGxldCBjb21tb25fcHJlZml4MiBhIGIgPSBjb21tb25fZ2VuZXJpYzIgYSBiIH50YWtlOnByZWZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9sZWZ0XG4gIGxldCBjb21tb25fc3VmZml4MiBhIGIgPSBjb21tb25fZ2VuZXJpYzIgYSBiIH50YWtlOnN1ZmZpeCB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuICBsZXQgY29tbW9uX3ByZWZpeF9sZW5ndGggbGlzdCA9IGNvbW1vbl9nZW5lcmljX2xlbmd0aCBsaXN0IH5nZXRfcG9zOnBvc19mcm9tX2xlZnRcbiAgbGV0IGNvbW1vbl9zdWZmaXhfbGVuZ3RoIGxpc3QgPSBjb21tb25fZ2VuZXJpY19sZW5ndGggbGlzdCB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuICBsZXQgY29tbW9uX3ByZWZpeDJfbGVuZ3RoIGEgYiA9IGNvbW1vbl9nZW5lcmljMl9sZW5ndGggYSBiIH5nZXRfcG9zOnBvc19mcm9tX2xlZnRcbiAgbGV0IGNvbW1vbl9zdWZmaXgyX2xlbmd0aCBhIGIgPSBjb21tb25fZ2VuZXJpYzJfbGVuZ3RoIGEgYiB+Z2V0X3Bvczpwb3NfZnJvbV9yaWdodFxuZW5kXG5cbigqIFRoZXJlIHVzZWQgdG8gYmUgYSBjdXN0b20gaW1wbGVtZW50YXRpb24gdGhhdCB3YXMgZmFzdGVyIGZvciB2ZXJ5IHNob3J0IHN0cmluZ3NcbiAgIChwZWFraW5nIGF0IDQwJSBmYXN0ZXIgZm9yIDQtNiBjaGFyIGxvbmcgc3RyaW5ncykuXG4gICBUaGlzIG5ldyBmdW5jdGlvbiBpcyBhcm91bmQgMjAlIGZhc3RlciB0aGFuIHRoZSBkZWZhdWx0IGhhc2ggZnVuY3Rpb24sIGJ1dCBzbG93ZXJcbiAgIHRoYW4gdGhlIHByZXZpb3VzIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi4gSG93ZXZlciwgdGhlIG5ldyBPQ2FtbCBmdW5jdGlvbiBpcyB3ZWxsXG4gICBiZWhhdmVkLCBhbmQgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBsZXNzIGxpa2VseSB0byBkaXZlcmdlIGZyb20gdGhlIGRlZmF1bHQgT0NhbWxcbiAgIGltcGxlbWVudGF0aW9uIGRvZXMsIHdoaWNoIGlzIGEgZGVzaXJhYmxlIHByb3BlcnR5LiAoVGhlIG9ubHkgd2F5IHRvIGF2b2lkIHRoZVxuICAgZGl2ZXJnZW5jZSBpcyB0byBleHBvc2UgdGhlIG1hY3JvIHJlZGVmaW5lZCBpbiBoYXNoX3N0dWJzLmMgaW4gdGhlIGhhc2guaCBoZWFkZXIgb2ZcbiAgIHRoZSBPQ2FtbCBjb21waWxlci4pICopXG5tb2R1bGUgSGFzaCA9IHN0cnVjdFxuICBleHRlcm5hbCBoYXNoIDogc3RyaW5nIC0+IGludCA9IFwiQmFzZV9oYXNoX3N0cmluZ1wiIFtAQG5vYWxsb2NdXG5lbmRcblxuKCogW2luY2x1ZGUgSGFzaF0gdG8gbWFrZSB0aGUgW2V4dGVybmFsXSB2ZXJzaW9uIG92ZXJyaWRlIHRoZSBbaGFzaF0gZnJvbVxuICAgW0hhc2hhYmxlLk1ha2VfYmluYWJsZV0sIHNvIHRoYXQgd2UgZ2V0IGEgbGl0dGxlIGJpdCBvZiBhIHNwZWVkdXAgYnkgZXhwb3NpbmcgaXQgYXNcbiAgIGV4dGVybmFsIGluIHRoZSBtbGkuICopXG5sZXQgXyA9IGhhc2hcblxuaW5jbHVkZSBIYXNoXG5cbigqIGZvciBpbnRlcmFjdGl2ZSB0b3AtbGV2ZWxzIC0tIG1vZHVsZXMgZGVyaXZpbmcgZnJvbSBTdHJpbmcgc2hvdWxkIGhhdmUgU3RyaW5nJ3MgcHJldHR5XG4gICBwcmludGVyLiAqKVxubGV0IHBwIHBwZiBzdHJpbmcgPSBDYW1sLkZvcm1hdC5mcHJpbnRmIHBwZiBcIiVTXCIgc3RyaW5nXG5sZXQgb2ZfY2hhciBjID0gbWFrZSAxIGNcblxubGV0IG9mX2NoYXJfbGlzdCBsID1cbiAgbGV0IHQgPSBCeXRlcy5jcmVhdGUgKExpc3QubGVuZ3RoIGwpIGluXG4gIExpc3QuaXRlcmkgbCB+ZjooZnVuIGkgYyAtPiBCeXRlcy5zZXQgdCBpIGMpO1xuICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOnRcbjs7XG5cbm1vZHVsZSBFc2NhcGluZyA9IHN0cnVjdFxuICAoKiBJZiB0aGlzIGlzIGNoYW5nZWQsIG1ha2Ugc3VyZSB0byB1cGRhdGUgW2VzY2FwZV0sIHdoaWNoIGF0dGVtcHRzIHRvIGVuc3VyZSBhbGwgdGhlXG4gICAgIGludmFyaWFudHMgY2hlY2tlZCBoZXJlLiAgKilcbiAgbGV0IGJ1aWxkX2FuZF92YWxpZGF0ZV9lc2NhcGV3b3J0aHlfbWFwIGVzY2FwZXdvcnRoeV9tYXAgZXNjYXBlX2NoYXIgZnVuYyA9XG4gICAgbGV0IGVzY2FwZXdvcnRoeV9tYXAgPVxuICAgICAgaWYgTGlzdC5Bc3NvYy5tZW0gZXNjYXBld29ydGh5X21hcCB+ZXF1YWw6Q2hhci5lcXVhbCBlc2NhcGVfY2hhclxuICAgICAgdGhlbiBlc2NhcGV3b3J0aHlfbWFwXG4gICAgICBlbHNlIChlc2NhcGVfY2hhciwgZXNjYXBlX2NoYXIpIDo6IGVzY2FwZXdvcnRoeV9tYXBcbiAgICBpblxuICAgIGxldCBhcnIgPSBBcnJheS5jcmVhdGUgfmxlbjoyNTYgKC0xKSBpblxuICAgIGxldCB2YWxzID0gQXJyYXkuY3JlYXRlIH5sZW46MjU2IGZhbHNlIGluXG4gICAgbGV0IHJlYyBsb29wID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gT2sgYXJyXG4gICAgICB8IChjX2Zyb20sIGNfdG8pIDo6IGwgLT5cbiAgICAgICAgbGV0IGssIHYgPVxuICAgICAgICAgIG1hdGNoIGZ1bmMgd2l0aFxuICAgICAgICAgIHwgYEVzY2FwZSAtPiBDaGFyLnRvX2ludCBjX2Zyb20sIGNfdG9cbiAgICAgICAgICB8IGBVbmVzY2FwZSAtPiBDaGFyLnRvX2ludCBjX3RvLCBjX2Zyb21cbiAgICAgICAgaW5cbiAgICAgICAgaWYgYXJyLihrKSA8PiAtMSB8fCB2YWxzLihDaGFyLnRvX2ludCB2KVxuICAgICAgICB0aGVuXG4gICAgICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgICAgXCJlc2NhcGV3b3J0aHlfbWFwIG5vdCBvbmUtdG8tb25lXCJcbiAgICAgICAgICAgICAgIFsgXCJjX2Zyb21cIiwgc2V4cF9vZl9jaGFyIGNfZnJvbVxuICAgICAgICAgICAgICAgOyBcImNfdG9cIiwgc2V4cF9vZl9jaGFyIGNfdG9cbiAgICAgICAgICAgICAgIDsgKCBcImVzY2FwZXdvcnRoeV9tYXBcIlxuICAgICAgICAgICAgICAgICAsIHNleHBfb2ZfbGlzdCAoc2V4cF9vZl9wYWlyIHNleHBfb2ZfY2hhciBzZXhwX29mX2NoYXIpIGVzY2FwZXdvcnRoeV9tYXBcbiAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgXSlcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgYXJyLihrKSA8LSBDaGFyLnRvX2ludCB2O1xuICAgICAgICAgIHZhbHMuKENoYXIudG9faW50IHYpIDwtIHRydWU7XG4gICAgICAgICAgbG9vcCBsKVxuICAgIGluXG4gICAgbG9vcCBlc2NhcGV3b3J0aHlfbWFwXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBidWlsZF9hbmRfdmFsaWRhdGVfZXNjYXBld29ydGh5X21hcCBlc2NhcGV3b3J0aHlfbWFwIGVzY2FwZV9jaGFyIGBFc2NhcGUgd2l0aFxuICAgIHwgRXJyb3IgXyBhcyB4IC0+IHhcbiAgICB8IE9rIGVzY2FwZXdvcnRoeSAtPlxuICAgICAgT2tcbiAgICAgICAgKGZ1biBzcmMgLT5cbiAgICAgICAgICAgKCogY2FsY3VsYXRlIGEgbGlzdCBvZiAoaW5kZXggb2YgY2hhciB0byBlc2NhcGUgKiBlc2NhcGVkIGNoYXIpIGZpcnN0LCB0aGUgb3JkZXJcbiAgICAgICAgICAgICAgaXMgZnJvbSB0YWlsIHRvIGhlYWQgKilcbiAgICAgICAgICAgbGV0IHRvX2VzY2FwZV9sZW4gPSByZWYgMCBpblxuICAgICAgICAgICBsZXQgdG9fZXNjYXBlID1cbiAgICAgICAgICAgICBmb2xkaSBzcmMgfmluaXQ6W10gfmY6KGZ1biBpIGFjYyBjIC0+XG4gICAgICAgICAgICAgICBtYXRjaCBlc2NhcGV3b3J0aHkuKENoYXIudG9faW50IGMpIHdpdGhcbiAgICAgICAgICAgICAgIHwgLTEgLT4gYWNjXG4gICAgICAgICAgICAgICB8IG4gLT5cbiAgICAgICAgICAgICAgICAgKCogKGluZGV4IG9mIGNoYXIgdG8gZXNjYXBlICogZXNjYXBlZCBjaGFyKSAqKVxuICAgICAgICAgICAgICAgICBpbmNyIHRvX2VzY2FwZV9sZW47XG4gICAgICAgICAgICAgICAgIChpLCBDaGFyLnVuc2FmZV9vZl9pbnQgbikgOjogYWNjKVxuICAgICAgICAgICBpblxuICAgICAgICAgICBtYXRjaCB0b19lc2NhcGUgd2l0aFxuICAgICAgICAgICB8IFtdIC0+IHNyY1xuICAgICAgICAgICB8IF8gLT5cbiAgICAgICAgICAgICAoKiBbdG9fZXNjYXBlXSBkaXZpZGUgW3NyY10gdG8gW0xpc3QubGVuZ3RoIHRvX2VzY2FwZSArIDFdIHBpZWNlcyBzZXBhcmF0ZWQgYnlcbiAgICAgICAgICAgICAgICB0aGUgY2hhcnMgdG8gZXNjYXBlLlxuXG4gICAgICAgICAgICAgICAgTGV0cyB0YWtlXG4gICAgICAgICAgICAgICAge1tcbiAgICAgICAgICAgICAgICAgIGVzY2FwZV9nZW5fZXhuXG4gICAgICAgICAgICAgICAgICAgIH5lc2NhcGV3b3J0aHlfbWFwOlsoJ2EnLCAnQScpOyAoJ2InLCAnQicpOyAoJ2MnLCAnQycpXVxuICAgICAgICAgICAgICAgICAgICB+ZXNjYXBlX2NoYXI6J18nXG4gICAgICAgICAgICAgICAgXX1cbiAgICAgICAgICAgICAgICBmb3IgZXhhbXBsZSwgYW5kIGFzc3VtZSB0aGUgc3RyaW5nIHRvIGVzY2FwZSBpc1xuXG4gICAgICAgICAgICAgICAgXCIwMDBhMTExYjIyMmMzMzNcIlxuXG4gICAgICAgICAgICAgICAgdGhlbiBbdG9fZXNjYXBlXSBpcyBbKDExLCAnQycpOyAoNywgJ0InKTsgKDMsICdBJyldLlxuXG4gICAgICAgICAgICAgICAgVGhlbiB3ZSBjcmVhdGUgYSBbZHN0XSBvZiBsZW5ndGggW2xlbmd0aCBzcmMgKyAzXSB0byBzdG9yZSB0aGVcbiAgICAgICAgICAgICAgICByZXN1bHQsIGNvcHkgcGllY2UgXCIzMzNcIiB0byBbZHN0XSBkaXJlY3RseSwgdGhlbiBjb3B5ICdfJyBhbmQgJ0MnIHRvIFtkc3RdO1xuICAgICAgICAgICAgICAgIHRoZW4gbW92ZSBvbiB0byBuZXh0OyBhZnRlciAzIGl0ZXJhdGlvbnMsIGNvcHkgcGllY2UgXCIwMDBcIiBhbmQgd2UgYXJlIGRvbmUuXG5cbiAgICAgICAgICAgICAgICBGaW5hbGx5IHRoZSByZXN1bHQgd2lsbCBiZVxuXG4gICAgICAgICAgICAgICAgXCIwMDBfQTExMV9CMjIyX0MzMzNcIiAqKVxuICAgICAgICAgICAgIGxldCBzcmNfbGVuID0gbGVuZ3RoIHNyYyBpblxuICAgICAgICAgICAgIGxldCBkc3RfbGVuID0gc3JjX2xlbiArICF0b19lc2NhcGVfbGVuIGluXG4gICAgICAgICAgICAgbGV0IGRzdCA9IEJ5dGVzLmNyZWF0ZSBkc3RfbGVuIGluXG4gICAgICAgICAgICAgbGV0IHJlYyBsb29wIGxhc3RfaWR4IGxhc3RfZHN0X3BvcyA9IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgICAgICAgICgqIGNvcHkgXCIwMDBcIiBhdCBsYXN0ICopXG4gICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOjAgfmxlbjpsYXN0X2lkeFxuICAgICAgICAgICAgICAgfCAoaWR4LCBlc2NhcGVkX2NoYXIpIDo6IHRvX2VzY2FwZSAtPlxuICAgICAgICAgICAgICAgICAoKltpZHhdID0gdGhlIGNoYXIgdG8gZXNjYXBlKilcbiAgICAgICAgICAgICAgICAgKCogdGFrZSBmaXJzdCBpdGVyYXRpb24gZm9yIGV4YW1wbGUgKilcbiAgICAgICAgICAgICAgICAgKCogY2FsY3VsYXRlIGxlbmd0aCBvZiBcIjMzM1wiLCBtaW51cyAxIGJlY2F1c2Ugd2UgZG9uJ3QgY29weSAnYycgKilcbiAgICAgICAgICAgICAgICAgbGV0IGxlbiA9IGxhc3RfaWR4IC0gaWR4IC0gMSBpblxuICAgICAgICAgICAgICAgICAoKiBzZXQgdGhlIGRzdF9wb3MgdG8gY29weSB0byAqKVxuICAgICAgICAgICAgICAgICBsZXQgZHN0X3BvcyA9IGxhc3RfZHN0X3BvcyAtIGxlbiBpblxuICAgICAgICAgICAgICAgICAoKiBjb3B5IFwiMzMzXCIsIHNldCBbc3JjX3Bvc10gdG8gW2lkeCArIDFdIHRvIHNraXAgJ2MnICopXG4gICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6KGlkeCArIDEpIH5kc3QgfmRzdF9wb3MgfmxlbjtcbiAgICAgICAgICAgICAgICAgKCogYmFja29mZiBbZHN0X3Bvc10gYnkgMiB0byBjb3B5ICdfJyBhbmQgJ0MnICopXG4gICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gZHN0X3BvcyAtIDIgaW5cbiAgICAgICAgICAgICAgICAgQnl0ZXMuc2V0IGRzdCBkc3RfcG9zIGVzY2FwZV9jaGFyO1xuICAgICAgICAgICAgICAgICBCeXRlcy5zZXQgZHN0IChkc3RfcG9zICsgMSkgZXNjYXBlZF9jaGFyO1xuICAgICAgICAgICAgICAgICBsb29wIGlkeCBkc3RfcG9zIHRvX2VzY2FwZVxuICAgICAgICAgICAgIGluXG4gICAgICAgICAgICAgKCogc2V0IFtsYXN0X2RzdF9wb3NdIGFuZCBbbGFzdF9pZHhdIHRvIGxlbmd0aCBvZiBbZHN0XSBhbmQgW3NyY10gZmlyc3QgKilcbiAgICAgICAgICAgICBsb29wIHNyY19sZW4gZHN0X2xlbiB0b19lc2NhcGU7XG4gICAgICAgICAgICAgQnl0ZXMudW5zYWZlX3RvX3N0cmluZyB+bm9fbXV0YXRpb25fd2hpbGVfc3RyaW5nX3JlYWNoYWJsZTpkc3QpXG4gIDs7XG5cbiAgbGV0IGVzY2FwZV9nZW5fZXhuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhciA9XG4gICAgT3JfZXJyb3Iub2tfZXhuIChlc2NhcGVfZ2VuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhcikgfD4gc3RhZ2VcbiAgOztcblxuICBsZXQgZXNjYXBlIH5lc2NhcGV3b3J0aHkgfmVzY2FwZV9jaGFyID1cbiAgICAoKiBGb3IgW2VzY2FwZV9nZW5fZXhuXSwgd2UgZG9uJ3Qga25vdyBob3cgdG8gZml4IGludmFsaWQgZXNjYXBld29ydGh5X21hcCBzbyB3ZSBoYXZlXG4gICAgICAgdG8gcmFpc2UgZXhjZXB0aW9uOyBidXQgaW4gdGhpcyBjYXNlLCB3ZSBrbm93IGhvdyB0byBmaXggZHVwbGljYXRlZCBlbGVtZW50cyBpblxuICAgICAgIGVzY2FwZXdvcnRoeSBsaXN0LCBzbyB3ZSBqdXN0IGZpeCBpdCBpbnN0ZWFkIG9mIHJhaXNpbmcgZXhjZXB0aW9uIHRvIG1ha2UgdGhpc1xuICAgICAgIGZ1bmN0aW9uIGVhc2llciB0byB1c2UuICAqKVxuICAgIGxldCBlc2NhcGV3b3J0aHlfbWFwID1cbiAgICAgIGVzY2FwZXdvcnRoeVxuICAgICAgfD4gTGlzdC5kZWR1cF9hbmRfc29ydCB+Y29tcGFyZTpDaGFyLmNvbXBhcmVcbiAgICAgIHw+IExpc3QubWFwIH5mOihmdW4gYyAtPiBjLCBjKVxuICAgIGluXG4gICAgZXNjYXBlX2dlbl9leG4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyXG4gIDs7XG5cbiAgKCogSW4gYW4gZXNjYXBlZCBzdHJpbmcsIGFueSBjaGFyIGlzIGVpdGhlciBgRXNjYXBpbmcsIGBFc2NhcGVkIG9yIGBMaXRlcmFsLiBGb3JcbiAgICAgZXhhbXBsZSwgdGhlIGVzY2FwZSBzdGF0dXNlcyBvZiBjaGFycyBpbiBzdHJpbmcgXCJhX2FfX1wiIHdpdGggZXNjYXBlX2NoYXIgPSAnXycgYXJlXG5cbiAgICAgYSA6IGBMaXRlcmFsXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgYSA6IGBFc2NhcGVkXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgXyA6IGBFc2NhcGVkXG5cbiAgICAgW3VwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSBwcmV2aW91c19zdGF0dXNdIGdldHMgZXNjYXBlIHN0YXR1cyBvZlxuICAgICBzdHIuW2ldIGJhc2luZyBvbiBlc2NhcGUgc3RhdHVzIG9mIHN0ci5baSAtIDFdICopXG4gIGxldCB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgPSBmdW5jdGlvblxuICAgIHwgYEVzY2FwaW5nIC0+IGBFc2NhcGVkXG4gICAgfCBgTGl0ZXJhbCB8IGBFc2NhcGVkIC0+XG4gICAgICBpZiBDaGFyLmVxdWFsIHN0ci5baV0gZXNjYXBlX2NoYXIgdGhlbiBgRXNjYXBpbmcgZWxzZSBgTGl0ZXJhbFxuICA7O1xuXG4gIGxldCB1bmVzY2FwZV9nZW4gfmVzY2FwZXdvcnRoeV9tYXAgfmVzY2FwZV9jaGFyID1cbiAgICBtYXRjaCBidWlsZF9hbmRfdmFsaWRhdGVfZXNjYXBld29ydGh5X21hcCBlc2NhcGV3b3J0aHlfbWFwIGVzY2FwZV9jaGFyIGBVbmVzY2FwZSB3aXRoXG4gICAgfCBFcnJvciBfIGFzIHggLT4geFxuICAgIHwgT2sgZXNjYXBld29ydGh5IC0+XG4gICAgICBPa1xuICAgICAgICAoZnVuIHNyYyAtPlxuICAgICAgICAgICAoKiBDb250aW51ZSB0aGUgZXhhbXBsZSBpbiBbZXNjYXBlX2dlbl9leG5dLCBub3cgd2UgdW5lc2NhcGVcblxuICAgICAgICAgICAgICBcIjAwMF9BMTExX0IyMjJfQzMzM1wiXG5cbiAgICAgICAgICAgICAgYmFjayB0b1xuXG4gICAgICAgICAgICAgIFwiMDAwYTExMWIyMjJjMzMzXCJcblxuICAgICAgICAgICAgICBUaGVuIFt0b191bmVzY2FwZV0gaXMgWzE0OyA5OyA0XSwgd2hpY2ggaXMgaW5kZXhlcyBvZiAnXydzLlxuXG4gICAgICAgICAgICAgIFRoZW4gd2UgY3JlYXRlIGEgc3RyaW5nIFtkc3RdIHRvIHN0b3JlIHRoZSByZXN1bHQsIGNvcHkgXCIzMzNcIiB0byBpdCwgdGhlbiBjb3B5XG4gICAgICAgICAgICAgICdjJywgdGhlbiBtb3ZlIG9uIHRvIG5leHQgaXRlcmF0aW9uLiBBZnRlciAzIGl0ZXJhdGlvbnMgY29weSBcIjAwMFwiIGFuZCB3ZSBhcmVcbiAgICAgICAgICAgICAgZG9uZS4gICopXG4gICAgICAgICAgICgqIGluZGV4ZXMgb2YgZXNjYXBlIGNoYXJzICopXG4gICAgICAgICAgIGxldCB0b191bmVzY2FwZSA9XG4gICAgICAgICAgICAgbGV0IHJlYyBsb29wIGkgc3RhdHVzIGFjYyA9XG4gICAgICAgICAgICAgICBpZiBpID49IGxlbmd0aCBzcmNcbiAgICAgICAgICAgICAgIHRoZW4gYWNjXG4gICAgICAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgICAgICAgbGV0IHN0YXR1cyA9IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHNyYyB+ZXNjYXBlX2NoYXIgaSBzdGF0dXMgaW5cbiAgICAgICAgICAgICAgICAgbG9vcFxuICAgICAgICAgICAgICAgICAgIChpICsgMSlcbiAgICAgICAgICAgICAgICAgICBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICAobWF0Y2ggc3RhdHVzIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgfCBgRXNjYXBpbmcgLT4gaSA6OiBhY2NcbiAgICAgICAgICAgICAgICAgICAgfCBgRXNjYXBlZCB8IGBMaXRlcmFsIC0+IGFjYykpXG4gICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICBsb29wIDAgYExpdGVyYWwgW11cbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgbWF0Y2ggdG9fdW5lc2NhcGUgd2l0aFxuICAgICAgICAgICB8IFtdIC0+IHNyY1xuICAgICAgICAgICB8IGlkeCA6OiB0b191bmVzY2FwZScgLT5cbiAgICAgICAgICAgICBsZXQgZHN0ID0gQnl0ZXMuY3JlYXRlIChsZW5ndGggc3JjIC0gTGlzdC5sZW5ndGggdG9fdW5lc2NhcGUpIGluXG4gICAgICAgICAgICAgbGV0IHJlYyBsb29wIGxhc3RfaWR4IGxhc3RfZHN0X3BvcyA9IGZ1bmN0aW9uXG4gICAgICAgICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgICAgICAgICgqIGNvcHkgXCIwMDBcIiBhdCBsYXN0ICopXG4gICAgICAgICAgICAgICAgIEJ5dGVzLmJsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOjAgfmxlbjpsYXN0X2lkeFxuICAgICAgICAgICAgICAgfCBpZHggOjogdG9fdW5lc2NhcGUgLT5cbiAgICAgICAgICAgICAgICAgKCogW2lkeF0gPSBpbmRleCBvZiBlc2NhcGluZyBjaGFyICopXG4gICAgICAgICAgICAgICAgICgqIHRha2UgMXN0IGl0ZXJhdGlvbiBhcyBleGFtcGxlLCBjYWxjdWxhdGUgdGhlIGxlbmd0aCBvZiBcIjMzM1wiLCBtaW51cyAyIHRvXG4gICAgICAgICAgICAgICAgICAgIHNraXAgJ19DJyAqKVxuICAgICAgICAgICAgICAgICBsZXQgbGVuID0gbGFzdF9pZHggLSBpZHggLSAyIGluXG4gICAgICAgICAgICAgICAgICgqIHBvaW50IFtkc3RfcG9zXSB0byB0aGUgcG9zaXRpb24gdG8gY29weSBcIjMzM1wiIHRvICopXG4gICAgICAgICAgICAgICAgIGxldCBkc3RfcG9zID0gbGFzdF9kc3RfcG9zIC0gbGVuIGluXG4gICAgICAgICAgICAgICAgICgqIGNvcHkgXCIzMzNcIiAqKVxuICAgICAgICAgICAgICAgICBCeXRlcy5ibGl0X3N0cmluZyB+c3JjIH5zcmNfcG9zOihpZHggKyAyKSB+ZHN0IH5kc3RfcG9zIH5sZW47XG4gICAgICAgICAgICAgICAgICgqIGJhY2tvZmYgW2RzdF9wb3NdIGJ5IDEgdG8gY29weSAnYycgKilcbiAgICAgICAgICAgICAgICAgbGV0IGRzdF9wb3MgPSBkc3RfcG9zIC0gMSBpblxuICAgICAgICAgICAgICAgICBCeXRlcy5zZXRcbiAgICAgICAgICAgICAgICAgICBkc3RcbiAgICAgICAgICAgICAgICAgICBkc3RfcG9zXG4gICAgICAgICAgICAgICAgICAgKG1hdGNoIGVzY2FwZXdvcnRoeS4oQ2hhci50b19pbnQgc3JjLltpZHggKyAxXSkgd2l0aFxuICAgICAgICAgICAgICAgICAgICB8IC0xIC0+IHNyYy5baWR4ICsgMV1cbiAgICAgICAgICAgICAgICAgICAgfCBuIC0+IENoYXIudW5zYWZlX29mX2ludCBuKTtcbiAgICAgICAgICAgICAgICAgKCogdXBkYXRlIFtsYXN0X2RzdF9wb3NdIGFuZCBbbGFzdF9pZHhdICopXG4gICAgICAgICAgICAgICAgIGxvb3AgaWR4IGRzdF9wb3MgdG9fdW5lc2NhcGVcbiAgICAgICAgICAgICBpblxuICAgICAgICAgICAgIGlmIGlkeCA8IGxlbmd0aCBzcmMgLSAxXG4gICAgICAgICAgICAgdGhlblxuICAgICAgICAgICAgICAgKCogc2V0IFtsYXN0X2RzdF9wb3NdIGFuZCBbbGFzdF9pZHhdIHRvIGxlbmd0aCBvZiBbZHN0XSBhbmQgW3NyY10gKilcbiAgICAgICAgICAgICAgIGxvb3AgKGxlbmd0aCBzcmMpIChCeXRlcy5sZW5ndGggZHN0KSB0b191bmVzY2FwZVxuICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICgqIGZvciBlc2NhcGVkIHN0cmluZyBlbmRpbmcgd2l0aCBhbiBlc2NhcGluZyBjaGFyIGxpa2UgXCIwMDBfXCIsIGp1c3QgaWdub3JlXG4gICAgICAgICAgICAgICAgICB0aGUgbGFzdCBlc2NhcGluZyBjaGFyICopXG4gICAgICAgICAgICAgICBsb29wIChsZW5ndGggc3JjIC0gMSkgKEJ5dGVzLmxlbmd0aCBkc3QpIHRvX3VuZXNjYXBlJztcbiAgICAgICAgICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOmRzdClcbiAgOztcblxuICBsZXQgdW5lc2NhcGVfZ2VuX2V4biB+ZXNjYXBld29ydGh5X21hcCB+ZXNjYXBlX2NoYXIgPVxuICAgIE9yX2Vycm9yLm9rX2V4biAodW5lc2NhcGVfZ2VuIH5lc2NhcGV3b3J0aHlfbWFwIH5lc2NhcGVfY2hhcikgfD4gc3RhZ2VcbiAgOztcblxuICBsZXQgdW5lc2NhcGUgfmVzY2FwZV9jaGFyID0gdW5lc2NhcGVfZ2VuX2V4biB+ZXNjYXBld29ydGh5X21hcDpbXSB+ZXNjYXBlX2NoYXJcblxuICBsZXQgcHJlY2VkaW5nX2VzY2FwZV9jaGFycyBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgbGV0IHJlYyBsb29wIHAgY250ID1cbiAgICAgIGlmIHAgPCAwIHx8IENoYXIuKCA8PiApIHN0ci5bcF0gZXNjYXBlX2NoYXIgdGhlbiBjbnQgZWxzZSBsb29wIChwIC0gMSkgKGNudCArIDEpXG4gICAgaW5cbiAgICBsb29wIChwb3MgLSAxKSAwXG4gIDs7XG5cbiAgKCogSW4gYW4gZXNjYXBlZCBzdHJpbmcsIGFueSBjaGFyIGlzIGVpdGhlciBgRXNjYXBpbmcsIGBFc2NhcGVkIG9yIGBMaXRlcmFsLiBGb3JcbiAgICAgZXhhbXBsZSwgdGhlIGVzY2FwZSBzdGF0dXNlcyBvZiBjaGFycyBpbiBzdHJpbmcgXCJhX2FfX1wiIHdpdGggZXNjYXBlX2NoYXIgPSAnXycgYXJlXG5cbiAgICAgYSA6IGBMaXRlcmFsXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgYSA6IGBFc2NhcGVkXG4gICAgIF8gOiBgRXNjYXBpbmdcbiAgICAgXyA6IGBFc2NhcGVkXG5cbiAgICAgW3VwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgaSBwcmV2aW91c19zdGF0dXNdIGdldHMgZXNjYXBlIHN0YXR1cyBvZlxuICAgICBzdHIuW2ldIGJhc2luZyBvbiBlc2NhcGUgc3RhdHVzIG9mIHN0ci5baSAtIDFdICopXG4gIGxldCB1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgPSBmdW5jdGlvblxuICAgIHwgYEVzY2FwaW5nIC0+IGBFc2NhcGVkXG4gICAgfCBgTGl0ZXJhbCB8IGBFc2NhcGVkIC0+XG4gICAgICBpZiBDaGFyLmVxdWFsIHN0ci5baV0gZXNjYXBlX2NoYXIgdGhlbiBgRXNjYXBpbmcgZWxzZSBgTGl0ZXJhbFxuICA7O1xuXG4gIGxldCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBsZXQgb2RkID0gcHJlY2VkaW5nX2VzY2FwZV9jaGFycyBzdHIgfmVzY2FwZV9jaGFyIHBvcyBtb2QgMiA9IDEgaW5cbiAgICBtYXRjaCBvZGQsIENoYXIuZXF1YWwgc3RyLltwb3NdIGVzY2FwZV9jaGFyIHdpdGhcbiAgICB8IHRydWUsICh0cnVlIHwgZmFsc2UpIC0+IGBFc2NhcGVkXG4gICAgfCBmYWxzZSwgdHJ1ZSAtPiBgRXNjYXBpbmdcbiAgICB8IGZhbHNlLCBmYWxzZSAtPiBgTGl0ZXJhbFxuICA7O1xuXG4gIGxldCBjaGVja19ib3VuZCBzdHIgcG9zIGZ1bmN0aW9uX25hbWUgPVxuICAgIGlmIHBvcyA+PSBsZW5ndGggc3RyIHx8IHBvcyA8IDAgdGhlbiBpbnZhbGlkX2FyZ2YgXCIlczogb3V0IG9mIGJvdW5kc1wiIGZ1bmN0aW9uX25hbWUgKClcbiAgOztcblxuICBsZXQgaXNfY2hhcl9lc2NhcGluZyBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImlzX2NoYXJfZXNjYXBpbmdcIjtcbiAgICBtYXRjaCBlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHdpdGhcbiAgICB8IGBFc2NhcGluZyAtPiB0cnVlXG4gICAgfCBgRXNjYXBlZCB8IGBMaXRlcmFsIC0+IGZhbHNlXG4gIDs7XG5cbiAgbGV0IGlzX2NoYXJfZXNjYXBlZCBzdHIgfmVzY2FwZV9jaGFyIHBvcyA9XG4gICAgY2hlY2tfYm91bmQgc3RyIHBvcyBcImlzX2NoYXJfZXNjYXBlZFwiO1xuICAgIG1hdGNoIGVzY2FwZV9zdGF0dXMgc3RyIH5lc2NhcGVfY2hhciBwb3Mgd2l0aFxuICAgIHwgYEVzY2FwZWQgLT4gdHJ1ZVxuICAgIHwgYEVzY2FwaW5nIHwgYExpdGVyYWwgLT4gZmFsc2VcbiAgOztcblxuICBsZXQgaXNfY2hhcl9saXRlcmFsIHN0ciB+ZXNjYXBlX2NoYXIgcG9zID1cbiAgICBjaGVja19ib3VuZCBzdHIgcG9zIFwiaXNfY2hhcl9saXRlcmFsXCI7XG4gICAgbWF0Y2ggZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIHBvcyB3aXRoXG4gICAgfCBgTGl0ZXJhbCAtPiB0cnVlXG4gICAgfCBgRXNjYXBlZCB8IGBFc2NhcGluZyAtPiBmYWxzZVxuICA7O1xuXG4gIGxldCBpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJpbmRleF9mcm9tXCI7XG4gICAgbGV0IHJlYyBsb29wIGkgc3RhdHVzID1cbiAgICAgIGlmIGkgPj0gcG9zXG4gICAgICAmJiAobWF0Y2ggc3RhdHVzIHdpdGhcbiAgICAgICAgICB8IGBMaXRlcmFsIC0+IHRydWVcbiAgICAgICAgICB8IGBFc2NhcGVkIHwgYEVzY2FwaW5nIC0+IGZhbHNlKVxuICAgICAgJiYgQ2hhci5lcXVhbCBzdHIuW2ldIGNoYXJcbiAgICAgIHRoZW4gU29tZSBpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGkgPSBpICsgMSBpblxuICAgICAgICBpZiBpID49IGxlbmd0aCBzdHJcbiAgICAgICAgdGhlbiBOb25lXG4gICAgICAgIGVsc2UgbG9vcCBpICh1cGRhdGVfZXNjYXBlX3N0YXR1cyBzdHIgfmVzY2FwZV9jaGFyIGkgc3RhdHVzKSlcbiAgICBpblxuICAgIGxvb3AgcG9zIChlc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zKVxuICA7O1xuXG4gIGxldCBpbmRleF9mcm9tX2V4biBzdHIgfmVzY2FwZV9jaGFyIHBvcyBjaGFyID1cbiAgICBtYXRjaCBpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiaW5kZXhfZnJvbV9leG46IG5vdCBmb3VuZFwiXG4gICAgICAgICAgIFsgXCJzdHJcIiwgc2V4cF9vZl90IHN0clxuICAgICAgICAgICA7IFwiZXNjYXBlX2NoYXJcIiwgc2V4cF9vZl9jaGFyIGVzY2FwZV9jaGFyXG4gICAgICAgICAgIDsgXCJwb3NcIiwgc2V4cF9vZl9pbnQgcG9zXG4gICAgICAgICAgIDsgXCJjaGFyXCIsIHNleHBfb2ZfY2hhciBjaGFyXG4gICAgICAgICAgIF0pXG4gICAgfCBTb21lIHBvcyAtPiBwb3NcbiAgOztcblxuICBsZXQgaW5kZXggc3RyIH5lc2NhcGVfY2hhciBjaGFyID0gaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIDAgY2hhclxuICBsZXQgaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9IGluZGV4X2Zyb21fZXhuIHN0ciB+ZXNjYXBlX2NoYXIgMCBjaGFyXG5cbiAgbGV0IHJpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgPVxuICAgIGNoZWNrX2JvdW5kIHN0ciBwb3MgXCJyaW5kZXhfZnJvbVwiO1xuICAgICgqIGlmIHRoZSB0YXJnZXQgY2hhciBpcyB0aGUgc2FtZSBhcyBbZXNjYXBlX2NoYXJdLCB3ZSBoYXZlIG5vIHdheSB0byBkZXRlcm1pbmUgd2hpY2hcbiAgICAgICBlc2NhcGVfY2hhciBpcyBsaXRlcmFsLCBzbyBqdXN0IHJldHVybiBOb25lICopXG4gICAgaWYgQ2hhci5lcXVhbCBjaGFyIGVzY2FwZV9jaGFyXG4gICAgdGhlbiBOb25lXG4gICAgZWxzZSAoXG4gICAgICBsZXQgcmVjIGxvb3AgcG9zID1cbiAgICAgICAgaWYgcG9zIDwgMFxuICAgICAgICB0aGVuIE5vbmVcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IGVzY2FwZV9jaGFycyA9IHByZWNlZGluZ19lc2NhcGVfY2hhcnMgc3RyIH5lc2NhcGVfY2hhciBwb3MgaW5cbiAgICAgICAgICBpZiBlc2NhcGVfY2hhcnMgbW9kIDIgPSAwICYmIENoYXIuZXF1YWwgc3RyLltwb3NdIGNoYXJcbiAgICAgICAgICB0aGVuIFNvbWUgcG9zXG4gICAgICAgICAgZWxzZSBsb29wIChwb3MgLSBlc2NhcGVfY2hhcnMgLSAxKSlcbiAgICAgIGluXG4gICAgICBsb29wIHBvcylcbiAgOztcblxuICBsZXQgcmluZGV4X2Zyb21fZXhuIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgPVxuICAgIG1hdGNoIHJpbmRleF9mcm9tIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIGNoYXIgd2l0aFxuICAgIHwgTm9uZSAtPlxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwicmluZGV4X2Zyb21fZXhuOiBub3QgZm91bmRcIlxuICAgICAgICAgICBbIFwic3RyXCIsIHNleHBfb2ZfdCBzdHJcbiAgICAgICAgICAgOyBcImVzY2FwZV9jaGFyXCIsIHNleHBfb2ZfY2hhciBlc2NhcGVfY2hhclxuICAgICAgICAgICA7IFwicG9zXCIsIHNleHBfb2ZfaW50IHBvc1xuICAgICAgICAgICA7IFwiY2hhclwiLCBzZXhwX29mX2NoYXIgY2hhclxuICAgICAgICAgICBdKVxuICAgIHwgU29tZSBwb3MgLT4gcG9zXG4gIDs7XG5cbiAgbGV0IHJpbmRleCBzdHIgfmVzY2FwZV9jaGFyIGNoYXIgPVxuICAgIGlmIGlzX2VtcHR5IHN0ciB0aGVuIE5vbmUgZWxzZSByaW5kZXhfZnJvbSBzdHIgfmVzY2FwZV9jaGFyIChsZW5ndGggc3RyIC0gMSkgY2hhclxuICA7O1xuXG4gIGxldCByaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgY2hhciA9XG4gICAgcmluZGV4X2Zyb21fZXhuIHN0ciB+ZXNjYXBlX2NoYXIgKGxlbmd0aCBzdHIgLSAxKSBjaGFyXG4gIDs7XG5cbiAgKCogW3NwbGl0X2dlbiBzdHIgfmVzY2FwZV9jaGFyIH5vbl0gd29ya3Mgc2ltaWxhcmx5IHRvIFtTdHJpbmcuc3BsaXRfZ2VuXSwgd2l0aCBhblxuICAgICBhZGRpdGlvbmFsIHJlcXVpcmVtZW50OiBvbmx5IHNwbGl0IG9uIGxpdGVyYWwgY2hhcnMsIG5vdCBlc2NhcGluZyBvciBlc2NhcGVkICopXG4gIGxldCBzcGxpdF9nZW4gc3RyIH5lc2NhcGVfY2hhciB+b24gPVxuICAgIGxldCBpc19kZWxpbSA9XG4gICAgICBtYXRjaCBvbiB3aXRoXG4gICAgICB8IGBjaGFyIGMnIC0+IGZ1biBjIC0+IENoYXIuZXF1YWwgYyBjJ1xuICAgICAgfCBgY2hhcl9saXN0IGwgLT4gZnVuIGMgLT4gY2hhcl9saXN0X21lbSBsIGNcbiAgICBpblxuICAgIGxldCBsZW4gPSBsZW5ndGggc3RyIGluXG4gICAgbGV0IHJlYyBsb29wIGFjYyBzdGF0dXMgbGFzdF9wb3MgcG9zID1cbiAgICAgIGlmIHBvcyA9IGxlblxuICAgICAgdGhlbiBMaXN0LnJldiAoc3ViIHN0ciB+cG9zOmxhc3RfcG9zIH5sZW46KGxlbiAtIGxhc3RfcG9zKSA6OiBhY2MpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHN0YXR1cyA9IHVwZGF0ZV9lc2NhcGVfc3RhdHVzIHN0ciB+ZXNjYXBlX2NoYXIgcG9zIHN0YXR1cyBpblxuICAgICAgICBpZiAobWF0Y2ggc3RhdHVzIHdpdGhcbiAgICAgICAgICB8IGBMaXRlcmFsIC0+IHRydWVcbiAgICAgICAgICB8IGBFc2NhcGVkIHwgYEVzY2FwaW5nIC0+IGZhbHNlKVxuICAgICAgICAmJiBpc19kZWxpbSBzdHIuW3Bvc11cbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHN1Yl9zdHIgPSBzdWIgc3RyIH5wb3M6bGFzdF9wb3MgfmxlbjoocG9zIC0gbGFzdF9wb3MpIGluXG4gICAgICAgICAgbG9vcCAoc3ViX3N0ciA6OiBhY2MpIHN0YXR1cyAocG9zICsgMSkgKHBvcyArIDEpKVxuICAgICAgICBlbHNlIGxvb3AgYWNjIHN0YXR1cyBsYXN0X3BvcyAocG9zICsgMSkpXG4gICAgaW5cbiAgICBsb29wIFtdIGBMaXRlcmFsIDAgMFxuICA7O1xuXG4gIGxldCBzcGxpdCBzdHIgfm9uID0gc3BsaXRfZ2VuIHN0ciB+b246KGBjaGFyIG9uKVxuICBsZXQgc3BsaXRfb25fY2hhcnMgc3RyIH5vbjpjaGFycyA9IHNwbGl0X2dlbiBzdHIgfm9uOihgY2hhcl9saXN0IGNoYXJzKVxuXG4gIGxldCBzcGxpdF9hdCBzdHIgcG9zID1cbiAgICBzdWIgc3RyIH5wb3M6MCB+bGVuOnBvcywgc3ViIHN0ciB+cG9zOihwb3MgKyAxKSB+bGVuOihsZW5ndGggc3RyIC0gcG9zIC0gMSlcbiAgOztcblxuICBsZXQgbHNwbGl0MiBzdHIgfm9uIH5lc2NhcGVfY2hhciA9XG4gICAgT3B0aW9uLm1hcCAoaW5kZXggc3RyIH5lc2NhcGVfY2hhciBvbikgfmY6KGZ1biB4IC0+IHNwbGl0X2F0IHN0ciB4KVxuICA7O1xuXG4gIGxldCByc3BsaXQyIHN0ciB+b24gfmVzY2FwZV9jaGFyID1cbiAgICBPcHRpb24ubWFwIChyaW5kZXggc3RyIH5lc2NhcGVfY2hhciBvbikgfmY6KGZ1biB4IC0+IHNwbGl0X2F0IHN0ciB4KVxuICA7O1xuXG4gIGxldCBsc3BsaXQyX2V4biBzdHIgfm9uIH5lc2NhcGVfY2hhciA9IHNwbGl0X2F0IHN0ciAoaW5kZXhfZXhuIHN0ciB+ZXNjYXBlX2NoYXIgb24pXG4gIGxldCByc3BsaXQyX2V4biBzdHIgfm9uIH5lc2NhcGVfY2hhciA9IHNwbGl0X2F0IHN0ciAocmluZGV4X2V4biBzdHIgfmVzY2FwZV9jaGFyIG9uKVxuXG4gICgqIFtsYXN0X25vbl9kcm9wX2xpdGVyYWxdIGFuZCBbZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbF0gYXJlIGVpdGhlciBib3RoIFtOb25lXSBvciBib3RoXG4gICAgIFtTb21lXS4gSWYgW1NvbWVdLCB0aGVuIHRoZSBmb3JtZXIgaXMgPj0gdGhlIGxhdHRlci4gKilcbiAgbGV0IGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB+ZHJvcCB+ZXNjYXBlX2NoYXIgdCA9XG4gICAgcmZpbmRpIHQgfmY6KGZ1biBpIGMgLT5cbiAgICAgIChub3QgKGRyb3AgYykpXG4gICAgICB8fCBpc19jaGFyX2VzY2FwaW5nIHQgfmVzY2FwZV9jaGFyIGlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBlZCB0IH5lc2NhcGVfY2hhciBpKVxuICA7O1xuXG4gIGxldCBmaXJzdF9ub25fZHJvcF9saXRlcmFsIH5kcm9wIH5lc2NhcGVfY2hhciB0ID1cbiAgICBsZmluZGkgdCB+ZjooZnVuIGkgYyAtPlxuICAgICAgKG5vdCAoZHJvcCBjKSlcbiAgICAgIHx8IGlzX2NoYXJfZXNjYXBpbmcgdCB+ZXNjYXBlX2NoYXIgaVxuICAgICAgfHwgaXNfY2hhcl9lc2NhcGVkIHQgfmVzY2FwZV9jaGFyIGkpXG4gIDs7XG5cbiAgbGV0IHJzdHJpcF9saXRlcmFsID8oZHJvcCA9IENoYXIuaXNfd2hpdGVzcGFjZSkgdCB+ZXNjYXBlX2NoYXIgPVxuICAgIG1hdGNoIGxhc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgaSAtPiBpZiBpID0gbGVuZ3RoIHQgLSAxIHRoZW4gdCBlbHNlIHByZWZpeCB0IChpICsgMSlcbiAgOztcblxuICBsZXQgbHN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbWF0Y2ggZmlyc3Rfbm9uX2Ryb3BfbGl0ZXJhbCB0IH5kcm9wIH5lc2NhcGVfY2hhciB3aXRoXG4gICAgfCBOb25lIC0+IFwiXCJcbiAgICB8IFNvbWUgMCAtPiB0XG4gICAgfCBTb21lIG4gLT4gZHJvcF9wcmVmaXggdCBuXG4gIDs7XG5cbiAgKCogW3N0cmlwIHRdIGNvdWxkIGJlIGltcGxlbWVudGVkIGFzIFtsc3RyaXAgKHJzdHJpcCB0KV0uICBUaGUgaW1wbGVtZW50YXRpb25cbiAgICAgYmVsb3cgc2F2ZXMgKGF0IGxlYXN0KSBhIGZhY3RvciBvZiB0d28gYWxsb2NhdGlvbiwgYnkgb25seSBhbGxvY2F0aW5nIHRoZVxuICAgICBmaW5hbCByZXN1bHQuICBUaGlzIGFsc28gc2F2ZXMgc29tZSBhbW91bnQgb2YgdGltZS4gKilcbiAgbGV0IHN0cmlwX2xpdGVyYWwgPyhkcm9wID0gQ2hhci5pc193aGl0ZXNwYWNlKSB0IH5lc2NhcGVfY2hhciA9XG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aCB0IGluXG4gICAgKCogcGVyZm9ybWFuY2UgaGFjazogYXZvaWQgY29weWluZyBbdF0gaW4gY29tbW9uIGNhc2VzICopXG4gICAgaWYgbGVuZ3RoID0gMCB8fCBub3QgKGRyb3AgdC5bMF0gfHwgZHJvcCB0LltsZW5ndGggLSAxXSlcbiAgICB0aGVuIHRcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGZpcnN0X25vbl9kcm9wX2xpdGVyYWwgdCB+ZHJvcCB+ZXNjYXBlX2NoYXIgd2l0aFxuICAgICAgfCBOb25lIC0+IFwiXCJcbiAgICAgIHwgU29tZSBmaXJzdCAtPlxuICAgICAgICAobWF0Y2ggbGFzdF9ub25fZHJvcF9saXRlcmFsIHQgfmRyb3AgfmVzY2FwZV9jaGFyIHdpdGhcbiAgICAgICAgIHwgTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgIHwgU29tZSBsYXN0IC0+IHN1YiB0IH5wb3M6Zmlyc3QgfmxlbjoobGFzdCAtIGZpcnN0ICsgMSkpKVxuICA7O1xuZW5kXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFN0cmluZ19yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxuKCogT3ZlcnJpZGUgW1NlYXJjaF9wYXR0ZXJuXSB3aXRoIGRlZmF1bHQgY2FzZS1zZW5zaXRpdml0eSBhcmd1bWVudCBhdCB0aGUgZW5kIG9mIHRoZVxuICAgZmlsZSwgc28gdGhhdCBjYWxsIHNpdGVzIGFib3ZlIGFyZSBmb3JjZWQgdG8gc3VwcGx5IGNhc2Utc2Vuc2l0aXZpdHkgZXhwbGljaXRseS4gKilcbm1vZHVsZSBTZWFyY2hfcGF0dGVybiA9IHN0cnVjdFxuICBpbmNsdWRlIFNlYXJjaF9wYXR0ZXJuMFxuXG4gIGxldCBjcmVhdGUgPyhjYXNlX3NlbnNpdGl2ZSA9IHRydWUpIHBhdHRlcm4gPSBjcmVhdGUgcGF0dGVybiB+Y2FzZV9zZW5zaXRpdmVcbmVuZFxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgU3RyaW5nX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgQXJyYXkgPSBBcnJheTBcblxubGV0IHN0YWdlID0gU3RhZ2VkLnN0YWdlXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGJ5dGVzIFtAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChieXRlc19vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9ieXRlcyA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBieXRlc19zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQnl0ZXMwXG5cbiAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkJ5dGVzXCJcbiAgbGV0IHBwIGZtdCB0ID0gQ2FtbC5Gb3JtYXQuZnByaW50ZiBmbXQgXCIlU1wiICh0b19zdHJpbmcgdClcbmVuZFxuXG5pbmNsdWRlIFRcblxubW9kdWxlIFRvX2J5dGVzID0gQmxpdC5NYWtlIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCBjcmVhdGUgfmxlbiA9IGNyZWF0ZSBsZW5cbiAgZW5kKVxuXG5pbmNsdWRlIFRvX2J5dGVzXG5pbmNsdWRlIENvbXBhcmF0b3IuTWFrZSAoVClcbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXJfcHAgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIEJ5dGVzX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxubW9kdWxlIFRvX3N0cmluZyA9IEJsaXQuTWFrZV90b19zdHJpbmcgKFQpIChUb19ieXRlcylcblxubW9kdWxlIEZyb21fc3RyaW5nID1cbiAgQmxpdC5NYWtlX2Rpc3RpbmN0XG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSB0ID0gc3RyaW5nXG5cbiAgICAgIGxldCBsZW5ndGggPSBTdHJpbmcubGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGxldCBjcmVhdGUgfmxlbiA9IGNyZWF0ZSBsZW5cbiAgICAgIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgICAgIGxldCB1bnNhZmVfYmxpdCA9IHVuc2FmZV9ibGl0X3N0cmluZ1xuICAgIGVuZClcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcblxubGV0IGluaXQgbiB+ZiA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8ICkgbiAwXG4gIHRoZW4gUHJpbnRmLmludmFsaWRfYXJnZiBcIkJ5dGVzLmluaXQgJWRcIiBuICgpO1xuICBsZXQgdCA9IGNyZWF0ZSBuIGluXG4gIGZvciBpID0gMCB0byBuIC0gMSBkb1xuICAgIHVuc2FmZV9zZXQgdCBpIChmIGkpXG4gIGRvbmU7XG4gIHRcbjs7XG5cbmxldCBvZl9jaGFyX2xpc3QgbCA9XG4gIGxldCB0ID0gY3JlYXRlIChMaXN0Lmxlbmd0aCBsKSBpblxuICBMaXN0Lml0ZXJpIGwgfmY6KGZ1biBpIGMgLT4gc2V0IHQgaSBjKTtcbiAgdFxuOztcblxubGV0IHRvX2xpc3QgdCA9XG4gIGxldCByZWMgbG9vcCB0IGkgYWNjID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIGkgMFxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgKGkgLSAxKSAodW5zYWZlX2dldCB0IGkgOjogYWNjKVxuICBpblxuICBsb29wIHQgKGxlbmd0aCB0IC0gMSkgW11cbjs7XG5cbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCAobGVuZ3RoIHQpIH5mOihmdW4gaSAtPiB1bnNhZmVfZ2V0IHQgaSlcbmxldCBtYXAgdCB+ZiA9IG1hcCB0IH5mXG5sZXQgbWFwaSB0IH5mID0gbWFwaSB0IH5mXG5cbmxldCBmb2xkID1cbiAgbGV0IHJlYyBsb29wIHQgfmYgfmxlbiB+cG9zIGFjYyA9XG4gICAgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5lcXVhbCBwb3MgbGVuXG4gICAgdGhlbiBhY2NcbiAgICBlbHNlIGxvb3AgdCB+ZiB+bGVuIH5wb3M6KHBvcyArIDEpIChmIGFjYyAodW5zYWZlX2dldCB0IHBvcykpXG4gIGluXG4gIGZ1biB0IH5pbml0IH5mIC0+IGxvb3AgdCB+ZiB+bGVuOihsZW5ndGggdCkgfnBvczowIGluaXRcbjs7XG5cbmxldCBmb2xkaSA9XG4gIGxldCByZWMgbG9vcCB0IH5mIH5sZW4gfnBvcyBhY2MgPVxuICAgIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuZXF1YWwgcG9zIGxlblxuICAgIHRoZW4gYWNjXG4gICAgZWxzZSBsb29wIHQgfmYgfmxlbiB+cG9zOihwb3MgKyAxKSAoZiBwb3MgYWNjICh1bnNhZmVfZ2V0IHQgcG9zKSlcbiAgaW5cbiAgZnVuIHQgfmluaXQgfmYgLT4gbG9vcCB0IH5mIH5sZW46KGxlbmd0aCB0KSB+cG9zOjAgaW5pdFxuOztcblxubGV0IHRyIH50YXJnZXQgfnJlcGxhY2VtZW50IHMgPVxuICBmb3IgaSA9IDAgdG8gbGVuZ3RoIHMgLSAxIGRvXG4gICAgaWYgQ2hhci5lcXVhbCAodW5zYWZlX2dldCBzIGkpIHRhcmdldCB0aGVuIHVuc2FmZV9zZXQgcyBpIHJlcGxhY2VtZW50XG4gIGRvbmVcbjs7XG5cbmxldCB0cl9tdWx0aSB+dGFyZ2V0IH5yZXBsYWNlbWVudCA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA9ICkgKFN0cmluZy5sZW5ndGggdGFyZ2V0KSAwXG4gIHRoZW4gc3RhZ2UgaWdub3JlXG4gIGVsc2UgaWYgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID0gKSAoU3RyaW5nLmxlbmd0aCByZXBsYWNlbWVudCkgMFxuICB0aGVuIGludmFsaWRfYXJnIFwidHJfbXVsdGk6IHJlcGxhY2VtZW50IGlzIHRoZSBlbXB0eSBzdHJpbmdcIlxuICBlbHNlIChcbiAgICBtYXRjaCBCeXRlc190ci50cl9jcmVhdGVfbWFwIH50YXJnZXQgfnJlcGxhY2VtZW50IHdpdGhcbiAgICB8IE5vbmUgLT4gc3RhZ2UgaWdub3JlXG4gICAgfCBTb21lIHRyX21hcCAtPlxuICAgICAgc3RhZ2UgKGZ1biBzIC0+XG4gICAgICAgIGZvciBpID0gMCB0byBsZW5ndGggcyAtIDEgZG9cbiAgICAgICAgICB1bnNhZmVfc2V0IHMgaSAoU3RyaW5nLnVuc2FmZV9nZXQgdHJfbWFwIChDaGFyLnRvX2ludCAodW5zYWZlX2dldCBzIGkpKSlcbiAgICAgICAgZG9uZSkpXG47O1xuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgY29udGFpbnMgP3BvcyA/bGVuIHQgY2hhciA9XG4gIGxldCBwb3MsIGxlbiA9XG4gICAgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbi5nZXRfcG9zX2xlbl9leG4gKCkgP3BvcyA/bGVuIH50b3RhbF9sZW5ndGg6KGxlbmd0aCB0KVxuICBpblxuICBsZXQgbGFzdCA9IHBvcyArIGxlbiBpblxuICBsZXQgcmVjIGxvb3AgaSA9XG4gICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDwgKSBpIGxhc3RcbiAgICAmJiAoQ2hhci5lcXVhbCAoZ2V0IHQgaSkgY2hhciB8fCBsb29wIChpICsgMSkpXG4gIGluXG4gIGxvb3AgcG9zXG47O1xuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgQnl0ZXNfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCIjIDEgXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gXG50eXBlIHJlc3VsdCA9XG58IE5lZyBvZiBzdHJpbmdcbnwgUG9zIG9mIHN0cmluZ1xuXG4jIDggXCJzcmMvaGV4X2xleGVyLm1sXCJcbmxldCBfX29jYW1sX2xleF90YWJsZXMgPSB7XG4gIExleGluZy5sZXhfYmFzZSA9XG4gICBcIlxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDFcXDAwMFxcMDAxXFwwMDBcXDAwMlxcMDAwXFwwMjdcXDAwMFxcMDgyXFwwMDBcXDEwNVxcMDAwXFxcbiAgICBcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwMFxcMDAwXFwyNTVcXDI1NVxcMDAxXFwwMDBcXFxuICAgIFwiO1xuICBMZXhpbmcubGV4X2RlZmF1bHQgPVxuICAgXCJcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXCI7XG4gIExleGluZy5sZXhfdHJhbnMgPVxuICAgXCJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDJcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMVxcMDAwXFwwMDNcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwNFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFxcbiAgICBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDRcXDAwMFxcMDA1XFwwMDBcXDAwMFxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDA3XFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDdcXDAwMFxcMDAwXFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcXG4gICAgXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXFxuICAgIFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFwwMDBcXDAwMFxcMDAwXFxcbiAgICBcXDAwMFxcMDAwXFwwMDBcXDAwMFwiO1xuICBMZXhpbmcubGV4X2NoZWNrID1cbiAgIFwiXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDAwXFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDBcXDAwMFxcMDAyXFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcXG4gICAgXFwwMDRcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDAwMVxcMDAwXFwwMDNcXDAwMFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDVcXDAwMFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcXG4gICAgXFwwMDVcXDAwMFxcMDA1XFwwMDBcXDI1NVxcMjU1XFwwMDRcXDAwMFxcMDA0XFwwMDBcXDAwNFxcMDAwXFwwMDRcXDAwMFxcMDA0XFwwMDBcXFxuICAgIFxcMDA0XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwwMDFcXDAwMFxcMDAzXFwwMDBcXDAwNVxcMDAwXFwyNTVcXDI1NVxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDVcXDAwMFxcMDA1XFwwMDBcXFxuICAgIFxcMDA1XFwwMDBcXDAwNVxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXFxuICAgIFxcMDA2XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMDA2XFwwMDBcXDAwNlxcMDAwXFwwMDZcXDAwMFxcMDA2XFwwMDBcXDAwNlxcMDAwXFxcbiAgICBcXDAwNlxcMDAwXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMDA3XFwwMDBcXDI1NVxcMjU1XFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFwwMDdcXDAwMFxcMDA3XFwwMDBcXDAwN1xcMDAwXFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXFxuICAgIFxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFxcbiAgICBcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcMjU1XFwyNTVcXDI1NVxcXG4gICAgXFwyNTVcXDI1NVxcMjU1XFwyNTVcIjtcbiAgTGV4aW5nLmxleF9iYXNlX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9iYWNrdHJrX2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF9kZWZhdWx0X2NvZGUgPVxuICAgXCJcIjtcbiAgTGV4aW5nLmxleF90cmFuc19jb2RlID1cbiAgIFwiXCI7XG4gIExleGluZy5sZXhfY2hlY2tfY29kZSA9XG4gICBcIlwiO1xuICBMZXhpbmcubGV4X2NvZGUgPVxuICAgXCJcIjtcbn1cblxubGV0IHJlYyBwYXJzZV9oZXggbGV4YnVmID1cbiAgIF9fb2NhbWxfbGV4X3BhcnNlX2hleF9yZWMgbGV4YnVmIDBcbmFuZCBfX29jYW1sX2xleF9wYXJzZV9oZXhfcmVjIGxleGJ1ZiBfX29jYW1sX2xleF9zdGF0ZSA9XG4gIG1hdGNoIExleGluZy5lbmdpbmUgX19vY2FtbF9sZXhfdGFibGVzIF9fb2NhbWxfbGV4X3N0YXRlIGxleGJ1ZiB3aXRoXG4gICAgICB8IDAgLT5cbmxldFxuIyA4IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keVxuIyAxMzUgXCJzcmMvaGV4X2xleGVyLm1sXCJcbj0gTGV4aW5nLnN1Yl9sZXhlbWUgbGV4YnVmIChsZXhidWYuTGV4aW5nLmxleF9zdGFydF9wb3MgKyAzKSBsZXhidWYuTGV4aW5nLmxleF9jdXJyX3BvcyBpblxuIyAxNCBcInNyYy9oZXhfbGV4ZXIubWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKCBOZWcgYm9keSApXG4jIDEzOSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuXG4gIHwgMSAtPlxubGV0XG4jIDggXCJzcmMvaGV4X2xleGVyLm1sbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5XG4jIDE0NSBcInNyYy9oZXhfbGV4ZXIubWxcIlxuPSBMZXhpbmcuc3ViX2xleGVtZSBsZXhidWYgKGxleGJ1Zi5MZXhpbmcubGV4X3N0YXJ0X3BvcyArIDIpIGxleGJ1Zi5MZXhpbmcubGV4X2N1cnJfcG9zIGluXG4jIDE1IFwic3JjL2hleF9sZXhlci5tbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoIFBvcyBib2R5IClcbiMgMTQ5IFwic3JjL2hleF9sZXhlci5tbFwiXG5cbiAgfCBfX29jYW1sX2xleF9zdGF0ZSAtPiBsZXhidWYuTGV4aW5nLnJlZmlsbF9idWZmIGxleGJ1ZjtcbiAgICAgIF9fb2NhbWxfbGV4X3BhcnNlX2hleF9yZWMgbGV4YnVmIF9fb2NhbWxfbGV4X3N0YXRlXG5cbjs7XG5cbiIsIm9wZW4hIEltcG9ydFxubW9kdWxlIEludCA9IEludDBcbm1vZHVsZSBTeXMgPSBTeXMwXG5cbmxldCBjb252ZXJ0X2ZhaWx1cmUgeCBhIGIgdG9fc3RyaW5nID1cbiAgUHJpbnRmLmZhaWx3aXRoZlxuICAgIFwiY29udmVyc2lvbiBmcm9tICVzIHRvICVzIGZhaWxlZDogJXMgaXMgb3V0IG9mIHJhbmdlXCJcbiAgICBhXG4gICAgYlxuICAgICh0b19zdHJpbmcgeClcbiAgICAoKVxuW0BAY29sZF0gW0BAaW5saW5lIG5ldmVyXSBbQEBsb2NhbCBuZXZlcl0gW0BAc3BlY2lhbGlzZSBuZXZlcl1cbjs7XG5cbmxldCBudW1fYml0c19pbnQgPSBTeXMuaW50X3NpemVfaW5fYml0c1xubGV0IG51bV9iaXRzX2ludDMyID0gMzJcbmxldCBudW1fYml0c19pbnQ2NCA9IDY0XG5sZXQgbnVtX2JpdHNfbmF0aXZlaW50ID0gV29yZF9zaXplLm51bV9iaXRzIFdvcmRfc2l6ZS53b3JkX3NpemVcbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50ID0gNjMgfHwgbnVtX2JpdHNfaW50ID0gMzEgfHwgbnVtX2JpdHNfaW50ID0gMzIpXG5sZXQgbWluX2ludDMyID0gQ2FtbC5JbnQzMi5taW5faW50XG5sZXQgbWF4X2ludDMyID0gQ2FtbC5JbnQzMi5tYXhfaW50XG5sZXQgbWluX2ludDY0ID0gQ2FtbC5JbnQ2NC5taW5faW50XG5sZXQgbWF4X2ludDY0ID0gQ2FtbC5JbnQ2NC5tYXhfaW50XG5sZXQgbWluX25hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50Lm1pbl9pbnRcbmxldCBtYXhfbmF0aXZlaW50ID0gQ2FtbC5OYXRpdmVpbnQubWF4X2ludFxubGV0IGludF90b19zdHJpbmcgPSBDYW1sLnN0cmluZ19vZl9pbnRcbmxldCBpbnQzMl90b19zdHJpbmcgPSBDYW1sLkludDMyLnRvX3N0cmluZ1xubGV0IGludDY0X3RvX3N0cmluZyA9IENhbWwuSW50NjQudG9fc3RyaW5nXG5sZXQgbmF0aXZlaW50X3RvX3N0cmluZyA9IENhbWwuTmF0aXZlaW50LnRvX3N0cmluZ1xuXG4oKiBpbnQgPC0+IGludDMyICopXG5cbmxldCBpbnRfdG9faW50MzJfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnRcIiBcImludDMyXCIgaW50X3RvX3N0cmluZ1xubGV0IGludDMyX3RvX2ludF9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDMyXCIgXCJpbnRcIiBpbnQzMl90b19zdHJpbmdcbmxldCBpbnQzMl90b19pbnRfdHJ1bmMgPSBDYW1sLkludDMyLnRvX2ludFxubGV0IGludF90b19pbnQzMl90cnVuYyA9IENhbWwuSW50MzIub2ZfaW50XG5cbmxldCBpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiA9XG4gIGlmIG51bV9iaXRzX2ludCA8PSBudW1fYml0c19pbnQzMlxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IGludDMyX3RvX2ludF90cnVuYyBtaW5faW50MzIgaW5cbiAgICBsZXQgbWF4ID0gaW50MzJfdG9faW50X3RydW5jIG1heF9pbnQzMiBpblxuICAgIGZ1biB4IC0+IGNvbXBhcmVfaW50IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCA9XG4gIGlmIG51bV9iaXRzX2ludDMyIDw9IG51bV9iaXRzX2ludFxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IGludF90b19pbnQzMl90cnVuYyBJbnQubWluX3ZhbHVlIGluXG4gICAgbGV0IG1heCA9IGludF90b19pbnQzMl90cnVuYyBJbnQubWF4X3ZhbHVlIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9pbnQzMiBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50MzIgeCBtYXggPD0gMClcbjs7XG5cbmxldCBpbnRfdG9faW50MzIgeCA9XG4gIGlmIGludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHggdGhlbiBTb21lIChpbnRfdG9faW50MzJfdHJ1bmMgeCkgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50MzJfdG9faW50IHggPVxuICBpZiBpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAoaW50MzJfdG9faW50X3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludF90b19pbnQzMl9leG4geCA9XG4gIGlmIGludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyIHggdGhlbiBpbnRfdG9faW50MzJfdHJ1bmMgeCBlbHNlIGludF90b19pbnQzMl9mYWlsdXJlIHhcbjs7XG5cbmxldCBpbnQzMl90b19pbnRfZXhuIHggPVxuICBpZiBpbnQzMl9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gaW50MzJfdG9faW50X3RydW5jIHggZWxzZSBpbnQzMl90b19pbnRfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQgPC0+IGludDY0ICopXG5cbmxldCBpbnQ2NF90b19pbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwiaW50XCIgaW50NjRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA8IG51bV9iaXRzX2ludDY0KVxubGV0IGludF90b19pbnQ2NCA9IENhbWwuSW50NjQub2ZfaW50XG5sZXQgaW50NjRfdG9faW50X3RydW5jID0gQ2FtbC5JbnQ2NC50b19pbnRcblxubGV0IGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50ID1cbiAgbGV0IG1pbiA9IGludF90b19pbnQ2NCBJbnQubWluX3ZhbHVlIGluXG4gIGxldCBtYXggPSBpbnRfdG9faW50NjQgSW50Lm1heF92YWx1ZSBpblxuICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwXG47O1xuXG5sZXQgaW50NjRfdG9faW50IHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAoaW50NjRfdG9faW50X3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX2ludF9leG4geCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHggdGhlbiBpbnQ2NF90b19pbnRfdHJ1bmMgeCBlbHNlIGludDY0X3RvX2ludF9mYWlsdXJlIHhcbjs7XG5cbigqIGludCA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBuYXRpdmVpbnRfdG9faW50X2ZhaWx1cmUgeCA9IGNvbnZlcnRfZmFpbHVyZSB4IFwibmF0aXZlaW50XCIgXCJpbnRcIiBuYXRpdmVpbnRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludCA8PSBudW1fYml0c19uYXRpdmVpbnQpXG5sZXQgaW50X3RvX25hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50Lm9mX2ludFxubGV0IG5hdGl2ZWludF90b19pbnRfdHJ1bmMgPSBDYW1sLk5hdGl2ZWludC50b19pbnRcblxubGV0IG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCA9XG4gIGlmIG51bV9iaXRzX25hdGl2ZWludCA8PSBudW1fYml0c19pbnRcbiAgdGhlbiBmdW4gXyAtPiB0cnVlXG4gIGVsc2UgKFxuICAgIGxldCBtaW4gPSBpbnRfdG9fbmF0aXZlaW50IEludC5taW5fdmFsdWUgaW5cbiAgICBsZXQgbWF4ID0gaW50X3RvX25hdGl2ZWludCBJbnQubWF4X3ZhbHVlIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9uYXRpdmVpbnQgbWluIHggPD0gMCAmJiBjb21wYXJlX25hdGl2ZWludCB4IG1heCA8PSAwKVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnQgeCA9XG4gIGlmIG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludCB4IHRoZW4gU29tZSAobmF0aXZlaW50X3RvX2ludF90cnVuYyB4KSBlbHNlIE5vbmVcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50X2V4biB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50IHhcbiAgdGhlbiBuYXRpdmVpbnRfdG9faW50X3RydW5jIHhcbiAgZWxzZSBuYXRpdmVpbnRfdG9faW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50MzIgPC0+IGludDY0ICopXG5cbmxldCBpbnQ2NF90b19pbnQzMl9mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDY0XCIgXCJpbnQzMlwiIGludDY0X3RvX3N0cmluZ1xubGV0ICgpID0gYXNzZXJ0IChudW1fYml0c19pbnQzMiA8IG51bV9iaXRzX2ludDY0KVxubGV0IGludDMyX3RvX2ludDY0ID0gQ2FtbC5JbnQ2NC5vZl9pbnQzMlxubGV0IGludDY0X3RvX2ludDMyX3RydW5jID0gQ2FtbC5JbnQ2NC50b19pbnQzMlxuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiA9XG4gIGxldCBtaW4gPSBpbnQzMl90b19pbnQ2NCBtaW5faW50MzIgaW5cbiAgbGV0IG1heCA9IGludDMyX3RvX2ludDY0IG1heF9pbnQzMiBpblxuICBmdW4geCAtPiBjb21wYXJlX2ludDY0IG1pbiB4IDw9IDAgJiYgY29tcGFyZV9pbnQ2NCB4IG1heCA8PSAwXG47O1xuXG5sZXQgaW50NjRfdG9faW50MzIgeCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeCB0aGVuIFNvbWUgKGludDY0X3RvX2ludDMyX3RydW5jIHgpIGVsc2UgTm9uZVxuOztcblxubGV0IGludDY0X3RvX2ludDMyX2V4biB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4XG4gIHRoZW4gaW50NjRfdG9faW50MzJfdHJ1bmMgeFxuICBlbHNlIGludDY0X3RvX2ludDMyX2ZhaWx1cmUgeFxuOztcblxuKCogaW50MzIgPC0+IG5hdGl2ZWludCAqKVxuXG5sZXQgbmF0aXZlaW50X3RvX2ludDMyX2ZhaWx1cmUgeCA9XG4gIGNvbnZlcnRfZmFpbHVyZSB4IFwibmF0aXZlaW50XCIgXCJpbnQzMlwiIG5hdGl2ZWludF90b19zdHJpbmdcbjs7XG5cbmxldCAoKSA9IGFzc2VydCAobnVtX2JpdHNfaW50MzIgPD0gbnVtX2JpdHNfbmF0aXZlaW50KVxubGV0IGludDMyX3RvX25hdGl2ZWludCA9IENhbWwuTmF0aXZlaW50Lm9mX2ludDMyXG5sZXQgbmF0aXZlaW50X3RvX2ludDMyX3RydW5jID0gQ2FtbC5OYXRpdmVpbnQudG9faW50MzJcblxubGV0IG5hdGl2ZWludF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDMyID1cbiAgaWYgbnVtX2JpdHNfbmF0aXZlaW50IDw9IG51bV9iaXRzX2ludDMyXG4gIHRoZW4gZnVuIF8gLT4gdHJ1ZVxuICBlbHNlIChcbiAgICBsZXQgbWluID0gaW50MzJfdG9fbmF0aXZlaW50IG1pbl9pbnQzMiBpblxuICAgIGxldCBtYXggPSBpbnQzMl90b19uYXRpdmVpbnQgbWF4X2ludDMyIGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9uYXRpdmVpbnQgbWluIHggPD0gMCAmJiBjb21wYXJlX25hdGl2ZWludCB4IG1heCA8PSAwKVxuOztcblxubGV0IG5hdGl2ZWludF90b19pbnQzMiB4ID1cbiAgaWYgbmF0aXZlaW50X2lzX3JlcHJlc2VudGFibGVfYXNfaW50MzIgeFxuICB0aGVuIFNvbWUgKG5hdGl2ZWludF90b19pbnQzMl90cnVuYyB4KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldCBuYXRpdmVpbnRfdG9faW50MzJfZXhuIHggPVxuICBpZiBuYXRpdmVpbnRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQzMiB4XG4gIHRoZW4gbmF0aXZlaW50X3RvX2ludDMyX3RydW5jIHhcbiAgZWxzZSBuYXRpdmVpbnRfdG9faW50MzJfZmFpbHVyZSB4XG47O1xuXG4oKiBpbnQ2NCA8LT4gbmF0aXZlaW50ICopXG5cbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfZmFpbHVyZSB4ID0gY29udmVydF9mYWlsdXJlIHggXCJpbnQ2NFwiIFwibmF0aXZlaW50XCIgaW50NjRfdG9fc3RyaW5nXG5sZXQgKCkgPSBhc3NlcnQgKG51bV9iaXRzX2ludDY0ID49IG51bV9iaXRzX25hdGl2ZWludClcbmxldCBpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgPSBDYW1sLkludDY0LnRvX25hdGl2ZWludFxubGV0IG5hdGl2ZWludF90b19pbnQ2NCA9IENhbWwuSW50NjQub2ZfbmF0aXZlaW50XG5cbmxldCBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX25hdGl2ZWludCA9XG4gIGlmIG51bV9iaXRzX2ludDY0IDw9IG51bV9iaXRzX25hdGl2ZWludFxuICB0aGVuIGZ1biBfIC0+IHRydWVcbiAgZWxzZSAoXG4gICAgbGV0IG1pbiA9IG5hdGl2ZWludF90b19pbnQ2NCBtaW5fbmF0aXZlaW50IGluXG4gICAgbGV0IG1heCA9IG5hdGl2ZWludF90b19pbnQ2NCBtYXhfbmF0aXZlaW50IGluXG4gICAgZnVuIHggLT4gY29tcGFyZV9pbnQ2NCBtaW4geCA8PSAwICYmIGNvbXBhcmVfaW50NjQgeCBtYXggPD0gMClcbjs7XG5cbmxldCBpbnQ2NF90b19uYXRpdmVpbnQgeCA9XG4gIGlmIGludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfbmF0aXZlaW50IHhcbiAgdGhlbiBTb21lIChpbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgeClcbiAgZWxzZSBOb25lXG47O1xuXG5sZXQgaW50NjRfdG9fbmF0aXZlaW50X2V4biB4ID1cbiAgaWYgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19uYXRpdmVpbnQgeFxuICB0aGVuIGludDY0X3RvX25hdGl2ZWludF90cnVuYyB4XG4gIGVsc2UgaW50NjRfdG9fbmF0aXZlaW50X2ZhaWx1cmUgeFxuOztcblxuKCogaW50NjQgPC0+IGludDYzICopXG5cbmxldCBpbnQ2NF90b19pbnQ2M19mYWlsdXJlIHggPSBjb252ZXJ0X2ZhaWx1cmUgeCBcImludDY0XCIgXCJpbnQ2M1wiIGludDY0X3RvX3N0cmluZ1xuXG5sZXQgaW50NjRfaXNfcmVwcmVzZW50YWJsZV9hc19pbnQ2MyA9XG4gIGxldCBtaW4gPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IG1pbl9pbnQ2NCAxIGluXG4gIGxldCBtYXggPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IG1heF9pbnQ2NCAxIGluXG4gIGZ1biB4IC0+IGNvbXBhcmVfaW50NjQgbWluIHggPD0gMCAmJiBjb21wYXJlX2ludDY0IHggbWF4IDw9IDBcbjs7XG5cbmxldCBpbnQ2NF9maXRfb25faW50NjNfZXhuIHggPVxuICBpZiBpbnQ2NF9pc19yZXByZXNlbnRhYmxlX2FzX2ludDYzIHggdGhlbiAoKSBlbHNlIGludDY0X3RvX2ludDYzX2ZhaWx1cmUgeFxuOztcblxuKCogc3RyaW5nIGNvbnZlcnNpb25zICopXG5cbmxldCBpbnNlcnRfZGVsaW1pdGVyX2V2ZXJ5IGlucHV0IH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXIgPVxuICBsZXQgaW5wdXRfbGVuZ3RoID0gU3RyaW5nLmxlbmd0aCBpbnB1dCBpblxuICBpZiBpbnB1dF9sZW5ndGggPD0gY2hhcnNfcGVyX2RlbGltaXRlclxuICB0aGVuIGlucHV0XG4gIGVsc2UgKFxuICAgIGxldCBoYXNfc2lnbiA9XG4gICAgICBtYXRjaCBpbnB1dC5bMF0gd2l0aFxuICAgICAgfCAnKycgfCAnLScgLT4gdHJ1ZVxuICAgICAgfCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgbnVtX2RpZ2l0cyA9IGlmIGhhc19zaWduIHRoZW4gaW5wdXRfbGVuZ3RoIC0gMSBlbHNlIGlucHV0X2xlbmd0aCBpblxuICAgIGxldCBudW1fZGVsaW1pdGVycyA9IChudW1fZGlnaXRzIC0gMSkgLyBjaGFyc19wZXJfZGVsaW1pdGVyIGluXG4gICAgbGV0IG91dHB1dF9sZW5ndGggPSBpbnB1dF9sZW5ndGggKyBudW1fZGVsaW1pdGVycyBpblxuICAgIGxldCBvdXRwdXQgPSBCeXRlcy5jcmVhdGUgb3V0cHV0X2xlbmd0aCBpblxuICAgIGxldCBpbnB1dF9wb3MgPSByZWYgKGlucHV0X2xlbmd0aCAtIDEpIGluXG4gICAgbGV0IG91dHB1dF9wb3MgPSByZWYgKG91dHB1dF9sZW5ndGggLSAxKSBpblxuICAgIGxldCBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyID0gcmVmIGNoYXJzX3Blcl9kZWxpbWl0ZXIgaW5cbiAgICBsZXQgZmlyc3RfZGlnaXRfcG9zID0gaWYgaGFzX3NpZ24gdGhlbiAxIGVsc2UgMCBpblxuICAgIHdoaWxlICFpbnB1dF9wb3MgPj0gZmlyc3RfZGlnaXRfcG9zIGRvXG4gICAgICBpZiAhbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlciA9IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBCeXRlcy5zZXQgb3V0cHV0ICFvdXRwdXRfcG9zIGRlbGltaXRlcjtcbiAgICAgICAgZGVjciBvdXRwdXRfcG9zO1xuICAgICAgICBudW1fY2hhcnNfdW50aWxfZGVsaW1pdGVyIDo9IGNoYXJzX3Blcl9kZWxpbWl0ZXIpO1xuICAgICAgQnl0ZXMuc2V0IG91dHB1dCAhb3V0cHV0X3BvcyBpbnB1dC5bIWlucHV0X3Bvc107XG4gICAgICBkZWNyIGlucHV0X3BvcztcbiAgICAgIGRlY3Igb3V0cHV0X3BvcztcbiAgICAgIGRlY3IgbnVtX2NoYXJzX3VudGlsX2RlbGltaXRlclxuICAgIGRvbmU7XG4gICAgaWYgaGFzX3NpZ24gdGhlbiBCeXRlcy5zZXQgb3V0cHV0IDAgaW5wdXQuWzBdO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgfm5vX211dGF0aW9uX3doaWxlX3N0cmluZ19yZWFjaGFibGU6b3V0cHV0KVxuOztcblxubGV0IGluc2VydF9kZWxpbWl0ZXIgaW5wdXQgfmRlbGltaXRlciA9XG4gIGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgaW5wdXQgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlcjozXG47O1xuXG5sZXQgaW5zZXJ0X3VuZGVyc2NvcmVzIGlucHV0ID0gaW5zZXJ0X2RlbGltaXRlciBpbnB1dCB+ZGVsaW1pdGVyOidfJ1xubGV0IHNleHBfb2ZfaW50X3N0eWxlID0gU2V4cC5vZl9pbnRfc3R5bGVcblxubW9kdWxlIE1ha2UgKEkgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCB0b19zdHJpbmcgOiB0IC0+IHN0cmluZ1xuICBlbmQpID1cbnN0cnVjdFxuICBvcGVuIElcblxuICBsZXQgY2hhcnNfcGVyX2RlbGltaXRlciA9IDNcblxuICBsZXQgdG9fc3RyaW5nX2h1bSA/KGRlbGltaXRlciA9ICdfJykgdCA9XG4gICAgaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSAodG9fc3RyaW5nIHQpIH5kZWxpbWl0ZXIgfmNoYXJzX3Blcl9kZWxpbWl0ZXJcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IHQgPVxuICAgIGxldCBzID0gdG9fc3RyaW5nIHQgaW5cbiAgICBTZXhwLkF0b21cbiAgICAgIChtYXRjaCAhc2V4cF9vZl9pbnRfc3R5bGUgd2l0aFxuICAgICAgIHwgYFVuZGVyc2NvcmVzIC0+IGluc2VydF9kZWxpbWl0ZXJfZXZlcnkgcyB+Y2hhcnNfcGVyX2RlbGltaXRlciB+ZGVsaW1pdGVyOidfJ1xuICAgICAgIHwgYE5vX3VuZGVyc2NvcmVzIC0+IHMpXG4gIDs7XG5lbmRcblxubW9kdWxlIE1ha2VfaGV4IChJIDogc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgICBpbmNsdWRlIFBweF9oYXNoX2xpYi5IYXNoYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICB2YWwgdG9fc3RyaW5nIDogdCAtPiBzdHJpbmdcbiAgICB2YWwgb2Zfc3RyaW5nIDogc3RyaW5nIC0+IHRcbiAgICB2YWwgemVybyA6IHRcbiAgICB2YWwgKCA8ICkgOiB0IC0+IHQgLT4gYm9vbFxuICAgIHZhbCBuZWcgOiB0IC0+IHRcbiAgICB2YWwgbW9kdWxlX25hbWUgOiBzdHJpbmdcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbW9kdWxlIFRfaGV4ID0gc3RydWN0XG4gICAgdHlwZSB0ID0gSS50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoSS5jb21wYXJlIDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIEkuaGFzaF9mb2xkX3RcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gSS5oYXNoIGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgW0BAQGVuZF1cblxuICAgIGxldCBjaGFyc19wZXJfZGVsaW1pdGVyID0gNFxuXG4gICAgbGV0IHRvX3N0cmluZycgP2RlbGltaXRlciB0ID1cbiAgICAgIGxldCBtYWtlX3N1ZmZpeCA9XG4gICAgICAgIG1hdGNoIGRlbGltaXRlciB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBJLnRvX3N0cmluZ1xuICAgICAgICB8IFNvbWUgZGVsaW1pdGVyIC0+XG4gICAgICAgICAgZnVuIHQgLT4gaW5zZXJ0X2RlbGltaXRlcl9ldmVyeSAoSS50b19zdHJpbmcgdCkgfmRlbGltaXRlciB+Y2hhcnNfcGVyX2RlbGltaXRlclxuICAgICAgaW5cbiAgICAgIGlmIEkuKCA8ICkgdCBJLnplcm8gdGhlbiBcIi0weFwiIF4gbWFrZV9zdWZmaXggKEkubmVnIHQpIGVsc2UgXCIweFwiIF4gbWFrZV9zdWZmaXggdFxuICAgIDs7XG5cbiAgICBsZXQgdG9fc3RyaW5nIHQgPSB0b19zdHJpbmcnIHQgP2RlbGltaXRlcjpOb25lXG4gICAgbGV0IHRvX3N0cmluZ19odW0gPyhkZWxpbWl0ZXIgPSAnXycpIHQgPSB0b19zdHJpbmcnIHQgfmRlbGltaXRlclxuXG4gICAgbGV0IGludmFsaWQgc3RyID1cbiAgICAgIFByaW50Zi5mYWlsd2l0aGYgXCIlcy5vZl9zdHJpbmc6IGludmFsaWQgaW5wdXQgJVNcIiBJLm1vZHVsZV9uYW1lIHN0ciAoKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc3RyaW5nX3dpdGhfZGVsaW1pdGVyIHN0ciA9XG4gICAgICBJLm9mX3N0cmluZyAoU3RyaW5nLmZpbHRlciBzdHIgfmY6KGZ1biBjIC0+IENoYXIuKCA8PiApIGMgJ18nKSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX3N0cmluZyBzdHIgPVxuICAgICAgbGV0IG1vZHVsZSBMID0gSGV4X2xleGVyIGluXG4gICAgICBsZXQgbGV4ID0gQ2FtbC5MZXhpbmcuZnJvbV9zdHJpbmcgc3RyIGluXG4gICAgICBsZXQgcmVzdWx0ID0gT3B0aW9uLnRyeV93aXRoIChmdW4gKCkgLT4gTC5wYXJzZV9oZXggbGV4KSBpblxuICAgICAgaWYgbGV4LmxleF9jdXJyX3BvcyA9IGxleC5sZXhfYnVmZmVyX2xlblxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBpbnZhbGlkIHN0clxuICAgICAgICB8IFNvbWUgKE5lZyBib2R5KSAtPiBJLm5lZyAob2Zfc3RyaW5nX3dpdGhfZGVsaW1pdGVyIGJvZHkpXG4gICAgICAgIHwgU29tZSAoUG9zIGJvZHkpIC0+IG9mX3N0cmluZ193aXRoX2RlbGltaXRlciBib2R5KVxuICAgICAgZWxzZSBpbnZhbGlkIHN0clxuICAgIDs7XG5cbiAgICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgICAgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLmNvZXJjZSBTdHJpbmcudF9zZXhwX2dyYW1tYXJcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgSGV4ID0gc3RydWN0XG4gICAgaW5jbHVkZSBUX2hleFxuICAgIGluY2x1ZGUgU2V4cGFibGUuT2Zfc3RyaW5nYWJsZSAoVF9oZXgpXG4gIGVuZFxuZW5kXG4iLCIoKiBUaGlzIGZpbGUgd2FzIGF1dG9nZW5lcmF0ZWQgYnkgLi4vZ2VuZXJhdGUvZ2VuZXJhdGVfcG93X292ZXJmbG93X2JvdW5kcy5leGUgKilcblxub3BlbiEgSW1wb3J0XG5cbm1vZHVsZSBBcnJheSA9IEFycmF5MFxuXG4oKiBXZSBoYXZlIHRvIHVzZSBJbnQ2NC50b19pbnRfZXhuIGluc3RlYWQgb2YgaW50IGNvbnN0YW50cyB0byBtYWtlXG4gICBzdXJlIHRoYXQgZmlsZSBjYW4gYmUgcHJlcHJvY2Vzc2VkIG9uIDMyLWJpdCBtYWNoaW5lcy4gKilcblxubGV0IG92ZXJmbG93X2JvdW5kX21heF9pbnQzMl92YWx1ZSA6IGludDMyID1cbiAgMjE0NzQ4MzY0N2xcblxubGV0IGludDMyX3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDMyIGFycmF5ID1cbiAgW3wgMjE0NzQ4MzY0N2xcbiAgOyAgMjE0NzQ4MzY0N2xcbiAgOyAgNDYzNDBsXG4gIDsgIDEyOTBsXG4gIDsgIDIxNWxcbiAgOyAgNzNsXG4gIDsgIDM1bFxuICA7ICAyMWxcbiAgOyAgMTRsXG4gIDsgIDEwbFxuICA7ICA4bFxuICA7ICA3bFxuICA7ICA1bFxuICA7ICA1bFxuICA7ICA0bFxuICA7ICA0bFxuICA7ICAzbFxuICA7ICAzbFxuICA7ICAzbFxuICA7ICAzbFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAybFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICA7ICAxbFxuICB8XVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludF92YWx1ZSA6IGludCA9XG4gICgtMSkgbHNyIDFcblxubGV0IGludF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQgYXJyYXkgPVxuICBtYXRjaCBJbnRfY29udmVyc2lvbnMubnVtX2JpdHNfaW50IHdpdGhcbiAgfCAzMiAtPiBBcnJheS5tYXAgaW50MzJfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIH5mOkNhbWwuSW50MzIudG9faW50XG4gIHwgNjMgLT5cbiAgICBbfCBDYW1sLkludDY0LnRvX2ludCA0NjExNjg2MDE4NDI3Mzg3OTAzTFxuICAgIDsgIENhbWwuSW50NjQudG9faW50IDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gICAgOyAgQ2FtbC5JbnQ2NC50b19pbnQgMjE0NzQ4MzY0N0xcbiAgICA7ICAxNjY0NTEwXG4gICAgOyAgNDYzNDBcbiAgICA7ICA1NDA0XG4gICAgOyAgMTI5MFxuICAgIDsgIDQ2M1xuICAgIDsgIDIxNVxuICAgIDsgIDExOFxuICAgIDsgIDczXG4gICAgOyAgNDlcbiAgICA7ICAzNVxuICAgIDsgIDI3XG4gICAgOyAgMjFcbiAgICA7ICAxN1xuICAgIDsgIDE0XG4gICAgOyAgMTJcbiAgICA7ICAxMFxuICAgIDsgIDlcbiAgICA7ICA4XG4gICAgOyAgN1xuICAgIDsgIDdcbiAgICA7ICA2XG4gICAgOyAgNVxuICAgIDsgIDVcbiAgICA7ICA1XG4gICAgOyAgNFxuICAgIDsgIDRcbiAgICA7ICA0XG4gICAgOyAgNFxuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIHxdXG4gIHwgMzEgLT5cbiAgICBbfCAxMDczNzQxODIzXG4gICAgOyAgMTA3Mzc0MTgyM1xuICAgIDsgIDMyNzY3XG4gICAgOyAgMTAyM1xuICAgIDsgIDE4MVxuICAgIDsgIDYzXG4gICAgOyAgMzFcbiAgICA7ICAxOVxuICAgIDsgIDEzXG4gICAgOyAgMTBcbiAgICA7ICA3XG4gICAgOyAgNlxuICAgIDsgIDVcbiAgICA7ICA0XG4gICAgOyAgNFxuICAgIDsgIDNcbiAgICA7ICAzXG4gICAgOyAgM1xuICAgIDsgIDNcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDJcbiAgICA7ICAyXG4gICAgOyAgMlxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICA7ICAxXG4gICAgOyAgMVxuICAgIDsgIDFcbiAgICB8XVxuICB8IF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBvdmVyZmxvd19ib3VuZF9tYXhfaW50NjNfb25faW50NjRfdmFsdWUgOiBpbnQ2NCA9XG4gIDQ2MTE2ODYwMTg0MjczODc5MDNMXG5cbmxldCBpbnQ2M19vbl9pbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMgOiBpbnQ2NCBhcnJheSA9XG4gIFt8IDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gIDsgIDQ2MTE2ODYwMTg0MjczODc5MDNMXG4gIDsgIDIxNDc0ODM2NDdMXG4gIDsgIDE2NjQ1MTBMXG4gIDsgIDQ2MzQwTFxuICA7ICA1NDA0TFxuICA7ICAxMjkwTFxuICA7ICA0NjNMXG4gIDsgIDIxNUxcbiAgOyAgMTE4TFxuICA7ICA3M0xcbiAgOyAgNDlMXG4gIDsgIDM1TFxuICA7ICAyN0xcbiAgOyAgMjFMXG4gIDsgIDE3TFxuICA7ICAxNExcbiAgOyAgMTJMXG4gIDsgIDEwTFxuICA7ICA5TFxuICA7ICA4TFxuICA7ICA3TFxuICA7ICA3TFxuICA7ICA2TFxuICA7ICA1TFxuICA7ICA1TFxuICA7ICA1TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICA0TFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAzTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAyTFxuICA7ICAxTFxuICA7ICAxTFxuICB8XVxuXG5sZXQgb3ZlcmZsb3dfYm91bmRfbWF4X2ludDY0X3ZhbHVlIDogaW50NjQgPVxuICA5MjIzMzcyMDM2ODU0Nzc1ODA3TFxuXG5sZXQgaW50NjRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzIDogaW50NjQgYXJyYXkgPVxuICBbfCA5MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICA7ICA5MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICA7ICAzMDM3MDAwNDk5TFxuICA7ICAyMDk3MTUxTFxuICA7ICA1NTEwOExcbiAgOyAgNjIwOExcbiAgOyAgMTQ0OExcbiAgOyAgNTExTFxuICA7ICAyMzRMXG4gIDsgIDEyN0xcbiAgOyAgNzhMXG4gIDsgIDUyTFxuICA7ICAzOExcbiAgOyAgMjhMXG4gIDsgIDIyTFxuICA7ICAxOExcbiAgOyAgMTVMXG4gIDsgIDEzTFxuICA7ICAxMUxcbiAgOyAgOUxcbiAgOyAgOExcbiAgOyAgN0xcbiAgOyAgN0xcbiAgOyAgNkxcbiAgOyAgNkxcbiAgOyAgNUxcbiAgOyAgNUxcbiAgOyAgNUxcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgNExcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgM0xcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMkxcbiAgOyAgMUxcbiAgfF1cblxubGV0IGludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcyA6IGludDY0IGFycmF5ID1cbiAgW3wgLTkyMjMzNzIwMzY4NTQ3NzU4MDdMXG4gIDsgIC05MjIzMzcyMDM2ODU0Nzc1ODA3TFxuICA7ICAtMzAzNzAwMDQ5OUxcbiAgOyAgLTIwOTcxNTFMXG4gIDsgIC01NTEwOExcbiAgOyAgLTYyMDhMXG4gIDsgIC0xNDQ4TFxuICA7ICAtNTExTFxuICA7ICAtMjM0TFxuICA7ICAtMTI3TFxuICA7ICAtNzhMXG4gIDsgIC01MkxcbiAgOyAgLTM4TFxuICA7ICAtMjhMXG4gIDsgIC0yMkxcbiAgOyAgLTE4TFxuICA7ICAtMTVMXG4gIDsgIC0xM0xcbiAgOyAgLTExTFxuICA7ICAtOUxcbiAgOyAgLThMXG4gIDsgIC03TFxuICA7ICAtN0xcbiAgOyAgLTZMXG4gIDsgIC02TFxuICA7ICAtNUxcbiAgOyAgLTVMXG4gIDsgIC01TFxuICA7ICAtNExcbiAgOyAgLTRMXG4gIDsgIC00TFxuICA7ICAtNExcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtM0xcbiAgOyAgLTNMXG4gIDsgIC0zTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0yTFxuICA7ICAtMkxcbiAgOyAgLTJMXG4gIDsgIC0xTFxuICB8XVxuIiwib3BlbiEgSW1wb3J0XG5cbmxldCBpbnZhbGlkX2FyZ2YgPSBQcmludGYuaW52YWxpZF9hcmdmXG5sZXQgbmVnYXRpdmVfZXhwb25lbnQgKCkgPSBQcmludGYuaW52YWxpZF9hcmdmIFwiZXhwb25lbnQgY2FuIG5vdCBiZSBuZWdhdGl2ZVwiICgpXG5sZXQgb3ZlcmZsb3cgKCkgPSBQcmludGYuaW52YWxpZF9hcmdmIFwiaW50ZWdlciBvdmVyZmxvdyBpbiBwb3dcIiAoKVxuXG4oKiBUbyBpbXBsZW1lbnQgW2ludDY0X3Bvd10sIHdlIHVzZSBDIGNvZGUgcmF0aGVyIHRoYW4gT0NhbWwgdG8gZWxpbWluYXRlIGFsbG9jYXRpb24uICopXG5leHRlcm5hbCBpbnRfbWF0aF9pbnRfcG93IDogaW50IC0+IGludCAtPiBpbnQgPSBcIkJhc2VfaW50X21hdGhfaW50X3Bvd19zdHViXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIGludF9tYXRoX2ludDY0X3BvdyA6IGludDY0IC0+IGludDY0IC0+IGludDY0ID0gXCJCYXNlX2ludF9tYXRoX2ludDY0X3Bvd19zdHViXCJcblxubGV0IGludF9wb3cgYmFzZSBleHBvbmVudCA9XG4gIGlmIGV4cG9uZW50IDwgMCB0aGVuIG5lZ2F0aXZlX2V4cG9uZW50ICgpO1xuICBpZiBhYnMgYmFzZSA+IDFcbiAgJiYgKGV4cG9uZW50ID4gNjNcbiAgICAgIHx8IGFicyBiYXNlID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnRfcG9zaXRpdmVfb3ZlcmZsb3dfYm91bmRzLihleHBvbmVudCkpXG4gIHRoZW4gb3ZlcmZsb3cgKCk7XG4gIGludF9tYXRoX2ludF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubW9kdWxlIEludDY0X3dpdGhfY29tcGFyaXNvbnMgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBDYW1sLkludDY0XG5cbiAgZXh0ZXJuYWwgKCA8ICkgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBib29sID0gXCIlbGVzc3RoYW5cIlxuICBleHRlcm5hbCAoID4gKSA6IGludDY0IC0+IGludDY0IC0+IGJvb2wgPSBcIiVncmVhdGVydGhhblwiXG4gIGV4dGVybmFsICggPj0gKSA6IGludDY0IC0+IGludDY0IC0+IGJvb2wgPSBcIiVncmVhdGVyZXF1YWxcIlxuZW5kXG5cbigqIHdlIGRvbid0IGRvIFthYnNdIGluIGludDY0IGNhc2UgdG8gYXZvaWQgYWxsb2NhdGlvbiAqKVxubGV0IGludDY0X3BvdyBiYXNlIGV4cG9uZW50ID1cbiAgbGV0IG9wZW4gSW50NjRfd2l0aF9jb21wYXJpc29ucyBpblxuICBpZiBleHBvbmVudCA8IDBMIHRoZW4gbmVnYXRpdmVfZXhwb25lbnQgKCk7XG4gIGlmIChiYXNlID4gMUwgfHwgYmFzZSA8IC0xTClcbiAgJiYgKGV4cG9uZW50ID4gNjNMXG4gICAgICB8fCAoYmFzZSA+PSAwTFxuICAgICAgICAgICYmIGJhc2UgPiBQb3dfb3ZlcmZsb3dfYm91bmRzLmludDY0X3Bvc2l0aXZlX292ZXJmbG93X2JvdW5kcy4odG9faW50IGV4cG9uZW50KVxuICAgICAgICAgKVxuICAgICAgfHwgKGJhc2UgPCAwTFxuICAgICAgICAgICYmIGJhc2UgPCBQb3dfb3ZlcmZsb3dfYm91bmRzLmludDY0X25lZ2F0aXZlX292ZXJmbG93X2JvdW5kcy4odG9faW50IGV4cG9uZW50KVxuICAgICAgICAgKSlcbiAgdGhlbiBvdmVyZmxvdyAoKTtcbiAgaW50X21hdGhfaW50NjRfcG93IGJhc2UgZXhwb25lbnRcbjs7XG5cbmxldCBpbnQ2M19wb3dfb25faW50NjQgYmFzZSBleHBvbmVudCA9XG4gIGxldCBvcGVuIEludDY0X3dpdGhfY29tcGFyaXNvbnMgaW5cbiAgaWYgZXhwb25lbnQgPCAwTCB0aGVuIG5lZ2F0aXZlX2V4cG9uZW50ICgpO1xuICBpZiBhYnMgYmFzZSA+IDFMXG4gICYmIChleHBvbmVudCA+IDYzTFxuICAgICAgfHwgYWJzIGJhc2VcbiAgICAgICAgID4gUG93X292ZXJmbG93X2JvdW5kcy5pbnQ2M19vbl9pbnQ2NF9wb3NpdGl2ZV9vdmVyZmxvd19ib3VuZHMuKHRvX2ludCBleHBvbmVudClcbiAgICAgKVxuICB0aGVuIG92ZXJmbG93ICgpO1xuICBpbnRfbWF0aF9pbnQ2NF9wb3cgYmFzZSBleHBvbmVudFxuOztcblxubW9kdWxlIHR5cGUgTWFrZV9hcmcgPSBzaWdcbiAgdHlwZSB0XG5cbiAgaW5jbHVkZSBGbG9hdGFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGluY2x1ZGUgU3RyaW5nYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgKCArICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAtICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAqICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCAvICkgOiB0IC0+IHQgLT4gdFxuICB2YWwgKCB+LSApIDogdCAtPiB0XG5cbiAgaW5jbHVkZSBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0XG5cbiAgdmFsIGFicyA6IHQgLT4gdFxuICB2YWwgbmVnIDogdCAtPiB0XG4gIHZhbCB6ZXJvIDogdFxuICB2YWwgb2ZfaW50X2V4biA6IGludCAtPiB0XG4gIHZhbCByZW0gOiB0IC0+IHQgLT4gdFxuZW5kXG5cbm1vZHVsZSBNYWtlIChYIDogTWFrZV9hcmcpID0gc3RydWN0XG4gIG9wZW4gWFxuXG4gIGxldCAoICUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIGludmFsaWRfYXJnZlxuICAgICAgICBcIiVzICUlICVzIGluIGNvcmVfaW50Lm1sOiBtb2R1bHVzIHNob3VsZCBiZSBwb3NpdGl2ZVwiXG4gICAgICAgICh0b19zdHJpbmcgeClcbiAgICAgICAgKHRvX3N0cmluZyB5KVxuICAgICAgICAoKTtcbiAgICBsZXQgcnZhbCA9IFgucmVtIHggeSBpblxuICAgIGlmIHJ2YWwgPCB6ZXJvIHRoZW4gcnZhbCArIHkgZWxzZSBydmFsXG4gIDs7XG5cbiAgbGV0IG9uZSA9IG9mX2ludF9leG4gMVxuXG4gIGxldCAoIC8lICkgeCB5ID1cbiAgICBpZiB5IDw9IHplcm9cbiAgICB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAvJSUgJXMgaW4gY29yZV9pbnQubWw6IGRpdmlzb3Igc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGlmIHggPCB6ZXJvIHRoZW4gKCh4ICsgb25lKSAvIHkpIC0gb25lIGVsc2UgeCAvIHlcbiAgOztcblxuICAoKiogZmxvYXQgZGl2aXNpb24gb2YgaW50ZWdlcnMgKilcbiAgbGV0ICggLy8gKSB4IHkgPSB0b19mbG9hdCB4IC8uIHRvX2Zsb2F0IHlcblxuICBsZXQgcm91bmRfZG93biBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID0gaSAtIChpICUgbW9kdWx1cylcblxuICBsZXQgcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2Y6bW9kdWx1cyA9XG4gICAgbGV0IHJlbWFpbmRlciA9IGkgJSBtb2R1bHVzIGluXG4gICAgaWYgcmVtYWluZGVyID0gemVybyB0aGVuIGkgZWxzZSBpICsgbW9kdWx1cyAtIHJlbWFpbmRlclxuICA7O1xuXG4gIGxldCByb3VuZF90b3dhcmRzX3plcm8gaSB+dG9fbXVsdGlwbGVfb2YgPVxuICAgIGlmIGkgPSB6ZXJvXG4gICAgdGhlbiB6ZXJvXG4gICAgZWxzZSBpZiBpID4gemVyb1xuICAgIHRoZW4gcm91bmRfZG93biBpIH50b19tdWx0aXBsZV9vZlxuICAgIGVsc2Ugcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2ZcbiAgOztcblxuICBsZXQgcm91bmRfbmVhcmVzdCBpIH50b19tdWx0aXBsZV9vZjptb2R1bHVzID1cbiAgICBsZXQgcmVtYWluZGVyID0gaSAlIG1vZHVsdXMgaW5cbiAgICBsZXQgbW9kdWx1c19taW51c19yZW1haW5kZXIgPSBtb2R1bHVzIC0gcmVtYWluZGVyIGluXG4gICAgaWYgbW9kdWx1c19taW51c19yZW1haW5kZXIgPD0gcmVtYWluZGVyXG4gICAgdGhlbiBpICsgbW9kdWx1c19taW51c19yZW1haW5kZXJcbiAgICBlbHNlIGkgLSByZW1haW5kZXJcbiAgOztcblxuICBsZXQgcm91bmQgPyhkaXIgPSBgTmVhcmVzdCkgaSB+dG9fbXVsdGlwbGVfb2YgPVxuICAgIG1hdGNoIGRpciB3aXRoXG4gICAgfCBgTmVhcmVzdCAtPiByb3VuZF9uZWFyZXN0IGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgRG93biAtPiByb3VuZF9kb3duIGkgfnRvX211bHRpcGxlX29mXG4gICAgfCBgVXAgLT4gcm91bmRfdXAgaSB+dG9fbXVsdGlwbGVfb2ZcbiAgICB8IGBaZXJvIC0+IHJvdW5kX3Rvd2FyZHNfemVybyBpIH50b19tdWx0aXBsZV9vZlxuICA7O1xuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBpbnRfcG93ID0gaW50X3Bvd1xuICBsZXQgaW50NjRfcG93ID0gaW50NjRfcG93XG4gIGxldCBpbnQ2M19wb3dfb25faW50NjQgPSBpbnQ2M19wb3dfb25faW50NjRcblxuICBtb2R1bGUgUG93X292ZXJmbG93X2JvdW5kcyA9IFBvd19vdmVyZmxvd19ib3VuZHNcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbigqIEMgc3R1YiBmb3IgaW50IHBvcGNvdW50IHRvIHVzZSB0aGUgUE9QQ05UIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG5leHRlcm5hbCBpbnRfcG9wY291bnQgOiBpbnQgLT4gaW50ID0gXCJCYXNlX2ludF9tYXRoX2ludF9wb3Bjb3VudFwiIFtAQG5vYWxsb2NdXG5cbigqIFRvIG1haW50YWluIGphdmFzY3JpcHQgY29tcGF0aWJpbGl0eSBhbmQgZW5hYmxlIHVuYm94aW5nLCB3ZSBpbXBsZW1lbnQgcG9wY291bnQgaW5cbiAgIE9DYW1sIHJhdGhlciB0aGFuIHVzZSBDIHN0dWJzLiBJbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb206XG4gICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYW1taW5nX3dlaWdodCNFZmZpY2llbnRfaW1wbGVtZW50YXRpb24gKilcbmxldCBpbnQ2NF9wb3Bjb3VudCA9XG4gIGxldCBvcGVuIENhbWwuSW50NjQgaW5cbiAgbGV0ICggKyApID0gYWRkIGluXG4gIGxldCAoIC0gKSA9IHN1YiBpblxuICBsZXQgKCAqICkgPSBtdWwgaW5cbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsIGluXG4gIGxldCAoIGxhbmQgKSA9IGxvZ2FuZCBpblxuICBsZXQgbTEgPSAweDU1NTU1NTU1NTU1NTU1NTVMIGluXG4gICgqIDBiMDEwMTAxMDEuLi4gKilcbiAgbGV0IG0yID0gMHgzMzMzMzMzMzMzMzMzMzMzTCBpblxuICAoKiAwYjAwMTEwMDExLi4uICopXG4gIGxldCBtNCA9IDB4MGYwZjBmMGYwZjBmMGYwZkwgaW5cbiAgKCogMGIwMDAwMTExMS4uLiAqKVxuICBsZXQgaDAxID0gMHgwMTAxMDEwMTAxMDEwMTAxTCBpblxuICAoKiAxIGJpdCBzZXQgcGVyIGJ5dGUgKilcbiAgZnVuIFtAaW5saW5lXSB4IC0+XG4gICAgKCogZ2F0aGVyIHRoZSBiaXQgY291bnQgZm9yIGV2ZXJ5IHBhaXIgb2YgYml0cyAqKVxuICAgIGxldCB4ID0geCAtICgoeCBsc3IgMSkgbGFuZCBtMSkgaW5cbiAgICAoKiBnYXRoZXIgdGhlIGJpdCBjb3VudCBmb3IgZXZlcnkgNCBiaXRzICopXG4gICAgbGV0IHggPSAoeCBsYW5kIG0yKSArICgoeCBsc3IgMikgbGFuZCBtMikgaW5cbiAgICAoKiBnYXRoZXIgdGhlIGJpdCBjb3VudCBmb3IgZXZlcnkgYnl0ZSAqKVxuICAgIGxldCB4ID0gKHggKyAoeCBsc3IgNCkpIGxhbmQgbTQgaW5cbiAgICAoKiBzdW0gdGhlIGJpdCBjb3VudHMgaW4gdGhlIHRvcCBieXRlIGFuZCBzaGlmdCBpdCBkb3duICopXG4gICAgdG9faW50ICgoeCAqIGgwMSkgbHNyIDU2KVxuOztcblxubGV0IGludDMyX3BvcGNvdW50ID1cbiAgKCogT24gNjQtYml0IHN5c3RlbXMsIHRoaXMgaXMgZmFzdGVyIHRoYW4gaW1wbGVtZW50aW5nIHVzaW5nIFtpbnQzMl0gYXJpdGhtZXRpYy4gKilcbiAgbGV0IG1hc2sgPSAweGZmZmZfZmZmZkwgaW5cbiAgZnVuIFtAaW5saW5lXSB4IC0+IGludDY0X3BvcGNvdW50IChDYW1sLkludDY0LmxvZ2FuZCAoQ2FtbC5JbnQ2NC5vZl9pbnQzMiB4KSBtYXNrKVxuOztcblxubGV0IG5hdGl2ZWludF9wb3Bjb3VudCA9XG4gIG1hdGNoIENhbWwuTmF0aXZlaW50LnNpemUgd2l0aFxuICB8IDMyIC0+IGZ1biBbQGlubGluZV0geCAtPiBpbnQzMl9wb3Bjb3VudCAoQ2FtbC5OYXRpdmVpbnQudG9faW50MzIgeClcbiAgfCA2NCAtPiBmdW4gW0BpbmxpbmVdIHggLT4gaW50NjRfcG9wY291bnQgKENhbWwuSW50NjQub2ZfbmF0aXZlaW50IHgpXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2Vcbjs7XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgU2lnbjBcbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKFNpZ24wKVxuXG4oKiBPcGVuIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9ucyBzb1xuICAgdGhleSBkbyBub3Qgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zXG4gICBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubGV0IHRvX2Zsb2F0ID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gLTEuXG4gIHwgWmVybyAtPiAwLlxuICB8IFBvcyAtPiAxLlxuOztcblxubGV0IGZsaXAgPSBmdW5jdGlvblxuICB8IE5lZyAtPiBQb3NcbiAgfCBaZXJvIC0+IFplcm9cbiAgfCBQb3MgLT4gTmVnXG47O1xuXG5sZXQgKCAqICkgdCB0JyA9IG9mX2ludCAodG9faW50IHQgKiB0b19pbnQgdCcpXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGF0IHRoZSBlbmQsIGFmdGVyIGFueVxuICAgZnVuY3RvciBhcHBsaWNhdGlvbnMgdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc29cbiAgIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpc1xuICAgbW9kdWxlLiAqKVxuaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuaW5jbHVkZSBJbnRfaW50ZlxuaW5jbHVkZSBJbnQwXG5cbm1vZHVsZSBUID0gc3RydWN0XG4gIHR5cGUgdCA9IGludCBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGludF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBsZXQgY29tcGFyZSB4IHkgPSBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmUgeCB5XG5cbiAgbGV0IG9mX3N0cmluZyBzID1cbiAgICB0cnkgb2Zfc3RyaW5nIHMgd2l0aFxuICAgIHwgXyAtPiBQcmludGYuZmFpbHdpdGhmIFwiSW50Lm9mX3N0cmluZzogJVNcIiBzICgpXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuZW5kXG5cbmxldCBudW1fYml0cyA9IEludF9jb252ZXJzaW9ucy5udW1fYml0c19pbnRcbmxldCBmbG9hdF9sb3dlcl9ib3VuZCA9IEZsb2F0MC5sb3dlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgZmxvYXRfdXBwZXJfYm91bmQgPSBGbG9hdDAudXBwZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IHRvX2Zsb2F0ID0gQ2FtbC5mbG9hdF9vZl9pbnRcbmxldCBvZl9mbG9hdF91bmNoZWNrZWQgPSBDYW1sLmludF9vZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBDYW1sLmludF9vZl9mbG9hdCBmXG4gIGVsc2VcbiAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICBcIkludC5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxubGV0IHplcm8gPSAwXG5sZXQgb25lID0gMVxubGV0IG1pbnVzX29uZSA9IC0xXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIG9wZW4gSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gICAgdHlwZSB0ID0gaW50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9pbnQgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX2ludFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX2ludCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gKCB+LSApXG4gICAgbGV0ICggPCApID0gKCA8IClcbiAgICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiV4XCIgaVxuICAgIGxldCBvZl9zdHJpbmcgcyA9IENhbWwuU2NhbmYuc3NjYW5mIHMgXCIleFwiIEZuLmlkXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludC5IZXhcIlxuICBlbmQpXG5cbmluY2x1ZGUgUHJldHR5X3ByaW50ZXIuUmVnaXN0ZXIgKHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICBsZXQgdG9fc3RyaW5nID0gdG9fc3RyaW5nXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludFwiXG4gIGVuZClcblxuKCogT3BlbiByZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgYWZ0ZXIgaW5jbHVkaW5nIGZ1bmN0b3IgaW5zdGFudGlhdGlvbnMgc29cbiAgIHRoZXkgZG8gbm90IHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9uc1xuICAgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxuZXh0ZXJuYWwgdG9faW50MzJfdHJ1bmMgOiB0IC0+IGludDMyID0gXCIlaW50MzJfb2ZfaW50XCJcbmV4dGVybmFsIG9mX2ludDMyX3RydW5jIDogaW50MzIgLT4gdCA9IFwiJWludDMyX3RvX2ludFwiXG5leHRlcm5hbCBvZl9pbnQ2NF90cnVuYyA6IGludDY0IC0+IHQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgb2ZfbmF0aXZlaW50X3RydW5jIDogbmF0aXZlaW50IC0+IHQgPSBcIiVuYXRpdmVpbnRfdG9faW50XCJcblxubGV0IHByZWQgaSA9IGkgLSAxXG5sZXQgc3VjYyBpID0gaSArIDFcbmxldCB0b19pbnQgaSA9IGlcbmxldCB0b19pbnRfZXhuID0gdG9faW50XG5sZXQgb2ZfaW50IGkgPSBpXG5sZXQgb2ZfaW50X2V4biA9IG9mX2ludFxubGV0IG1heF92YWx1ZSA9IENhbWwubWF4X2ludFxubGV0IG1pbl92YWx1ZSA9IENhbWwubWluX2ludFxubGV0IG1heF92YWx1ZV8zMF9iaXRzID0gMHgzRkZGX0ZGRkZcbmxldCBvZl9pbnQzMiA9IENvbnYuaW50MzJfdG9faW50XG5sZXQgb2ZfaW50MzJfZXhuID0gQ29udi5pbnQzMl90b19pbnRfZXhuXG5sZXQgdG9faW50MzIgPSBDb252LmludF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYuaW50X3RvX2ludDMyX2V4blxubGV0IG9mX2ludDY0ID0gQ29udi5pbnQ2NF90b19pbnRcbmxldCBvZl9pbnQ2NF9leG4gPSBDb252LmludDY0X3RvX2ludF9leG5cbmxldCB0b19pbnQ2NCA9IENvbnYuaW50X3RvX2ludDY0XG5sZXQgb2ZfbmF0aXZlaW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50XG5sZXQgb2ZfbmF0aXZlaW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludF9leG5cbmxldCB0b19uYXRpdmVpbnQgPSBDb252LmludF90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgYWJzIHggPSBhYnMgeFxuXG4oKiBub3RlIHRoYXQgcmVtIGlzIG5vdCBzYW1lIGFzICUgKilcbmxldCByZW0gYSBiID0gYSBtb2QgYlxubGV0IGluY3IgPSBDYW1sLmluY3JcbmxldCBkZWNyID0gQ2FtbC5kZWNyXG5sZXQgc2hpZnRfcmlnaHQgYSBiID0gYSBhc3IgYlxubGV0IHNoaWZ0X3JpZ2h0X2xvZ2ljYWwgYSBiID0gYSBsc3IgYlxubGV0IHNoaWZ0X2xlZnQgYSBiID0gYSBsc2wgYlxubGV0IGJpdF9ub3QgYSA9IGxub3QgYVxubGV0IGJpdF9vciBhIGIgPSBhIGxvciBiXG5sZXQgYml0X2FuZCBhIGIgPSBhIGxhbmQgYlxubGV0IGJpdF94b3IgYSBiID0gYSBseG9yIGJcbmxldCBwb3cgPSBJbnRfbWF0aC5Qcml2YXRlLmludF9wb3dcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCAtIDEgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgICgqIFRoZSBuZXh0IGxpbmUgaXMgc3VwZXJmbHVvdXMgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIGZhc3RlciB0byBkbyBpdFxuICAgICAgIGFueXdheSB0aGFuIHRvIGJyYW5jaCAqKVxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIHggKyAxXG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IDAgdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMSkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAyKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDQpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgOCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxNikgaW5cbiAgICAoKiBUaGUgbmV4dCBsaW5lIGlzIHN1cGVyZmx1b3VzIG9uIDMyLWJpdCBhcmNoaXRlY3R1cmVzLCBidXQgaXQncyBmYXN0ZXIgdG8gZG8gaXRcbiAgICAgICBhbnl3YXkgdGhhbiB0byBicmFuY2ggKilcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAzMikgaW5cbiAgICB4IC0gKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIHggbGFuZCAoeCAtIDEpID0gMFxuICA7O1xuXG4gICgqIEMgc3R1YnMgZm9yIGludCBjbHogYW5kIGN0eiB0byB1c2UgdGhlIENMWi9CU1IvQ1RaL0JTRiBpbnN0cnVjdGlvbiB3aGVyZSBwb3NzaWJsZSAqKVxuICBleHRlcm5hbCBjbHpcbiAgICA6ICAoKiBOb3RlIHRoYXQgd2UgcGFzcyB0aGUgdGFnZ2VkIGludCBoZXJlLiBTZWUgaW50X21hdGhfc3R1YnMuYyBmb3IgZGV0YWlscyBvbiB3aHlcbiAgICAgICAgICB0aGlzIGlzIGNvcnJlY3QuICopXG4gICAgaW50XG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX2ludF9jbHpcIiBcIkJhc2VfaW50X21hdGhfaW50X2Nsel91bnRhZ2dlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKGludFtAdW50YWdnZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnRfY3R6XCIgXCJCYXNlX2ludF9tYXRoX2ludF9jdHpfdW50YWdnZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgaSA8PSAwXG4gICAgdGhlbiByYWlzZV9zIChTZXhwLm1lc3NhZ2UgXCJbSW50LmZsb29yX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludCBpIF0pO1xuICAgIG51bV9iaXRzIC0gMSAtIGNseiBpXG4gIDs7XG5cbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBpIDw9IDBcbiAgICB0aGVuIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQuY2VpbF9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl9pbnQgaSBdKTtcbiAgICBpZiBpID0gMSB0aGVuIDAgZWxzZSBudW1fYml0cyAtIGNseiAoaSAtIDEpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5cbmxldCBzaWduID0gU2lnbi5vZl9pbnRcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludF9wb3Bjb3VudFxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgZXh0ZXJuYWwgKCArICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFkZGludFwiXG4gIGV4dGVybmFsICggLSApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVzdWJpbnRcIlxuICBleHRlcm5hbCAoICogKSA6IGludCAtPiBpbnQgLT4gaW50ID0gXCIlbXVsaW50XCJcbiAgZXh0ZXJuYWwgKCAvICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWRpdmludFwiXG4gIGV4dGVybmFsICggfi0gKSA6IGludCAtPiBpbnQgPSBcIiVuZWdpbnRcIlxuXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgYWJzID0gYWJzXG5cbiAgZXh0ZXJuYWwgbmVnIDogdCAtPiB0ID0gXCIlbmVnaW50XCJcblxuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIG1vZHVsZSBGID0gSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgaW5jbHVkZSBGXG5cbiAgZXh0ZXJuYWwgYnN3YXAxNiA6IGludCAtPiBpbnQgPSBcIiVic3dhcDE2XCJcblxuICAoKiBUaGVzZSBpbmxpbmVkIHZlcnNpb25zIG9mICglKSwgKC8lKSwgYW5kICgvLykgcGVyZm9ybSBiZXR0ZXIgdGhhbiB0aGVpciBmdW5jdG9yaXplZFxuICAgICBjb3VudGVycGFydHMgaW4gW0ZdIChzZWUgYmVuY2htYXJrcyBiZWxvdykuXG5cbiAgICAgVGhlIHJlYXNvbiB0aGVzZSBmdW5jdGlvbnMgYXJlIGlubGluZWQgaW4gW0ludF0gYnV0IG5vdCBpbiBhbnkgb2YgdGhlIG90aGVyIGludGVnZXJcbiAgICAgbW9kdWxlcyBpcyB0aGF0IHRoZXkgZXhpc3RlZCBpbiBbSW50XSBhbmQgW0ludF0gYWxvbmUgcHJpb3IgdG8gdGhlIGludHJvZHVjdGlvbiBvZlxuICAgICB0aGUgW0ludF9tYXRoLk1ha2VdIGZ1bmN0b3IsIGFuZCB3ZSBkaWRuJ3Qgd2FudCB0byBkZWdyYWRlIHRoZWlyIHBlcmZvcm1hbmNlLlxuXG4gICAgIFdlIHdvbid0IHByZS1lbXB0aXZlbHkgZG8gdGhlIHNhbWUgZm9yIG5ldyBmdW5jdGlvbnMsIHVubGVzcyBzb21lb25lIGNhcmVzLCBvbiBhIGNhc2VcbiAgICAgYnkgY2FzZSBmYXNoaW9uLiAgKilcblxuICBsZXQgKCAlICkgeCB5ID1cbiAgICBpZiB5IDw9IHplcm9cbiAgICB0aGVuXG4gICAgICBQcmludGYuaW52YWxpZF9hcmdmXG4gICAgICAgIFwiJXMgJSUgJXMgaW4gY29yZV9pbnQubWw6IG1vZHVsdXMgc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGxldCBydmFsID0gcmVtIHggeSBpblxuICAgIGlmIHJ2YWwgPCB6ZXJvIHRoZW4gcnZhbCArIHkgZWxzZSBydmFsXG4gIDs7XG5cbiAgbGV0ICggLyUgKSB4IHkgPVxuICAgIGlmIHkgPD0gemVyb1xuICAgIHRoZW5cbiAgICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCIlcyAvJSUgJXMgaW4gY29yZV9pbnQubWw6IGRpdmlzb3Igc2hvdWxkIGJlIHBvc2l0aXZlXCJcbiAgICAgICAgKHRvX3N0cmluZyB4KVxuICAgICAgICAodG9fc3RyaW5nIHkpXG4gICAgICAgICgpO1xuICAgIGlmIHggPCB6ZXJvIHRoZW4gKCh4ICsgb25lKSAvIHkpIC0gb25lIGVsc2UgeCAvIHlcbiAgOztcblxuICBsZXQgKCAvLyApIHggeSA9IHRvX2Zsb2F0IHggLy4gdG9fZmxvYXQgeVxuXG4gIGV4dGVybmFsICggbGFuZCApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVhbmRpbnRcIlxuICBleHRlcm5hbCAoIGxvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiVvcmludFwiXG4gIGV4dGVybmFsICggbHhvciApIDogaW50IC0+IGludCAtPiBpbnQgPSBcIiV4b3JpbnRcIlxuXG4gIGxldCBsbm90ID0gbG5vdFxuXG4gIGV4dGVybmFsICggbHNsICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzbGludFwiXG4gIGV4dGVybmFsICggbHNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWxzcmludFwiXG4gIGV4dGVybmFsICggYXNyICkgOiBpbnQgLT4gaW50IC0+IGludCA9IFwiJWFzcmludFwiXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnRdIGFuZCBbSW50Lk9dIGFncmVlIHZhbHVlLXdpc2UgKilcblxubW9kdWxlIFByaXZhdGUgPSBzdHJ1Y3RcbiAgbW9kdWxlIE9fRiA9IE8uRlxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlciBpbmNsdWRpbmcgZnVuY3RvclxuICAgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnNcbiAgIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnkgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgZmFpbHdpdGhmID0gUHJpbnRmLmZhaWx3aXRoZlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICBpbmNsdWRlIFVjaGFyMFxuXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5VY2hhclwiXG4gIGxldCBoYXNoX2ZvbGRfdCBzdGF0ZSB0ID0gSGFzaC5mb2xkX2ludCBzdGF0ZSAodG9faW50IHQpXG4gIGxldCBoYXNoIHQgPSBIYXNoLnJ1biBoYXNoX2ZvbGRfdCB0XG4gIGxldCB0b19zdHJpbmcgdCA9IFByaW50Zi5zcHJpbnRmIFwiVSslMDRYXCIgKHRvX2ludCB0KVxuXG4gICgqIERvIG5vdCBhY3R1YWxseSBleHBvcnQgdGhpcy4gU2VlIGRpc2N1c3Npb24gaW4gdGhlIC5tbGkgKilcblxuICBsZXQgc2V4cF9vZl90IHQgPSBTZXhwLkF0b20gKHRvX3N0cmluZyB0KVxuXG4gIGxldCB0X29mX3NleHAgc2V4cCA9XG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBTZXhwLkxpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiVWNoYXIudF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbiAgICB8IFNleHAuQXRvbSBzIC0+XG4gICAgICAodHJ5IENhbWwuU2NhbmYuc3NjYW5mIHMgXCJVKyVYXCIgKGZ1biBpIC0+IFVjaGFyMC5vZl9pbnQgaSkgd2l0aFxuICAgICAgIHwgXyAtPiBvZl9zZXhwX2Vycm9yIFwiVWNoYXIudF9vZl9zZXhwOiBhdG9tIG9mIHRoZSBmb3JtIFUrWFhYWCBuZWVkZWRcIiBzZXhwKVxuICA7O1xuXG4gIGxldCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgPVxuICAgIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgU3RyaW5nLnRfc2V4cF9ncmFtbWFyXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBUXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChUKVxuaW5jbHVkZSBDb21wYXJhYmxlLk1ha2UgKFQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4hIFVjaGFyX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGludF9pc19zY2FsYXIgPSBpc192YWxpZFxuXG5sZXQgc3VjY19leG4gYyA9XG4gIHRyeSBVY2hhcjAuc3VjYyBjIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPiBmYWlsd2l0aGYgXCJVY2hhci5zdWNjX2V4bjogJXNcIiBtc2cgKClcbjs7XG5cbmxldCBzdWNjIGMgPVxuICB0cnkgU29tZSAoVWNoYXIwLnN1Y2MgYykgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBOb25lXG47O1xuXG5sZXQgcHJlZF9leG4gYyA9XG4gIHRyeSBVY2hhcjAucHJlZCBjIHdpdGhcbiAgfCBJbnZhbGlkX2FyZ3VtZW50IG1zZyAtPiBmYWlsd2l0aGYgXCJVY2hhci5wcmVkX2V4bjogJXNcIiBtc2cgKClcbjs7XG5cbmxldCBwcmVkIGMgPVxuICB0cnkgU29tZSAoVWNoYXIwLnByZWQgYykgd2l0aFxuICB8IEludmFsaWRfYXJndW1lbnQgXyAtPiBOb25lXG47O1xuXG5sZXQgb2Zfc2NhbGFyIGkgPSBpZiBpbnRfaXNfc2NhbGFyIGkgdGhlbiBTb21lICh1bnNhZmVfb2ZfaW50IGkpIGVsc2UgTm9uZVxuXG5sZXQgb2Zfc2NhbGFyX2V4biBpID1cbiAgaWYgaW50X2lzX3NjYWxhciBpXG4gIHRoZW4gdW5zYWZlX29mX2ludCBpXG4gIGVsc2UgZmFpbHdpdGhmIFwiVWNoYXIub2ZfaW50X2V4biBnb3QgYSBpbnZhbGlkIFVuaWNvZGUgc2NhbGFyIHZhbHVlOiAlMDRYXCIgaSAoKVxuOztcblxubGV0IHRvX3NjYWxhciB0ID0gVWNoYXIwLnRvX2ludCB0XG5sZXQgdG9fY2hhciBjID0gaWYgaXNfY2hhciBjIHRoZW4gU29tZSAodW5zYWZlX3RvX2NoYXIgYykgZWxzZSBOb25lXG5cbmxldCB0b19jaGFyX2V4biBjID1cbiAgaWYgaXNfY2hhciBjXG4gIHRoZW4gdW5zYWZlX3RvX2NoYXIgY1xuICBlbHNlIGZhaWx3aXRoZiBcIlVjaGFyLnRvX2NoYXJfZXhuIGdvdCBhIG5vbiBsYXRpbi0xIGNoYXJhY3RlcjogVSslMDRYXCIgKHRvX2ludCBjKSAoKVxuOztcblxubGV0IHV0ZjhfYnl0ZV9sZW5ndGggdWNoYXIgPVxuICBsZXQgY29kZXBvaW50ID0gdG9fc2NhbGFyIHVjaGFyIGluXG4gIGlmIEludC4oIDwgKSBjb2RlcG9pbnQgMHg4MFxuICB0aGVuIDFcbiAgZWxzZSBpZiBJbnQuKCA8ICkgY29kZXBvaW50IDB4ODAwXG4gIHRoZW4gMlxuICBlbHNlIGlmIEludC4oIDwgKSBjb2RlcG9pbnQgMHgxMDAwMFxuICB0aGVuIDNcbiAgZWxzZSA0XG47O1xuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgVWNoYXJfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcblxudHlwZSAoJ2EsICdiKSB0ID0gVCA6ICgnYSwgJ2EpIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgOlxuICAnYSAnYi5cbiAgKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdiIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwbGliMC5TZXhwLnRcbiAgPVxuICBmdW4gKHR5cGUgYV9fMDAzXyBiX18wMDRfKVxuICAgICAgOiAgKChhX18wMDNfIC0+IFNleHBsaWIwLlNleHAudCkgLT4gKGJfXzAwNF8gLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAgIC0+IChhX18wMDNfLCBiX18wMDRfKSB0IC0+IFNleHBsaWIwLlNleHAudCkgLT5cbiAgICBmdW4gX29mX2FfXzAwMV8gX29mX2JfXzAwMl8gVCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJUXCJcbjs7XG5cbltAQEBlbmRdXG5cbnR5cGUgKCdhLCAnYikgZXF1YWwgPSAoJ2EsICdiKSB0XG5cbmxldCByZWZsID0gVFxubGV0IHN5bSAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIDogKGIsIGEpIHQgPSBUXG5sZXQgdHJhbnMgKHR5cGUgYSBiIGMpIChUIDogKGEsIGIpIHQpIChUIDogKGIsIGMpIHQpIDogKGEsIGMpIHQgPSBUXG5sZXQgY29udiAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIChhIDogYSkgOiBiID0gYVxuXG5tb2R1bGUgTGlmdCAoWCA6IHNpZ1xuICAgIHR5cGUgJ2EgdFxuICBlbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhIGIpIChUIDogKGEsIGIpIHQpIDogKGEgWC50LCBiIFgudCkgdCA9IFRcbmVuZFxuXG5tb2R1bGUgTGlmdDIgKFggOiBzaWdcbiAgICB0eXBlICgnYTEsICdhMikgdFxuICBlbmQpID1cbnN0cnVjdFxuICBsZXQgbGlmdCAodHlwZSBhMSBiMSBhMiBiMikgKFQgOiAoYTEsIGIxKSB0KSAoVCA6IChhMiwgYjIpIHQpXG4gICAgOiAoKGExLCBhMikgWC50LCAoYjEsIGIyKSBYLnQpIHRcbiAgICA9XG4gICAgVFxuICA7O1xuZW5kXG5cbm1vZHVsZSBMaWZ0MyAoWCA6IHNpZ1xuICAgIHR5cGUgKCdhMSwgJ2EyLCAnYTMpIHRcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgbGV0IGxpZnQgKHR5cGUgYTEgYjEgYTIgYjIgYTMgYjMpIChUIDogKGExLCBiMSkgdCkgKFQgOiAoYTIsIGIyKSB0KSAoVCA6IChhMywgYjMpIHQpXG4gICAgOiAoKGExLCBhMiwgYTMpIFgudCwgKGIxLCBiMiwgYjMpIFgudCkgdFxuICAgID1cbiAgICBUXG4gIDs7XG5lbmRcblxubGV0IGRldHVwbGUyICh0eXBlIGExIGEyIGIxIGIyKSAoVCA6IChhMSAqIGEyLCBiMSAqIGIyKSB0KSA6IChhMSwgYjEpIHQgKiAoYTIsIGIyKSB0ID1cbiAgVCwgVFxuOztcblxubGV0IHR1cGxlMiAodHlwZSBhMSBhMiBiMSBiMikgKFQgOiAoYTEsIGIxKSB0KSAoVCA6IChhMiwgYjIpIHQpIDogKGExICogYTIsIGIxICogYjIpIHQgPSBUXG5cbm1vZHVsZSB0eXBlIEluamVjdGl2ZSA9IHNpZ1xuICB0eXBlICdhIHRcblxuICB2YWwgc3RyaXAgOiAoJ2EgdCwgJ2IgdCkgZXF1YWwgLT4gKCdhLCAnYikgZXF1YWxcbmVuZFxuXG5tb2R1bGUgdHlwZSBJbmplY3RpdmUyID0gc2lnXG4gIHR5cGUgKCdhMSwgJ2EyKSB0XG5cbiAgdmFsIHN0cmlwIDogKCgnYTEsICdhMikgdCwgKCdiMSwgJ2IyKSB0KSBlcXVhbCAtPiAoJ2ExLCAnYjEpIGVxdWFsICogKCdhMiwgJ2IyKSBlcXVhbFxuZW5kXG5cbm1vZHVsZSBDb21wb3NpdGlvbl9wcmVzZXJ2ZXNfaW5qZWN0aXZpdHkgKE0xIDogSW5qZWN0aXZlKSAoTTIgOiBJbmplY3RpdmUpID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIE0xLnQgTTIudFxuXG4gIGxldCBzdHJpcCBlID0gTTEuc3RyaXAgKE0yLnN0cmlwIGUpXG5lbmRcblxubW9kdWxlIElkID0gc3RydWN0XG4gIG1vZHVsZSBVaWQgPSBJbnRcblxuICBtb2R1bGUgV2l0bmVzcyA9IHN0cnVjdFxuICAgIG1vZHVsZSBLZXkgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgXyB0ID0gLi5cbiAgICAgIHR5cGUgdHlwZV93aXRuZXNzX2ludCA9IFsgYHR5cGVfd2l0bmVzcyBvZiBpbnQgXSBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgICAgbGV0IHNleHBfb2ZfdHlwZV93aXRuZXNzX2ludCA9XG4gICAgICAgIChmdW4gKGB0eXBlX3dpdG5lc3Mgdl9fMDA1XykgLT5cbiAgICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwidHlwZV93aXRuZXNzXCI7IHNleHBfb2ZfaW50IHZfXzAwNV8gXVxuICAgICAgICAgICA6IHR5cGVfd2l0bmVzc19pbnQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgOztcblxuICAgICAgW0BAQGVuZF1cblxuICAgICAgbGV0IHNleHBfb2ZfdCBfc2V4cF9vZl9hIHQgPVxuICAgICAgICBgdHlwZV93aXRuZXNzXG4gICAgICAgICAgKENhbWwuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZCAoQ2FtbC5PYmouRXh0ZW5zaW9uX2NvbnN0cnVjdG9yLm9mX3ZhbCB0KSlcbiAgICAgICAgfD4gc2V4cF9vZl90eXBlX3dpdG5lc3NfaW50XG4gICAgICA7O1xuICAgIGVuZFxuXG4gICAgbW9kdWxlIHR5cGUgUyA9IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgICB0eXBlIF8gS2V5LnQgKz0gS2V5IDogdCBLZXkudFxuICAgIGVuZFxuXG4gICAgdHlwZSAnYSB0ID0gKG1vZHVsZSBTIHdpdGggdHlwZSB0ID0gJ2EpXG5cbiAgICBsZXQgc2V4cF9vZl90ICh0eXBlIGEpIHNleHBfb2ZfYSAobW9kdWxlIE0gOiBTIHdpdGggdHlwZSB0ID0gYSkgPVxuICAgICAgTS5LZXkgfD4gS2V5LnNleHBfb2ZfdCBzZXhwX29mX2FcbiAgICA7O1xuXG4gICAgbGV0IGNyZWF0ZSAodHlwZSB0KSAoKSA9XG4gICAgICBsZXQgbW9kdWxlIE0gPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSBub25yZWMgdCA9IHRcbiAgICAgICAgdHlwZSBfIEtleS50ICs9IEtleSA6IHQgS2V5LnRcbiAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSB0KVxuICAgIDs7XG5cbiAgICBsZXQgdWlkICh0eXBlIGEpIChtb2R1bGUgTSA6IFMgd2l0aCB0eXBlIHQgPSBhKSA9XG4gICAgICBDYW1sLk9iai5FeHRlbnNpb25fY29uc3RydWN0b3IuaWQgKENhbWwuT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5vZl92YWwgTS5LZXkpXG4gICAgOztcblxuICAgICgqIFdlIHdhbnQgYSBjb25zdGFudCBhbGxvY2F0ZWQgb25jZSB0aGF0IFtzYW1lXSBjYW4gcmV0dXJuIHdoZW5ldmVyIGl0IGdldHMgdGhlIHNhbWVcbiAgICAgICB3aXRuZXNzZXMuICBJZiB3ZSB3cml0ZSB0aGUgY29uc3RhbnQgaW5zaWRlIHRoZSBib2R5IG9mIFtzYW1lXSwgdGhlIG5hdGl2ZS1jb2RlXG4gICAgICAgY29tcGlsZXIgd2lsbCBkbyB0aGUgcmlnaHQgdGhpbmcgYW5kIGxpZnQgaXQgb3V0LiAgQnV0IGZvciBjbGFyaXR5IGFuZCByb2J1c3RuZXNzLFxuICAgICAgIHdlIGRvIGl0IG91cnNlbHZlcy4gKilcbiAgICBsZXQgc29tZV90ID0gU29tZSBUXG5cbiAgICBsZXQgc2FtZSAodHlwZSBhIGIpIChhIDogYSB0KSAoYiA6IGIgdCkgOiAoYSwgYikgZXF1YWwgb3B0aW9uID1cbiAgICAgIGxldCBtb2R1bGUgQSA9ICh2YWwgYSA6IFMgd2l0aCB0eXBlIHQgPSBhKSBpblxuICAgICAgbGV0IG1vZHVsZSBCID0gKHZhbCBiIDogUyB3aXRoIHR5cGUgdCA9IGIpIGluXG4gICAgICBtYXRjaCBBLktleSB3aXRoXG4gICAgICB8IEIuS2V5IC0+IHNvbWVfdFxuICAgICAgfCBfIC0+IE5vbmVcbiAgICA7O1xuICBlbmRcblxuXG4gIHR5cGUgJ2EgdCA9XG4gICAgeyB3aXRuZXNzIDogJ2EgV2l0bmVzcy50XG4gICAgOyBuYW1lIDogc3RyaW5nXG4gICAgOyB0b19zZXhwIDogJ2EgLT4gU2V4cC50XG4gICAgfVxuXG4gIGxldCBzZXhwX29mX3QgXyB7IHdpdG5lc3M7IG5hbWU7IHRvX3NleHAgfSA6IFNleHAudCA9XG4gICAgaWYgYW1fdGVzdGluZ1xuICAgIHRoZW4gQXRvbSBuYW1lXG4gICAgZWxzZVxuICAgICAgTGlzdFxuICAgICAgICBbIExpc3QgWyBBdG9tIFwibmFtZVwiOyBBdG9tIG5hbWUgXVxuICAgICAgICA7IExpc3QgWyBBdG9tIFwid2l0bmVzc1wiOyB3aXRuZXNzIHw+IFdpdG5lc3Muc2V4cF9vZl90IHRvX3NleHAgXVxuICAgICAgICBdXG4gIDs7XG5cbiAgbGV0IHRvX3NleHAgdCA9IHQudG9fc2V4cFxuICBsZXQgbmFtZSB0ID0gdC5uYW1lXG4gIGxldCBjcmVhdGUgfm5hbWUgdG9fc2V4cCA9IHsgd2l0bmVzcyA9IFdpdG5lc3MuY3JlYXRlICgpOyBuYW1lOyB0b19zZXhwIH1cbiAgbGV0IHVpZCB0ID0gV2l0bmVzcy51aWQgdC53aXRuZXNzXG4gIGxldCBoYXNoIHQgPSB1aWQgdFxuICBsZXQgaGFzaF9mb2xkX3QgcyB0ID0gaGFzaF9mb2xkX2ludCBzICh1aWQgdClcbiAgbGV0IHNhbWVfd2l0bmVzcyB0MSB0MiA9IFdpdG5lc3Muc2FtZSB0MS53aXRuZXNzIHQyLndpdG5lc3NcbiAgbGV0IHNhbWUgdDEgdDIgPSBPcHRpb24uaXNfc29tZSAoc2FtZV93aXRuZXNzIHQxIHQyKVxuXG4gIGxldCBzYW1lX3dpdG5lc3NfZXhuIHQxIHQyID1cbiAgICBtYXRjaCBzYW1lX3dpdG5lc3MgdDEgdDIgd2l0aFxuICAgIHwgU29tZSB3IC0+IHdcbiAgICB8IE5vbmUgLT5cbiAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIlR5cGVfZXF1YWwuSWQuc2FtZV93aXRuZXNzX2V4biBnb3QgZGlmZmVyZW50IGlkc1wiXG4gICAgICAgICAgIFsgKCBcIlwiXG4gICAgICAgICAgICAgLCBzZXhwX29mX3BhaXIgKHNleHBfb2ZfdCBzZXhwX29mX29wYXF1ZSkgKHNleHBfb2ZfdCBzZXhwX29mX29wYXF1ZSkgKHQxLCB0MilcbiAgICAgICAgICAgICApXG4gICAgICAgICAgIF0pXG4gIDs7XG5lbmRcbiIsIm9wZW4hIEltcG9ydFxuXG4oKiogWydhIENoZWFwX29wdGlvbi50XSBpcyBsaWtlIFsnYSBvcHRpb25dLCBidXQgaXQgZG9lc24ndCBib3ggW3NvbWUgX10gdmFsdWVzLlxuXG4gICAgVGhlcmUgYXJlIHNldmVyYWwgdGhpbmdzIHRoYXQgYXJlIHVuc2FmZSBhYm91dCBpdDpcblxuICAgIC0gW2Zsb2F0IHQgYXJyYXldIChvciBhbnkgYXJyYXktYmFja2VkIGNvbnRhaW5lcikgaXMgbm90IG1lbW9yeS1zYWZlXG4gICAgICBiZWNhdXNlIGZsb2F0IGFycmF5IG9wdGltaXphdGlvbiBpcyBpbmNvbXBhdGlibGUgd2l0aCB1bmJveGVkIG9wdGlvblxuICAgICAgb3B0aW1pemF0aW9uLiBZb3UgaGF2ZSB0byB1c2UgW1VuaWZvcm1fYXJyYXkudF0gaW5zdGVhZCBvZiBbYXJyYXldLlxuXG4gICAgLSBOZXN0ZWQgb3B0aW9ucyAoWydhIHQgdF0pIGRvbid0IHdvcmsuIFRoZXkgYXJlIGJlbGlldmVkIHRvIGJlXG4gICAgICBtZW1vcnktc2FmZSwgYnV0IG5vdCBwYXJhbWV0cmljLlxuXG4gICAgLSBBIHJlY29yZCB3aXRoIFtmbG9hdCB0XXMgaW4gaXQgc2hvdWxkIGJlIHNhZmUsIGJ1dCBpdCdzIG9ubHkgW3RdIGJlaW5nXG4gICAgICBhYnN0cmFjdCB0aGF0IGdpdmVzIHlvdSBzYWZldHkuIElmIHRoZSBjb21waWxlciB3YXMgc21hcnQgZW5vdWdoIHRvIHBlZWtcbiAgICAgIHRocm91Z2ggdGhlIG1vZHVsZSBzaWduYXR1cmUgdGhlbiBpdCBjb3VsZCBkZWNpZGUgdG8gY29uc3RydWN0IGEgZmxvYXRcbiAgICAgIGFycmF5IGluc3RlYWQuICopXG5tb2R1bGUgQ2hlYXBfb3B0aW9uID0gc3RydWN0XG4gICgqIFRoaXMgaXMgdGFrZW4gZnJvbSBjb3JlLiBSYXRoZXIgdGhhbiBleHBvc2UgaXQgaW4gdGhlIHB1YmxpYyBpbnRlcmZhY2Ugb2YgYmFzZSwganVzdFxuICAgICBrZWVwIGEgY29weSBhcm91bmQgaGVyZS4gKilcbiAgbGV0IHBoeXNfc2FtZSAodHlwZSBhIGIpIChhIDogYSkgKGIgOiBiKSA9IHBoeXNfZXF1YWwgYSAoQ2FtbC5PYmoubWFnaWMgYiA6IGEpXG5cbiAgbW9kdWxlIFQwIDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgbm9uZSA6IF8gdFxuICAgIHZhbCBzb21lIDogJ2EgLT4gJ2EgdFxuICAgIHZhbCBpc19ub25lIDogXyB0IC0+IGJvb2xcbiAgICB2YWwgaXNfc29tZSA6IF8gdCAtPiBib29sXG4gICAgdmFsIHZhbHVlX2V4biA6ICdhIHQgLT4gJ2FcbiAgICB2YWwgdmFsdWVfdW5zYWZlIDogJ2EgdCAtPiAnYVxuICAgIHZhbCBpdGVyX3NvbWUgOiAnYSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgZW5kID0gc3RydWN0XG4gICAgdHlwZSArJ2EgdFxuXG4gICAgKCogQmVpbmcgYSBwb2ludGVyLCBubyBvbmUgb3V0c2lkZSB0aGlzIG1vZHVsZSBjYW4gY29uc3RydWN0IGEgdmFsdWUgdGhhdCBpc1xuICAgICAgIFtwaHlzX3NhbWVdIGFzIHRoaXMgb25lLlxuXG4gICAgICAgSXQgd291bGQgYmUgc2ltcGxlciB0byB1c2UgdGhpcyB2YWx1ZSBhcyBbbm9uZV0sIGJ1dCB3ZSB1c2UgYW4gaW1tZWRpYXRlIGluc3RlYWRcbiAgICAgICBiZWNhdXNlIGl0IGxldHMgdXMgYXZvaWQgY2FtbF9tb2RpZnkgd2hlbiBzZXR0aW5nIHRvIFtub25lXSwgbWFraW5nIGNlcnRhaW5cbiAgICAgICBiZW5jaG1hcmtzIHNpZ25pZmljYW50bHkgZmFzdGVyIChlLmcuIC4uL2JlbmNoL2FycmF5X3F1ZXVlLmV4ZSkuXG5cbiAgICAgICB0aGlzIGNvZGUgaXMgZHVwbGljYXRlZCBpbiBNb3B0aW9uLCBhbmQgaWYgd2UgZmluZCB5ZXQgYW5vdGhlciBwbGFjZSB3aGVyZSB3ZSB3YW50XG4gICAgICAgaXQgd2Ugc2hvdWxkIHJlY29uc2lkZXIgbWFraW5nIGl0IHNoYXJlZC4gKilcbiAgICBsZXQgbm9uZV9zdWJzdGl0dXRlIDogXyB0ID0gQ2FtbC5PYmoub2JqIChDYW1sLk9iai5uZXdfYmxvY2sgQ2FtbC5PYmouYWJzdHJhY3RfdGFnIDEpXG5cbiAgICBsZXQgbm9uZSA6IF8gdCA9XG4gICAgICAoKiBUaGUgbnVtYmVyIHdhcyBwcm9kdWNlZCBieVxuICAgICAgICAgWzwgL2Rldi91cmFuZG9tIHRyIC1jIC1kICcxMjM0NTY3ODkwYWJjZGVmJyB8IGhlYWQgLWMgMTZdLlxuXG4gICAgICAgICBUaGUgaWRlYSBpcyB0aGF0IGEgcmFuZG9tIG51bWJlciB3aWxsIGhhdmUgbG93ZXIgcHJvYmFiaWxpdHkgdG8gY29sbGlkZSB3aXRoXG4gICAgICAgICBhbnl0aGluZyB0aGFuIGFueSBudW1iZXIgd2UgY2FuIGNob29zZSBvdXJzZWx2ZXMuXG5cbiAgICAgICAgIFdlIGFyZSB1c2luZyBhIHBvbHltb3JwaGljIHZhcmlhbnQgaW5zdGVhZCBvZiBhbiBpbnRlZ2VyIGNvbnN0YW50IGJlY2F1c2UgdGhlcmVcbiAgICAgICAgIGlzIGEgY29tcGlsZXIgYnVnIHdoZXJlIGl0IHdyb25nbHkgYXNzdW1lcyB0aGF0IHRoZSByZXN1bHQgb2YgW2lmIF8gdGhlbiBjIGVsc2VcbiAgICAgICAgIHldIGlzIG5vdCBhIHBvaW50ZXIgaWYgW2NdIGlzIGFuIGludGVnZXIgY29tcGlsZS10aW1lIGNvbnN0YW50LiAgVGhpcyBpcyBiZWluZ1xuICAgICAgICAgZml4ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL29jYW1sL29jYW1sL3B1bGwvNTU1LiAgVGhlIFwibWVtb3J5IGNvcnJ1cHRpb25cIiB0ZXN0XG4gICAgICAgICBiZWxvdyBkZW1vbnN0cmF0ZXMgdGhlIGlzc3VlLiAgKilcbiAgICAgIENhbWwuT2JqLm1hZ2ljIGB4NmU4ZWUzNDc4ZTFkNzQ0OVxuICAgIDs7XG5cbiAgICBsZXQgaXNfbm9uZSB4ID0gcGh5c19lcXVhbCB4IG5vbmVcbiAgICBsZXQgaXNfc29tZSB4ID0gbm90IChwaHlzX2VxdWFsIHggbm9uZSlcblxuICAgIGxldCBzb21lICh0eXBlIGEpICh4IDogYSkgOiBhIHQgPVxuICAgICAgaWYgcGh5c19zYW1lIHggbm9uZSB0aGVuIG5vbmVfc3Vic3RpdHV0ZSBlbHNlIENhbWwuT2JqLm1hZ2ljIHhcbiAgICA7O1xuXG4gICAgbGV0IHZhbHVlX3Vuc2FmZSAodHlwZSBhKSAoeCA6IGEgdCkgOiBhID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgeCBub25lX3N1YnN0aXR1dGUgdGhlbiBDYW1sLk9iai5tYWdpYyBub25lIGVsc2UgQ2FtbC5PYmoubWFnaWMgeFxuICAgIDs7XG5cbiAgICBsZXQgdmFsdWVfZXhuIHggPVxuICAgICAgaWYgaXNfc29tZSB4XG4gICAgICB0aGVuIHZhbHVlX3Vuc2FmZSB4XG4gICAgICBlbHNlIGZhaWx3aXRoIFwiT3B0aW9uX2FycmF5LmdldF9zb21lX2V4bjogdGhlIGVsZW1lbnQgaXMgW05vbmVdXCJcbiAgICA7O1xuXG4gICAgbGV0IGl0ZXJfc29tZSB0IH5mID0gaWYgaXNfc29tZSB0IHRoZW4gZiAodmFsdWVfdW5zYWZlIHQpXG4gIGVuZFxuXG4gIG1vZHVsZSBUMSA9IHN0cnVjdFxuICAgIGluY2x1ZGUgVDBcblxuICAgIGxldCBvZl9vcHRpb24gPSBmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IG5vbmVcbiAgICAgIHwgU29tZSB4IC0+IHNvbWUgeFxuICAgIDs7XG5cbiAgICBsZXRbQGlubGluZV0gdG9fb3B0aW9uIHggPSBpZiBpc19zb21lIHggdGhlbiBTb21lICh2YWx1ZV91bnNhZmUgeCkgZWxzZSBOb25lXG4gICAgbGV0IHRvX3NleHBhYmxlID0gdG9fb3B0aW9uXG4gICAgbGV0IG9mX3NleHBhYmxlID0gb2Zfb3B0aW9uXG5cbiAgICBsZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgICAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgICAgID1cbiAgICAgIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKE9wdGlvbi50X3NleHBfZ3JhbW1hciBncmFtbWFyKVxuICAgIDs7XG4gIGVuZFxuXG4gIGluY2x1ZGUgVDFcbiAgaW5jbHVkZSBTZXhwYWJsZS5PZl9zZXhwYWJsZTEgKE9wdGlvbikgKFQxKVxuZW5kXG5cbnR5cGUgJ2EgdCA9ICdhIENoZWFwX29wdGlvbi50IFVuaWZvcm1fYXJyYXkudCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgZnVuIF9vZl9hX18wMDFfIHhfXzAwM18gLT5cbiAgVW5pZm9ybV9hcnJheS50X29mX3NleHAgKENoZWFwX29wdGlvbi50X29mX3NleHAgX29mX2FfXzAwMV8pIHhfXzAwM19cbjs7XG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAwNF8geF9fMDA1XyAtPlxuICBVbmlmb3JtX2FycmF5LnNleHBfb2ZfdCAoQ2hlYXBfb3B0aW9uLnNleHBfb2ZfdCBfb2ZfYV9fMDA0XykgeF9fMDA1X1xuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgVW5pZm9ybV9hcnJheS50X3NleHBfZ3JhbW1hciAoQ2hlYXBfb3B0aW9uLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXIpXG47O1xuXG5bQEBAZW5kXVxuXG5sZXQgZW1wdHkgPSBVbmlmb3JtX2FycmF5LmVtcHR5XG5sZXQgY3JlYXRlIH5sZW4gPSBVbmlmb3JtX2FycmF5LmNyZWF0ZSB+bGVuIENoZWFwX29wdGlvbi5ub25lXG5sZXQgaW5pdCBuIH5mID0gVW5pZm9ybV9hcnJheS5pbml0IG4gfmY6KGZ1biBpIC0+IENoZWFwX29wdGlvbi5vZl9vcHRpb24gKGYgaSkpXG5sZXQgaW5pdF9zb21lIG4gfmYgPSBVbmlmb3JtX2FycmF5LmluaXQgbiB+ZjooZnVuIGkgLT4gQ2hlYXBfb3B0aW9uLnNvbWUgKGYgaSkpXG5sZXQgbGVuZ3RoID0gVW5pZm9ybV9hcnJheS5sZW5ndGhcbmxldFtAaW5saW5lXSBnZXQgdCBpID0gQ2hlYXBfb3B0aW9uLnRvX29wdGlvbiAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IGdldF9zb21lX2V4biB0IGkgPSBDaGVhcF9vcHRpb24udmFsdWVfZXhuIChVbmlmb3JtX2FycmF5LmdldCB0IGkpXG5sZXQgaXNfbm9uZSB0IGkgPSBDaGVhcF9vcHRpb24uaXNfbm9uZSAoVW5pZm9ybV9hcnJheS5nZXQgdCBpKVxubGV0IGlzX3NvbWUgdCBpID0gQ2hlYXBfb3B0aW9uLmlzX3NvbWUgKFVuaWZvcm1fYXJyYXkuZ2V0IHQgaSlcbmxldCBzZXQgdCBpIHggPSBVbmlmb3JtX2FycmF5LnNldCB0IGkgKENoZWFwX29wdGlvbi5vZl9vcHRpb24geClcbmxldCBzZXRfc29tZSB0IGkgeCA9IFVuaWZvcm1fYXJyYXkuc2V0IHQgaSAoQ2hlYXBfb3B0aW9uLnNvbWUgeClcbmxldCBzZXRfbm9uZSB0IGkgPSBVbmlmb3JtX2FycmF5LnNldCB0IGkgQ2hlYXBfb3B0aW9uLm5vbmVcbmxldCBzd2FwIHQgaSBqID0gVW5pZm9ybV9hcnJheS5zd2FwIHQgaSBqXG5sZXQgdW5zYWZlX2dldCB0IGkgPSBDaGVhcF9vcHRpb24udG9fb3B0aW9uIChVbmlmb3JtX2FycmF5LnVuc2FmZV9nZXQgdCBpKVxubGV0IHVuc2FmZV9nZXRfc29tZV9leG4gdCBpID0gQ2hlYXBfb3B0aW9uLnZhbHVlX2V4biAoVW5pZm9ybV9hcnJheS51bnNhZmVfZ2V0IHQgaSlcblxubGV0IHVuc2FmZV9nZXRfc29tZV9hc3N1bWluZ19zb21lIHQgaSA9XG4gIENoZWFwX29wdGlvbi52YWx1ZV91bnNhZmUgKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG47O1xuXG5sZXQgdW5zYWZlX2lzX3NvbWUgdCBpID0gQ2hlYXBfb3B0aW9uLmlzX3NvbWUgKFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCB0IGkpXG5sZXQgdW5zYWZlX3NldCB0IGkgeCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX3NldCB0IGkgKENoZWFwX29wdGlvbi5vZl9vcHRpb24geClcbmxldCB1bnNhZmVfc2V0X3NvbWUgdCBpIHggPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIChDaGVhcF9vcHRpb24uc29tZSB4KVxubGV0IHVuc2FmZV9zZXRfbm9uZSB0IGkgPSBVbmlmb3JtX2FycmF5LnVuc2FmZV9zZXQgdCBpIENoZWFwX29wdGlvbi5ub25lXG5cbmxldCBjbGVhciB0ID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCB0IC0gMSBkb1xuICAgIHVuc2FmZV9zZXRfbm9uZSB0IGlcbiAgZG9uZVxuOztcblxubGV0IGl0ZXJpIGlucHV0IH5mID1cbiAgZm9yIGkgPSAwIHRvIGxlbmd0aCBpbnB1dCAtIDEgZG9cbiAgICBmIGkgKHVuc2FmZV9nZXQgaW5wdXQgaSlcbiAgZG9uZVxuOztcblxubGV0IGl0ZXIgaW5wdXQgfmYgPSBpdGVyaSBpbnB1dCB+ZjooZnVuIChfIDogaW50KSB4IC0+IGYgeClcblxubGV0IGZvbGRpIGlucHV0IH5pbml0IH5mID1cbiAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gIGl0ZXJpIGlucHV0IH5mOihmdW4gaSBlbGVtIC0+IGFjYyA6PSBmIGkgIWFjYyBlbGVtKTtcbiAgIWFjY1xuOztcblxubGV0IGZvbGQgaW5wdXQgfmluaXQgfmYgPSBmb2xkaSBpbnB1dCB+aW5pdCB+ZjooZnVuIChfIDogaW50KSBhY2MgeCAtPiBmIGFjYyB4KVxuXG5pbmNsdWRlIEluZGV4ZWRfY29udGFpbmVyLk1ha2VfZ2VuIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuICAgIHR5cGUgJ2EgZWx0ID0gJ2Egb3B0aW9uXG5cbiAgICBsZXQgZm9sZCA9IGZvbGRcbiAgICBsZXQgZm9sZGkgPSBgQ3VzdG9tIGZvbGRpXG4gICAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgICBsZXQgaXRlcmkgPSBgQ3VzdG9tIGl0ZXJpXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gIGVuZClcblxubGV0IG1hcGkgaW5wdXQgfmYgPVxuICBsZXQgb3V0cHV0ID0gY3JlYXRlIH5sZW46KGxlbmd0aCBpbnB1dCkgaW5cbiAgaXRlcmkgaW5wdXQgfmY6KGZ1biBpIGVsZW0gLT4gdW5zYWZlX3NldCBvdXRwdXQgaSAoZiBpIGVsZW0pKTtcbiAgb3V0cHV0XG47O1xuXG5sZXQgbWFwIGlucHV0IH5mID0gbWFwaSBpbnB1dCB+ZjooZnVuIChfIDogaW50KSBlbGVtIC0+IGYgZWxlbSlcblxubGV0IG1hcF9zb21lIGlucHV0IH5mID1cbiAgbGV0IGxlbiA9IGxlbmd0aCBpbnB1dCBpblxuICBsZXQgb3V0cHV0ID0gY3JlYXRlIH5sZW4gaW5cbiAgbGV0ICgpID1cbiAgICBmb3IgaSA9IDAgdG8gbGVuIC0gMSBkb1xuICAgICAgbGV0IG9wdCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2dldCBpbnB1dCBpIGluXG4gICAgICBDaGVhcF9vcHRpb24uaXRlcl9zb21lIG9wdCB+ZjooZnVuIHggLT4gdW5zYWZlX3NldF9zb21lIG91dHB1dCBpIChmIHgpKVxuICAgIGRvbmVcbiAgaW5cbiAgb3V0cHV0XG47O1xuXG5sZXQgb2ZfYXJyYXkgYXJyYXkgPSBpbml0IChBcnJheS5sZW5ndGggYXJyYXkpIH5mOihmdW4gaSAtPiBBcnJheS51bnNhZmVfZ2V0IGFycmF5IGkpXG5cbmxldCBvZl9hcnJheV9zb21lIGFycmF5ID1cbiAgaW5pdF9zb21lIChBcnJheS5sZW5ndGggYXJyYXkpIH5mOihmdW4gaSAtPiBBcnJheS51bnNhZmVfZ2V0IGFycmF5IGkpXG47O1xuXG5sZXQgdG9fYXJyYXkgdCA9IEFycmF5LmluaXQgKGxlbmd0aCB0KSB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5cbmluY2x1ZGUgQmxpdC5NYWtlMV9nZW5lcmljIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGxlbmd0aCA9IGxlbmd0aFxuICAgIGxldCBjcmVhdGVfbGlrZSB+bGVuIF8gPSBjcmVhdGUgfmxlblxuICAgIGxldCB1bnNhZmVfYmxpdCA9IFVuaWZvcm1fYXJyYXkudW5zYWZlX2JsaXRcbiAgZW5kKVxuXG5sZXQgY29weSA9IFVuaWZvcm1fYXJyYXkuY29weVxuXG5tb2R1bGUgRm9yX3Rlc3RpbmcgPSBzdHJ1Y3RcbiAgbW9kdWxlIFVuc2FmZV9jaGVhcF9vcHRpb24gPSBDaGVhcF9vcHRpb25cbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5pbmNsdWRlIFN0YWNrX2ludGZcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbigqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgc2ltaWxhciB0byBbRGVxdWVdIGluIHRoYXQgaXQgdXNlcyBhbiBhcnJheSBvZiBbJ2FdIGFuZFxuICAgYSBtdXRhYmxlIFtpbnRdIHRvIGluZGljYXRlIHdoYXQgaW4gdGhlIGFycmF5IGlzIHVzZWQuICBXZSBjaG9vc2UgdG8gaW1wbGVtZW50IFtTdGFja11cbiAgIGRpcmVjdGx5IHJhdGhlciB0aGFuIG9uIHRvcCBvZiBbRGVxdWVdIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiAgRS5nLiBhIHNpbXBsZVxuICAgbWljcm9iZW5jaG1hcmsgc2hvd3MgdGhhdCBwdXNoL3BvcCBpcyBhYm91dCAyMCUgZmFzdGVyLiAqKVxudHlwZSAnYSB0ID1cbiAgeyBtdXRhYmxlIGxlbmd0aCA6IGludFxuICA7IG11dGFibGUgZWx0cyA6ICdhIE9wdGlvbl9hcnJheS50XG4gIH1cbltAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG5sZXQgc2V4cF9vZl90IDogJ2EuICgnYSAtPiBTZXhwbGliMC5TZXhwLnQpIC0+ICdhIHQgLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgZnVuIF9vZl9hX18wMDFfIHsgbGVuZ3RoID0gbGVuZ3RoX18wMDNfOyBlbHRzID0gZWx0c19fMDA1XyB9IC0+XG4gIGxldCBibmRzX18wMDJfID0gW10gaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAwNl8gPSBPcHRpb25fYXJyYXkuc2V4cF9vZl90IF9vZl9hX18wMDFfIGVsdHNfXzAwNV8gaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJlbHRzXCI7IGFyZ19fMDA2XyBdIDo6IGJuZHNfXzAwMl9cbiAgaW5cbiAgbGV0IGJuZHNfXzAwMl8gPVxuICAgIGxldCBhcmdfXzAwNF8gPSBzZXhwX29mX2ludCBsZW5ndGhfXzAwM18gaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJsZW5ndGhcIjsgYXJnX18wMDRfIF0gOjogYm5kc19fMDAyX1xuICBpblxuICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDAyX1xuOztcblxuW0BAQGVuZF1cblxubGV0IHNleHBfb2ZfdF9pbnRlcm5hbCA9IHNleHBfb2ZfdFxubGV0IHNleHBfb2ZfdCA9IGBSZWJvdW5kX2xhdGVyXG5sZXQgXyA9IHNleHBfb2ZfdFxubGV0IGNhcGFjaXR5IHQgPSBPcHRpb25fYXJyYXkubGVuZ3RoIHQuZWx0c1xuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9hICh7IGxlbmd0aDsgZWx0cyB9IGFzIHQpIDogdW5pdCA9XG4gIHRyeVxuICAgIGFzc2VydCAoMCA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IE9wdGlvbl9hcnJheS5sZW5ndGggZWx0cyk7XG4gICAgZm9yIGkgPSAwIHRvIGxlbmd0aCAtIDEgZG9cbiAgICAgIGludmFyaWFudF9hIChPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIGVsdHMgaSlcbiAgICBkb25lO1xuICAgICgqIFdlIG1haW50YWluIHRoZSBpbnZhcmlhbnQgdGhhdCB1bnVzZWQgZWxlbWVudHMgYXJlIHVuc2V0IHRvIGF2b2lkIGEgc3BhY2VcbiAgICAgICBsZWFrLiAqKVxuICAgIGZvciBpID0gbGVuZ3RoIHRvIE9wdGlvbl9hcnJheS5sZW5ndGggZWx0cyAtIDEgZG9cbiAgICAgIGFzc2VydCAobm90IChPcHRpb25fYXJyYXkuaXNfc29tZSBlbHRzIGkpKVxuICAgIGRvbmVcbiAgd2l0aFxuICB8IGV4biAtPlxuICAgIHJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiU3RhY2suaW52YXJpYW50IGZhaWxlZFwiXG4gICAgICAgICBbIFwiZXhuXCIsIGV4biB8PiBFeG4uc2V4cF9vZl90OyBcInN0YWNrXCIsIHQgfD4gc2V4cF9vZl90X2ludGVybmFsIHNleHBfb2Zfb3BhcXVlIF0pXG47O1xuXG5sZXQgY3JlYXRlICh0eXBlIGEpICgpIDogYSB0ID0geyBsZW5ndGggPSAwOyBlbHRzID0gT3B0aW9uX2FycmF5LmVtcHR5IH1cbmxldCBsZW5ndGggdCA9IHQubGVuZ3RoXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG4oKiBUaGUgb3JkZXIgaW4gd2hpY2ggZWxlbWVudHMgYXJlIHZpc2l0ZWQgaGFzIGJlZW4gY2hvc2VuIHNvIGFzIHRvIGJlIGJhY2t3YXJkc1xuICAgY29tcGF0aWJsZSB3aXRoIFtDYW1sLlN0YWNrXSAqKVxubGV0IGZvbGQgdCB+aW5pdCB+ZiA9XG4gIGxldCByID0gcmVmIGluaXQgaW5cbiAgZm9yIGkgPSB0Lmxlbmd0aCAtIDEgZG93bnRvIDAgZG9cbiAgICByIDo9IGYgIXIgKE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gdC5lbHRzIGkpXG4gIGRvbmU7XG4gICFyXG47O1xuXG5sZXQgaXRlciB0IH5mID1cbiAgZm9yIGkgPSB0Lmxlbmd0aCAtIDEgZG93bnRvIDAgZG9cbiAgICBmIChPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuZWx0cyBpKVxuICBkb25lXG47O1xuXG5tb2R1bGUgQyA9IENvbnRhaW5lci5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyAnYSB0ID0gJ2EgdFxuXG4gICAgbGV0IGZvbGQgPSBmb2xkXG4gICAgbGV0IGl0ZXIgPSBgQ3VzdG9tIGl0ZXJcbiAgICBsZXQgbGVuZ3RoID0gYEN1c3RvbSBsZW5ndGhcbiAgZW5kKVxuXG5sZXQgbWVtID0gQy5tZW1cbmxldCBleGlzdHMgPSBDLmV4aXN0c1xubGV0IGZvcl9hbGwgPSBDLmZvcl9hbGxcbmxldCBjb3VudCA9IEMuY291bnRcbmxldCBzdW0gPSBDLnN1bVxubGV0IGZpbmQgPSBDLmZpbmRcbmxldCBmaW5kX21hcCA9IEMuZmluZF9tYXBcbmxldCB0b19saXN0ID0gQy50b19saXN0XG5sZXQgdG9fYXJyYXkgPSBDLnRvX2FycmF5XG5sZXQgbWluX2VsdCA9IEMubWluX2VsdFxubGV0IG1heF9lbHQgPSBDLm1heF9lbHRcbmxldCBmb2xkX3Jlc3VsdCA9IEMuZm9sZF9yZXN1bHRcbmxldCBmb2xkX3VudGlsID0gQy5mb2xkX3VudGlsXG5cbmxldCBvZl9saXN0ICh0eXBlIGEpIChsIDogYSBsaXN0KSA9XG4gIGlmIExpc3QuaXNfZW1wdHkgbFxuICB0aGVuIGNyZWF0ZSAoKVxuICBlbHNlIChcbiAgICBsZXQgbGVuZ3RoID0gTGlzdC5sZW5ndGggbCBpblxuICAgIGxldCBlbHRzID0gT3B0aW9uX2FycmF5LmNyZWF0ZSB+bGVuOigyICogbGVuZ3RoKSBpblxuICAgIGxldCByID0gcmVmIGwgaW5cbiAgICBmb3IgaSA9IGxlbmd0aCAtIDEgZG93bnRvIDAgZG9cbiAgICAgIG1hdGNoICFyIHdpdGhcbiAgICAgIHwgW10gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IGEgOjogbCAtPlxuICAgICAgICBPcHRpb25fYXJyYXkuc2V0X3NvbWUgZWx0cyBpIGE7XG4gICAgICAgIHIgOj0gbFxuICAgIGRvbmU7XG4gICAgeyBsZW5ndGg7IGVsdHMgfSlcbjs7XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSBMaXN0LnNleHBfb2ZfdCBzZXhwX29mX2EgKHRvX2xpc3QgdClcbmxldCB0X29mX3NleHAgYV9vZl9zZXhwIHNleHAgPSBvZl9saXN0IChMaXN0LnRfb2Zfc2V4cCBhX29mX3NleHAgc2V4cClcblxubGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuXG5sZXQgcmVzaXplIHQgc2l6ZSA9XG4gIGxldCBhcnIgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46c2l6ZSBpblxuICBPcHRpb25fYXJyYXkuYmxpdCB+c3JjOnQuZWx0cyB+ZHN0OmFyciB+c3JjX3BvczowIH5kc3RfcG9zOjAgfmxlbjp0Lmxlbmd0aDtcbiAgdC5lbHRzIDwtIGFyclxuOztcblxubGV0IHNldF9jYXBhY2l0eSB0IG5ld19jYXBhY2l0eSA9XG4gIGxldCBuZXdfY2FwYWNpdHkgPSBtYXggbmV3X2NhcGFjaXR5IChsZW5ndGggdCkgaW5cbiAgaWYgbmV3X2NhcGFjaXR5IDw+IGNhcGFjaXR5IHQgdGhlbiByZXNpemUgdCBuZXdfY2FwYWNpdHlcbjs7XG5cbmxldCBwdXNoIHQgYSA9XG4gIGlmIHQubGVuZ3RoID0gT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHMgdGhlbiByZXNpemUgdCAoMiAqICh0Lmxlbmd0aCArIDEpKTtcbiAgT3B0aW9uX2FycmF5LnNldF9zb21lIHQuZWx0cyB0Lmxlbmd0aCBhO1xuICB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDFcbjs7XG5cbmxldCBwb3Bfbm9uZW1wdHkgdCA9XG4gIGxldCBpID0gdC5sZW5ndGggLSAxIGluXG4gIGxldCByZXN1bHQgPSBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuZWx0cyBpIGluXG4gIE9wdGlvbl9hcnJheS5zZXRfbm9uZSB0LmVsdHMgaTtcbiAgdC5sZW5ndGggPC0gaTtcbiAgcmVzdWx0XG47O1xuXG5sZXQgcG9wX2Vycm9yID0gRXJyb3Iub2Zfc3RyaW5nIFwiU3RhY2sucG9wIG9mIGVtcHR5IHN0YWNrXCJcbmxldCBwb3AgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAocG9wX25vbmVtcHR5IHQpXG5sZXQgcG9wX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIEVycm9yLnJhaXNlIHBvcF9lcnJvciBlbHNlIHBvcF9ub25lbXB0eSB0XG5sZXQgdG9wX25vbmVtcHR5IHQgPSBPcHRpb25fYXJyYXkuZ2V0X3NvbWVfZXhuIHQuZWx0cyAodC5sZW5ndGggLSAxKVxubGV0IHRvcF9lcnJvciA9IEVycm9yLm9mX3N0cmluZyBcIlN0YWNrLnRvcCBvZiBlbXB0eSBzdGFja1wiXG5sZXQgdG9wIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKHRvcF9ub25lbXB0eSB0KVxubGV0IHRvcF9leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBFcnJvci5yYWlzZSB0b3BfZXJyb3IgZWxzZSB0b3Bfbm9uZW1wdHkgdFxubGV0IGNvcHkgeyBsZW5ndGg7IGVsdHMgfSA9IHsgbGVuZ3RoOyBlbHRzID0gT3B0aW9uX2FycmF5LmNvcHkgZWx0cyB9XG5cbmxldCBjbGVhciB0ID1cbiAgaWYgdC5sZW5ndGggPiAwXG4gIHRoZW4gKFxuICAgIGZvciBpID0gMCB0byB0Lmxlbmd0aCAtIDEgZG9cbiAgICAgIE9wdGlvbl9hcnJheS5zZXRfbm9uZSB0LmVsdHMgaVxuICAgIGRvbmU7XG4gICAgdC5sZW5ndGggPC0gMClcbjs7XG5cbmxldCB1bnRpbF9lbXB0eSB0IGYgPVxuICBsZXQgcmVjIGxvb3AgKCkgPVxuICAgIGlmIHQubGVuZ3RoID4gMFxuICAgIHRoZW4gKFxuICAgICAgZiAocG9wX25vbmVtcHR5IHQpO1xuICAgICAgbG9vcCAoKSlcbiAgaW5cbiAgbG9vcCAoKVxuOztcblxubGV0IHNpbmdsZXRvbiB4ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgcHVzaCB0IHg7XG4gIHRcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxuKCogVGhpcyBpcyBsaWZ0ZWQgb3V0IG9mIFtNXSBiZWNhdXNlIFtTb3VyY2VfY29kZV9wb3NpdGlvbjBdIGV4cG9ydHMgW1N0cmluZzBdXG4gICBhcyBbU3RyaW5nXSwgd2hpY2ggZG9lcyBub3QgZXhwb3J0IGEgaGFzaCBmdW5jdGlvbi4gKilcbmxldCBoYXNoX292ZXJyaWRlIHsgQ2FtbC5MZXhpbmcucG9zX2ZuYW1lOyBwb3NfbG51bTsgcG9zX2JvbDsgcG9zX2NudW0gfSA9XG4gIFN0cmluZy5oYXNoIHBvc19mbmFtZVxuICBseG9yIEludC5oYXNoIHBvc19sbnVtXG4gIGx4b3IgSW50Lmhhc2ggcG9zX2JvbFxuICBseG9yIEludC5oYXNoIHBvc19jbnVtXG47O1xuXG5tb2R1bGUgTSA9IHN0cnVjdFxuICBpbmNsdWRlIFNvdXJjZV9jb2RlX3Bvc2l0aW9uMFxuXG4gIGxldCBoYXNoID0gaGFzaF9vdmVycmlkZVxuZW5kXG5cbmluY2x1ZGUgTVxuaW5jbHVkZSBDb21wYXJhYmxlLk1ha2VfdXNpbmdfY29tcGFyYXRvciAoTSlcblxubGV0IG9mX3BvcyAocG9zX2ZuYW1lLCBwb3NfbG51bSwgcG9zX2NudW0sIF8pID1cbiAgeyBwb3NfZm5hbWU7IHBvc19sbnVtOyBwb3NfY251bTsgcG9zX2JvbCA9IDAgfVxuOztcbiIsIm9wZW4hIEltcG9ydFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgTmVnXG4gICAgfCBaZXJvXG4gICAgfCBQb3NcbiAgICB8IE5hblxuICBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cCwgc2V4cF9ncmFtbWFyLCBjb21wYXJlLCBoYXNoLCBlbnVtZXJhdGVdXG5cbiAgbGV0IHRfb2Zfc2V4cCA9XG4gICAgKGxldCBlcnJvcl9zb3VyY2VfXzAwM18gPSBcInNpZ25fb3JfbmFuLm1sLlQudFwiIGluXG4gICAgIGZ1bmN0aW9uXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5lZ1wiIHwgXCJOZWdcIikgLT4gTmVnXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSAtPiBaZXJvXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgLT4gUG9zXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgLT4gTmFuXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibmVnXCIgfCBcIk5lZ1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSA6OiBfKSBhcyBzZXhwX18wMDRfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDA0X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInBvc1wiIHwgXCJQb3NcIikgOjogXykgYXMgc2V4cF9fMDA0XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDNfIHNleHBfXzAwNF9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIDo6IF8pIGFzIHNleHBfXzAwNF8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDRfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDJfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzAwMl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwM18gc2V4cF9fMDAyX1xuICAgICB8IHNleHBfXzAwMl8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudW5leHBlY3RlZF9zdGFnIGVycm9yX3NvdXJjZV9fMDAzXyBzZXhwX18wMDJfXG4gICAgICAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgOztcblxuICBsZXQgc2V4cF9vZl90ID1cbiAgICAoZnVuY3Rpb25cbiAgICAgIHwgTmVnIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIk5lZ1wiXG4gICAgICB8IFplcm8gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiWmVyb1wiXG4gICAgICB8IFBvcyAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJQb3NcIlxuICAgICAgfCBOYW4gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTmFuXCJcbiAgICAgICAgICAgICAgIDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICB7IHVudHlwZWQgPVxuICAgICAgICBWYXJpYW50XG4gICAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICAgIDsgY2xhdXNlcyA9XG4gICAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiTmVnXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlplcm9cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiUG9zXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIk5hblwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICB9XG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAoZnVuIGhzdiBhcmcgLT5cbiAgICAgICBtYXRjaCBhcmcgd2l0aFxuICAgICAgIHwgTmVnIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5mb2xkX2ludCBoc3YgMFxuICAgICAgIHwgWmVybyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDFcbiAgICAgICB8IFBvcyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDJcbiAgICAgICB8IE5hbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guZm9sZF9pbnQgaHN2IDNcbiAgICAgICAgICAgICAgICA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgOztcblxuICBsZXQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgYXJnID1cbiAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5nZXRfaGFzaF92YWx1ZVxuICAgICAgICAobGV0IGhzdiA9IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5jcmVhdGUgKCkgaW5cbiAgICAgICAgIGhhc2hfZm9sZF90IGhzdiBhcmcpXG4gICAgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgYWxsID0gKFsgTmVnOyBaZXJvOyBQb3M7IE5hbiBdIDogdCBsaXN0KVxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IG9mX3N0cmluZyBzID0gdF9vZl9zZXhwIChzZXhwX29mX3N0cmluZyBzKVxuICBsZXQgdG9fc3RyaW5nIHQgPSBzdHJpbmdfb2Zfc2V4cCAoc2V4cF9vZl90IHQpXG4gIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5TaWduX29yX25hblwiXG5lbmRcblxubW9kdWxlIFJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSA9IHN0cnVjdFxuICBsZXQgKCA8ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPCApIHggeVxuICBsZXQgKCA8PSApICh4IDogVC50KSB5ID0gUG9seS4oIDw9ICkgeCB5XG4gIGxldCAoIDw+ICkgKHggOiBULnQpIHkgPSBQb2x5LiggPD4gKSB4IHlcbiAgbGV0ICggPSApICh4IDogVC50KSB5ID0gUG9seS4oID0gKSB4IHlcbiAgbGV0ICggPiApICh4IDogVC50KSB5ID0gUG9seS4oID4gKSB4IHlcbiAgbGV0ICggPj0gKSAoeCA6IFQudCkgeSA9IFBvbHkuKCA+PSApIHggeVxuICBsZXQgYXNjZW5kaW5nICh4IDogVC50KSB5ID0gUG9seS5hc2NlbmRpbmcgeCB5XG4gIGxldCBkZXNjZW5kaW5nICh4IDogVC50KSB5ID0gUG9seS5kZXNjZW5kaW5nIHggeVxuICBsZXQgY29tcGFyZSAoeCA6IFQudCkgeSA9IFBvbHkuY29tcGFyZSB4IHlcbiAgbGV0IGVxdWFsICh4IDogVC50KSB5ID0gUG9seS5lcXVhbCB4IHlcbiAgbGV0IG1heCAoeCA6IFQudCkgeSA9IGlmIHggPj0geSB0aGVuIHggZWxzZSB5XG4gIGxldCBtaW4gKHggOiBULnQpIHkgPSBpZiB4IDw9IHkgdGhlbiB4IGVsc2UgeVxuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBJZGVudGlmaWFibGUuTWFrZSAoVClcblxuKCogT3BlbiBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbnMgc28gdGhleSBkbyBub3RcbiAgIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXMgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvblxuICAgZnVuY3Rpb25zIGFyZSBhdmFpbGFibGUgd2l0aGluIHRoaXMgbW9kdWxlLiAqKVxub3BlbiEgUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBvZl9zaWduID0gZnVuY3Rpb25cbiAgfCBTaWduLk5lZyAtPiBOZWdcbiAgfCBTaWduLlplcm8gLT4gWmVyb1xuICB8IFNpZ24uUG9zIC0+IFBvc1xuOztcblxubGV0IHRvX3NpZ25fZXhuID0gZnVuY3Rpb25cbiAgfCBOZWcgLT4gU2lnbi5OZWdcbiAgfCBaZXJvIC0+IFNpZ24uWmVyb1xuICB8IFBvcyAtPiBTaWduLlBvc1xuICB8IE5hbiAtPiBpbnZhbGlkX2FyZyBcIkJhc2UuU2lnbl9vcl9uYW4udG9fc2lnbl9leG46IE5hblwiXG47O1xuXG5sZXQgb2ZfaW50IG4gPSBvZl9zaWduIChTaWduLm9mX2ludCBuKVxubGV0IHRvX2ludF9leG4gdCA9IFNpZ24udG9faW50ICh0b19zaWduX2V4biB0KVxuXG5sZXQgZmxpcCA9IGZ1bmN0aW9uXG4gIHwgTmVnIC0+IFBvc1xuICB8IFplcm8gLT4gWmVyb1xuICB8IFBvcyAtPiBOZWdcbiAgfCBOYW4gLT4gTmFuXG47O1xuXG5sZXQgKCAqICkgdCB0JyA9XG4gIG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBOYW4sIF8gfCBfLCBOYW4gLT4gTmFuXG4gIHwgXyAtPiBvZl9zaWduIChTaWduLiggKiApICh0b19zaWduX2V4biB0KSAodG9fc2lnbl9leG4gdCcpKVxuOztcblxuKCogSW5jbHVkZSBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlciBhbnkgZnVuY3RvciBhcHBsaWNhdGlvbnMgdGhhdFxuICAgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5IHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuXG50eXBlICdhIHQgPVxuICB8IEluY2wgb2YgJ2FcbiAgfCBFeGNsIG9mICdhXG4gIHwgVW5ib3VuZGVkXG5bQEBkZXJpdmluZ19pbmxpbmUgZW51bWVyYXRlLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbmxldCBhbGwgOiAnYS4gJ2EgbGlzdCAtPiAnYSB0IGxpc3QgPVxuICBmdW4gX2FsbF9vZl9hIC0+XG4gIFBweF9lbnVtZXJhdGVfbGliLkxpc3QuYXBwZW5kXG4gICAgKGxldCByZWMgbWFwIGwgYWNjID1cbiAgICAgICBtYXRjaCBsIHdpdGhcbiAgICAgICB8IFtdIC0+IFBweF9lbnVtZXJhdGVfbGliLkxpc3QucmV2IGFjY1xuICAgICAgIHwgZW51bWVyYXRlX18wMDFfIDo6IGwgLT4gbWFwIGwgKEluY2wgZW51bWVyYXRlX18wMDFfIDo6IGFjYylcbiAgICAgaW5cbiAgICAgbWFwIF9hbGxfb2ZfYSBbXSlcbiAgICAoUHB4X2VudW1lcmF0ZV9saWIuTGlzdC5hcHBlbmRcbiAgICAgICAobGV0IHJlYyBtYXAgbCBhY2MgPVxuICAgICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICAgIHwgW10gLT4gUHB4X2VudW1lcmF0ZV9saWIuTGlzdC5yZXYgYWNjXG4gICAgICAgICAgfCBlbnVtZXJhdGVfXzAwMl8gOjogbCAtPiBtYXAgbCAoRXhjbCBlbnVtZXJhdGVfXzAwMl8gOjogYWNjKVxuICAgICAgICBpblxuICAgICAgICBtYXAgX2FsbF9vZl9hIFtdKVxuICAgICAgIFsgVW5ib3VuZGVkIF0pXG47O1xuXG5sZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID1cbiAgZnVuICh0eXBlIGFfXzAxOF8pIDogKChTZXhwbGliMC5TZXhwLnQgLT4gYV9fMDE4XykgLT4gU2V4cGxpYjAuU2V4cC50IC0+IGFfXzAxOF8gdCkgLT5cbiAgbGV0IGVycm9yX3NvdXJjZV9fMDA2XyA9IFwibWF5YmVfYm91bmQubWwudFwiIGluXG4gIGZ1biBfb2ZfYV9fMDAzXyAtPiBmdW5jdGlvblxuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgIChTZXhwbGliMC5TZXhwLkF0b20gKChcImluY2xcIiB8IFwiSW5jbFwiKSBhcyBfdGFnX18wMDlfKSA6OiBzZXhwX2FyZ3NfXzAxMF8pIGFzXG4gICAgICBfc2V4cF9fMDA4XyAtPlxuICAgICAgKG1hdGNoIHNleHBfYXJnc19fMDEwXyB3aXRoXG4gICAgICAgfCBbIGFyZzBfXzAxMV8gXSAtPlxuICAgICAgICAgbGV0IHJlczBfXzAxMl8gPSBfb2ZfYV9fMDAzXyBhcmcwX18wMTFfIGluXG4gICAgICAgICBJbmNsIHJlczBfXzAxMl9cbiAgICAgICB8IF8gLT5cbiAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgZXJyb3Jfc291cmNlX18wMDZfXG4gICAgICAgICAgIF90YWdfXzAwOV9cbiAgICAgICAgICAgX3NleHBfXzAwOF8pXG4gICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoKFwiZXhjbFwiIHwgXCJFeGNsXCIpIGFzIF90YWdfXzAxNF8pIDo6IHNleHBfYXJnc19fMDE1XykgYXNcbiAgICAgIF9zZXhwX18wMTNfIC0+XG4gICAgICAobWF0Y2ggc2V4cF9hcmdzX18wMTVfIHdpdGhcbiAgICAgICB8IFsgYXJnMF9fMDE2XyBdIC0+XG4gICAgICAgICBsZXQgcmVzMF9fMDE3XyA9IF9vZl9hX18wMDNfIGFyZzBfXzAxNl8gaW5cbiAgICAgICAgIEV4Y2wgcmVzMF9fMDE3X1xuICAgICAgIHwgXyAtPlxuICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfaW5jb3JyZWN0X25fYXJnc1xuICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzAwNl9cbiAgICAgICAgICAgX3RhZ19fMDE0X1xuICAgICAgICAgICBfc2V4cF9fMDEzXylcbiAgICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJ1bmJvdW5kZWRcIiB8IFwiVW5ib3VuZGVkXCIpIC0+IFVuYm91bmRlZFxuICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImluY2xcIiB8IFwiSW5jbFwiKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiZXhjbFwiIHwgXCJFeGNsXCIpIGFzIHNleHBfXzAwN18gLT5cbiAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInVuYm91bmRlZFwiIHwgXCJVbmJvdW5kZWRcIikgOjogXykgYXNcbiAgICAgIHNleHBfXzAwN18gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMDVfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICB8IFNleHBsaWIwLlNleHAuTGlzdCBbXSBhcyBzZXhwX18wMDVfIC0+XG4gICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuICAgIHwgc2V4cF9fMDA1XyAtPlxuICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnVuZXhwZWN0ZWRfc3RhZyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA1X1xuOztcblxubGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gIGZ1biAodHlwZSBhX18wMjRfKSA6ICgoYV9fMDI0XyAtPiBTZXhwbGliMC5TZXhwLnQpIC0+IGFfXzAyNF8gdCAtPiBTZXhwbGliMC5TZXhwLnQpIC0+XG4gIGZ1biBfb2ZfYV9fMDE5XyAtPiBmdW5jdGlvblxuICAgIHwgSW5jbCBhcmcwX18wMjBfIC0+XG4gICAgICBsZXQgcmVzMF9fMDIxXyA9IF9vZl9hX18wMTlfIGFyZzBfXzAyMF8gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIkluY2xcIjsgcmVzMF9fMDIxXyBdXG4gICAgfCBFeGNsIGFyZzBfXzAyMl8gLT5cbiAgICAgIGxldCByZXMwX18wMjNfID0gX29mX2FfXzAxOV8gYXJnMF9fMDIyXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiRXhjbFwiOyByZXMwX18wMjNfIF1cbiAgICB8IFVuYm91bmRlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmJvdW5kZWRcIlxuOztcblxubGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT5cbiAgeyB1bnR5cGVkID1cbiAgICAgIFZhcmlhbnRcbiAgICAgICAgeyBjYXNlX3NlbnNpdGl2aXR5ID0gQ2FzZV9zZW5zaXRpdmVfZXhjZXB0X2ZpcnN0X2NoYXJhY3RlclxuICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkluY2xcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWdcbiAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkV4Y2xcIlxuICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZSB7IGFyZ3MgPSBDb25zIChfJ2Ffc2V4cF9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJVbmJvdW5kZWRcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgfVxuOztcblxuW0BAQGVuZF1cblxudHlwZSBpbnRlcnZhbF9jb21wYXJpc29uID1cbiAgfCBCZWxvd19sb3dlcl9ib3VuZFxuICB8IEluX3JhbmdlXG4gIHwgQWJvdmVfdXBwZXJfYm91bmRcbltAQGRlcml2aW5nX2lubGluZSBzZXhwLCBzZXhwX2dyYW1tYXIsIGNvbXBhcmUsIGhhc2hdXG5cbmxldCBpbnRlcnZhbF9jb21wYXJpc29uX29mX3NleHAgPVxuICAobGV0IGVycm9yX3NvdXJjZV9fMDI3XyA9IFwibWF5YmVfYm91bmQubWwuaW50ZXJ2YWxfY29tcGFyaXNvblwiIGluXG4gICBmdW5jdGlvblxuICAgfCBTZXhwbGliMC5TZXhwLkF0b20gKFwiYmVsb3dfbG93ZXJfYm91bmRcIiB8IFwiQmVsb3dfbG93ZXJfYm91bmRcIikgLT4gQmVsb3dfbG93ZXJfYm91bmRcbiAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImluX3JhbmdlXCIgfCBcIkluX3JhbmdlXCIpIC0+IEluX3JhbmdlXG4gICB8IFNleHBsaWIwLlNleHAuQXRvbSAoXCJhYm92ZV91cHBlcl9ib3VuZFwiIHwgXCJBYm92ZV91cHBlcl9ib3VuZFwiKSAtPiBBYm92ZV91cHBlcl9ib3VuZFxuICAgfCBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAoU2V4cGxpYjAuU2V4cC5BdG9tIChcImJlbG93X2xvd2VyX2JvdW5kXCIgfCBcIkJlbG93X2xvd2VyX2JvdW5kXCIpIDo6IF8pIGFzIHNleHBfXzAyOF9cbiAgICAgLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI4X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJpbl9yYW5nZVwiIHwgXCJJbl9yYW5nZVwiKSA6OiBfKSBhcyBzZXhwX18wMjhfXG4gICAgIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyOF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0XG4gICAgICAgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJhYm92ZV91cHBlcl9ib3VuZFwiIHwgXCJBYm92ZV91cHBlcl9ib3VuZFwiKSA6OiBfKSBhcyBzZXhwX18wMjhfXG4gICAgIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyOF9cbiAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkxpc3QgXyA6OiBfKSBhcyBzZXhwX18wMjZfIC0+XG4gICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5uZXN0ZWRfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI2X1xuICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDI2XyAtPlxuICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuZW1wdHlfbGlzdF9pbnZhbGlkX3N1bSBlcnJvcl9zb3VyY2VfXzAyN18gc2V4cF9fMDI2X1xuICAgfCBzZXhwX18wMjZfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMjdfIHNleHBfXzAyNl9cbiAgICAgICAgICAgICAgICAgICA6IFNleHBsaWIwLlNleHAudCAtPiBpbnRlcnZhbF9jb21wYXJpc29uKVxuOztcblxubGV0IHNleHBfb2ZfaW50ZXJ2YWxfY29tcGFyaXNvbiA9XG4gIChmdW5jdGlvblxuICAgIHwgQmVsb3dfbG93ZXJfYm91bmQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiQmVsb3dfbG93ZXJfYm91bmRcIlxuICAgIHwgSW5fcmFuZ2UgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiSW5fcmFuZ2VcIlxuICAgIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiQWJvdmVfdXBwZXJfYm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBpbnRlcnZhbF9jb21wYXJpc29uIC0+IFNleHBsaWIwLlNleHAudClcbjs7XG5cbmxldCAoaW50ZXJ2YWxfY29tcGFyaXNvbl9zZXhwX2dyYW1tYXIgOiBpbnRlcnZhbF9jb21wYXJpc29uIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9XG4gIHsgdW50eXBlZCA9XG4gICAgICBWYXJpYW50XG4gICAgICAgIHsgY2FzZV9zZW5zaXRpdml0eSA9IENhc2Vfc2Vuc2l0aXZlX2V4Y2VwdF9maXJzdF9jaGFyYWN0ZXJcbiAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgIFsgTm9fdGFnIHsgbmFtZSA9IFwiQmVsb3dfbG93ZXJfYm91bmRcIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIkluX3JhbmdlXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJBYm92ZV91cHBlcl9ib3VuZFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICB9XG47O1xuXG5sZXQgY29tcGFyZV9pbnRlcnZhbF9jb21wYXJpc29uID1cbiAgKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlXG4gICA6IGludGVydmFsX2NvbXBhcmlzb24gLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBpbnQpXG47O1xuXG5sZXQgKGhhc2hfZm9sZF9pbnRlcnZhbF9jb21wYXJpc29uIDpcbiAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gID1cbiAgKGZ1biBoc3YgYXJnIC0+XG4gICAgIG1hdGNoIGFyZyB3aXRoXG4gICAgIHwgQmVsb3dfbG93ZXJfYm91bmQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAwXG4gICAgIHwgSW5fcmFuZ2UgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAxXG4gICAgIHwgQWJvdmVfdXBwZXJfYm91bmQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmZvbGRfaW50IGhzdiAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50ZXJ2YWxfY29tcGFyaXNvbiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG47O1xuXG5sZXQgKGhhc2hfaW50ZXJ2YWxfY29tcGFyaXNvbiA6IGludGVydmFsX2NvbXBhcmlzb24gLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgbGV0IGZ1bmMgYXJnID1cbiAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guZ2V0X2hhc2hfdmFsdWVcbiAgICAgIChsZXQgaHN2ID0gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmNyZWF0ZSAoKSBpblxuICAgICAgIGhhc2hfZm9sZF9pbnRlcnZhbF9jb21wYXJpc29uIGhzdiBhcmcpXG4gIGluXG4gIGZ1biB4IC0+IGZ1bmMgeFxuOztcblxuW0BAQGVuZF1cblxubGV0IG1hcCB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgSW5jbCBpbmNsIC0+IEluY2wgKGYgaW5jbClcbiAgfCBFeGNsIGV4Y2wgLT4gRXhjbCAoZiBleGNsKVxuICB8IFVuYm91bmRlZCAtPiBVbmJvdW5kZWRcbjs7XG5cbmxldCBpc19sb3dlcl9ib3VuZCB0IH5vZl86YSB+Y29tcGFyZSA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEluY2wgaW5jbCAtPiBjb21wYXJlIGluY2wgYSA8PSAwXG4gIHwgRXhjbCBleGNsIC0+IGNvbXBhcmUgZXhjbCBhIDwgMFxuICB8IFVuYm91bmRlZCAtPiB0cnVlXG47O1xuXG5sZXQgaXNfdXBwZXJfYm91bmQgdCB+b2ZfOmEgfmNvbXBhcmUgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBJbmNsIGluY2wgLT4gY29tcGFyZSBhIGluY2wgPD0gMFxuICB8IEV4Y2wgZXhjbCAtPiBjb21wYXJlIGEgZXhjbCA8IDBcbiAgfCBVbmJvdW5kZWQgLT4gdHJ1ZVxuOztcblxubGV0IGJvdW5kc19jcm9zc2VkIH5sb3dlciB+dXBwZXIgfmNvbXBhcmUgPVxuICBtYXRjaCBsb3dlciB3aXRoXG4gIHwgVW5ib3VuZGVkIC0+IGZhbHNlXG4gIHwgSW5jbCBsb3dlciB8IEV4Y2wgbG93ZXIgLT5cbiAgICAobWF0Y2ggdXBwZXIgd2l0aFxuICAgICB8IFVuYm91bmRlZCAtPiBmYWxzZVxuICAgICB8IEluY2wgdXBwZXIgfCBFeGNsIHVwcGVyIC0+IGNvbXBhcmUgbG93ZXIgdXBwZXIgPiAwKVxuOztcblxubGV0IGNoZWNrX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIH5jb21wYXJlID1cbiAgaWYgYm91bmRzX2Nyb3NzZWQgfmxvd2VyIH51cHBlciB+Y29tcGFyZVxuICB0aGVuIGZhaWx3aXRoIFwiTWF5YmVfYm91bmQuY29tcGFyZV90b19pbnRlcnZhbF9leG46IGxvd2VyIGJvdW5kID4gdXBwZXIgYm91bmRcIlxuOztcblxubGV0IGNvbXBhcmVfdG9faW50ZXJ2YWxfZXhuIH5sb3dlciB+dXBwZXIgYSB+Y29tcGFyZSA9XG4gIGNoZWNrX2ludGVydmFsX2V4biB+bG93ZXIgfnVwcGVyIH5jb21wYXJlO1xuICBpZiBub3QgKGlzX2xvd2VyX2JvdW5kIGxvd2VyIH5vZl86YSB+Y29tcGFyZSlcbiAgdGhlbiBCZWxvd19sb3dlcl9ib3VuZFxuICBlbHNlIGlmIG5vdCAoaXNfdXBwZXJfYm91bmQgdXBwZXIgfm9mXzphIH5jb21wYXJlKVxuICB0aGVuIEFib3ZlX3VwcGVyX2JvdW5kXG4gIGVsc2UgSW5fcmFuZ2Vcbjs7XG5cbmxldCBpbnRlcnZhbF9jb250YWluc19leG4gfmxvd2VyIH51cHBlciBhIH5jb21wYXJlID1cbiAgbWF0Y2ggY29tcGFyZV90b19pbnRlcnZhbF9leG4gfmxvd2VyIH51cHBlciBhIH5jb21wYXJlIHdpdGhcbiAgfCBJbl9yYW5nZSAtPiB0cnVlXG4gIHwgQmVsb3dfbG93ZXJfYm91bmQgfCBBYm92ZV91cHBlcl9ib3VuZCAtPiBmYWxzZVxuOztcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgVFxuXG5tb2R1bGUgT3JfZHVwbGljYXRlID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgWyBgT2sgb2YgJ2FcbiAgICB8IGBEdXBsaWNhdGVcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID1cbiAgICBmdW4gX2NtcF9fYSBhX18wMDFfIGJfXzAwMl8gLT5cbiAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wMDFfIGJfXzAwMl9cbiAgICB0aGVuIDBcbiAgICBlbHNlIChcbiAgICAgIG1hdGNoIGFfXzAwMV8sIGJfXzAwMl8gd2l0aFxuICAgICAgfCBgT2sgX2xlZnRfXzAwM18sIGBPayBfcmlnaHRfXzAwNF8gLT4gX2NtcF9fYSBfbGVmdF9fMDAzXyBfcmlnaHRfXzAwNF9cbiAgICAgIHwgYER1cGxpY2F0ZSwgYER1cGxpY2F0ZSAtPiAwXG4gICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgeCB5KVxuICA7O1xuXG4gIGxldCBlcXVhbCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2wgPVxuICAgIGZ1biBfY21wX19hIGFfXzAwNV8gYl9fMDA2XyAtPlxuICAgICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDA1XyBiX18wMDZfXG4gICAgICB0aGVuIHRydWVcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBhX18wMDVfLCBiX18wMDZfIHdpdGhcbiAgICAgICAgfCBgT2sgX2xlZnRfXzAwN18sIGBPayBfcmlnaHRfXzAwOF8gLT4gX2NtcF9fYSBfbGVmdF9fMDA3XyBfcmlnaHRfXzAwOF9cbiAgICAgICAgfCBgRHVwbGljYXRlLCBgRHVwbGljYXRlIC0+IHRydWVcbiAgICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19lcXVhbCB4IHkpXG4gIDs7XG5cbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgZnVuIF9vZl9hX18wMDlfIC0+IGZ1bmN0aW9uXG4gICAgICB8IGBPayB2X18wMTBfIC0+IFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIk9rXCI7IF9vZl9hX18wMDlfIHZfXzAxMF8gXVxuICAgICAgfCBgRHVwbGljYXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkR1cGxpY2F0ZVwiXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgV2l0aG91dF9jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gJ3pcbmVuZFxuXG5tb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gY29tcGFyYXRvcjooJ2tleSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICd6XG5lbmRcblxubW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gc3RydWN0XG4gIHR5cGUgKCdrZXksICdjbXAsICd6KSB0ID0gKCdrZXksICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ3pcbmVuZFxuXG5tb2R1bGUgU3ltbWV0cmljX2RpZmZfZWxlbWVudCA9IHN0cnVjdFxuICB0eXBlICgnaywgJ3YpIHQgPSAnayAqIFsgYExlZnQgb2YgJ3YgfCBgUmlnaHQgb2YgJ3YgfCBgVW5lcXVhbCBvZiAndiAqICd2IF1cbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgOlxuICAgICdrICd2LiAoJ2sgLT4gJ2sgLT4gaW50KSAtPiAoJ3YgLT4gJ3YgLT4gaW50KSAtPiAoJ2ssICd2KSB0IC0+ICgnaywgJ3YpIHQgLT4gaW50XG4gICAgPVxuICAgIGZ1biBfY21wX19rIF9jbXBfX3YgYV9fMDExXyBiX18wMTJfIC0+XG4gICAgbGV0IHRfXzAxM18sIHRfXzAxNF8gPSBhX18wMTFfIGluXG4gICAgbGV0IHRfXzAxNV8sIHRfXzAxNl8gPSBiX18wMTJfIGluXG4gICAgbWF0Y2ggX2NtcF9fayB0X18wMTNfIHRfXzAxNV8gd2l0aFxuICAgIHwgMCAtPlxuICAgICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgdF9fMDE0XyB0X18wMTZfXG4gICAgICB0aGVuIDBcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0X18wMTRfLCB0X18wMTZfIHdpdGhcbiAgICAgICAgfCBgTGVmdCBfbGVmdF9fMDE3XywgYExlZnQgX3JpZ2h0X18wMThfIC0+IF9jbXBfX3YgX2xlZnRfXzAxN18gX3JpZ2h0X18wMThfXG4gICAgICAgIHwgYFJpZ2h0IF9sZWZ0X18wMTlfLCBgUmlnaHQgX3JpZ2h0X18wMjBfIC0+IF9jbXBfX3YgX2xlZnRfXzAxOV8gX3JpZ2h0X18wMjBfXG4gICAgICAgIHwgYFVuZXF1YWwgX2xlZnRfXzAyMV8sIGBVbmVxdWFsIF9yaWdodF9fMDIyXyAtPlxuICAgICAgICAgIGxldCB0X18wMjNfLCB0X18wMjRfID0gX2xlZnRfXzAyMV8gaW5cbiAgICAgICAgICBsZXQgdF9fMDI1XywgdF9fMDI2XyA9IF9yaWdodF9fMDIyXyBpblxuICAgICAgICAgIChtYXRjaCBfY21wX192IHRfXzAyM18gdF9fMDI1XyB3aXRoXG4gICAgICAgICAgIHwgMCAtPiBfY21wX192IHRfXzAyNF8gdF9fMDI2X1xuICAgICAgICAgICB8IG4gLT4gbilcbiAgICAgICAgfCB4LCB5IC0+IFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19jb21wYXJlIHggeSlcbiAgICB8IG4gLT4gblxuICA7O1xuXG4gIGxldCBlcXVhbCA6XG4gICAgJ2sgJ3YuXG4gICAgKCdrIC0+ICdrIC0+IGJvb2wpIC0+ICgndiAtPiAndiAtPiBib29sKSAtPiAoJ2ssICd2KSB0IC0+ICgnaywgJ3YpIHQgLT4gYm9vbFxuICAgID1cbiAgICBmdW4gX2NtcF9fayBfY21wX192IGFfXzAyN18gYl9fMDI4XyAtPlxuICAgICAgbGV0IHRfXzAyOV8sIHRfXzAzMF8gPSBhX18wMjdfIGluXG4gICAgICBsZXQgdF9fMDMxXywgdF9fMDMyXyA9IGJfXzAyOF8gaW5cbiAgICAgIFBweF9jb21wYXJlX2xpYi4oICYmIClcbiAgICAgICAgKF9jbXBfX2sgdF9fMDI5XyB0X18wMzFfKVxuICAgICAgICAoaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgdF9fMDMwXyB0X18wMzJfXG4gICAgICAgICB0aGVuIHRydWVcbiAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICBtYXRjaCB0X18wMzBfLCB0X18wMzJfIHdpdGhcbiAgICAgICAgICAgfCBgTGVmdCBfbGVmdF9fMDMzXywgYExlZnQgX3JpZ2h0X18wMzRfIC0+IF9jbXBfX3YgX2xlZnRfXzAzM18gX3JpZ2h0X18wMzRfXG4gICAgICAgICAgIHwgYFJpZ2h0IF9sZWZ0X18wMzVfLCBgUmlnaHQgX3JpZ2h0X18wMzZfIC0+IF9jbXBfX3YgX2xlZnRfXzAzNV8gX3JpZ2h0X18wMzZfXG4gICAgICAgICAgIHwgYFVuZXF1YWwgX2xlZnRfXzAzN18sIGBVbmVxdWFsIF9yaWdodF9fMDM4XyAtPlxuICAgICAgICAgICAgIGxldCB0X18wMzlfLCB0X18wNDBfID0gX2xlZnRfXzAzN18gaW5cbiAgICAgICAgICAgICBsZXQgdF9fMDQxXywgdF9fMDQyXyA9IF9yaWdodF9fMDM4XyBpblxuICAgICAgICAgICAgIFBweF9jb21wYXJlX2xpYi4oICYmICkgKF9jbXBfX3YgdF9fMDM5XyB0X18wNDFfKSAoX2NtcF9fdiB0X18wNDBfIHRfXzA0Ml8pXG4gICAgICAgICAgIHwgeCwgeSAtPiBQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfZXF1YWwgeCB5KSlcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIDpcbiAgICAnayAndi5cbiAgICAoU2V4cGxpYjAuU2V4cC50IC0+ICdrKVxuICAgIC0+IChTZXhwbGliMC5TZXhwLnQgLT4gJ3YpXG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgLT4gKCdrLCAndikgdFxuICAgID1cbiAgICBsZXQgZXJyb3Jfc291cmNlX18wNTdfID0gXCJtYXBfaW50Zi5tbC5TeW1tZXRyaWNfZGlmZl9lbGVtZW50LnRcIiBpblxuICAgIGZ1biBfb2Zfa19fMDQzXyBfb2Zfdl9fMDQ0XyAtPiBmdW5jdGlvblxuICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wNjdfOyBhcmcxX18wNjhfIF0gLT5cbiAgICAgICAgbGV0IHJlczBfXzA2OV8gPSBfb2Zfa19fMDQzXyBhcmcwX18wNjdfXG4gICAgICAgIGFuZCByZXMxX18wNzBfID1cbiAgICAgICAgICBsZXQgc2V4cF9fMDY2XyA9IGFyZzFfXzA2OF8gaW5cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIG1hdGNoIHNleHBfXzA2Nl8gd2l0aFxuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkF0b20gYXRvbV9fMDQ3XyBhcyBfc2V4cF9fMDQ5XyAtPlxuICAgICAgICAgICAgICAobWF0Y2ggYXRvbV9fMDQ3XyB3aXRoXG4gICAgICAgICAgICAgICB8IFwiTGVmdFwiIC0+XG4gICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX3Rha2VzX2FyZ3MgZXJyb3Jfc291cmNlX18wNTdfIF9zZXhwX18wNDlfXG4gICAgICAgICAgICAgICB8IFwiUmlnaHRcIiAtPlxuICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBfc2V4cF9fMDQ5X1xuICAgICAgICAgICAgICAgfCBcIlVuZXF1YWxcIiAtPlxuICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ190YWtlc19hcmdzIGVycm9yX3NvdXJjZV9fMDU3XyBfc2V4cF9fMDQ5X1xuICAgICAgICAgICAgICAgfCBfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5ub192YXJpYW50X21hdGNoICgpKVxuICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSBhdG9tX18wNDdfIDo6IHNleHBfYXJnc19fMDUwXykgYXNcbiAgICAgICAgICAgICAgX3NleHBfXzA0OV8gLT5cbiAgICAgICAgICAgICAgKG1hdGNoIGF0b21fXzA0N18gd2l0aFxuICAgICAgICAgICAgICAgfCBcIkxlZnRcIiBhcyBfdGFnX18wNjNfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA2NF8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDY1XyA9IF9vZl92X18wNDRfIGFyZzBfXzA2NF8gaW5cbiAgICAgICAgICAgICAgICAgICAgYExlZnQgcmVzMF9fMDY1X1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNjNfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IFwiUmlnaHRcIiBhcyBfdGFnX18wNjBfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA2MV8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDYyXyA9IF9vZl92X18wNDRfIGFyZzBfXzA2MV8gaW5cbiAgICAgICAgICAgICAgICAgICAgYFJpZ2h0IHJlczBfXzA2Ml9cbiAgICAgICAgICAgICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IucHRhZ19pbmNvcnJlY3Rfbl9hcmdzXG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgICAgICAgICAgX3RhZ19fMDYwX1xuICAgICAgICAgICAgICAgICAgICAgIF9zZXhwX18wNDlfKVxuICAgICAgICAgICAgICAgfCBcIlVuZXF1YWxcIiBhcyBfdGFnX18wNTFfIC0+XG4gICAgICAgICAgICAgICAgIChtYXRjaCBzZXhwX2FyZ3NfXzA1MF8gd2l0aFxuICAgICAgICAgICAgICAgICAgfCBbIGFyZzBfXzA1OF8gXSAtPlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzMF9fMDU5XyA9XG4gICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggYXJnMF9fMDU4XyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgWyBhcmcwX18wNTJfOyBhcmcxX18wNTNfIF0gLT5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXMwX18wNTRfID0gX29mX3ZfXzA0NF8gYXJnMF9fMDUyX1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5kIHJlczFfXzA1NV8gPSBfb2Zfdl9fMDQ0XyBhcmcxX18wNTNfIGluXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMwX18wNTRfLCByZXMxX18wNTVfXG4gICAgICAgICAgICAgICAgICAgICAgfCBzZXhwX18wNTZfIC0+XG4gICAgICAgICAgICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IudHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNleHBfXzA1Nl9cbiAgICAgICAgICAgICAgICAgICAgaW5cbiAgICAgICAgICAgICAgICAgICAgYFVuZXF1YWwgcmVzMF9fMDU5X1xuICAgICAgICAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5wdGFnX2luY29ycmVjdF9uX2FyZ3NcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcl9zb3VyY2VfXzA1N19cbiAgICAgICAgICAgICAgICAgICAgICBfdGFnX18wNTFfXG4gICAgICAgICAgICAgICAgICAgICAgX3NleHBfXzA0OV8pXG4gICAgICAgICAgICAgICB8IF8gLT4gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX3ZhcmlhbnRfbWF0Y2ggKCkpXG4gICAgICAgICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5MaXN0IF8gOjogXykgYXMgc2V4cF9fMDQ4XyAtPlxuICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhclxuICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgIHNleHBfXzA0OF9cbiAgICAgICAgICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IFtdIGFzIHNleHBfXzA0OF8gLT5cbiAgICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X2xpc3RfaW52YWxpZF9wb2x5X3ZhclxuICAgICAgICAgICAgICAgIGVycm9yX3NvdXJjZV9fMDU3X1xuICAgICAgICAgICAgICAgIHNleHBfXzA0OF9cbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IuTm9fdmFyaWFudF9tYXRjaCAtPlxuICAgICAgICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLm5vX21hdGNoaW5nX3ZhcmlhbnRfZm91bmRcbiAgICAgICAgICAgICAgZXJyb3Jfc291cmNlX18wNTdfXG4gICAgICAgICAgICAgIHNleHBfXzA2Nl9cbiAgICAgICAgaW5cbiAgICAgICAgcmVzMF9fMDY5XywgcmVzMV9fMDcwX1xuICAgICAgfCBzZXhwX18wNzFfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci50dXBsZV9vZl9zaXplX25fZXhwZWN0ZWQgZXJyb3Jfc291cmNlX18wNTdfIDIgc2V4cF9fMDcxX1xuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgOlxuICAgICdrICd2LlxuICAgICgnayAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgLT4gKCd2IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgLT4gU2V4cGxpYjAuU2V4cC50XG4gICAgPVxuICAgIGZ1biBfb2Zfa19fMDcyXyBfb2Zfdl9fMDczXyAoYXJnMF9fMDgxXywgYXJnMV9fMDgyXykgLT5cbiAgICAgIGxldCByZXMwX18wODNfID0gX29mX2tfXzA3Ml8gYXJnMF9fMDgxX1xuICAgICAgYW5kIHJlczFfXzA4NF8gPVxuICAgICAgICBtYXRjaCBhcmcxX18wODJfIHdpdGhcbiAgICAgICAgfCBgTGVmdCB2X18wNzRfIC0+XG4gICAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVmdFwiOyBfb2Zfdl9fMDczXyB2X18wNzRfIF1cbiAgICAgICAgfCBgUmlnaHQgdl9fMDc1XyAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIlJpZ2h0XCI7IF9vZl92X18wNzNfIHZfXzA3NV8gXVxuICAgICAgICB8IGBVbmVxdWFsIHZfXzA3Nl8gLT5cbiAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3RcbiAgICAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiVW5lcXVhbFwiXG4gICAgICAgICAgICA7IChsZXQgYXJnMF9fMDc3XywgYXJnMV9fMDc4XyA9IHZfXzA3Nl8gaW5cbiAgICAgICAgICAgICAgIGxldCByZXMwX18wNzlfID0gX29mX3ZfXzA3M18gYXJnMF9fMDc3X1xuICAgICAgICAgICAgICAgYW5kIHJlczFfXzA4MF8gPSBfb2Zfdl9fMDczXyBhcmcxX18wNzhfIGluXG4gICAgICAgICAgICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyByZXMwX18wNzlfOyByZXMxX18wODBfIF0pXG4gICAgICAgICAgICBdXG4gICAgICBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgcmVzMF9fMDgzXzsgcmVzMV9fMDg0XyBdXG4gIDs7XG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6XG4gICAgICAgICAnayBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgIC0+ICd2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAgLT4gKCdrLCAndikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8na19zZXhwX2dyYW1tYXIgXyd2X3NleHBfZ3JhbW1hciAtPlxuICAgICAgeyB1bnR5cGVkID1cbiAgICAgICAgICBMaXN0XG4gICAgICAgICAgICAoQ29uc1xuICAgICAgICAgICAgICAgKCBfJ2tfc2V4cF9ncmFtbWFyLnVudHlwZWRcbiAgICAgICAgICAgICAgICwgQ29uc1xuICAgICAgICAgICAgICAgICAgICggVmFyaWFudFxuICAgICAgICAgICAgICAgICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgWyBOb190YWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWUgPSBcIkxlZnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9IENvbnMgKF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiUmlnaHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDsgY2xhdXNlX2tpbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0X2NsYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgYXJncyA9IENvbnMgKF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA7IE5vX3RhZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZSA9IFwiVW5lcXVhbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOyBjbGF1c2Vfa2luZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpc3RfY2xhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBhcmdzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICggTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoQ29uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIENvbnMgKF8ndl9zZXhwX2dyYW1tYXIudW50eXBlZCwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBFbXB0eSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICwgRW1wdHkgKSApKVxuICAgICAgfVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIE1lcmdlX2VsZW1lbnQgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2xlZnQsICdyaWdodCkgdCA9XG4gICAgWyBgTGVmdCBvZiAnbGVmdFxuICAgIHwgYFJpZ2h0IG9mICdyaWdodFxuICAgIHwgYEJvdGggb2YgJ2xlZnQgKiAncmlnaHRcbiAgICBdXG4gIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA6XG4gICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICgnbGVmdCAtPiAnbGVmdCAtPiBpbnQpXG4gICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gaW50KVxuICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAtPiBpbnRcbiAgICA9XG4gICAgZnVuIF9jbXBfX2xlZnQgX2NtcF9fcmlnaHQgYV9fMDg1XyBiX18wODZfIC0+XG4gICAgaWYgUHB4X2NvbXBhcmVfbGliLnBoeXNfZXF1YWwgYV9fMDg1XyBiX18wODZfXG4gICAgdGhlbiAwXG4gICAgZWxzZSAoXG4gICAgICBtYXRjaCBhX18wODVfLCBiX18wODZfIHdpdGhcbiAgICAgIHwgYExlZnQgX2xlZnRfXzA4N18sIGBMZWZ0IF9yaWdodF9fMDg4XyAtPiBfY21wX19sZWZ0IF9sZWZ0X18wODdfIF9yaWdodF9fMDg4X1xuICAgICAgfCBgUmlnaHQgX2xlZnRfXzA4OV8sIGBSaWdodCBfcmlnaHRfXzA5MF8gLT4gX2NtcF9fcmlnaHQgX2xlZnRfXzA4OV8gX3JpZ2h0X18wOTBfXG4gICAgICB8IGBCb3RoIF9sZWZ0X18wOTFfLCBgQm90aCBfcmlnaHRfXzA5Ml8gLT5cbiAgICAgICAgbGV0IHRfXzA5M18sIHRfXzA5NF8gPSBfbGVmdF9fMDkxXyBpblxuICAgICAgICBsZXQgdF9fMDk1XywgdF9fMDk2XyA9IF9yaWdodF9fMDkyXyBpblxuICAgICAgICAobWF0Y2ggX2NtcF9fbGVmdCB0X18wOTNfIHRfXzA5NV8gd2l0aFxuICAgICAgICAgfCAwIC0+IF9jbXBfX3JpZ2h0IHRfXzA5NF8gdF9fMDk2X1xuICAgICAgICAgfCBuIC0+IG4pXG4gICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgeCB5KVxuICA7O1xuXG4gIGxldCBlcXVhbCA6XG4gICAgJ2xlZnQgJ3JpZ2h0LlxuICAgICgnbGVmdCAtPiAnbGVmdCAtPiBib29sKVxuICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGJvb2wpXG4gICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgIC0+IGJvb2xcbiAgICA9XG4gICAgZnVuIF9jbXBfX2xlZnQgX2NtcF9fcmlnaHQgYV9fMDk3XyBiX18wOThfIC0+XG4gICAgICBpZiBQcHhfY29tcGFyZV9saWIucGh5c19lcXVhbCBhX18wOTdfIGJfXzA5OF9cbiAgICAgIHRoZW4gdHJ1ZVxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGFfXzA5N18sIGJfXzA5OF8gd2l0aFxuICAgICAgICB8IGBMZWZ0IF9sZWZ0X18wOTlfLCBgTGVmdCBfcmlnaHRfXzEwMF8gLT4gX2NtcF9fbGVmdCBfbGVmdF9fMDk5XyBfcmlnaHRfXzEwMF9cbiAgICAgICAgfCBgUmlnaHQgX2xlZnRfXzEwMV8sIGBSaWdodCBfcmlnaHRfXzEwMl8gLT4gX2NtcF9fcmlnaHQgX2xlZnRfXzEwMV8gX3JpZ2h0X18xMDJfXG4gICAgICAgIHwgYEJvdGggX2xlZnRfXzEwM18sIGBCb3RoIF9yaWdodF9fMTA0XyAtPlxuICAgICAgICAgIGxldCB0X18xMDVfLCB0X18xMDZfID0gX2xlZnRfXzEwM18gaW5cbiAgICAgICAgICBsZXQgdF9fMTA3XywgdF9fMTA4XyA9IF9yaWdodF9fMTA0XyBpblxuICAgICAgICAgIFBweF9jb21wYXJlX2xpYi4oICYmICkgKF9jbXBfX2xlZnQgdF9fMTA1XyB0X18xMDdfKSAoX2NtcF9fcmlnaHQgdF9fMTA2XyB0X18xMDhfKVxuICAgICAgICB8IHgsIHkgLT4gUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2VxdWFsIHggeSlcbiAgOztcblxuICBsZXQgc2V4cF9vZl90IDpcbiAgICAnbGVmdCAncmlnaHQuXG4gICAgKCdsZWZ0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ3JpZ2h0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgIC0+IFNleHBsaWIwLlNleHAudFxuICAgID1cbiAgICBmdW4gX29mX2xlZnRfXzEwOV8gX29mX3JpZ2h0X18xMTBfIC0+IGZ1bmN0aW9uXG4gICAgICB8IGBMZWZ0IHZfXzExMV8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiTGVmdFwiOyBfb2ZfbGVmdF9fMTA5XyB2X18xMTFfIF1cbiAgICAgIHwgYFJpZ2h0IHZfXzExMl8gLT5cbiAgICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiUmlnaHRcIjsgX29mX3JpZ2h0X18xMTBfIHZfXzExMl8gXVxuICAgICAgfCBgQm90aCB2X18xMTNfIC0+XG4gICAgICAgIFNleHBsaWIwLlNleHAuTGlzdFxuICAgICAgICAgIFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiQm90aFwiXG4gICAgICAgICAgOyAobGV0IGFyZzBfXzExNF8sIGFyZzFfXzExNV8gPSB2X18xMTNfIGluXG4gICAgICAgICAgICAgbGV0IHJlczBfXzExNl8gPSBfb2ZfbGVmdF9fMTA5XyBhcmcwX18xMTRfXG4gICAgICAgICAgICAgYW5kIHJlczFfXzExN18gPSBfb2ZfcmlnaHRfXzExMF8gYXJnMV9fMTE1XyBpblxuICAgICAgICAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIHJlczBfXzExNl87IHJlczFfXzExN18gXSlcbiAgICAgICAgICBdXG4gIDs7XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG4oKiogQGNhbm9uaWNhbCBCYXNlLk1hcC5Db250aW51ZV9vcl9zdG9wICopXG5tb2R1bGUgQ29udGludWVfb3Jfc3RvcCA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHwgQ29udGludWVcbiAgICB8IFN0b3BcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVudW1lcmF0ZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgbGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgQ29udGludWU7IFN0b3AgXSA6IHQgbGlzdClcbiAgbGV0IGVxdWFsID0gKFBweF9jb21wYXJlX2xpYi5wb2x5bW9ycGhpY19lcXVhbCA6IHQgLT4gdCAtPiBib29sKVxuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICAgfCBDb250aW51ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJDb250aW51ZVwiXG4gICAgICB8IFN0b3AgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiU3RvcFwiXG4gICAgICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kXG5cbigqKiBAY2Fub25pY2FsIEJhc2UuTWFwLkZpbmlzaGVkX29yX3VuZmluaXNoZWQgKilcbm1vZHVsZSBGaW5pc2hlZF9vcl91bmZpbmlzaGVkID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBGaW5pc2hlZFxuICAgIHwgVW5maW5pc2hlZFxuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBlcXVhbCwgc2V4cF9vZl1cblxuICBsZXQgY29tcGFyZSA9IChQcHhfY29tcGFyZV9saWIucG9seW1vcnBoaWNfY29tcGFyZSA6IHQgLT4gdCAtPiBpbnQpXG4gIGxldCBhbGwgPSAoWyBGaW5pc2hlZDsgVW5maW5pc2hlZCBdIDogdCBsaXN0KVxuICBsZXQgZXF1YWwgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2VxdWFsIDogdCAtPiB0IC0+IGJvb2wpXG5cbiAgbGV0IHNleHBfb2ZfdCA9XG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEZpbmlzaGVkIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIkZpbmlzaGVkXCJcbiAgICAgIHwgVW5maW5pc2hlZCAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJVbmZpbmlzaGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICA7O1xuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzX2dlbmVyaWMgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdHJlZVxuICB0eXBlICdhIGtleVxuICB0eXBlICdjbXAgY21wXG4gIHR5cGUgKCdhLCAnY21wLCAneikgb3B0aW9uc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2wpIG9wdGlvbnNcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogKF8sIF8sIF8pIHQgLT4gaW50XG5cbiAgdmFsIGFkZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZHVwbGljYXRlLnQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGFkZF9leG5cbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBzZXRcbiAgICA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBhZGRfbXVsdGlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4ga2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgcmVtb3ZlX211bHRpXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIGZpbmRfbXVsdGkgOiAoJ2ssICdjbXAsICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiAnayBrZXkgLT4gJ3YgbGlzdCkgb3B0aW9uc1xuXG4gIHZhbCBjaGFuZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiBmOigndiBvcHRpb24gLT4gJ3Ygb3B0aW9uKSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCB1cGRhdGVcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIGtleSAtPiBmOigndiBvcHRpb24gLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGZpbmQgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2IG9wdGlvbikgb3B0aW9uc1xuICB2YWwgZmluZF9leG4gOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICd2KSBvcHRpb25zXG4gIHZhbCByZW1vdmUgOiAoJ2ssICdjbXAsICgnaywgJ3YsICdjbXApIHQgLT4gJ2sga2V5IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG1lbSA6ICgnaywgJ2NtcCwgKCdrLCBfLCAnY21wKSB0IC0+ICdrIGtleSAtPiBib29sKSBvcHRpb25zXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2ssIF8sIF8pIHQgLT4gZjooJ2sga2V5IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdrLCAndiwgXykgdFxuICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBDb250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gRmluaXNoZWRfb3JfdW5maW5pc2hlZC50XG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gdW5pdClcbiAgICAgIC0+IHVuaXQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG1hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gIHZhbCBtYXBpIDogKCdrLCAndjEsICdjbXApIHQgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG4gIHZhbCBmb2xkIDogKCdrLCAndiwgXykgdCAtPiBpbml0OidhIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYSAtPiAnYSkgLT4gJ2FcblxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhIC0+ICgnYSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2EgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdrLCAndiwgXykgdCAtPiBpbml0OidhIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYSAtPiAnYSkgLT4gJ2FcblxuICB2YWwgZm9sZDJcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgIC0+IGluaXQ6J2FcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTooJ3YxLCAndjIpIE1lcmdlX2VsZW1lbnQudCAtPiAnYSAtPiAnYSlcbiAgICAgIC0+ICdhIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfa2V5c1xuICAgIDogKCdrLCAnY21wLCAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KCdrIGtleSAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIGZpbHRlciA6ICgnaywgJ2NtcCwgKCdrLCAndiwgJ2NtcCkgdCAtPiBmOigndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIGZpbHRlcmlcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfbWFwXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIgb3B0aW9uKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondjEgLT4gJ3YyIG9wdGlvbikgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBwYXJ0aXRpb25fbWFwaVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YxLCAnY21wKSB0XG4gICAgICAtPiBmOihrZXk6J2sga2V5IC0+IGRhdGE6J3YxIC0+ICgndjIsICd2MykgRWl0aGVyLnQpXG4gICAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdCAqICgnaywgJ3YzLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndjEsICdjbXApIHRcbiAgICAgIC0+IGY6KCd2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHQgKiAoJ2ssICd2MywgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGNvbWJpbmVfZXJyb3JzXG4gICAgOiAoJ2ssICdjbXAsICgnaywgJ3YgT3JfZXJyb3IudCwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICB2YWwgY29tcGFyZV9kaXJlY3RcbiAgICA6ICgnaywgJ2NtcCwgKCd2IC0+ICd2IC0+IGludCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGludCkgb3B0aW9uc1xuXG4gIHZhbCBlcXVhbFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgndiAtPiAndiAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0IC0+ICgnaywgJ3YsICdjbXApIHQgLT4gYm9vbCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwga2V5cyA6ICgnaywgXywgXykgdCAtPiAnayBrZXkgbGlzdFxuICB2YWwgZGF0YSA6IChfLCAndiwgXykgdCAtPiAndiBsaXN0XG5cbiAgdmFsIHRvX2FsaXN0XG4gICAgOiAgP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiAoJ2sga2V5ICogJ3YpIGxpc3RcblxuICB2YWwgbWVyZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAgIC0+IGY6KGtleTonayBrZXkgLT4gKCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ3YzIG9wdGlvbilcbiAgICAgIC0+ICgnaywgJ3YzLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBjb21iaW5lOihrZXk6J2sga2V5IC0+ICd2IC0+ICd2IC0+ICd2KVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBkYXRhX2VxdWFsOigndiAtPiAndiAtPiBib29sKVxuICAgICAgLT4gKCdrIGtleSwgJ3YpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAgIC0+IGluaXQ6J2FcbiAgICAgIC0+IGY6KCdhIC0+ICgnayBrZXksICd2KSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2EpXG4gICAgICAtPiAnYSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgbWluX2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrIGtleSAqICd2KSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayBrZXkgKiAndlxuICB2YWwgbWF4X2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrIGtleSAqICd2KSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdrLCAndiwgXykgdCAtPiAnayBrZXkgKiAndlxuICB2YWwgZm9yX2FsbCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KCd2IC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBib29sKSAtPiBpbnRcblxuICB2YWwgc3BsaXRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAnayBrZXlcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2sga2V5ICogJ3YpIG9wdGlvbiAqICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGFwcGVuZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsIGxvd2VyX3BhcnQ6KCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gdXBwZXJfcGFydDooJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXSApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBsb3dlcl9ib3VuZDonayBrZXkgTWF5YmVfYm91bmQudFxuICAgICAgLT4gdXBwZXJfYm91bmQ6J2sga2V5IE1heWJlX2JvdW5kLnRcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gbWluOidrIGtleVxuICAgICAgLT4gbWF4OidrIGtleVxuICAgICAgLT4gaW5pdDonYVxuICAgICAgLT4gZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+ICdhIC0+ICdhKVxuICAgICAgLT4gJ2EgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIHJhbmdlX3RvX2FsaXN0XG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdrLCAndiwgJ2NtcCkgdCAtPiBtaW46J2sga2V5IC0+IG1heDonayBrZXkgLT4gKCdrIGtleSAqICd2KSBsaXN0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAgIC0+ICdrIGtleVxuICAgICAgLT4gKCdrIGtleSAqICd2KSBvcHRpb24gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG50aCA6ICgnaywgJ3YsICdjbXApIHQgLT4gaW50IC0+ICgnayBrZXkgKiAndikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnQgLT4gJ2sga2V5ICogJ3ZcbiAgdmFsIHJhbmsgOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCAtPiAnayBrZXkgLT4gaW50IG9wdGlvbikgb3B0aW9uc1xuICB2YWwgdG9fdHJlZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrIGtleSwgJ3YsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonayBrZXlcbiAgICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2sga2V5XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAtPiBjb21wYXJlOihrZXk6J2sga2V5IC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAgIC0+ICdrZXlcbiAgICAgIC0+ICgnayBrZXkgKiAndikgb3B0aW9uIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgICAtPiAoJ2sga2V5ICogJ3YpIG9wdGlvbiApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnaywgJ3YsICdjbXApIHRcbiAgICAgIC0+IGNvbXBhcmU6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAgIC0+IHVwcGVyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczEgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgdHJlZVxuICB0eXBlIGtleVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogXyB0IC0+IGJvb2xcbiAgdmFsIGlzX2VtcHR5IDogXyB0IC0+IGJvb2xcbiAgdmFsIGxlbmd0aCA6IF8gdCAtPiBpbnRcbiAgdmFsIGFkZCA6ICdhIHQgLT4ga2V5OmtleSAtPiBkYXRhOidhIC0+ICdhIHQgT3JfZHVwbGljYXRlLnRcbiAgdmFsIGFkZF9leG4gOiAnYSB0IC0+IGtleTprZXkgLT4gZGF0YTonYSAtPiAnYSB0XG4gIHZhbCBzZXQgOiAnYSB0IC0+IGtleTprZXkgLT4gZGF0YTonYSAtPiAnYSB0XG4gIHZhbCBhZGRfbXVsdGkgOiAnYSBsaXN0IHQgLT4ga2V5OmtleSAtPiBkYXRhOidhIC0+ICdhIGxpc3QgdFxuICB2YWwgcmVtb3ZlX211bHRpIDogJ2EgbGlzdCB0IC0+IGtleSAtPiAnYSBsaXN0IHRcbiAgdmFsIGZpbmRfbXVsdGkgOiAnYSBsaXN0IHQgLT4ga2V5IC0+ICdhIGxpc3RcbiAgdmFsIGNoYW5nZSA6ICdhIHQgLT4ga2V5IC0+IGY6KCdhIG9wdGlvbiAtPiAnYSBvcHRpb24pIC0+ICdhIHRcbiAgdmFsIHVwZGF0ZSA6ICdhIHQgLT4ga2V5IC0+IGY6KCdhIG9wdGlvbiAtPiAnYSkgLT4gJ2EgdFxuICB2YWwgZmluZCA6ICdhIHQgLT4ga2V5IC0+ICdhIG9wdGlvblxuICB2YWwgZmluZF9leG4gOiAnYSB0IC0+IGtleSAtPiAnYVxuICB2YWwgcmVtb3ZlIDogJ2EgdCAtPiBrZXkgLT4gJ2EgdFxuICB2YWwgbWVtIDogXyB0IC0+IGtleSAtPiBib29sXG4gIHZhbCBpdGVyX2tleXMgOiBfIHQgLT4gZjooa2V5IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAnYSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBpdGVyaV91bnRpbFxuICAgIDogICdhIHRcbiAgICAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gIHZhbCBpdGVyMiA6ICdhIHQgLT4gJ2IgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6KCdhLCAnYikgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIG1hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgdmFsIG1hcGkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYikgLT4gJ2IgdFxuICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYiAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAnYSB0XG4gICAgLT4gaW5pdDonYWNjXG4gICAgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdhY2MgLT4gKCdhY2MsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdhY2MgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogJ2EgdCAtPiBpbml0OidiIC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYiAtPiAnYikgLT4gJ2JcblxuICB2YWwgZm9sZDJcbiAgICA6ICAnYSB0XG4gICAgLT4gJ2IgdFxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOihrZXk6a2V5IC0+IGRhdGE6KCdhLCAnYikgTWVyZ2VfZWxlbWVudC50IC0+ICdjIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIGZpbHRlcl9rZXlzIDogJ2EgdCAtPiBmOihrZXkgLT4gYm9vbCkgLT4gJ2EgdFxuICB2YWwgZmlsdGVyIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSB0XG4gIHZhbCBmaWx0ZXJpIDogJ2EgdCAtPiBmOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gYm9vbCkgLT4gJ2EgdFxuICB2YWwgZmlsdGVyX21hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAnYiB0XG4gIHZhbCBmaWx0ZXJfbWFwaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdiIG9wdGlvbikgLT4gJ2IgdFxuICB2YWwgcGFydGl0aW9uX21hcGkgOiAnYSB0IC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAoJ2IsICdjKSBFaXRoZXIudCkgLT4gJ2IgdCAqICdjIHRcbiAgdmFsIHBhcnRpdGlvbl9tYXAgOiAnYSB0IC0+IGY6KCdhIC0+ICgnYiwgJ2MpIEVpdGhlci50KSAtPiAnYiB0ICogJ2MgdFxuICB2YWwgcGFydGl0aW9uaV90ZiA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+ICdhIHQgKiAnYSB0XG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAnYSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIHQgKiAnYSB0XG4gIHZhbCBjb21iaW5lX2Vycm9ycyA6ICdhIE9yX2Vycm9yLnQgdCAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGludFxuICB2YWwgZXF1YWwgOiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSB0IC0+IGJvb2xcbiAgdmFsIGtleXMgOiBfIHQgLT4ga2V5IGxpc3RcbiAgdmFsIGRhdGEgOiAnYSB0IC0+ICdhIGxpc3RcbiAgdmFsIHRvX2FsaXN0IDogP2tleV9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXSAtPiAnYSB0IC0+IChrZXkgKiAnYSkgbGlzdFxuICB2YWwgbWVyZ2UgOiAnYSB0IC0+ICdiIHQgLT4gZjooa2V5OmtleSAtPiAoJ2EsICdiKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2Mgb3B0aW9uKSAtPiAnYyB0XG4gIHZhbCBtZXJnZV9za2V3ZWQgOiAndiB0IC0+ICd2IHQgLT4gY29tYmluZTooa2V5OmtleSAtPiAndiAtPiAndiAtPiAndikgLT4gJ3YgdFxuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogICdhIHRcbiAgICAtPiAnYSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbClcbiAgICAtPiAoa2V5LCAnYSkgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogICdhIHRcbiAgICAtPiAnYSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2EgLT4gJ2EgLT4gYm9vbClcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gKGtleSwgJ2EpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBtaW5fZWx0IDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAnYSB0IC0+IGtleSAqICdhXG4gIHZhbCBtYXhfZWx0IDogJ2EgdCAtPiAoa2V5ICogJ2EpIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAnYSB0IC0+IGtleSAqICdhXG4gIHZhbCBmb3JfYWxsIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50aSA6ICdhIHQgLT4gZjooa2V5OmtleSAtPiBkYXRhOidhIC0+IGJvb2wpIC0+IGludFxuICB2YWwgc3BsaXQgOiAnYSB0IC0+IGtleSAtPiAnYSB0ICogKGtleSAqICdhKSBvcHRpb24gKiAnYSB0XG5cbiAgdmFsIGFwcGVuZFxuICAgIDogIGxvd2VyX3BhcnQ6J2EgdFxuICAgIC0+IHVwcGVyX3BhcnQ6J2EgdFxuICAgIC0+IFsgYE9rIG9mICdhIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgJ2EgdFxuICAgIC0+IGxvd2VyX2JvdW5kOmtleSBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6a2V5IE1heWJlX2JvdW5kLnRcbiAgICAtPiAnYSB0XG5cbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAgJ2EgdFxuICAgIC0+IG1pbjprZXlcbiAgICAtPiBtYXg6a2V5XG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KGtleTprZXkgLT4gZGF0YTonYSAtPiAnYiAtPiAnYilcbiAgICAtPiAnYlxuXG4gIHZhbCByYW5nZV90b19hbGlzdCA6ICdhIHQgLT4gbWluOmtleSAtPiBtYXg6a2V5IC0+IChrZXkgKiAnYSkgbGlzdFxuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogICdhIHRcbiAgICAtPiBbIGBHcmVhdGVyX29yX2VxdWFsX3RvIHwgYEdyZWF0ZXJfdGhhbiB8IGBMZXNzX29yX2VxdWFsX3RvIHwgYExlc3NfdGhhbiBdXG4gICAgLT4ga2V5XG4gICAgLT4gKGtleSAqICdhKSBvcHRpb25cblxuICB2YWwgbnRoIDogJ2EgdCAtPiBpbnQgLT4gKGtleSAqICdhKSBvcHRpb25cbiAgdmFsIG50aF9leG4gOiAnYSB0IC0+IGludCAtPiBrZXkgKiAnYVxuICB2YWwgcmFuayA6IF8gdCAtPiBrZXkgLT4gaW50IG9wdGlvblxuICB2YWwgdG9fdHJlZSA6ICdhIHQgLT4gJ2EgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzprZXlcbiAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOmtleVxuICAgIC0+ICdhIHRcbiAgICAtPiAoa2V5ICogJ2EpIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICdhIHRcbiAgICAtPiBjb21wYXJlOihrZXk6a2V5IC0+IGRhdGE6J2EgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+IChrZXkgKiAnYSkgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgJ2EgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTprZXkgLT4gZGF0YTonYSAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+IChrZXkgKiAnYSkgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc3VicmFuZ2VcbiAgICA6ICAnYSB0XG4gICAgLT4gY29tcGFyZTooa2V5OmtleSAtPiBkYXRhOidhIC0+ICdib3VuZCAtPiBpbnQpXG4gICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+ICdhIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMyID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICgnYSwgJ2IpIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogKF8sIF8pIHQgLT4gaW50XG4gIHZhbCBhZGQgOiAoJ2EsICdiKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IpIHQgT3JfZHVwbGljYXRlLnRcbiAgdmFsIGFkZF9leG4gOiAoJ2EsICdiKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIHNldCA6ICgnYSwgJ2IpIHQgLT4ga2V5OidhIC0+IGRhdGE6J2IgLT4gKCdhLCAnYikgdFxuICB2YWwgYWRkX211bHRpIDogKCdhLCAnYiBsaXN0KSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IgbGlzdCkgdFxuICB2YWwgcmVtb3ZlX211bHRpIDogKCdhLCAnYiBsaXN0KSB0IC0+ICdhIC0+ICgnYSwgJ2IgbGlzdCkgdFxuICB2YWwgZmluZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCkgdCAtPiAnYSAtPiAnYiBsaXN0XG4gIHZhbCBjaGFuZ2UgOiAoJ2EsICdiKSB0IC0+ICdhIC0+IGY6KCdiIG9wdGlvbiAtPiAnYiBvcHRpb24pIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIHVwZGF0ZSA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gZjooJ2Igb3B0aW9uIC0+ICdiKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaW5kIDogKCdhLCAnYikgdCAtPiAnYSAtPiAnYiBvcHRpb25cbiAgdmFsIGZpbmRfZXhuIDogKCdhLCAnYikgdCAtPiAnYSAtPiAnYlxuICB2YWwgcmVtb3ZlIDogKCdhLCAnYikgdCAtPiAnYSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBtZW0gOiAoJ2EsICdiKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGl0ZXJfa2V5cyA6ICgnYSwgXykgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gKCdhLCAnYykgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgbWFwIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiAnYykgLT4gKCdhLCAnYykgdFxuICB2YWwgbWFwaSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MpIC0+ICgnYSwgJ2MpIHRcbiAgdmFsIGZvbGQgOiAoJ2EsICdiKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2KSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICgnYSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2EgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCAnYikgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkMlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EsICdjKSB0XG4gICAgLT4gaW5pdDonZFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCAtPiAnZClcbiAgICAtPiAnZFxuXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICgnYSwgJ2IpIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnYikgdFxuICB2YWwgZmlsdGVyIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaWx0ZXJpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MpIHRcbiAgdmFsIGZpbHRlcl9tYXBpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MpIHRcblxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYykgdCAqICgnYSwgJ2QpIHRcblxuICB2YWwgcGFydGl0aW9uX21hcCA6ICgnYSwgJ2IpIHQgLT4gZjooJ2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpIC0+ICgnYSwgJ2MpIHQgKiAoJ2EsICdkKSB0XG5cbiAgdmFsIHBhcnRpdGlvbmlfdGZcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiKSB0ICogKCdhLCAnYikgdFxuXG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHQgKiAoJ2EsICdiKSB0XG4gIHZhbCBjb21iaW5lX2Vycm9ycyA6ICgnYSwgJ2IgT3JfZXJyb3IudCkgdCAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdiIC0+ICdiIC0+IGludCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGludFxuICB2YWwgZXF1YWwgOiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGJvb2xcbiAgdmFsIGtleXMgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgZGF0YSA6IChfLCAnYikgdCAtPiAnYiBsaXN0XG4gIHZhbCB0b19hbGlzdCA6ID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF0gLT4gKCdhLCAnYikgdCAtPiAoJ2EgKiAnYikgbGlzdFxuXG4gIHZhbCBtZXJnZVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EsICdjKSB0XG4gICAgLT4gZjooa2V5OidhIC0+ICgnYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCBvcHRpb24pXG4gICAgLT4gKCdhLCAnZCkgdFxuXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICAoJ2ssICd2KSB0XG4gICAgLT4gKCdrLCAndikgdFxuICAgIC0+IGNvbWJpbmU6KGtleTonayAtPiAndiAtPiAndiAtPiAndilcbiAgICAtPiAoJ2ssICd2KSB0XG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5cbiAgdmFsIGZvbGRfc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gKCdhLCAnYikgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBtaW5fZWx0IDogKCdhLCAnYikgdCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgJ2IpIHQgLT4gJ2EgKiAnYlxuICB2YWwgbWF4X2VsdCA6ICgnYSwgJ2IpIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsICdiKSB0IC0+ICdhICogJ2JcbiAgdmFsIGZvcl9hbGwgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0cyA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50aSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBzcGxpdCA6ICgnYSwgJ2IpIHQgLT4gJ2EgLT4gKCdhLCAnYikgdCAqICgnYSAqICdiKSBvcHRpb24gKiAoJ2EsICdiKSB0XG5cbiAgdmFsIGFwcGVuZFxuICAgIDogIGxvd2VyX3BhcnQ6KCdhLCAnYikgdFxuICAgIC0+IHVwcGVyX3BhcnQ6KCdhLCAnYikgdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyBdXG5cbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGxvd2VyX2JvdW5kOidhIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYSBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdhLCAnYikgdFxuXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiBtaW46J2FcbiAgICAtPiBtYXg6J2FcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgcmFuZ2VfdG9fYWxpc3QgOiAoJ2EsICdiKSB0IC0+IG1pbjonYSAtPiBtYXg6J2EgLT4gKCdhICogJ2IpIGxpc3RcblxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+ICdhXG4gICAgLT4gKCdhICogJ2IpIG9wdGlvblxuXG4gIHZhbCBudGggOiAoJ2EsICdiKSB0IC0+IGludCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdhLCAnYikgdCAtPiBpbnQgLT4gJ2EgKiAnYlxuICB2YWwgcmFuayA6ICgnYSwgXykgdCAtPiAnYSAtPiBpbnQgb3B0aW9uXG4gIHZhbCB0b190cmVlIDogKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmdfa2V5IHwgYERlY3JlYXNpbmdfa2V5IF1cbiAgICAtPiA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2tleXNfbGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2IpIHRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAoJ2sgKiAndikgb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAgKCdrLCAndikgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdib3VuZCAtPiBpbnQpXG4gICAgLT4gbG93ZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYm91bmQgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMzID0gc2lnXG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdFxuICB0eXBlICgnYSwgJ2IsICdjbXApIHRyZWVcblxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIGlzX2VtcHR5IDogKF8sIF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbGVuZ3RoIDogKF8sIF8sIF8pIHQgLT4gaW50XG4gIHZhbCBhZGQgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZHVwbGljYXRlLnRcbiAgdmFsIGFkZF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIHNldCA6ICgnYSwgJ2IsICdjbXApIHQgLT4ga2V5OidhIC0+IGRhdGE6J2IgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgYWRkX211bHRpIDogKCdhLCAnYiBsaXN0LCAnY21wKSB0IC0+IGtleTonYSAtPiBkYXRhOidiIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICB2YWwgcmVtb3ZlX211bHRpIDogKCdhLCAnYiBsaXN0LCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICB2YWwgZmluZF9tdWx0aSA6ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdCAtPiAnYSAtPiAnYiBsaXN0XG4gIHZhbCBjaGFuZ2UgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+IGY6KCdiIG9wdGlvbiAtPiAnYiBvcHRpb24pIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgdmFsIHVwZGF0ZSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gZjooJ2Igb3B0aW9uIC0+ICdiKSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBmaW5kIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAnYiBvcHRpb25cbiAgdmFsIGZpbmRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAnYlxuICB2YWwgcmVtb3ZlIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBtZW0gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGl0ZXJfa2V5cyA6ICgnYSwgXywgJ2NtcCkgdCAtPiBmOignYSAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0XG5cbiAgdmFsIGl0ZXJpX3VudGlsXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IENvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLnRcblxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgbWFwIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiAnYykgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICB2YWwgbWFwaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MpIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgdmFsIGZvbGQgOiAoJ2EsICdiLCBfKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICgnYSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2EgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCAnYiwgXykgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkMlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG4gICAgLT4gaW5pdDonZFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCAtPiAnZClcbiAgICAtPiAnZFxuXG4gIHZhbCBmaWx0ZXJfa2V5cyA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiBib29sKSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiAoJ2EsICdiLCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2Mgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gKCdjLCAnZCkgRWl0aGVyLnQpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdCAqICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX21hcFxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYiAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0ICogKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCAqICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCAqICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgY29tYmluZV9lcnJvcnMgOiAoJ2EsICdiIE9yX2Vycm9yLnQsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYiAtPiAnYiAtPiBpbnQpIC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogKCdiIC0+ICdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBrZXlzIDogKCdhLCBfLCBfKSB0IC0+ICdhIGxpc3RcbiAgdmFsIGRhdGEgOiAoXywgJ2IsIF8pIHQgLT4gJ2IgbGlzdFxuXG4gIHZhbCB0b19hbGlzdFxuICAgIDogID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiAoJ2EsICdiLCBfKSB0XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcblxuICB2YWwgbWVyZ2VcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiAoJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2Qgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2QsICdjbXApIHRcblxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgU2VxdWVuY2UudFxuXG4gIHZhbCBmb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgOiAgKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBkYXRhX2VxdWFsOignYiAtPiAnYiAtPiBib29sKVxuICAgIC0+IGluaXQ6J2NcbiAgICAtPiBmOignYyAtPiAoJ2EsICdiKSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50LnQgLT4gJ2MpXG4gICAgLT4gJ2NcblxuICB2YWwgbWluX2VsdCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhICogJ2JcbiAgdmFsIG1heF9lbHQgOiAoJ2EsICdiLCAnY21wKSB0IC0+ICgnYSAqICdiKSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAqICdiXG4gIHZhbCBmb3JfYWxsIDogKF8sICdiLCBfKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdhLCAnYiwgXykgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoXywgJ2IsIF8pIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzaSA6ICgnYSwgJ2IsIF8pIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgY291bnQgOiAoXywgJ2IsIF8pIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2EsICdiLCBfKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGludFxuXG4gIHZhbCBzcGxpdFxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAna1xuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2sgKiAndikgb3B0aW9uICogKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBsb3dlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiB1cHBlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXVxuXG4gIHZhbCBzdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBsb3dlcl9ib3VuZDonayBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2sgTWF5YmVfYm91bmQudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICB2YWwgZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICA6ICAoJ2EsICdiLCBfKSB0XG4gICAgLT4gbWluOidhXG4gICAgLT4gbWF4OidhXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIHJhbmdlX3RvX2FsaXN0IDogKCdhLCAnYiwgXykgdCAtPiBtaW46J2EgLT4gbWF4OidhIC0+ICgnYSAqICdiKSBsaXN0XG5cbiAgdmFsIGNsb3Nlc3Rfa2V5XG4gICAgOiAgKCdhLCAnYiwgXykgdFxuICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAtPiAnYVxuICAgIC0+ICgnYSAqICdiKSBvcHRpb25cblxuICB2YWwgbnRoIDogKCdhLCAnYiwgXykgdCAtPiBpbnQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbnRoX2V4biA6ICgnYSwgJ2IsIF8pIHQgLT4gaW50IC0+ICdhICogJ2JcbiAgdmFsIHJhbmsgOiAoJ2EsIF8sIF8pIHQgLT4gJ2EgLT4gaW50IG9wdGlvblxuICB2YWwgdG9fdHJlZSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhLCAnYiwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdiLCBfKSB0XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBzZWdtZW50X29mOihrZXk6J2sgLT4gZGF0YTondiAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IgPSBzaWdcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnYiwgJ2NtcCkgdHJlZVxuXG4gIHZhbCBpbnZhcmlhbnRzIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdiLCAnY21wKSB0IC0+IGJvb2xcbiAgdmFsIGlzX2VtcHR5IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBsZW5ndGggOiAoJ2EsICdiLCAnY21wKSB0IC0+IGludFxuXG4gIHZhbCBhZGRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGtleTonYVxuICAgIC0+IGRhdGE6J2JcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2R1cGxpY2F0ZS50XG5cbiAgdmFsIGFkZF9leG5cbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGtleTonYVxuICAgIC0+IGRhdGE6J2JcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIHNldFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4ga2V5OidhXG4gICAgLT4gZGF0YTonYlxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgYWRkX211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICAgIC0+IGtleTonYVxuICAgIC0+IGRhdGE6J2JcbiAgICAtPiAoJ2EsICdiIGxpc3QsICdjbXApIHRcblxuICB2YWwgcmVtb3ZlX211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgdmFsIGZpbmRfbXVsdGlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiAnYiBsaXN0XG5cbiAgdmFsIGNoYW5nZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gJ2FcbiAgICAtPiBmOignYiBvcHRpb24gLT4gJ2Igb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgdXBkYXRlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+IGY6KCdiIG9wdGlvbiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIGZpbmQgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gJ2Igb3B0aW9uXG4gIHZhbCBmaW5kX2V4biA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiAnYlxuXG4gIHZhbCByZW1vdmVcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBtZW0gOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgLT4gYm9vbFxuICB2YWwgaXRlcl9rZXlzIDogKCdhLCBfLCAnY21wKSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ2IsICdjbXApIHQgLT4gZjooJ2IgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgaXRlcmkgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXRcblxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gIHZhbCBpdGVyMlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOignYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgbWFwIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiAnYykgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICB2YWwgbWFwaSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MpIC0+ICgnYSwgJ2MsICdjbXApIHRcbiAgdmFsIGZvbGQgOiAoJ2EsICdiLCBfKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gJ2MgLT4gJ2MpIC0+ICdjXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gaW5pdDonYVxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+ICdhIC0+ICgnYSwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2EgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCAnYiwgXykgdCAtPiBpbml0OidjIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBmb2xkMlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuICAgIC0+IGluaXQ6J2RcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTooJ2IsICdjKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2QgLT4gJ2QpXG4gICAgLT4gJ2RcblxuICB2YWwgZmlsdGVyX2tleXNcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdhIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KCdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2IgLT4gJ2Mgb3B0aW9uKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICB2YWwgZmlsdGVyX21hcGlcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIG9wdGlvbilcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl9tYXBpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0ICogKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25fbWFwXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOignYiAtPiAoJ2MsICdkKSBFaXRoZXIudClcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0ICogKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgKiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIHBhcnRpdGlvbl90ZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gZjooJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0ICogKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBjb21iaW5lX2Vycm9yc1xuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiIE9yX2Vycm9yLnQsICdjbXApIHRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgY29tcGFyZV9kaXJlY3RcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdiIC0+ICdiIC0+IGludClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGludFxuXG4gIHZhbCBlcXVhbFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2IgLT4gJ2IgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGJvb2xcblxuICB2YWwga2V5cyA6ICgnYSwgXywgXykgdCAtPiAnYSBsaXN0XG4gIHZhbCBkYXRhIDogKF8sICdiLCBfKSB0IC0+ICdiIGxpc3RcblxuICB2YWwgdG9fYWxpc3RcbiAgICA6ICA/a2V5X29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gKCdhLCAnYiwgXykgdFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG5cbiAgdmFsIG1lcmdlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidhIC0+ICgnYiwgJ2MpIE1lcmdlX2VsZW1lbnQudCAtPiAnZCBvcHRpb24pXG4gICAgLT4gKCdhLCAnZCwgJ2NtcCkgdFxuXG4gIHZhbCBtZXJnZV9za2V3ZWRcbiAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnYikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCdiIC0+ICdiIC0+IGJvb2wpXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICgnYSwgJ2IpIFN5bW1ldHJpY19kaWZmX2VsZW1lbnQudCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBtaW5fZWx0IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgJ2IsICdjbXApIHQgLT4gJ2EgKiAnYlxuICB2YWwgbWF4X2VsdCA6ICgnYSwgJ2IsICdjbXApIHQgLT4gKCdhICogJ2IpIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsICdiLCAnY21wKSB0IC0+ICdhICogJ2JcbiAgdmFsIGZvcl9hbGwgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOihrZXk6J2EgLT4gZGF0YTonYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHMgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGV4aXN0c2kgOiAoJ2EsICdiLCAnY21wKSB0IC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGNvdW50IDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBmOignYiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50aSA6ICgnYSwgJ2IsICdjbXApIHQgLT4gZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gaW50XG5cbiAgdmFsIHNwbGl0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiAnYVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgKiAoJ2EgKiAnYikgb3B0aW9uICogKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gbG93ZXJfcGFydDooJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gdXBwZXJfcGFydDooJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzIF1cblxuICB2YWwgc3VicmFuZ2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuICAgIC0+IGxvd2VyX2JvdW5kOidhIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonYSBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmb2xkX3JhbmdlX2luY2x1c2l2ZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gbWluOidhXG4gICAgLT4gbWF4OidhXG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KGtleTonYSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIHJhbmdlX3RvX2FsaXN0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbiAgICAtPiBtaW46J2FcbiAgICAtPiBtYXg6J2FcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuXG4gIHZhbCBjbG9zZXN0X2tleVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+ICdhXG4gICAgLT4gKCdhICogJ2IpIG9wdGlvblxuXG4gIHZhbCBudGggOiAoJ2EsICdiLCAnY21wKSB0IC0+IGludCAtPiAoJ2EgKiAnYikgb3B0aW9uXG4gIHZhbCBudGhfZXhuIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiBpbnQgLT4gJ2EgKiAnYlxuICB2YWwgcmFuayA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdCAtPiAnYSAtPiBpbnQgb3B0aW9uXG4gIHZhbCB0b190cmVlIDogKCdhLCAnYiwgJ2NtcCkgdCAtPiAoJ2EsICdiLCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ID9vcmRlcjpbIGBJbmNyZWFzaW5nX2tleSB8IGBEZWNyZWFzaW5nX2tleSBdXG4gICAgLT4gP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcblxuICB2YWwgYmluYXJ5X3NlYXJjaFxuICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfc2VnbWVudC50XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3N1YnJhbmdlXG4gICAgOiAgY29tcGFyYXRvcjooJ2ssICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5lbmRcblxuKCoqIENvbnNpc3RlbmN5IGNoZWNrcyAoc2FtZSBhcyBpbiBbQ29udGFpbmVyXSkuICopXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKFQgOiBUMylcbiAgICAoVHJlZSA6IFQzKVxuICAgIChLZXkgOiBUMSlcbiAgICAoQ21wIDogVDEpXG4gICAgKE9wdGlvbnMgOiBUMylcbiAgICAoXyA6IEFjY2Vzc29yc19nZW5lcmljXG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgT3B0aW9ucy50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgVC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgVHJlZS50XG4gICAgIHdpdGggdHlwZSAnYSBrZXkgOj0gJ2EgS2V5LnRcbiAgICAgd2l0aCB0eXBlICdjbXAgY21wIDo9ICdjbXAgQ21wLnQpID1cbnN0cnVjdCBlbmRcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczEgKE0gOiBBY2Nlc3NvcnMxKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAnYiBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICdiIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmtleVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMiAoTSA6IEFjY2Vzc29yczIpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMzIChNIDogQWNjZXNzb3JzMykgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IgKE0gOiBBY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvcikgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYiwgJ2MpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoV2l0aF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdrLCAndiwgJ2NtcCkgdFxuICB0eXBlICgnaywgJ3YsICdjbXApIHRyZWVcbiAgdHlwZSAnayBrZXlcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBvcHRpb25zXG4gIHR5cGUgJ2NtcCBjbXBcblxuICB2YWwgZW1wdHkgOiAoJ2ssICdjbXAsICgnaywgXywgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgc2luZ2xldG9uIDogKCdrLCAnY21wLCAnayBrZXkgLT4gJ3YgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogKCAnazJcbiAgICAgICwgJ2NtcDJcbiAgICAgICwgKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgICAtPiBmOignazEga2V5IC0+ICdrMiBrZXkpXG4gICAgICAtPiBbIGBPayBvZiAoJ2syLCAndiwgJ2NtcDIpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnazIga2V5IF0gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG1hcF9rZXlzX2V4blxuICAgIDogKCAnazJcbiAgICAgICwgJ2NtcDJcbiAgICAgICwgKCdrMSwgJ3YsICdjbXAxKSB0IC0+IGY6KCdrMSBrZXkgLT4gJ2syIGtleSkgLT4gKCdrMiwgJ3YsICdjbXAyKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBhcnJheSAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGFycmF5IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICgnaywgJ2NtcCwgbGVuOmludCAtPiBmOihpbnQgLT4gJ2sga2V5ICogJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X2V4biA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBsaXN0IC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG9mX2FsaXN0X211bHRpIDogKCdrLCAnY21wLCAoJ2sga2V5ICogJ3YpIGxpc3QgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X2ZvbGRcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YxKSBsaXN0IC0+IGluaXQ6J3YyIC0+IGY6KCd2MiAtPiAndjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgbGlzdCAtPiBmOigndiAtPiAndiAtPiAndikgLT4gKCdrLCAndiwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdXG4gICAgICApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3JcbiAgICA6ICgnaywgJ2NtcCwgKCdrIGtleSAqICd2KSBTZXF1ZW5jZS50IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudCkgb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZV9leG4gOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2LCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX3NlcXVlbmNlX211bHRpXG4gICAgOiAoJ2ssICdjbXAsICgnayBrZXkgKiAndikgU2VxdWVuY2UudCAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogKCAna1xuICAgICAgLCAnY21wXG4gICAgICAsICgnayBrZXkgKiAndjEpIFNlcXVlbmNlLnRcbiAgICAgIC0+IGluaXQ6J3YyXG4gICAgICAtPiBmOigndjIgLT4gJ3YxIC0+ICd2MilcbiAgICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2VcbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2sga2V5ICogJ3YpIFNlcXVlbmNlLnQgLT4gZjooJ3YgLT4gJ3YgLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAoICdrXG4gICAgICAsICdjbXBcbiAgICAgICwgaXRlcmk6KGY6KGtleTonayBrZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0KVxuICAgICAgLT4gWyBgT2sgb2YgKCdrLCAndiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrIGtleSBdIClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBvZl9pdGVyaV9leG5cbiAgICA6ICggJ2tcbiAgICAgICwgJ2NtcFxuICAgICAgLCBpdGVyaTooZjooa2V5OidrIGtleSAtPiBkYXRhOid2IC0+IHVuaXQpIC0+IHVuaXQpIC0+ICgnaywgJ3YsICdjbXApIHQgKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIG9mX3RyZWUgOiAoJ2ssICdjbXAsICgnayBrZXksICd2LCAnY21wKSB0cmVlIC0+ICgnaywgJ3YsICdjbXApIHQpIG9wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yczEgPSBzaWdcbiAgdHlwZSAnYSB0XG4gIHR5cGUgJ2EgdHJlZVxuICB0eXBlIGtleVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBlbXB0eSA6IF8gdFxuICB2YWwgc2luZ2xldG9uIDoga2V5IC0+ICdhIC0+ICdhIHRcbiAgdmFsIG1hcF9rZXlzIDogJ3YgdCAtPiBmOihrZXkgLT4ga2V5KSAtPiBbIGBPayBvZiAndiB0IHwgYER1cGxpY2F0ZV9rZXkgb2Yga2V5IF1cbiAgdmFsIG1hcF9rZXlzX2V4biA6ICd2IHQgLT4gZjooa2V5IC0+IGtleSkgLT4gJ3YgdFxuICB2YWwgb2ZfYWxpc3QgOiAoa2V5ICogJ2EpIGxpc3QgLT4gWyBgT2sgb2YgJ2EgdCB8IGBEdXBsaWNhdGVfa2V5IG9mIGtleSBdXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvciA6IChrZXkgKiAnYSkgbGlzdCAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX2FsaXN0X2V4biA6IChrZXkgKiAnYSkgbGlzdCAtPiAnYSB0XG4gIHZhbCBvZl9hbGlzdF9tdWx0aSA6IChrZXkgKiAnYSkgbGlzdCAtPiAnYSBsaXN0IHRcbiAgdmFsIG9mX2FsaXN0X2ZvbGQgOiAoa2V5ICogJ2EpIGxpc3QgLT4gaW5pdDonYiAtPiBmOignYiAtPiAnYSAtPiAnYikgLT4gJ2IgdFxuICB2YWwgb2ZfYWxpc3RfcmVkdWNlIDogKGtleSAqICdhKSBsaXN0IC0+IGY6KCdhIC0+ICdhIC0+ICdhKSAtPiAnYSB0XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXkgOiAoa2V5ICogJ2EpIGFycmF5IC0+ICdhIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6IChrZXkgKiAnYSkgYXJyYXkgLT4gJ2EgdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgOiBsZW46aW50IC0+IGY6KGludCAtPiBrZXkgKiAnYSkgLT4gJ2EgdFxuICB2YWwgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiAnYSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NlcXVlbmNlIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+IFsgYE9rIG9mICdhIHQgfCBgRHVwbGljYXRlX2tleSBvZiBrZXkgXVxuICB2YWwgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gJ2EgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zZXF1ZW5jZV9leG4gOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gJ2EgdFxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGkgOiAoa2V5ICogJ2EpIFNlcXVlbmNlLnQgLT4gJ2EgbGlzdCB0XG4gIHZhbCBvZl9zZXF1ZW5jZV9mb2xkIDogKGtleSAqICdhKSBTZXF1ZW5jZS50IC0+IGluaXQ6J2IgLT4gZjooJ2IgLT4gJ2EgLT4gJ2IpIC0+ICdiIHRcbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZSA6IChrZXkgKiAnYSkgU2VxdWVuY2UudCAtPiBmOignYSAtPiAnYSAtPiAnYSkgLT4gJ2EgdFxuXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogIGl0ZXJpOihmOihrZXk6a2V5IC0+IGRhdGE6J3YgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiBbIGBPayBvZiAndiB0IHwgYER1cGxpY2F0ZV9rZXkgb2Yga2V5IF1cblxuICB2YWwgb2ZfaXRlcmlfZXhuIDogaXRlcmk6KGY6KGtleTprZXkgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0KSAtPiAndiB0XG4gIHZhbCBvZl90cmVlIDogJ2EgdHJlZSAtPiAnYSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMyID0gc2lnXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICgnYSwgJ2IpIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgZW1wdHkgOiAoXywgXykgdFxuICB2YWwgc2luZ2xldG9uIDogJ2EgLT4gJ2IgLT4gKCdhLCAnYikgdFxuXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogICgnazEsICd2KSB0XG4gICAgLT4gZjooJ2sxIC0+ICdrMilcbiAgICAtPiBbIGBPayBvZiAoJ2syLCAndikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrMiBdXG5cbiAgdmFsIG1hcF9rZXlzX2V4biA6ICgnazEsICd2KSB0IC0+IGY6KCdrMSAtPiAnazIpIC0+ICgnazIsICd2KSB0XG4gIHZhbCBvZl9hbGlzdCA6ICgnYSAqICdiKSBsaXN0IC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvciA6ICgnYSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudFxuICB2YWwgb2ZfYWxpc3RfZXhuIDogKCdhICogJ2IpIGxpc3QgLT4gKCdhLCAnYikgdFxuICB2YWwgb2ZfYWxpc3RfbXVsdGkgOiAoJ2EgKiAnYikgbGlzdCAtPiAoJ2EsICdiIGxpc3QpIHRcbiAgdmFsIG9mX2FsaXN0X2ZvbGQgOiAoJ2EgKiAnYikgbGlzdCAtPiBpbml0OidjIC0+IGY6KCdjIC0+ICdiIC0+ICdjKSAtPiAoJ2EsICdjKSB0XG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2UgOiAoJ2EgKiAnYikgbGlzdCAtPiBmOignYiAtPiAnYiAtPiAnYikgLT4gKCdhLCAnYikgdFxuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogKCdhICogJ2IpIGFycmF5IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6ICgnYSAqICdiKSBhcnJheSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCA6IGxlbjppbnQgLT4gZjooaW50IC0+ICdhICogJ2IpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2UgOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiAoJ2EsICdiKSB0IE9yX2Vycm9yLnRcbiAgdmFsIG9mX3NlcXVlbmNlIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cbiAgdmFsIG9mX3NlcXVlbmNlX29yX2Vycm9yIDogKCdhICogJ2IpIFNlcXVlbmNlLnQgLT4gKCdhLCAnYikgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zZXF1ZW5jZV9leG4gOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl9zZXF1ZW5jZV9tdWx0aSA6ICgnYSAqICdiKSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2IgbGlzdCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9mb2xkXG4gICAgOiAgKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYykgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2UgOiAoJ2EgKiAnYikgU2VxdWVuY2UudCAtPiBmOignYiAtPiAnYiAtPiAnYikgLT4gKCdhLCAnYikgdFxuXG4gIHZhbCBvZl9pdGVyaVxuICAgIDogIGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KVxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgdmFsIG9mX2l0ZXJpX2V4biA6IGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBvZl90cmVlIDogKCdhLCAnYikgdHJlZSAtPiAoJ2EsICdiKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjbXApIHRcbiAgdHlwZSAoJ2EsICdiLCAnY21wKSB0cmVlXG5cbiAgdmFsIGVtcHR5IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsIF8sICdjbXApIHRcbiAgdmFsIHNpbmdsZXRvbiA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgLT4gJ2IgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gIHZhbCBtYXBfa2V5c1xuICAgIDogIGNvbXBhcmF0b3I6KCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IudFxuICAgIC0+ICgnazEsICd2LCAnY21wMSkgdFxuICAgIC0+IGY6KCdrMSAtPiAnazIpXG4gICAgLT4gWyBgT2sgb2YgKCdrMiwgJ3YsICdjbXAyKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2syIF1cblxuICB2YWwgbWFwX2tleXNfZXhuXG4gICAgOiAgY29tcGFyYXRvcjooJ2syLCAnY21wMikgQ29tcGFyYXRvci50XG4gICAgLT4gKCdrMSwgJ3YsICdjbXAxKSB0XG4gICAgLT4gZjooJ2sxIC0+ICdrMilcbiAgICAtPiAoJ2syLCAndiwgJ2NtcDIpIHRcblxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBvZl9hbGlzdF9leG5cbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX2FsaXN0X211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgdmFsIG9mX2FsaXN0X2ZvbGRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gIHZhbCBvZl9hbGlzdF9yZWR1Y2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBmOignYiAtPiAnYiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiBmOihpbnQgLT4gJ2EgKiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2Zfc2VxdWVuY2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvclxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9leG5cbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX3NlcXVlbmNlX211bHRpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgdmFsIG9mX3NlcXVlbmNlX2ZvbGRcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gIHZhbCBvZl9zZXF1ZW5jZV9yZWR1Y2VcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhICogJ2IpIFNlcXVlbmNlLnRcbiAgICAtPiBmOignYiAtPiAnYiAtPiAnYilcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+IGl0ZXJpOihmOihrZXk6J2EgLT4gZGF0YTonYiAtPiB1bml0KSAtPiB1bml0KVxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IsICdjbXApIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgdmFsIG9mX2l0ZXJpX2V4blxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgdmFsIG9mX3RyZWVcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdHJlZVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcbmVuZFxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnNcbiAgICAoVCA6IFQzKVxuICAgIChUcmVlIDogVDMpXG4gICAgKEtleSA6IFQxKVxuICAgIChDbXAgOiBUMSlcbiAgICAoT3B0aW9ucyA6IFQzKVxuICAgIChfIDogQ3JlYXRvcnNfZ2VuZXJpY1xuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIG9wdGlvbnMgOj0gKCdhLCAnYiwgJ2MpIE9wdGlvbnMudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIFQudFxuICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuICAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIEtleS50XG4gICAgIHdpdGggdHlwZSAnYSBjbXAgOj0gJ2EgQ21wLnQpID1cbnN0cnVjdCBlbmRcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMSAoTSA6IENyZWF0b3JzMSkgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAnYiBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICdiIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmtleVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMyIChNIDogQ3JlYXRvcnMyKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiLCAnYykgdCA9ICgnYSwgJ2IpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IsICdjKSB0ID0gKCdhLCAnYikgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczNfd2l0aF9jb21wYXJhdG9yIChNIDogQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvcikgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYiwgJ2MpIHQgPSAoJ2EsICdiLCAnYykgTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChXaXRoX2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnNfZ2VuZXJpYyA9IHNpZ1xuICBpbmNsdWRlIENyZWF0b3JzX2dlbmVyaWNcblxuICBpbmNsdWRlXG4gICAgQWNjZXNzb3JzX2dlbmVyaWNcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHQgOj0gKCdhLCAnYiwgJ2MpIHRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRyZWVcbiAgICB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIGtleVxuICAgIHdpdGggdHlwZSAnYSBjbXAgOj0gJ2EgY21wXG4gICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBvcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczEgPSBzaWdcbiAgaW5jbHVkZSBDcmVhdG9yczFcblxuICBpbmNsdWRlXG4gICAgQWNjZXNzb3JzMVxuICAgIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICB3aXRoIHR5cGUgJ2EgdHJlZSA6PSAnYSB0cmVlXG4gICAgd2l0aCB0eXBlIGtleSA6PSBrZXlcbiAgICB3aXRoIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzIDo9IGNvbXBhcmF0b3Jfd2l0bmVzc1xuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyID0gc2lnXG4gIGluY2x1ZGUgQ3JlYXRvcnMyXG5cbiAgaW5jbHVkZVxuICAgIEFjY2Vzc29yczJcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdHJlZVxuICAgIHdpdGggdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgOj0gY29tcGFyYXRvcl93aXRuZXNzXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yID0gc2lnXG4gIGluY2x1ZGUgQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvclxuXG4gIGluY2x1ZGVcbiAgICBBY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvclxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdHJlZSA6PSAoJ2EsICdiLCAnYykgdHJlZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfcG9seSA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyXG5cbm1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IsICdjKSB0XG5cbiAgbW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIENvbXBhcmF0b3IuUyB3aXRoIHR5cGUgdCA6PSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG4gIG1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG4gIG1vZHVsZSB0eXBlIEhhc2hfZm9sZF9tID0gSGFzaGVyLlNcblxuICB2YWwgc2V4cF9vZl9tX190XG4gICAgOiAgKG1vZHVsZSBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAoJ3YgLT4gU2V4cC50KVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBTZXhwLnRcblxuICB2YWwgbV9fdF9vZl9zZXhwXG4gICAgOiAgKG1vZHVsZSBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSAnayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnY21wKVxuICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgLT4gU2V4cC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIHZhbCBtX190X3NleHBfZ3JhbW1hclxuICAgIDogIChtb2R1bGUgTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICB2YWwgY29tcGFyZV9tX190XG4gICAgOiAgKG1vZHVsZSBDb21wYXJlX20pXG4gICAgLT4gKCd2IC0+ICd2IC0+IGludClcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGludFxuXG4gIHZhbCBlcXVhbF9tX190XG4gICAgOiAgKG1vZHVsZSBFcXVhbF9tKVxuICAgIC0+ICgndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gYm9vbFxuXG4gIHZhbCBoYXNoX2ZvbGRfbV9fdFxuICAgIDogIChtb2R1bGUgSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSAnaylcbiAgICAtPiAoSGFzaC5zdGF0ZSAtPiAndiAtPiBIYXNoLnN0YXRlKVxuICAgIC0+IEhhc2guc3RhdGVcbiAgICAtPiAoJ2ssICd2LCBfKSB0XG4gICAgLT4gSGFzaC5zdGF0ZVxuZW5kXG5cbm1vZHVsZSB0eXBlIE1hcCA9IHNpZ1xuICAoKiogW01hcF0gaXMgYSBmdW5jdGlvbmFsIGRhdGEgc3RydWN0dXJlIChiYWxhbmNlZCBiaW5hcnkgdHJlZSkgaW1wbGVtZW50aW5nIGZpbml0ZSBtYXBzXG4gICAgICBvdmVyIGEgdG90YWxseS1vcmRlcmVkIGRvbWFpbiwgY2FsbGVkIGEgXCJrZXlcIi4gKilcblxuICB0eXBlICgna2V5LCArJ3ZhbHVlLCAnY21wKSB0XG5cbiAgbW9kdWxlIE9yX2R1cGxpY2F0ZSA9IE9yX2R1cGxpY2F0ZVxuICBtb2R1bGUgQ29udGludWVfb3Jfc3RvcCA9IENvbnRpbnVlX29yX3N0b3BcblxuICBtb2R1bGUgRmluaXNoZWRfb3JfdW5maW5pc2hlZCA6IHNpZ1xuICAgIHR5cGUgdCA9IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudCA9XG4gICAgICB8IEZpbmlzaGVkXG4gICAgICB8IFVuZmluaXNoZWRcbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBlcXVhbCwgc2V4cF9vZl1cblxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUyB3aXRoIHR5cGUgdCA6PSB0XG4gICAgaW5jbHVkZSBQcHhfZW51bWVyYXRlX2xpYi5FbnVtZXJhYmxlLlMgd2l0aCB0eXBlIHQgOj0gdFxuICAgIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkVxdWFsLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgKCoqIE1hcHMgW0NvbnRpbnVlXSB0byBbRmluaXNoZWRdIGFuZCBbU3RvcF0gdG8gW1VuZmluaXNoZWRdLiAqKVxuICAgIHZhbCBvZl9jb250aW51ZV9vcl9zdG9wIDogQ29udGludWVfb3Jfc3RvcC50IC0+IHRcblxuICAgICgqKiBNYXBzIFtGaW5pc2hlZF0gdG8gW0NvbnRpbnVlXSBhbmQgW1VuZmluaXNoZWRdIHRvIFtTdG9wXS4gKilcbiAgICB2YWwgdG9fY29udGludWVfb3Jfc3RvcCA6IHQgLT4gQ29udGludWVfb3Jfc3RvcC50XG4gIGVuZFxuXG4gIG1vZHVsZSBNZXJnZV9lbGVtZW50IDogc2lnXG4gICAgdHlwZSAoJ2xlZnQsICdyaWdodCkgdCA9XG4gICAgICBbIGBMZWZ0IG9mICdsZWZ0XG4gICAgICB8IGBSaWdodCBvZiAncmlnaHRcbiAgICAgIHwgYEJvdGggb2YgJ2xlZnQgKiAncmlnaHRcbiAgICAgIF1cbiAgICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHBfb2ZdXG5cbiAgICB2YWwgY29tcGFyZVxuICAgICAgOiAgKCdsZWZ0IC0+ICdsZWZ0IC0+IGludClcbiAgICAgIC0+ICgncmlnaHQgLT4gJ3JpZ2h0IC0+IGludClcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gaW50XG5cbiAgICB2YWwgZXF1YWxcbiAgICAgIDogICgnbGVmdCAtPiAnbGVmdCAtPiBib29sKVxuICAgICAgLT4gKCdyaWdodCAtPiAncmlnaHQgLT4gYm9vbClcbiAgICAgIC0+ICgnbGVmdCwgJ3JpZ2h0KSB0XG4gICAgICAtPiAoJ2xlZnQsICdyaWdodCkgdFxuICAgICAgLT4gYm9vbFxuXG4gICAgdmFsIHNleHBfb2ZfdFxuICAgICAgOiAgKCdsZWZ0IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgIC0+ICgncmlnaHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgIHZhbCBsZWZ0IDogKCdsZWZ0LCBfKSB0IC0+ICdsZWZ0IG9wdGlvblxuICAgIHZhbCByaWdodCA6IChfLCAncmlnaHQpIHQgLT4gJ3JpZ2h0IG9wdGlvblxuICAgIHZhbCBsZWZ0X3ZhbHVlIDogKCdsZWZ0LCBfKSB0IC0+IGRlZmF1bHQ6J2xlZnQgLT4gJ2xlZnRcbiAgICB2YWwgcmlnaHRfdmFsdWUgOiAoXywgJ3JpZ2h0KSB0IC0+IGRlZmF1bHQ6J3JpZ2h0IC0+ICdyaWdodFxuXG4gICAgdmFsIHZhbHVlc1xuICAgICAgOiAgKCdsZWZ0LCAncmlnaHQpIHRcbiAgICAgIC0+IGxlZnRfZGVmYXVsdDonbGVmdFxuICAgICAgLT4gcmlnaHRfZGVmYXVsdDoncmlnaHRcbiAgICAgIC0+ICdsZWZ0ICogJ3JpZ2h0XG4gIGVuZFxuXG4gIHR5cGUgKCdrLCAnY21wKSBjb21wYXJhdG9yID0gKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gIFtAQGRlcHJlY2F0ZWQgXCJbc2luY2UgMjAyMS0xMl0gdXNlIFtDb21wYXJhdG9yLk1vZHVsZS50XSBpbnN0ZWFkXCJdXG5cbiAgKCoqIFRlc3QgaWYgdGhlIGludmFyaWFudHMgb2YgdGhlIGludGVybmFsIEFWTCBzZWFyY2ggdHJlZSBob2xkLiAqKVxuICB2YWwgaW52YXJpYW50cyA6IChfLCBfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGZpcnN0LWNsYXNzIG1vZHVsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJ1aWxkIG90aGVyIG1hcC9zZXQvZXRjLlxuICAgICAgd2l0aCB0aGUgc2FtZSBub3Rpb24gb2YgY29tcGFyaXNvbi4gKilcbiAgdmFsIGNvbXBhcmF0b3JfcyA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSwgXywgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IudFxuXG4gICgqKiBUaGUgZW1wdHkgbWFwLiAqKVxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBBIG1hcCB3aXRoIG9uZSAoa2V5LCBkYXRhKSBwYWlyLiAqKVxuICB2YWwgc2luZ2xldG9uIDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIC0+ICdiIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIGxpc3Qgd2l0aCB1bmlxdWUga2V5cy4gKilcbiAgdmFsIG9mX2FsaXN0XG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiLCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2EgXVxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLCByZXR1cm5pbmcgYW4gZXJyb3IgaWZcbiAgICAgIGR1cGxpY2F0ZSBbJ2FdIGtleXMgYXJlIGZvdW5kLiAqKVxuICB2YWwgb2ZfYWxpc3Rfb3JfZXJyb3JcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHVuaXF1ZSBrZXlzLCByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9hbGlzdF9leG4gOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gKCdhICogJ2IpIGxpc3QgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gbGlzdCB3aXRoIHBvc3NpYmx5IHJlcGVhdGVkIGtleXMuIFRoZSB2YWx1ZXMgaW5cbiAgICAgIHRoZSBtYXAgZm9yIGEgZ2l2ZW4ga2V5IGFwcGVhciBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IGRpZCBpbiB0aGUgYXNzb2NpYXRpb25cbiAgICAgIGxpc3QuICopXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIENvbWJpbmVzIGFuIGFzc29jaWF0aW9uIGxpc3QgaW50byBhIG1hcCwgZm9sZGluZyB0b2dldGhlciBib3VuZCB2YWx1ZXMgd2l0aCBjb21tb25cbiAgICAgIGtleXMuIFRoZSBhY2N1bXVsYXRvciBpcyBwZXIta2V5LlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7W1xuICAgICAgICAjIGxldCBtYXAgPSBTdHJpbmcuTWFwLm9mX2FsaXN0X2ZvbGRcbiAgICAgICAgICAgICAgICAgICAgICBbIFwiYVwiLCAxOyBcImFcIiwgMTA7IFwiYlwiLCAyOyBcImJcIiwgMjA7IFwiYlwiLCAyMDAgXVxuICAgICAgICAgICAgICAgICAgICAgIH5pbml0OkludC5TZXQuZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICB+ZjpTZXQuYWRkXG4gICAgICAgICAgaW5cbiAgICAgICAgICBwcmludF9zIFslc2V4cCAobWFwIDogSW50LlNldC50IFN0cmluZy5NYXAudCldOztcbiAgICAgICAgKChhICgxIDEwKSkgKGIgKDIgMjAgMjAwKSkpXG4gICAgICAgIC0gOiB1bml0ID0gKClcbiAgICAgIF19XG4gICopXG4gIHZhbCBvZl9hbGlzdF9mb2xkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBpbml0OidjXG4gICAgLT4gZjooJ2MgLT4gJ2IgLT4gJ2MpXG4gICAgLT4gKCdhLCAnYywgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBsaXN0IGludG8gYSBtYXAsIHJlZHVjaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy4gKilcbiAgdmFsIG9mX2FsaXN0X3JlZHVjZVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaXRlcmkgfml0ZXJpXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0XSwgZXhjZXB0IHRoYXQgaW5zdGVhZCBvZiB0YWtpbmcgYSBjb25jcmV0ZVxuICAgICAgZGF0YSBzdHJ1Y3R1cmUsIGl0IHRha2VzIGFuIGl0ZXJhdGlvbiBmdW5jdGlvbi4gIEZvciBpbnN0YW5jZSwgdG8gY29udmVydCBhIHN0cmluZyB0YWJsZVxuICAgICAgaW50byBhIG1hcDogW29mX2l0ZXJpIChtb2R1bGUgU3RyaW5nKSB+ZjooSGFzaHRibC5pdGVyaSB0YWJsZSldLiAgSXQgaXMgZmFzdGVyIHRoYW5cbiAgICAgIGFkZGluZyB0aGUgZWxlbWVudHMgb25lIGJ5IG9uZS4gKilcbiAgdmFsIG9mX2l0ZXJpXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gaXRlcmk6KGY6KGtleTonYSAtPiBkYXRhOidiIC0+IHVuaXQpIC0+IHVuaXQpXG4gICAgLT4gWyBgT2sgb2YgKCdhLCAnYiwgJ2NtcCkgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdhIF1cblxuICAoKiogTGlrZSBbb2ZfaXRlcmldIGV4Y2VwdCB0aGF0IGl0IHJhaXNlcyBhbiBleGNlcHRpb24gaWYgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuICopXG4gIHZhbCBvZl9pdGVyaV9leG5cbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBpdGVyaTooZjooa2V5OidhIC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdClcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhIHNvcnRlZCBhcnJheSBvZiBrZXktZGF0YSBwYWlycy4gVGhlIGlucHV0IGFycmF5IG11c3QgYmUgc29ydGVkXG4gICAgICAoZWl0aGVyIGluIGFzY2VuZGluZyBvciBkZXNjZW5kaW5nIG9yZGVyKSwgYXMgZ2l2ZW4gYnkgdGhlIHJlbGV2YW50IGNvbXBhcmF0b3IsIGFuZFxuICAgICAgbXVzdCBub3QgY29udGFpbiBkdXBsaWNhdGUga2V5cy4gSWYgZWl0aGVyIG9mIHRoZXNlIGNvbmRpdGlvbnMgZG9lcyBub3QgaG9sZCxcbiAgICAgIGFuIGVycm9yIGlzIHJldHVybmVkLiAgKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBhcnJheVxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBMaWtlIFtvZl9zb3J0ZWRfYXJyYXldIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgYSBtYXAgd2l0aCBicm9rZW4gaW52YXJpYW50cyB3aGVuIGFuXG4gICAgICBbRXJyb3JdIHdvdWxkIGhhdmUgYmVlbiByZXR1cm5lZC4gKilcbiAgdmFsIG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgYXJyYXlcbiAgICAtPiAoJ2EsICdiLCAnY21wKSB0XG5cbiAgKCoqIFtvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBjIH5sZW4gfmZdIGJlaGF2ZXMgbGlrZSBbb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBjXG4gICAgICAoQXJyYXkuaW5pdCBsZW4gfmYpXSwgd2l0aCB0aGUgYWRkaXRpb25hbCByZXN0cmljdGlvbiB0aGF0IGEgZGVjcmVhc2luZyBvcmRlciBpcyBub3RcbiAgICAgIHN1cHBvcnRlZC4gIFRoZSBhZHZhbnRhZ2UgaXMgbm90IHJlcXVpcmluZyB5b3UgdG8gYWxsb2NhdGUgYW4gaW50ZXJtZWRpYXRlIGFycmF5LiAgW2ZdXG4gICAgICB3aWxsIGJlIGNhbGxlZCB3aXRoIDAsIDEsIC4uLiBbbGVuIC0gMV0sIGluIG9yZGVyLiAqKVxuICB2YWwgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWRcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooaW50IC0+ICdhICogJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBbb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBjIHNlcV0gYmVoYXZlcyBsaWtlIFtvZl9zb3J0ZWRfYXJyYXkgYyAoU2VxdWVuY2UudG9fYXJyYXlcbiAgICAgIHNlcSldLCBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBhcnJheS5cblxuICAgICAgVGhlIHNlcXVlbmNlIHdpbGwgYmUgZm9sZGVkIG92ZXIgb25jZSwgYW5kIHRoZSBhZGRpdGlvbmFsIHRpbWUgY29tcGxleGl0eSBpcyB7ZSBPKG4pfS5cbiAgKilcbiAgdmFsIG9mX2luY3JlYXNpbmdfc2VxdWVuY2VcbiAgICA6ICAoJ2ssICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sgKiAndikgU2VxdWVuY2UudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cy5cblxuICAgICAgW29mX3NlcXVlbmNlIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0IGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV0gYnV0XG4gICAgICBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG5cbiAgICAgIElmIHlvdXIgc2VxdWVuY2UgaXMgaW5jcmVhc2luZywgdXNlIFtvZl9pbmNyZWFzaW5nX3NlcXVlbmNlXS5cbiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlXG4gICAgOiAgKCdrLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gKCdrICogJ3YpIFNlcXVlbmNlLnRcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYER1cGxpY2F0ZV9rZXkgb2YgJ2sgXVxuXG4gICgqKiBDcmVhdGVzIGEgbWFwIGZyb20gYW4gYXNzb2NpYXRpb24gc2VxdWVuY2Ugd2l0aCB1bmlxdWUga2V5cywgcmV0dXJuaW5nIGFuIGVycm9yIGlmXG4gICAgICBkdXBsaWNhdGUgWydhXSBrZXlzIGFyZSBmb3VuZC5cblxuICAgICAgW29mX3NlcXVlbmNlX29yX2Vycm9yIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X29yX2Vycm9yIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV1cbiAgICAgIGJ1dCBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9vcl9lcnJvclxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIENyZWF0ZXMgYSBtYXAgZnJvbSBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSB3aXRoIHVuaXF1ZSBrZXlzLCByYWlzaW5nIGFuIGV4Y2VwdGlvbiBpZlxuICAgICAgZHVwbGljYXRlIFsnYV0ga2V5cyBhcmUgZm91bmQuXG5cbiAgICAgIFtvZl9zZXF1ZW5jZV9leG4gYyBzZXFdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfZXhuIGMgKFNlcXVlbmNlLnRvX2xpc3Qgc2VxKV0gYnV0XG4gICAgICBkb2VzIG5vdCBhbGxvY2F0ZSB0aGUgaW50ZXJtZWRpYXRlIGxpc3QuXG4gICopXG4gIHZhbCBvZl9zZXF1ZW5jZV9leG5cbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IsICdjbXApIHRcblxuICAoKiogQ3JlYXRlcyBhIG1hcCBmcm9tIGFuIGFzc29jaWF0aW9uIHNlcXVlbmNlIHdpdGggcG9zc2libHkgcmVwZWF0ZWQga2V5cy4gVGhlIHZhbHVlcyBpblxuICAgICAgdGhlIG1hcCBmb3IgYSBnaXZlbiBrZXkgYXBwZWFyIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZXkgZGlkIGluIHRoZSBhc3NvY2lhdGlvblxuICAgICAgbGlzdC5cblxuICAgICAgW29mX3NlcXVlbmNlX211bHRpIGMgc2VxXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X2V4biBjIChTZXF1ZW5jZS50b19saXN0IHNlcSldIGJ1dFxuICAgICAgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfbXVsdGlcbiAgICA6ICAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EgKiAnYikgU2VxdWVuY2UudFxuICAgIC0+ICgnYSwgJ2IgbGlzdCwgJ2NtcCkgdFxuXG4gICgqKiBDb21iaW5lcyBhbiBhc3NvY2lhdGlvbiBzZXF1ZW5jZSBpbnRvIGEgbWFwLCBmb2xkaW5nIHRvZ2V0aGVyIGJvdW5kIHZhbHVlcyB3aXRoIGNvbW1vblxuICAgICAga2V5cy5cblxuICAgICAgW29mX3NlcXVlbmNlX2ZvbGQgYyBzZXEgfmluaXQgfmZdIGJlaGF2ZXMgbGlrZSBbb2ZfYWxpc3RfZm9sZCBjIChTZXF1ZW5jZS50b19saXN0IHNlcSkgfmluaXQgfmZdXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LlxuICAqKVxuICB2YWwgb2Zfc2VxdWVuY2VfZm9sZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gaW5pdDonY1xuICAgIC0+IGY6KCdjIC0+ICdiIC0+ICdjKVxuICAgIC0+ICgnYSwgJ2MsICdjbXApIHRcblxuICAoKiogQ29tYmluZXMgYW4gYXNzb2NpYXRpb24gc2VxdWVuY2UgaW50byBhIG1hcCwgcmVkdWNpbmcgdG9nZXRoZXIgYm91bmQgdmFsdWVzIHdpdGggY29tbW9uXG4gICAgICBrZXlzLlxuXG4gICAgICBbb2Zfc2VxdWVuY2VfcmVkdWNlIGMgc2VxIH5mXSBiZWhhdmVzIGxpa2UgW29mX2FsaXN0X3JlZHVjZSBjIChTZXF1ZW5jZS50b19saXN0IHNlcSkgfmZdXG4gICAgICBidXQgZG9lcyBub3QgYWxsb2NhdGUgdGhlIGludGVybWVkaWF0ZSBsaXN0LiAgKilcbiAgdmFsIG9mX3NlcXVlbmNlX3JlZHVjZVxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnYSAqICdiKSBTZXF1ZW5jZS50XG4gICAgLT4gZjooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgLT4gKCdhLCAnYiwgJ2NtcCkgdFxuXG4gICgqKiBUZXN0cyB3aGV0aGVyIGEgbWFwIGlzIGVtcHR5LiAqKVxuICB2YWwgaXNfZW1wdHkgOiAoXywgXywgXykgdCAtPiBib29sXG5cbiAgKCoqIFtsZW5ndGggbWFwXSByZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gW21hcF0uICBPKDEpLCBidXQgW1RyZWUubGVuZ3RoXSBpc1xuICAgICAgTyhuKS4gKilcbiAgdmFsIGxlbmd0aCA6IChfLCBfLCBfKSB0IC0+IGludFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIHRoZSBzcGVjaWZpZWQgbmV3IGJpbmRpbmc7IGlmIHRoZSBrZXkgd2FzIGFscmVhZHkgYm91bmQsIGl0c1xuICAgICAgcHJldmlvdXMgYmluZGluZyBkaXNhcHBlYXJzLiAqKVxuICB2YWwgc2V0IDogKCdrLCAndiwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFthZGQgdCB+a2V5IH5kYXRhXSBhZGRzIGEgbmV3IGVudHJ5IHRvIFt0XSBtYXBwaW5nIFtrZXldIHRvIFtkYXRhXSBhbmQgcmV0dXJucyBbYE9rXVxuICAgICAgd2l0aCB0aGUgbmV3IG1hcCwgb3IgaWYgW2tleV0gaXMgYWxyZWFkeSBwcmVzZW50IGluIFt0XSwgcmV0dXJucyBbYER1cGxpY2F0ZV0uICopXG4gIHZhbCBhZGQgOiAoJ2ssICd2LCAnY21wKSB0IC0+IGtleTonayAtPiBkYXRhOid2IC0+ICgnaywgJ3YsICdjbXApIHQgT3JfZHVwbGljYXRlLnRcblxuICB2YWwgYWRkX2V4biA6ICgnaywgJ3YsICdjbXApIHQgLT4ga2V5OidrIC0+IGRhdGE6J3YgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBJZiBba2V5XSBpcyBub3QgcHJlc2VudCB0aGVuIGFkZCBhIHNpbmdsZXRvbiBsaXN0LCBvdGhlcndpc2UsIGNvbnMgZGF0YSBvbnRvIHRoZVxuICAgICAgaGVhZCBvZiB0aGUgZXhpc3RpbmcgbGlzdC4gKilcbiAgdmFsIGFkZF9tdWx0aSA6ICgnaywgJ3YgbGlzdCwgJ2NtcCkgdCAtPiBrZXk6J2sgLT4gZGF0YTondiAtPiAoJ2ssICd2IGxpc3QsICdjbXApIHRcblxuICAoKiogSWYgdGhlIGtleSBpcyBwcmVzZW50LCB0aGVuIHJlbW92ZSBpdHMgaGVhZCBlbGVtZW50OyBpZiB0aGUgcmVzdWx0IGlzIGVtcHR5LCByZW1vdmVcbiAgICAgIHRoZSBrZXkuICopXG4gIHZhbCByZW1vdmVfbXVsdGkgOiAoJ2ssICd2IGxpc3QsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiBsaXN0LCAnY21wKSB0XG5cbiAgKCoqIFJldHVybnMgdGhlIHZhbHVlIGJvdW5kIHRvIHRoZSBnaXZlbiBrZXksIG9yIHRoZSBlbXB0eSBsaXN0IGlmIHRoZXJlIGlzIG5vbmUuICopXG4gIHZhbCBmaW5kX211bHRpIDogKCdrLCAndiBsaXN0LCAnY21wKSB0IC0+ICdrIC0+ICd2IGxpc3RcblxuICAoKiogW2NoYW5nZSB0IGtleSB+Zl0gcmV0dXJucyBhIG5ldyBtYXAgW21dIHRoYXQgaXMgdGhlIHNhbWUgYXMgW3RdIG9uIGFsbCBrZXlzIGV4Y2VwdFxuICAgICAgZm9yIFtrZXldLCBhbmQgd2hvc2UgdmFsdWUgZm9yIFtrZXldIGlzIGRlZmluZWQgYnkgW2ZdLCBpLmUuLCBbZmluZCBtIGtleSA9IGYgKGZpbmRcbiAgICAgIHQga2V5KV0uICopXG4gIHZhbCBjaGFuZ2UgOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+IGY6KCd2IG9wdGlvbiAtPiAndiBvcHRpb24pIC0+ICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogW3VwZGF0ZSB0IGtleSB+Zl0gaXMgW2NoYW5nZSB0IGtleSB+ZjooZnVuIG8gLT4gU29tZSAoZiBvKSldLiAqKVxuICB2YWwgdXBkYXRlIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiBmOigndiBvcHRpb24gLT4gJ3YpIC0+ICgnaywgJ3YsICdjbXApIHRcblxuXG4gICgqKiBSZXR1cm5zIFtTb21lIHZhbHVlXSBib3VuZCB0byB0aGUgZ2l2ZW4ga2V5LCBvciBbTm9uZV0gaWYgbm9uZSBleGlzdHMuICopXG4gIHZhbCBmaW5kIDogKCdrLCAndiwgJ2NtcCkgdCAtPiAnayAtPiAndiBvcHRpb25cblxuICAoKiogUmV0dXJucyB0aGUgdmFsdWUgYm91bmQgdG8gdGhlIGdpdmVuIGtleSwgcmFpc2luZyBbQ2FtbC5Ob3RfZm91bmRdIG9yIFtOb3RfZm91bmRfc11cbiAgICAgIGlmIG5vbmUgZXhpc3RzLiAqKVxuICB2YWwgZmluZF9leG4gOiAoJ2ssICd2LCAnY21wKSB0IC0+ICdrIC0+ICd2XG5cbiAgKCoqIFJldHVybnMgYSBuZXcgbWFwIHdpdGggYW55IGJpbmRpbmcgZm9yIHRoZSBrZXkgaW4gcXVlc3Rpb24gcmVtb3ZlZC4gKilcbiAgdmFsIHJlbW92ZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbbWVtIG1hcCBrZXldIHRlc3RzIHdoZXRoZXIgW21hcF0gY29udGFpbnMgYSBiaW5kaW5nIGZvciBba2V5XS4gKilcbiAgdmFsIG1lbSA6ICgnaywgXywgJ2NtcCkgdCAtPiAnayAtPiBib29sXG5cbiAgdmFsIGl0ZXJfa2V5cyA6ICgnaywgXywgXykgdCAtPiBmOignayAtPiB1bml0KSAtPiB1bml0XG4gIHZhbCBpdGVyIDogKF8sICd2LCBfKSB0IC0+IGY6KCd2IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXJpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCoqIEl0ZXJhdGVzIHVudGlsIHRoZSBmaXJzdCB0aW1lIFtmXSByZXR1cm5zIFtTdG9wXS4gSWYgW2ZdIHJldHVybnMgW1N0b3BdLCB0aGUgZmluYWxcbiAgICAgIHJlc3VsdCBpcyBbVW5maW5pc2hlZF0uIE90aGVyd2lzZSwgdGhlIGZpbmFsIHJlc3VsdCBpcyBbRmluaXNoZWRdLiAqKVxuICB2YWwgaXRlcmlfdW50aWxcbiAgICA6ICAoJ2ssICd2LCBfKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IEZpbmlzaGVkX29yX3VuZmluaXNoZWQudFxuXG4gICgqKiBJdGVyYXRlcyB0d28gbWFwcyBzaWRlIGJ5IHNpZGUuIFRoZSBjb21wbGV4aXR5IG9mIHRoaXMgZnVuY3Rpb24gaXMgTyhNICsgTikuICBJZiB0d29cbiAgICAgIGlucHV0cyBhcmUgW1soMCwgYSk7ICgxLCBhKV1dIGFuZCBbWygxLCBiKTsgKDIsIGIpXV0sIFtmXSB3aWxsIGJlIGNhbGxlZCB3aXRoIFtbKDAsXG4gICAgICBgTGVmdCBhKTsgKDEsIGBCb3RoIChhLCBiKSk7ICgyLCBgUmlnaHQgYildXS4gKilcbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdrLCAndjEsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOigndjEsICd2MikgTWVyZ2VfZWxlbWVudC50IC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIGJvdW5kIHZhbHVlcyByZXBsYWNlZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmQgdmFsdWVzLiopXG4gIHZhbCBtYXAgOiAoJ2ssICd2MSwgJ2NtcCkgdCAtPiBmOigndjEgLT4gJ3YyKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFttYXBdLCBidXQgdGhlIHBhc3NlZCBmdW5jdGlvbiB0YWtlcyBib3RoIFtrZXldIGFuZCBbZGF0YV0gYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgbWFwaSA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAndjIpIC0+ICgnaywgJ3YyLCAnY21wKSB0XG5cbiAgKCoqIENvbnZlcnQgbWFwIHdpdGgga2V5cyBvZiB0eXBlIFsnazJdIHRvIGEgbWFwIHdpdGgga2V5cyBvZiB0eXBlIFsnazJdIHVzaW5nIFtmXS4gKilcbiAgdmFsIG1hcF9rZXlzXG4gICAgOiAgKCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+IFsgYE9rIG9mICgnazIsICd2LCAnY21wMikgdCB8IGBEdXBsaWNhdGVfa2V5IG9mICdrMiBdXG5cbiAgKCoqIExpa2UgW21hcF9rZXlzXSwgYnV0IHJhaXNlcyBvbiBkdXBsaWNhdGUga2V5LiAqKVxuICB2YWwgbWFwX2tleXNfZXhuXG4gICAgOiAgKCdrMiwgJ2NtcDIpIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2sxLCAndiwgJ2NtcDEpIHRcbiAgICAtPiBmOignazEgLT4gJ2syKVxuICAgIC0+ICgnazIsICd2LCAnY21wMikgdFxuXG4gICgqKiBGb2xkcyBvdmVyIGtleXMgYW5kIGRhdGEgaW4gdGhlIG1hcCBpbiBpbmNyZWFzaW5nIG9yZGVyIG9mIFtrZXldLiAqKVxuICB2YWwgZm9sZCA6ICgnaywgJ3YsIF8pIHQgLT4gaW5pdDonYSAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAnYSkgLT4gJ2FcblxuICAoKiogRm9sZHMgb3ZlciBrZXlzIGFuZCBkYXRhIGluIHRoZSBtYXAgaW4gaW5jcmVhc2luZyBvcmRlciBvZiBba2V5XSwgdW50aWwgdGhlIGZpcnN0XG4gICAgICB0aW1lIHRoYXQgW2ZdIHJldHVybnMgW1N0b3AgX10uIElmIFtmXSByZXR1cm5zIFtTdG9wIGZpbmFsXSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zXG4gICAgICBpbW1lZGlhdGVseSB3aXRoIHRoZSB2YWx1ZSBbZmluYWxdLiBJZiBbZl0gbmV2ZXIgcmV0dXJucyBbU3RvcCBfXSwgYW5kIHRoZSBmaW5hbFxuICAgICAgY2FsbCB0byBbZl0gcmV0dXJucyBbQ29udGludWUgbGFzdF0sIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBbZmluaXNoIGxhc3RdLiAqKVxuICB2YWwgZm9sZF91bnRpbFxuICAgIDogICgnaywgJ3YsIF8pIHRcbiAgICAtPiBpbml0OidhY2NcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYWNjIC0+ICgnYWNjLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICAoKiogRm9sZHMgb3ZlciBrZXlzIGFuZCBkYXRhIGluIHRoZSBtYXAgaW4gZGVjcmVhc2luZyBvcmRlciBvZiBba2V5XS4gKilcbiAgdmFsIGZvbGRfcmlnaHQgOiAoJ2ssICd2LCBfKSB0IC0+IGluaXQ6J2EgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gJ2EgLT4gJ2EpIC0+ICdhXG5cbiAgKCoqIEZvbGRzIG92ZXIgdHdvIG1hcHMgc2lkZSBieSBzaWRlLCBsaWtlIFtpdGVyMl0uICopXG4gIHZhbCBmb2xkMlxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6KCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ2EgLT4gJ2EpXG4gICAgLT4gJ2FcblxuICAoKiogW2ZpbHRlcl0sIFtmaWx0ZXJpXSwgW2ZpbHRlcl9rZXlzXSwgW2ZpbHRlcl9tYXBdLCBhbmQgW2ZpbHRlcl9tYXBpXSBydW4gaW4gTyhuICogbGdcbiAgICAgIG4pIHRpbWU7IHRoZXkgc2ltcGx5IGFjY3VtdWxhdGUgZWFjaCBrZXkgJiBkYXRhIHBhaXIgcmV0YWluZWQgYnkgW2ZdIGludG8gYSBuZXcgbWFwXG4gICAgICB1c2luZyBbYWRkXS4gKilcbiAgdmFsIGZpbHRlcl9rZXlzIDogKCdrLCAndiwgJ2NtcCkgdCAtPiBmOignayAtPiBib29sKSAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgdmFsIGZpbHRlciA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICB2YWwgZmlsdGVyaSA6ICgnaywgJ3YsICdjbXApIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IG1hcCB3aXRoIGJvdW5kIHZhbHVlcyBmaWx0ZXJlZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmQgdmFsdWVzLiAqKVxuICB2YWwgZmlsdGVyX21hcCA6ICgnaywgJ3YxLCAnY21wKSB0IC0+IGY6KCd2MSAtPiAndjIgb3B0aW9uKSAtPiAoJ2ssICd2MiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIFtmaWx0ZXJfbWFwXSwgYnV0IHRoZSBwYXNzZWQgZnVuY3Rpb24gdGFrZXMgYm90aCBba2V5XSBhbmQgW2RhdGFdIGFzXG4gICAgICBhcmd1bWVudHMuICopXG4gIHZhbCBmaWx0ZXJfbWFwaVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YxIC0+ICd2MiBvcHRpb24pXG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcblxuICAoKiogW3BhcnRpdGlvbl9tYXBpIHQgfmZdIHJldHVybnMgdHdvIG5ldyBbdF1zLCB3aXRoIGVhY2gga2V5IGluIFt0XSBhcHBlYXJpbmcgaW5cbiAgICAgIGV4YWN0bHkgb25lIG9mIHRoZSByZXN1bHRpbmcgbWFwcyBkZXBlbmRpbmcgb24gaXRzIG1hcHBpbmcgaW4gW2ZdLiAqKVxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KGtleTonayAtPiBkYXRhOid2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICAoKiogW3BhcnRpdGlvbl9tYXAgdCB+ZiA9IHBhcnRpdGlvbl9tYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKV0gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXBcbiAgICA6ICAoJ2ssICd2MSwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2MSAtPiAoJ3YyLCAndjMpIEVpdGhlci50KVxuICAgIC0+ICgnaywgJ3YyLCAnY21wKSB0ICogKCdrLCAndjMsICdjbXApIHRcblxuICAoKipcbiAgICAge1tcbiAgICAgICBwYXJ0aXRpb25pX3RmIHQgfmZcbiAgICAgICA9XG4gICAgICAgcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgIGlmIGYgfmtleSB+ZGF0YVxuICAgICAgICAgdGhlbiBGaXJzdCBkYXRhXG4gICAgICAgICBlbHNlIFNlY29uZCBkYXRhKVxuICAgICBdfSAqKVxuICB2YWwgcGFydGl0aW9uaV90ZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YsICdjbXApIHQgKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtwYXJ0aXRpb25fdGYgdCB+ZiA9IHBhcnRpdGlvbmlfdGYgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXSAqKVxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGY6KCd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnaywgJ3YsICdjbXApIHRcblxuICAoKiogUHJvZHVjZXMgW09rXSBvZiBhIG1hcCBpbmNsdWRpbmcgYWxsIGtleXMgaWYgYWxsIGRhdGEgaXMgW09rXSwgb3IgYW4gW0Vycm9yXVxuICAgICAgaW5jbHVkaW5nIGFsbCBlcnJvcnMgb3RoZXJ3aXNlLiAqKVxuICB2YWwgY29tYmluZV9lcnJvcnMgOiAoJ2ssICd2IE9yX2Vycm9yLnQsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCBPcl9lcnJvci50XG5cbiAgKCoqIFJldHVybnMgYSB0b3RhbCBvcmRlcmluZyBiZXR3ZWVuIG1hcHMuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHRvdGFsIG9yZGVyaW5nIHVzZWRcbiAgICAgIHRvIGNvbXBhcmUgZGF0YSBhc3NvY2lhdGVkIHdpdGggZXF1YWwga2V5cyBpbiB0aGUgdHdvIG1hcHMuICopXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgndiAtPiAndiAtPiBpbnQpIC0+ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiBpbnRcblxuICAoKiogSGFzaCBmdW5jdGlvbjogYSBidWlsZGluZyBibG9jayB0byB1c2Ugd2hlbiBoYXNoaW5nIGRhdGEgc3RydWN0dXJlcyBjb250YWluaW5nIG1hcHMgaW5cbiAgICAgIHRoZW0uIFtoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbY29tcGFyZV9kaXJlY3RdIGlmZlxuICAgICAgW2hhc2hfZm9sZF9rZXldIGlzIGNvbXBhdGlibGUgd2l0aCBbKGNvbXBhcmF0b3IgbSkuY29tcGFyZV0gb2YgdGhlIG1hcCBbbV0gYmVpbmdcbiAgICAgIGhhc2hlZC4gKilcbiAgdmFsIGhhc2hfZm9sZF9kaXJlY3QgOiAnayBIYXNoLmZvbGRlciAtPiAndiBIYXNoLmZvbGRlciAtPiAoJ2ssICd2LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgKCoqIFtlcXVhbCBjbXAgbTEgbTJdIHRlc3RzIHdoZXRoZXIgdGhlIG1hcHMgW20xXSBhbmQgW20yXSBhcmUgZXF1YWwsIHRoYXQgaXMsIGNvbnRhaW5cbiAgICAgIHRoZSBzYW1lIGtleXMgYW5kIGFzc29jaWF0ZSBlYWNoIGtleSB3aXRoIHRoZSBzYW1lIHZhbHVlLiAgW2NtcF0gaXMgdGhlIGVxdWFsaXR5XG4gICAgICBwcmVkaWNhdGUgdXNlZCB0byBjb21wYXJlIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlzLiAqKVxuICB2YWwgZXF1YWwgOiAoJ3YgLT4gJ3YgLT4gYm9vbCkgLT4gKCdrLCAndiwgJ2NtcCkgdCAtPiAoJ2ssICd2LCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyBhIGxpc3Qgb2YgdGhlIGtleXMgaW4gdGhlIGdpdmVuIG1hcC4gKilcbiAgdmFsIGtleXMgOiAoJ2ssIF8sIF8pIHQgLT4gJ2sgbGlzdFxuXG4gICgqKiBSZXR1cm5zIGEgbGlzdCBvZiB0aGUgZGF0YSBpbiB0aGUgZ2l2ZW4gbWFwLiAqKVxuICB2YWwgZGF0YSA6IChfLCAndiwgXykgdCAtPiAndiBsaXN0XG5cbiAgKCoqIENyZWF0ZXMgYW4gYXNzb2NpYXRpb24gbGlzdCBmcm9tIHRoZSBnaXZlbiBtYXAuICopXG4gIHZhbCB0b19hbGlzdFxuICAgIDogID9rZXlfb3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF0gKCoqIGRlZmF1bHQgaXMgW2BJbmNyZWFzaW5nXSAqKVxuICAgIC0+ICgnaywgJ3YsIF8pIHRcbiAgICAtPiAoJ2sgKiAndikgbGlzdFxuXG4gICgqKiB7MiBBZGRpdGlvbmFsIG9wZXJhdGlvbnMgb24gbWFwc30gKilcblxuICAoKiogTWVyZ2VzIHR3byBtYXBzLiBUaGUgcnVudGltZSBpcyBPKGxlbmd0aCh0MSkgKyBsZW5ndGgodDIpKS4gWW91IHNob3VsZG4ndCB1c2UgdGhpc1xuICAgICAgZnVuY3Rpb24gdG8gbWVyZ2UgYSBsaXN0IG9mIG1hcHM7IGNvbnNpZGVyIHVzaW5nIFttZXJnZV9za2V3ZWRdIGluc3RlYWQuICopXG4gIHZhbCBtZXJnZVxuICAgIDogICgnaywgJ3YxLCAnY21wKSB0XG4gICAgLT4gKCdrLCAndjIsICdjbXApIHRcbiAgICAtPiBmOihrZXk6J2sgLT4gKCd2MSwgJ3YyKSBNZXJnZV9lbGVtZW50LnQgLT4gJ3YzIG9wdGlvbilcbiAgICAtPiAoJ2ssICd2MywgJ2NtcCkgdFxuXG4gICgqKiBBIHNwZWNpYWwgY2FzZSBvZiBbbWVyZ2VdLCBbbWVyZ2Vfc2tld2VkIHQxIHQyXSBpcyBhIG1hcCBjb250YWluaW5nIGFsbCB0aGVcbiAgICAgIGJpbmRpbmdzIG9mIFt0MV0gYW5kIFt0Ml0uIEJpbmRpbmdzIHRoYXQgYXBwZWFyIGluIGJvdGggW3QxXSBhbmQgW3QyXSBhcmVcbiAgICAgIGNvbWJpbmVkIGludG8gYSBzaW5nbGUgdmFsdWUgdXNpbmcgdGhlIFtjb21iaW5lXSBmdW5jdGlvbi4gSW4gYSBjYWxsXG4gICAgICBbY29tYmluZSB+a2V5IHYxIHYyXSwgdGhlIHZhbHVlIFt2MV0gY29tZXMgZnJvbSBbdDFdIGFuZCBbdjJdIGZyb20gW3QyXS5cblxuICAgICAgVGhlIHJ1bnRpbWUgb2YgW21lcmdlX3NrZXdlZF0gaXMgW08obWluKGwxLCBsMikgKiBsb2cobWF4KGwxLCBsMikpKV0sIHdoZXJlIFtsMV0gaXNcbiAgICAgIHRoZSBsZW5ndGggb2YgW3QxXSBhbmQgW2wyXSB0aGUgbGVuZ3RoIG9mIFt0Ml0uIFRoaXMgaXMgbGlrZWx5IHRvIGJlIGZhc3RlciB0aGFuXG4gICAgICBbbWVyZ2VdIHdoZW4gb25lIG9mIHRoZSBtYXBzIGlzIGEgbG90IHNtYWxsZXIsIG9yIHdoZW4geW91IG1lcmdlIGEgbGlzdCBvZiBtYXBzLiAqKVxuICB2YWwgbWVyZ2Vfc2tld2VkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21iaW5lOihrZXk6J2sgLT4gJ3YgLT4gJ3YgLT4gJ3YpXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIG1vZHVsZSBTeW1tZXRyaWNfZGlmZl9lbGVtZW50IDogc2lnXG4gICAgdHlwZSAoJ2ssICd2KSB0ID0gJ2sgKiBbIGBMZWZ0IG9mICd2IHwgYFJpZ2h0IG9mICd2IHwgYFVuZXF1YWwgb2YgJ3YgKiAndiBdXG4gICAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5Db21wYXJhYmxlLlMyIHdpdGggdHlwZSAoJ2ssICd2KSB0IDo9ICgnaywgJ3YpIHRcbiAgICBpbmNsdWRlIFBweF9jb21wYXJlX2xpYi5FcXVhbC5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG4gICAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMiB3aXRoIHR5cGUgKCdrLCAndikgdCA6PSAoJ2ssICd2KSB0XG5cbiAgICB2YWwgdF9zZXhwX2dyYW1tYXJcbiAgICAgIDogICdrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgICAtPiAndiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgICAgLT4gKCdrLCAndikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gICAgW0BAQGVuZF1cbiAgZW5kXG5cbiAgKCoqIFtzeW1tZXRyaWNfZGlmZiB0MSB0MiB+ZGF0YV9lcXVhbF0gcmV0dXJucyBhIGxpc3Qgb2YgY2hhbmdlcyBiZXR3ZWVuIFt0MV0gYW5kIFt0Ml0uXG4gICAgICBJdCBpcyBpbnRlbmRlZCB0byBiZSBlZmZpY2llbnQgaW4gdGhlIGNhc2Ugd2hlcmUgW3QxXSBhbmQgW3QyXSBzaGFyZSBhIGxhcmdlIGFtb3VudFxuICAgICAgb2Ygc3RydWN0dXJlLiBUaGUga2V5cyBpbiB0aGUgb3V0cHV0IHNlcXVlbmNlIHdpbGwgYmUgaW4gc29ydGVkIG9yZGVyLlxuXG4gICAgICBJdCBpcyBhc3N1bWVkIHRoYXQgW2RhdGFfZXF1YWxdIGlzIGF0IGxlYXN0IGFzIGVxdWF0aW5nIGFzIHBoeXNpY2FsIGVxdWFsaXR5OiB0aGF0XG4gICAgICBbcGh5c19lcXVhbCB4IHldIGltcGxpZXMgW2RhdGFfZXF1YWwgeCB5XS4gT3RoZXJ3aXNlLCBbc3ltbWV0cmljX2RpZmZdIG1heSBiZWhhdmUgaW5cbiAgICAgIHVuZXhwZWN0ZWQgd2F5cy4gRm9yIGV4YW1wbGUsIHdpdGggW35kYXRhX2VxdWFsOihmdW4gXyBfIC0+IGZhbHNlKV0gaXQgaXMgTk9UXG4gICAgICBuZWNlc3NhcmlseSB0aGUgY2FzZSB0aGUgcmVzdWx0aW5nIGNoYW5nZSBzZXF1ZW5jZSB3aWxsIGNvbnRhaW4gYW4gZWxlbWVudFxuICAgICAgWyhrLCBgVW5lcXVhbCBfKV0gZm9yIGV2ZXJ5IGtleSBba10gc2hhcmVkIGJ5IGJvdGggbWFwcy5cblxuICAgICAgV2FybmluZzogRmxvYXQgZXF1YWxpdHkgdmlvbGF0ZXMgdGhpcyBwcm9wZXJ0eSEgW3BoeXNfZXF1YWwgRmxvYXQubmFuIEZsb2F0Lm5hbl0gaXNcbiAgICAgIHRydWUsIGJ1dCBbRmxvYXQuKD0pIEZsb2F0Lm5hbiBGbG9hdC5uYW5dIGlzIGZhbHNlLiAqKVxuICB2YWwgc3ltbWV0cmljX2RpZmZcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGRhdGFfZXF1YWw6KCd2IC0+ICd2IC0+IGJvb2wpXG4gICAgLT4gKCdrLCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICAoKiogW2ZvbGRfc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWxdIGZvbGRzIGFjcm9zcyBhbiBpbXBsaWNpdCBzZXF1ZW5jZSBvZiBjaGFuZ2VzXG4gICAgICBiZXR3ZWVuIFt0MV0gYW5kIFt0Ml0sIGluIHNvcnRlZCBvcmRlciBieSBrZXlzLiBFcXVpdmFsZW50IHRvXG4gICAgICBbU2VxdWVuY2UuZm9sZCAoc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWwpXSwgYW5kIG1vcmUgZWZmaWNpZW50LiAqKVxuICB2YWwgZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gZGF0YV9lcXVhbDooJ3YgLT4gJ3YgLT4gYm9vbClcbiAgICAtPiBpbml0OidhXG4gICAgLT4gZjooJ2EgLT4gKCdrLCAndikgU3ltbWV0cmljX2RpZmZfZWxlbWVudC50IC0+ICdhKVxuICAgIC0+ICdhXG5cbiAgKCoqIFttaW5fZWx0IG1hcF0gcmV0dXJucyBbU29tZSAoa2V5LCBkYXRhKV0gcGFpciBjb3JyZXNwb25kaW5nIHRvIHRoZSBtaW5pbXVtIGtleSBpblxuICAgICAgW21hcF0sIG9yIFtOb25lXSBpZiBlbXB0eS4gKilcbiAgdmFsIG1pbl9lbHQgOiAoJ2ssICd2LCBfKSB0IC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2ssICd2LCBfKSB0IC0+ICdrICogJ3ZcblxuICAoKiogW21heF9lbHQgbWFwXSByZXR1cm5zIFtTb21lIChrZXksIGRhdGEpXSBwYWlyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIG1heGltdW0ga2V5IGluXG4gICAgICBbbWFwXSwgb3IgW05vbmVdIGlmIFttYXBdIGlzIGVtcHR5LiAqKVxuICB2YWwgbWF4X2VsdCA6ICgnaywgJ3YsIF8pIHQgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gIHZhbCBtYXhfZWx0X2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gJ2sgKiAndlxuXG4gICgqKiBUaGVzZSBmdW5jdGlvbnMgaGF2ZSB0aGUgc2FtZSBzZW1hbnRpY3MgYXMgc2ltaWxhciBmdW5jdGlvbnMgaW4gW0xpc3RdLiAqKVxuXG4gIHZhbCBmb3JfYWxsIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBmb3JfYWxsaSA6ICgnaywgJ3YsIF8pIHQgLT4gZjooa2V5OidrIC0+IGRhdGE6J3YgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKCdrLCAndiwgXykgdCAtPiBmOigndiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBleGlzdHNpIDogKCdrLCAndiwgXykgdCAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudCA6ICgnaywgJ3YsIF8pIHQgLT4gZjooJ3YgLT4gYm9vbCkgLT4gaW50XG4gIHZhbCBjb3VudGkgOiAoJ2ssICd2LCBfKSB0IC0+IGY6KGtleTonayAtPiBkYXRhOid2IC0+IGJvb2wpIC0+IGludFxuXG5cbiAgKCoqIFtzcGxpdCB0IGtleV0gcmV0dXJucyBhIG1hcCBvZiBrZXlzIHN0cmljdGx5IGxlc3MgdGhhbiBba2V5XSwgdGhlIG1hcHBpbmcgb2YgW2tleV0gaWZcbiAgICAgIGFueSwgYW5kIGEgbWFwIG9mIGtleXMgc3RyaWN0bHkgZ3JlYXRlciB0aGFuIFtrZXldLlxuXG4gICAgICBSdW50aW1lIGlzIE8obSArIGxvZyBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgaW5wdXQgbWFwIGFuZCBtIGlzIHRoZSBzaXplIG9mXG4gICAgICB0aGUgc21hbGxlciBvZiB0aGUgdHdvIG91dHB1dCBtYXBzLiAgVGhlIE8obSkgdGVybSBpcyBkdWUgdG8gdGhlIG5lZWQgdG8gY2FsY3VsYXRlXG4gICAgICB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQgbWFwcy4gKilcbiAgdmFsIHNwbGl0XG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICdrXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdCAqICgnayAqICd2KSBvcHRpb24gKiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFthcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnRdIHJldHVybnMgW2BPayBtYXBdIHdoZXJlIFttYXBdIGNvbnRhaW5zIGFsbCB0aGVcbiAgICAgIFsoa2V5LCB2YWx1ZSldIHBhaXJzIGZyb20gdGhlIHR3byBpbnB1dCBtYXBzIGlmIGFsbCB0aGUga2V5cyBmcm9tIFtsb3dlcl9wYXJ0XSBhcmVcbiAgICAgIGxlc3MgdGhhbiBhbGwgdGhlIGtleXMgZnJvbSBbdXBwZXJfcGFydF0uICBPdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAgW2BPdmVybGFwcGluZ19rZXlfcmFuZ2VzXS5cblxuICAgICAgUnVudGltZSBpcyBPKGxvZyBuKSB3aGVyZSBuIGlzIHRoZSBzaXplIG9mIHRoZSBsYXJnZXIgaW5wdXQgbWFwLiAgVGhpcyBjYW4gYmVcbiAgICAgIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gW01hcC5tZXJnZV0gb3IgcmVwZWF0ZWQgW01hcC5hZGRdLlxuXG4gICAgICB7W1xuICAgICAgICBhc3NlcnQgKG1hdGNoIE1hcC5hcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgd2l0aFxuICAgICAgICAgIHwgYE9rIHdob2xlX21hcCAtPlxuICAgICAgICAgICAgTWFwLnRvX2FsaXN0IHdob2xlX21hcFxuICAgICAgICAgICAgPSBMaXN0LmFwcGVuZCAodG9fYWxpc3QgbG93ZXJfcGFydCkgKHRvX2FsaXN0IHVwcGVyX3BhcnQpXG4gICAgICAgICAgfCBgT3ZlcmxhcHBpbmdfa2V5X3JhbmdlcyAtPiB0cnVlKTtcbiAgICAgIF19ICopXG4gIHZhbCBhcHBlbmRcbiAgICA6ICBsb3dlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiB1cHBlcl9wYXJ0OignaywgJ3YsICdjbXApIHRcbiAgICAtPiBbIGBPayBvZiAoJ2ssICd2LCAnY21wKSB0IHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgXVxuXG4gICgqKiBbc3VicmFuZ2UgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXSByZXR1cm5zIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBlbnRyaWVzIGZyb21cbiAgICAgIFt0XSB3aG9zZSBrZXlzIGxpZSBpbnNpZGUgdGhlIGludGVydmFsIGluZGljYXRlZCBieSBbfmxvd2VyX2JvdW5kXSBhbmRcbiAgICAgIFt+dXBwZXJfYm91bmRdLiAgSWYgdGhpcyBpbnRlcnZhbCBpcyBlbXB0eSwgYW4gZW1wdHkgbWFwIGlzIHJldHVybmVkLlxuXG4gICAgICBSdW50aW1lIGlzIE8obSArIGxvZyBuKSwgd2hlcmUgbiBpcyB0aGUgc2l6ZSBvZiB0aGUgaW5wdXQgbWFwIGFuZCBtIGlzIHRoZSBzaXplIG9mXG4gICAgICB0aGUgb3V0cHV0IG1hcC4gIFRoZSBPKG0pIHRlcm0gaXMgZHVlIHRvIHRoZSBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAgb3V0cHV0IG1hcC4gKilcbiAgdmFsIHN1YnJhbmdlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGxvd2VyX2JvdW5kOidrIE1heWJlX2JvdW5kLnRcbiAgICAtPiB1cHBlcl9ib3VuZDonayBNYXliZV9ib3VuZC50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBbZm9sZF9yYW5nZV9pbmNsdXNpdmUgdCB+bWluIH5tYXggfmluaXQgfmZdIGZvbGRzIFtmXSAod2l0aCBpbml0aWFsIHZhbHVlIFt+aW5pdF0pXG4gICAgICBvdmVyIGFsbCBrZXlzIChhbmQgdGhlaXIgYXNzb2NpYXRlZCB2YWx1ZXMpIHRoYXQgYXJlIGluIHRoZSByYW5nZSBbW21pbiwgbWF4XV1cbiAgICAgIChpbmNsdXNpdmUpLiAgKilcbiAgdmFsIGZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IG1pbjona1xuICAgIC0+IG1heDona1xuICAgIC0+IGluaXQ6J2FcbiAgICAtPiBmOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYSAtPiAnYSlcbiAgICAtPiAnYVxuXG4gICgqKiBbcmFuZ2VfdG9fYWxpc3QgdCB+bWluIH5tYXhdIHJldHVybnMgYW4gYXNzb2NpYXRpdmUgbGlzdCBvZiB0aGUgZWxlbWVudHMgd2hvc2Uga2V5c1xuICAgICAgbGllIGluIFtbbWluLCBtYXhdXSAoaW5jbHVzaXZlKSwgd2l0aCB0aGUgc21hbGxlc3Qga2V5IGJlaW5nIGF0IHRoZSBoZWFkIG9mIHRoZVxuICAgICAgbGlzdC4gKilcbiAgdmFsIHJhbmdlX3RvX2FsaXN0IDogKCdrLCAndiwgJ2NtcCkgdCAtPiBtaW46J2sgLT4gbWF4OidrIC0+ICgnayAqICd2KSBsaXN0XG5cbiAgKCoqIFtjbG9zZXN0X2tleSB0IGRpciBrXSByZXR1cm5zIHRoZSBbKGtleSwgdmFsdWUpXSBwYWlyIGluIFt0XSB3aXRoIFtrZXldIGNsb3Nlc3QgdG9cbiAgICAgIFtrXSB0aGF0IHNhdGlzZmllcyB0aGUgZ2l2ZW4gaW5lcXVhbGl0eSBib3VuZC5cblxuICAgICAgRm9yIGV4YW1wbGUsIFtjbG9zZXN0X2tleSB0IGBMZXNzX3RoYW4ga10gd291bGQgYmUgdGhlIHBhaXIgd2l0aCB0aGUgY2xvc2VzdCBrZXkgdG9cbiAgICAgIFtrXSB3aGVyZSBba2V5IDwga10uXG5cbiAgICAgIFt0b19zZXF1ZW5jZV0gY2FuIGJlIHVzZWQgdG8gZ2V0IHRoZSBzYW1lIHJlc3VsdHMgYXMgW2Nsb3Nlc3Rfa2V5XS4gIEl0IGlzIGxlc3NcbiAgICAgIGVmZmljaWVudCBmb3IgaW5kaXZpZHVhbCBsb29rdXBzIGJ1dCBtb3JlIGVmZmljaWVudCBmb3IgZmluZGluZyBtYW55IGVsZW1lbnRzIHN0YXJ0aW5nXG4gICAgICBhdCBzb21lIHZhbHVlLiAqKVxuICB2YWwgY2xvc2VzdF9rZXlcbiAgICA6ICAoJ2ssICd2LCAnY21wKSB0XG4gICAgLT4gWyBgR3JlYXRlcl9vcl9lcXVhbF90byB8IGBHcmVhdGVyX3RoYW4gfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gXVxuICAgIC0+ICdrXG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gICgqKiBbbnRoIHQgbl0gZmluZHMgdGhlIChrZXksIHZhbHVlKSBwYWlyIG9mIHJhbmsgbiAoaS5lLiwgc3VjaCB0aGF0IHRoZXJlIGFyZSBleGFjdGx5IG5cbiAgICAgIGtleXMgc3RyaWN0bHkgbGVzcyB0aGFuIHRoZSBmb3VuZCBrZXkpLCBpZiBvbmUgZXhpc3RzLiAgTyhsb2cobGVuZ3RoIHQpICsgbikgdGltZS4gKilcbiAgdmFsIG50aCA6ICgnaywgJ3YsIF8pIHQgLT4gaW50IC0+ICgnayAqICd2KSBvcHRpb25cblxuICB2YWwgbnRoX2V4biA6ICgnaywgJ3YsIF8pIHQgLT4gaW50IC0+ICdrICogJ3ZcblxuICAoKiogW3JhbmsgdCBrXSBJZiBba10gaXMgaW4gW3RdLCByZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5cyBzdHJpY3RseSBsZXNzIHRoYW4gW2tdIGluXG4gICAgICBbdF0sIGFuZCBbTm9uZV0gb3RoZXJ3aXNlLiAqKVxuICB2YWwgcmFuayA6ICgnaywgJ3YsICdjbXApIHQgLT4gJ2sgLT4gaW50IG9wdGlvblxuXG5cblxuICAoKiogW3RvX3NlcXVlbmNlID9vcmRlciA/a2V5c19ncmVhdGVyX29yX2VxdWFsX3RvID9rZXlzX2xlc3Nfb3JfZXF1YWxfdG8gdF1cbiAgICAgIGdpdmVzIGEgc2VxdWVuY2Ugb2Yga2V5LXZhbHVlIHBhaXJzIGJldHdlZW4gW2tleXNfbGVzc19vcl9lcXVhbF90b10gYW5kXG4gICAgICBba2V5c19ncmVhdGVyX29yX2VxdWFsX3RvXSBpbmNsdXNpdmUsIHByZXNlbnRlZCBpbiBbb3JkZXJdLiAgSWZcbiAgICAgIFtrZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gPiBrZXlzX2xlc3Nfb3JfZXF1YWxfdG9dLCB0aGUgc2VxdWVuY2UgaXNcbiAgICAgIGVtcHR5LlxuXG4gICAgICBXaGVuIG5laXRoZXIgW2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b10gbm9yIFtrZXlzX2xlc3Nfb3JfZXF1YWxfdG9dIGFyZVxuICAgICAgcHJvdmlkZWQsIHRoZSBjb3N0IGlzIE8obG9nIG4pIHVwIGZyb250IGFuZCBhbW9ydGl6ZWQgTygxKSB0byBwcm9kdWNlXG4gICAgICBlYWNoIGVsZW1lbnQuIElmIGVpdGhlciBpcyBwcm92aWRlZCAoYW5kIGlzIHVzZWQgYnkgdGhlIG9yZGVyIHBhcmFtZXRlclxuICAgICAgcHJvdmlkZWQpLCB0aGVuIHRoZSB0aGUgY29zdCBpcyBPKG4pIHVwIGZyb250LCBhbmQgYW1vcnRpemVkIE8oMSkgdG9cbiAgICAgIHByb2R1Y2UgZWFjaCBlbGVtZW50LiAqKVxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZ19rZXkgKCoqIGRlZmF1bHQgKikgfCBgRGVjcmVhc2luZ19rZXkgXVxuICAgIC0+ID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG86J2tcbiAgICAtPiA/a2V5c19sZXNzX29yX2VxdWFsX3RvOidrXG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+ICgnayAqICd2KSBTZXF1ZW5jZS50XG5cbiAgKCoqIFtiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgd2hpY2ggZWx0XSByZXR1cm5zIHRoZSBbKGtleSwgdmFsdWUpXSBwYWlyIGluIFt0XVxuICAgICAgc3BlY2lmaWVkIGJ5IFtjb21wYXJlXSBhbmQgW3doaWNoXSwgaWYgb25lIGV4aXN0cy5cblxuICAgICAgW3RdIG11c3QgYmUgc29ydGVkIGluIGluY3JlYXNpbmcgb3JkZXIgYWNjb3JkaW5nIHRvIFtjb21wYXJlXSwgd2hlcmUgW2NvbXBhcmVdIGFuZFxuICAgICAgW2VsdF0gZGl2aWRlIFt0XSBpbnRvIHRocmVlIChwb3NzaWJseSBlbXB0eSkgc2VnbWVudHM6XG5cbiAgICAgIHt2XG4gICAgICAgIHwgIDwgZWx0ICB8ICA9IGVsdCAgfCAgPiBlbHQgIHxcbiAgICAgIHZ9XG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoXSByZXR1cm5zIGFuIGVsZW1lbnQgb24gdGhlIGJvdW5kYXJ5IG9mIHNlZ21lbnRzIGFzIHNwZWNpZmllZCBieVxuICAgICAgW3doaWNoXS4gIFNlZSB0aGUgZGlhZ3JhbSBiZWxvdyBuZXh0IHRvIHRoZSBbd2hpY2hdIHZhcmlhbnRzLlxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF0gZG9lcyBub3QgY2hlY2sgdGhhdCBbY29tcGFyZV0gb3JkZXJzIFt0XSwgYW5kIGJlaGF2aW9yIGlzXG4gICAgICB1bnNwZWNpZmllZCBpZiBbY29tcGFyZV0gZG9lc24ndCBvcmRlciBbdF0uICBCZWhhdmlvciBpcyBhbHNvIHVuc3BlY2lmaWVkIGlmXG4gICAgICBbY29tcGFyZV0gbXV0YXRlcyBbdF0uICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IGNvbXBhcmU6KGtleTonayAtPiBkYXRhOid2IC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IFsgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuICgqKiAgICAgICAge3YgfCA8IGVsdCBYIHwgICAgICAgICAgICAgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG8gKCoqICAgICB7diB8ICAgICAgPD0gZWx0ICAgICAgIFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBMYXN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8ICAgPSBlbHQgWCB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2VxdWFsX3RvICgqKiAgICAgICAgICAgICAgICAge3YgICAgICAgICAgIHwgWCA9IGVsdCAgIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvICgqKiB7diAgICAgICAgICAgfCBYICAgICAgID49IGVsdCAgICAgIHwgdn0gKilcbiAgICAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gKCoqICAgIHt2ICAgICAgICAgICAgICAgICAgICAgICB8IFggPiBlbHQgfCB2fSAqKVxuICAgICAgIF1cbiAgICAtPiAna2V5XG4gICAgLT4gKCdrICogJ3YpIG9wdGlvblxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiB3aGljaF0gdGFrZXMgYSBbc2VnbWVudF9vZl0gZnVuY3Rpb24gdGhhdFxuICAgICAgZGl2aWRlcyBbdF0gaW50byB0d28gKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCBzZWdtZW50X29mIGVsdCA9IGBMZWZ0IHwgc2VnbWVudF9vZiBlbHQgPSBgUmlnaHQgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSByZXR1cm5zIHRoZSBbKGtleSwgdmFsdWUpXSBwYWlyIG9uIHRoZSBib3VuZGFyeSBvZiB0aGVcbiAgICAgIHNlZ21lbnRzIGFzIHNwZWNpZmllZCBieSBbd2hpY2hdOiBbYExhc3Rfb25fbGVmdF0geWllbGRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlXG4gICAgICBsZWZ0IHNlZ21lbnQsIHdoaWxlIFtgRmlyc3Rfb25fcmlnaHRdIHlpZWxkcyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgcmlnaHQgc2VnbWVudC5cbiAgICAgIEl0IHJldHVybnMgW05vbmVdIGlmIHRoZSBzZWdtZW50IGlzIGVtcHR5LlxuXG4gICAgICBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRdIGRvZXMgbm90IGNoZWNrIHRoYXQgW3NlZ21lbnRfb2ZdIHNlZ21lbnRzIFt0XSBhcyBpbiB0aGVcbiAgICAgIGRpYWdyYW0sIGFuZCBiZWhhdmlvciBpcyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gZG9lc24ndCBzZWdtZW50IFt0XS4gIEJlaGF2aW9yXG4gICAgICBpcyBhbHNvIHVuc3BlY2lmaWVkIGlmIFtzZWdtZW50X29mXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdrLCAndiwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KGtleTonayAtPiBkYXRhOid2IC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBbIGBMYXN0X29uX2xlZnQgfCBgRmlyc3Rfb25fcmlnaHQgXVxuICAgIC0+ICgnayAqICd2KSBvcHRpb25cblxuICAoKiogW2JpbmFyeV9zZWFyY2hfc3VicmFuZ2VdIHRha2VzIGEgW2NvbXBhcmVdIGZ1bmN0aW9uIHRoYXQgZGl2aWRlcyBbdF0gaW50byB0aHJlZVxuICAgICAgKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50cyB3aXRoIHJlc3BlY3QgdG8gW2xvd2VyX2JvdW5kXSBhbmQgW3VwcGVyX2JvdW5kXTpcblxuICAgICAge3ZcbiAgICAgICAgfCBCZWxvd19sb3dlcl9ib3VuZCB8IEluX3JhbmdlIHwgQWJvdmVfdXBwZXJfYm91bmQgfFxuICAgICAgdn1cblxuICAgICAgYW5kIHJldHVybnMgYSBtYXAgb2YgdGhlIFtJbl9yYW5nZV0gc2VnbWVudC5cblxuICAgICAgUnVudGltZSBpcyBPKGxvZyBtICsgbikgd2hlcmUgW21dIGlzIHRoZSBsZW5ndGggb2YgdGhlIGlucHV0IG1hcCBhbmQgW25dIGlzIHRoZVxuICAgICAgbGVuZ3RoIG9mIHRoZSBvdXRwdXQuIFRoZSBsaW5lYXIgdGVybSBpbiBbbl0gaXMgdG8gY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBvdXRwdXQuXG5cbiAgICAgIEJlaGF2aW9yIGlzIHVuZGVmaW5lZCBpZiBbY29tcGFyZV0gZG9lcyBub3Qgc2VnbWVudCBbdF0gYXMgc2hvd24gYWJvdmUsIG9yIGlmXG4gICAgICBbY29tcGFyZV0gbXV0YXRlcyBpdHMgaW5wdXRzLiAqKVxuICB2YWwgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZVxuICAgIDogICgnaywgJ3YsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOihrZXk6J2sgLT4gZGF0YTondiAtPiAnYm91bmQgLT4gaW50KVxuICAgIC0+IGxvd2VyX2JvdW5kOidib3VuZCBNYXliZV9ib3VuZC50XG4gICAgLT4gdXBwZXJfYm91bmQ6J2JvdW5kIE1heWJlX2JvdW5kLnRcbiAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgKCoqIFtNXSBpcyBtZWFudCB0byBiZSB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggT0NhbWwgYXBwbGljYXRpdmUgZnVuY3RvciB0eXBlczpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfdG9faW50X21hcCA9IGludCBNYXAuTShTdHJpbmcpLnRcbiAgICAgIF19XG5cbiAgICAgIHdoaWNoIHN0YW5kcyBmb3I6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3RvX2ludF9tYXAgPSAoU3RyaW5nLnQsIGludCwgU3RyaW5nLmNvbXBhcmF0b3Jfd2l0bmVzcykgTWFwLnRcbiAgICAgIF19XG5cbiAgICAgIFRoZSBwb2ludCBpcyB0aGF0IFtpbnQgTWFwLk0oU3RyaW5nKS50XSBzdXBwb3J0cyBkZXJpdmluZywgd2hlcmVhcyB0aGUgc2Vjb25kIHN5bnRheFxuICAgICAgZG9lc24ndCAoYmVjYXVzZSB0aGVyZSBpcyBubyBzdWNoIHRoaW5nIGFzLCBzYXksIFtTdHJpbmcuc2V4cF9vZl9jb21wYXJhdG9yX3dpdG5lc3NdXG4gICAgICAtLSBpbnN0ZWFkIHlvdSB3b3VsZCB3YW50IHRvIHBhc3MgdGhlIGNvbXBhcmF0b3IgZGlyZWN0bHkpLlxuXG4gICAgICBJbiBhZGRpdGlvbiwgd2hlbiB1c2luZyBbQEBkZXJpdmluZ10sIHRoZSByZXF1aXJlbWVudHMgb24gdGhlIGtleSBtb2R1bGUgYXJlIG9ubHlcbiAgICAgIHRob3NlIG5lZWRlZCB0byBzYXRpc2Z5IHdoYXQgeW91IGFyZSB0cnlpbmcgdG8gZGVyaXZlIG9uIHRoZSBtYXAgaXRzZWxmLiBTYXkgeW91XG4gICAgICB3cml0ZTpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSB0ID0gaW50IE1hcC5NKFgpLnQgW0BAZGVyaXZpbmcgaGFzaF1cbiAgICAgIF19XG5cbiAgICAgIHRoZW4gdGhpcyB3aWxsIGJlIHdlbGwgdHlwZWQgZXhhY3RseSBpZiBbWF0gY29udGFpbnMgYXQgbGVhc3Q6XG4gICAgICAtIGEgdHlwZSBbdF0gd2l0aCBubyBwYXJhbWV0ZXJzXG4gICAgICAtIGEgY29tcGFyYXRvciB3aXRuZXNzXG4gICAgICAtIGEgW2hhc2hfZm9sZF90XSBmdW5jdGlvbiB3aXRoIHRoZSByaWdodCB0eXBlICopXG4gIG1vZHVsZSBNIChLIDogc2lnXG4gICAgICB0eXBlIHRcbiAgICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gICAgZW5kKSA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgZW5kXG5cbiAgaW5jbHVkZSBGb3JfZGVyaXZpbmcgd2l0aCB0eXBlICgna2V5LCAndmFsdWUsICdjbXApIHQgOj0gKCdrZXksICd2YWx1ZSwgJ2NtcCkgdFxuXG4gICgqKiBbVXNpbmdfY29tcGFyYXRvcl0gaXMgYSBzaW1pbGFyIGludGVyZmFjZSBhcyB0aGUgdG9wbGV2ZWwgb2YgW01hcF0sIGV4Y2VwdCB0aGVcbiAgICAgIGZ1bmN0aW9ucyB0YWtlIGEgW35jb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XSwgd2hlcmVhcyB0aGUgZnVuY3Rpb25zIGF0IHRoZVxuICAgICAgdG9wbGV2ZWwgb2YgW01hcF0gdGFrZSBhIFsoJ2ssICdjbXApIGNvbXBhcmF0b3JdLiAqKVxuICBtb2R1bGUgVXNpbmdfY29tcGFyYXRvciA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICgnaywgKyd2LCAnY21wKSB0ID0gKCdrLCAndiwgJ2NtcCkgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9vZl1cblxuICAgIHZhbCBzZXhwX29mX3RcbiAgICAgIDogICgnayAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ3YgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdjbXAgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgIDogIGNvbXBhcmF0b3I6KCdrLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgIC0+IChTZXhwLnQgLT4gJ2spXG4gICAgICAtPiAoU2V4cC50IC0+ICd2KVxuICAgICAgLT4gU2V4cC50XG4gICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgICBtb2R1bGUgVHJlZSA6IHNpZ1xuICAgICAgdHlwZSAoKydrLCArJ3YsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICAgIHZhbCBzZXhwX29mX3RcbiAgICAgICAgOiAgKCdrIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCd2IC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdjbXAgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG4gICAgICAgIC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgICBbQEBAZW5kXVxuXG4gICAgICB2YWwgdF9vZl9zZXhwX2RpcmVjdFxuICAgICAgICA6ICBjb21wYXJhdG9yOignaywgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAgIC0+IChTZXhwLnQgLT4gJ2spXG4gICAgICAgIC0+IChTZXhwLnQgLT4gJ3YpXG4gICAgICAgIC0+IFNleHAudFxuICAgICAgICAtPiAoJ2ssICd2LCAnY21wKSB0XG5cbiAgICAgIGluY2x1ZGVcbiAgICAgICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yXG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgdCA6PSAoJ2EsICdiLCAnYykgdFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIHRcblxuICAgICAgdmFsIGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gOiAoXywgXywgXykgdFxuXG4gICAgICAoKiogW0J1aWxkX2luY3JlYXNpbmddIGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIG1hcCBpbmNyZW1lbnRhbGx5IGZyb20gYVxuICAgICAgICAgIHNlcXVlbmNlIHRoYXQgaXMga25vd24gdG8gYmUgaW5jcmVhc2luZy5cblxuICAgICAgICAgIFRoZSB0b3RhbCB0aW1lIGNvbXBsZXhpdHkgb2YgY29uc3RydWN0aW5nIGEgbWFwIHRoaXMgd2F5IGlzIE8obiksIHdoaWNoIGlzIG1vcmVcbiAgICAgICAgICBlZmZpY2llbnQgdGhhbiB1c2luZyBbTWFwLmFkZF0gYnkgYSBsb2dhcml0aG1pYyBmYWN0b3IuXG5cbiAgICAgICAgICBUaGlzIGludGVyZmFjZSBjYW4gYmUgdGhvdWdodCBvZiBhcyBhIGR1YWwgb2YgW3RvX3NlcXVlbmNlXSwgYnV0IHdlIGRvbid0IGhhdmVcbiAgICAgICAgICBhbiBlcXVhbGx5IG5lYXQgaWRpb20gZm9yIHRoZSBkdWFscyBvZiBzZXF1ZW5jZXMgKFtvZl9zZXF1ZW5jZV0gaXMgbXVjaCBsZXNzXG4gICAgICAgICAgZ2VuZXJhbCBiZWNhdXNlIGl0IGRvZXMgbm90IGFsbG93IHRoZSBzZXF1ZW5jZSB0byBiZSBwcm9kdWNlZCBhc3luY2hyb25vdXNseSkuICopXG4gICAgICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA6IHNpZ1xuICAgICAgICB0eXBlICgnYSwgJ2IsICdjKSB0cmVlIDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICAgIHR5cGUgKCdrLCAndiwgJ3cpIHRcblxuICAgICAgICB2YWwgZW1wdHkgOiAoJ2ssICd2LCAndykgdFxuXG4gICAgICAgICgqKiBUaW1lIGNvbXBsZXhpdHkgb2YgW2FkZF9leG5dIGlzIGFtb3J0aXplZCBjb25zdGFudC10aW1lIChpZiBbdF0gaXMgdXNlZFxuICAgICAgICAgICAgbGluZWFybHkpLCB3aXRoIGEgd29yc3QtY2FzZSBPKGxvZyhuKSkgdGltZS4gKilcbiAgICAgICAgdmFsIGFkZF9leG5cbiAgICAgICAgICA6ICAoJ2ssICd2LCAndykgdFxuICAgICAgICAgIC0+IGNvbXBhcmF0b3I6KCdrLCAndykgQ29tcGFyYXRvci50XG4gICAgICAgICAgLT4ga2V5OidrXG4gICAgICAgICAgLT4gZGF0YTondlxuICAgICAgICAgIC0+ICgnaywgJ3YsICd3KSB0XG5cbiAgICAgICAgKCoqIFRpbWUgY29tcGxleGl0eSBpcyBPKGxvZyhuKSkuICopXG4gICAgICAgIHZhbCB0b190cmVlIDogKCdrLCAndiwgJ3cpIHQgLT4gKCdrLCAndiwgJ3cpIHRyZWVcbiAgICAgIGVuZFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzM1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvclxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSB0IDo9ICgnYSwgJ2IsICdjKSB0XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MpIHRyZWUgOj0gKCdhLCAnYiwgJ2MpIFRyZWUudFxuXG4gICAgdmFsIGNvbXBhcmF0b3IgOiAoJ2EsIF8sICdjbXApIHQgLT4gKCdhLCAnY21wKSBDb21wYXJhdG9yLnRcblxuICAgIHZhbCBoYXNoX2ZvbGRfZGlyZWN0XG4gICAgICA6ICAnayBIYXNoLmZvbGRlclxuICAgICAgLT4gJ3YgSGFzaC5mb2xkZXJcbiAgICAgIC0+ICgnaywgJ3YsICdjbXApIHQgSGFzaC5mb2xkZXJcblxuICAgICgqKiBUbyBnZXQgYXJvdW5kIHRoZSB2YWx1ZSByZXN0cmljdGlvbiwgYXBwbHkgdGhlIGZ1bmN0b3IgYW5kIGluY2x1ZGUgaXQuIFlvdVxuICAgICAgICBjYW4gc2VlIGFuIGV4YW1wbGUgb2YgdGhpcyBpbiB0aGUgW1BvbHldIHN1Ym1vZHVsZSBiZWxvdy4gKilcbiAgICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoSyA6IENvbXBhcmF0b3IuUzEpIDogc2lnXG4gICAgICB2YWwgZW1wdHkgOiAoJ2EgSy50LCAndiwgSy5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbiAgICBlbmRcbiAgZW5kXG5cbiAgKCoqIEEgcG9seW1vcnBoaWMgTWFwLiAqKVxuICBtb2R1bGUgUG9seSA6XG4gICAgU19wb2x5XG4gICAgd2l0aCB0eXBlICgna2V5LCArJ3ZhbHVlKSB0ID0gKCdrZXksICd2YWx1ZSwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgICBhbmQgdHlwZSAoJ2tleSwgKyd2YWx1ZSkgdHJlZSA9XG4gICAgICAgICAgICgna2V5LCAndmFsdWUsIENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3MpIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG4gICAgIGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9IENvbXBhcmF0b3IuUG9seS5jb21wYXJhdG9yX3dpdG5lc3NcblxuICAoKiogQ3JlYXRlIGEgbWFwIGZyb20gYSB0cmVlIHVzaW5nIHRoZSBnaXZlbiBjb21wYXJhdG9yLiAqKVxuICB2YWwgb2ZfdHJlZVxuICAgIDogICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+ICgnaywgJ3YsICdjbXApIFVzaW5nX2NvbXBhcmF0b3IuVHJlZS50XG4gICAgLT4gKCdrLCAndiwgJ2NtcCkgdFxuXG4gICgqKiBFeHRyYWN0IGEgdHJlZSBmcm9tIGEgbWFwLiAqKVxuICB2YWwgdG9fdHJlZSA6ICgnaywgJ3YsICdjbXApIHQgLT4gKCdrLCAndiwgJ2NtcCkgVXNpbmdfY29tcGFyYXRvci5UcmVlLnRcblxuXG4gICgqKiB7MiBNb2R1bGVzIGFuZCBtb2R1bGUgdHlwZXMgZm9yIGV4dGVuZGluZyBbTWFwXX1cblxuICAgICAgRm9yIHVzZSBpbiBleHRlbnNpb25zIG9mIEJhc2UsIGxpa2UgW0NvcmVdLiAqKVxuXG4gIG1vZHVsZSBXaXRoX2NvbXBhcmF0b3IgPSBXaXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlID0gV2l0aF9maXJzdF9jbGFzc19tb2R1bGVcbiAgbW9kdWxlIFdpdGhvdXRfY29tcGFyYXRvciA9IFdpdGhvdXRfY29tcGFyYXRvclxuXG4gIG1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IEZvcl9kZXJpdmluZ1xuICBtb2R1bGUgdHlwZSBTX3BvbHkgPSBTX3BvbHlcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMSA9IEFjY2Vzc29yczFcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMiA9IEFjY2Vzc29yczJcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzMyA9IEFjY2Vzc29yczNcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3IgPSBBY2Nlc3NvcnMzX3dpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgdHlwZSBBY2Nlc3NvcnNfZ2VuZXJpYyA9IEFjY2Vzc29yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMSA9IENyZWF0b3JzMVxuICBtb2R1bGUgdHlwZSBDcmVhdG9yczIgPSBDcmVhdG9yczJcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMzX3dpdGhfY29tcGFyYXRvciA9IENyZWF0b3JzM193aXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczEgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMVxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMiA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczNfd2l0aF9jb21wYXJhdG9yID1cbiAgICBDcmVhdG9yc19hbmRfYWNjZXNzb3JzM193aXRoX2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWMgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2dlbmVyaWNcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5vcGVuISBUXG5cbm1vZHVsZSB0eXBlIEVsdF9wbGFpbiA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBNYXBfaW50Zi5XaXRob3V0X2NvbXBhcmF0b3Jcbm1vZHVsZSBXaXRoX2NvbXBhcmF0b3IgPSBNYXBfaW50Zi5XaXRoX2NvbXBhcmF0b3Jcbm1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IE1hcF9pbnRmLldpdGhfZmlyc3RfY2xhc3NfbW9kdWxlXG5tb2R1bGUgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudCA9IFNlcXVlbmNlLk1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50XG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIGluY2x1ZGUgQ29udGFpbmVyLkdlbmVyaWNfcGhhbnRvbVxuXG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgKCoqIFRoZSBbb3B0aW9uc10gdHlwZSBpcyB1c2VkIHRvIG1ha2UgW0FjY2Vzc29yc19nZW5lcmljXSBmbGV4aWJsZSBhcyB0byB3aGV0aGVyIGFcbiAgICAgIGNvbXBhcmF0b3IgaXMgcmVxdWlyZWQgdG8gYmUgcGFzc2VkIHRvIGNlcnRhaW4gZnVuY3Rpb25zLiAqKVxuICB0eXBlICgnYSwgJ2NtcCwgJ3opIG9wdGlvbnNcblxuICB0eXBlICdjbXAgY21wXG5cbiAgdmFsIGludmFyaWFudHMgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiBib29sKSBvcHRpb25zXG5cbiAgKCoqIG92ZXJyaWRlIFtDb250YWluZXJdJ3MgW21lbV0gKilcbiAgdmFsIG1lbSA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiBib29sKSBvcHRpb25zXG5cbiAgdmFsIGFkZCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIHVuaW9uIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgaW50ZXIgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCBkaWZmIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBzeW1tZXRyaWNfZGlmZlxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhIGVsdCwgJ2EgZWx0KSBFaXRoZXIudCBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBpbnQpIG9wdGlvbnNcbiAgdmFsIGVxdWFsIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2wpIG9wdGlvbnNcbiAgdmFsIGlzX3N1YnNldCA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSB0IC0+IG9mXzooJ2EsICdjbXApIHQgLT4gYm9vbCkgb3B0aW9uc1xuICB2YWwgYXJlX2Rpc2pvaW50IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2wpIG9wdGlvbnNcblxuICB0eXBlICgnYSwgJ2NtcCkgbmFtZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB2YWwgaXNfc3Vic2V0XG4gICAgICA6ICgnYSwgJ2NtcCwgKCdhLCAnY21wKSBuYW1lZCAtPiBvZl86KCdhLCAnY21wKSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnQpIG9wdGlvbnNcblxuICAgIHZhbCBlcXVhbFxuICAgICAgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgbmFtZWQgLT4gKCdhLCAnY21wKSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnQpIG9wdGlvbnNcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidiXG4gICAgLT4gZjooJ2IgLT4gJ2EgZWx0IC0+ICgnYiwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2IgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCBfKSB0IC0+IGluaXQ6J2IgLT4gZjooJ2EgZWx0IC0+ICdiIC0+ICdiKSAtPiAnYlxuXG4gIHZhbCBpdGVyMlxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gKCdhLCAnY21wKSB0XG4gICAgICAtPiBmOihbIGBMZWZ0IG9mICdhIGVsdCB8IGBSaWdodCBvZiAnYSBlbHQgfCBgQm90aCBvZiAnYSBlbHQgKiAnYSBlbHQgXSAtPiB1bml0KVxuICAgICAgLT4gdW5pdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyIDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuXG4gIHZhbCBwYXJ0aXRpb25fdGZcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCAoJ2EsICdjbXApIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCAqICgnYSwgJ2NtcCkgdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZWxlbWVudHMgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IGxpc3RcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0IG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0XG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhIGVsdFxuICB2YWwgY2hvb3NlIDogKCdhLCBfKSB0IC0+ICdhIGVsdCBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiAoJ2EsIF8pIHQgLT4gJ2EgZWx0XG5cbiAgdmFsIHNwbGl0XG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0IC0+ICdhIGVsdCAtPiAoJ2EsICdjbXApIHQgKiAnYSBlbHQgb3B0aW9uICogKCdhLCAnY21wKSB0IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBncm91cF9ieVxuICAgIDogKCAnYVxuICAgICAgLCAnY21wXG4gICAgICAsICgnYSwgJ2NtcCkgdCAtPiBlcXVpdjooJ2EgZWx0IC0+ICdhIGVsdCAtPiBib29sKSAtPiAoJ2EsICdjbXApIHQgbGlzdCApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgZmluZF9leG4gOiAoJ2EsIF8pIHQgLT4gZjooJ2EgZWx0IC0+IGJvb2wpIC0+ICdhIGVsdFxuICB2YWwgbnRoIDogKCdhLCBfKSB0IC0+IGludCAtPiAnYSBlbHQgb3B0aW9uXG4gIHZhbCByZW1vdmVfaW5kZXggOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCB0b190cmVlIDogKCdhLCAnY21wKSB0IC0+ICgnYSBlbHQsICdjbXApIHRyZWVcblxuICB2YWwgdG9fc2VxdWVuY2VcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhIGVsdFxuICAgICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgIC0+ICdhIGVsdCBTZXF1ZW5jZS50IClcbiAgICAgICAgb3B0aW9uc1xuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0XG4gICAgICAtPiBjb21wYXJlOignYSBlbHQgLT4gJ2tleSAtPiBpbnQpXG4gICAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAgIC0+ICdrZXlcbiAgICAgIC0+ICdhIGVsdCBvcHRpb24gKVxuICAgICAgICBvcHRpb25zXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAoICdhXG4gICAgICAsICdjbXBcbiAgICAgICwgKCdhLCAnY21wKSB0XG4gICAgICAtPiBzZWdtZW50X29mOignYSBlbHQgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgICAgLT4gJ2EgZWx0IG9wdGlvbiApXG4gICAgICAgIG9wdGlvbnNcblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICggJ2FcbiAgICAgICwgJ2NtcFxuICAgICAgLCA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhIGVsdFxuICAgICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2EgZWx0XG4gICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgLT4gKCdhIGVsdCwgJ2EgZWx0KSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudCApXG4gICAgICAgIG9wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMwID0gc2lnXG4gIGluY2x1ZGUgQ29udGFpbmVyLlMwXG5cbiAgdHlwZSB0cmVlXG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGludmFyaWFudHMgOiB0IC0+IGJvb2xcbiAgdmFsIG1lbSA6IHQgLT4gZWx0IC0+IGJvb2xcbiAgdmFsIGFkZCA6IHQgLT4gZWx0IC0+IHRcbiAgdmFsIHJlbW92ZSA6IHQgLT4gZWx0IC0+IHRcbiAgdmFsIHVuaW9uIDogdCAtPiB0IC0+IHRcbiAgdmFsIGludGVyIDogdCAtPiB0IC0+IHRcbiAgdmFsIGRpZmYgOiB0IC0+IHQgLT4gdFxuICB2YWwgc3ltbWV0cmljX2RpZmYgOiB0IC0+IHQgLT4gKGVsdCwgZWx0KSBFaXRoZXIudCBTZXF1ZW5jZS50XG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6IHQgLT4gdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogdCAtPiB0IC0+IGJvb2xcbiAgdmFsIGlzX3N1YnNldCA6IHQgLT4gb2ZfOnQgLT4gYm9vbFxuICB2YWwgYXJlX2Rpc2pvaW50IDogdCAtPiB0IC0+IGJvb2xcblxuICB0eXBlIG5hbWVkXG5cbiAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgdmFsIGlzX3N1YnNldCA6IG5hbWVkIC0+IG9mXzpuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgICB2YWwgZXF1YWwgOiBuYW1lZCAtPiBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICB0XG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+IGVsdCAtPiAoJ2IsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdiIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6IHQgLT4gaW5pdDonYiAtPiBmOihlbHQgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgdFxuICAgIC0+IHRcbiAgICAtPiBmOihbIGBMZWZ0IG9mIGVsdCB8IGBSaWdodCBvZiBlbHQgfCBgQm90aCBvZiBlbHQgKiBlbHQgXSAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gdFxuICB2YWwgcGFydGl0aW9uX3RmIDogdCAtPiBmOihlbHQgLT4gYm9vbCkgLT4gdCAqIHRcbiAgdmFsIGVsZW1lbnRzIDogdCAtPiBlbHQgbGlzdFxuICB2YWwgbWluX2VsdCA6IHQgLT4gZWx0IG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiB0IC0+IGVsdFxuICB2YWwgbWF4X2VsdCA6IHQgLT4gZWx0IG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiB0IC0+IGVsdFxuICB2YWwgY2hvb3NlIDogdCAtPiBlbHQgb3B0aW9uXG4gIHZhbCBjaG9vc2VfZXhuIDogdCAtPiBlbHRcbiAgdmFsIHNwbGl0IDogdCAtPiBlbHQgLT4gdCAqIGVsdCBvcHRpb24gKiB0XG4gIHZhbCBncm91cF9ieSA6IHQgLT4gZXF1aXY6KGVsdCAtPiBlbHQgLT4gYm9vbCkgLT4gdCBsaXN0XG4gIHZhbCBmaW5kX2V4biA6IHQgLT4gZjooZWx0IC0+IGJvb2wpIC0+IGVsdFxuICB2YWwgbnRoIDogdCAtPiBpbnQgLT4gZWx0IG9wdGlvblxuICB2YWwgcmVtb3ZlX2luZGV4IDogdCAtPiBpbnQgLT4gdFxuICB2YWwgdG9fdHJlZSA6IHQgLT4gdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOmVsdFxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOmVsdFxuICAgIC0+IHRcbiAgICAtPiBlbHQgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgdFxuICAgIC0+IGNvbXBhcmU6KGVsdCAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gZWx0IG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogIHRcbiAgICAtPiBzZWdtZW50X29mOihlbHQgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiBlbHQgb3B0aW9uXG5cbiAgdmFsIG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86ZWx0XG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86ZWx0XG4gICAgLT4gdFxuICAgIC0+IHRcbiAgICAtPiAoZWx0LCBlbHQpIE1lcmdlX3RvX3NlcXVlbmNlX2VsZW1lbnQudCBTZXF1ZW5jZS50XG5lbmRcblxubW9kdWxlIHR5cGUgQWNjZXNzb3JzMSA9IHNpZ1xuICBpbmNsdWRlIENvbnRhaW5lci5TMVxuXG4gIHR5cGUgJ2EgdHJlZVxuICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIHZhbCBpbnZhcmlhbnRzIDogXyB0IC0+IGJvb2xcbiAgdmFsIG1lbSA6ICdhIHQgLT4gJ2EgLT4gYm9vbFxuICB2YWwgYWRkIDogJ2EgdCAtPiAnYSAtPiAnYSB0XG4gIHZhbCByZW1vdmUgOiAnYSB0IC0+ICdhIC0+ICdhIHRcbiAgdmFsIHVuaW9uIDogJ2EgdCAtPiAnYSB0IC0+ICdhIHRcbiAgdmFsIGludGVyIDogJ2EgdCAtPiAnYSB0IC0+ICdhIHRcbiAgdmFsIGRpZmYgOiAnYSB0IC0+ICdhIHQgLT4gJ2EgdFxuICB2YWwgc3ltbWV0cmljX2RpZmYgOiAnYSB0IC0+ICdhIHQgLT4gKCdhLCAnYSkgRWl0aGVyLnQgU2VxdWVuY2UudFxuICB2YWwgY29tcGFyZV9kaXJlY3QgOiAnYSB0IC0+ICdhIHQgLT4gaW50XG4gIHZhbCBlcXVhbCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG4gIHZhbCBpc19zdWJzZXQgOiAnYSB0IC0+IG9mXzonYSB0IC0+IGJvb2xcbiAgdmFsIGFyZV9kaXNqb2ludCA6ICdhIHQgLT4gJ2EgdCAtPiBib29sXG5cbiAgdHlwZSAnYSBuYW1lZFxuXG4gIG1vZHVsZSBOYW1lZCA6IHNpZ1xuICAgIHZhbCBpc19zdWJzZXQgOiAnYSBuYW1lZCAtPiBvZl86J2EgbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50XG4gICAgdmFsIGVxdWFsIDogJ2EgbmFtZWQgLT4gJ2EgbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50XG4gIGVuZFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgJ2EgdFxuICAgIC0+IGluaXQ6J2JcbiAgICAtPiBmOignYiAtPiAnYSAtPiAoJ2IsICdmaW5hbCkgQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AudClcbiAgICAtPiBmaW5pc2g6KCdiIC0+ICdmaW5hbClcbiAgICAtPiAnZmluYWxcblxuICB2YWwgZm9sZF9yaWdodCA6ICdhIHQgLT4gaW5pdDonYiAtPiBmOignYSAtPiAnYiAtPiAnYikgLT4gJ2JcblxuICB2YWwgaXRlcjJcbiAgICA6ICAnYSB0XG4gICAgLT4gJ2EgdFxuICAgIC0+IGY6KFsgYExlZnQgb2YgJ2EgfCBgUmlnaHQgb2YgJ2EgfCBgQm90aCBvZiAnYSAqICdhIF0gLT4gdW5pdClcbiAgICAtPiB1bml0XG5cbiAgdmFsIGZpbHRlciA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2EgdFxuICB2YWwgcGFydGl0aW9uX3RmIDogJ2EgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYSB0ICogJ2EgdFxuICB2YWwgZWxlbWVudHMgOiAnYSB0IC0+ICdhIGxpc3RcbiAgdmFsIG1pbl9lbHQgOiAnYSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWluX2VsdF9leG4gOiAnYSB0IC0+ICdhXG4gIHZhbCBtYXhfZWx0IDogJ2EgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogJ2EgdCAtPiAnYVxuICB2YWwgY2hvb3NlIDogJ2EgdCAtPiAnYSBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiAnYSB0IC0+ICdhXG4gIHZhbCBzcGxpdCA6ICdhIHQgLT4gJ2EgLT4gJ2EgdCAqICdhIG9wdGlvbiAqICdhIHRcbiAgdmFsIGdyb3VwX2J5IDogJ2EgdCAtPiBlcXVpdjooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCBsaXN0XG4gIHZhbCBmaW5kX2V4biA6ICdhIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gJ2FcbiAgdmFsIG50aCA6ICdhIHQgLT4gaW50IC0+ICdhIG9wdGlvblxuICB2YWwgcmVtb3ZlX2luZGV4IDogJ2EgdCAtPiBpbnQgLT4gJ2EgdFxuICB2YWwgdG9fdHJlZSA6ICdhIHQgLT4gJ2EgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAnYSB0XG4gICAgLT4gJ2EgU2VxdWVuY2UudFxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoXG4gICAgOiAgJ2EgdFxuICAgIC0+IGNvbXBhcmU6KCdhIC0+ICdrZXkgLT4gaW50KVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9rZXkudFxuICAgIC0+ICdrZXlcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWRcbiAgICA6ICAnYSB0XG4gICAgLT4gc2VnbWVudF9vZjooJ2EgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gJ2EgdFxuICAgIC0+ICdhIHRcbiAgICAtPiAoJ2EsICdhKSBNZXJnZV90b19zZXF1ZW5jZV9lbGVtZW50LnQgU2VxdWVuY2UudFxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29yczIgPSBzaWdcbiAgaW5jbHVkZSBDb250YWluZXIuUzFfcGhhbnRvbV9pbnZhcmlhbnRcblxuICB0eXBlICgnYSwgJ2NtcCkgdHJlZVxuXG4gIHZhbCBpbnZhcmlhbnRzIDogKF8sIF8pIHQgLT4gYm9vbFxuICB2YWwgbWVtIDogKCdhLCBfKSB0IC0+ICdhIC0+IGJvb2xcbiAgdmFsIGFkZCA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHJlbW92ZSA6ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHVuaW9uIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIGludGVyIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIGRpZmYgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgc3ltbWV0cmljX2RpZmYgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2EpIEVpdGhlci50IFNlcXVlbmNlLnRcbiAgdmFsIGNvbXBhcmVfZGlyZWN0IDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBpbnRcbiAgdmFsIGVxdWFsIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXApIHQgLT4gb2ZfOignYSwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBhcmVfZGlzam9pbnQgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICB0eXBlICgnYSwgJ2NtcCkgbmFtZWRcblxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB2YWwgaXNfc3Vic2V0IDogKCdhLCAnY21wKSBuYW1lZCAtPiBvZl86KCdhLCAnY21wKSBuYW1lZCAtPiB1bml0IE9yX2Vycm9yLnRcbiAgICB2YWwgZXF1YWwgOiAoJ2EsICdjbXApIG5hbWVkIC0+ICgnYSwgJ2NtcCkgbmFtZWQgLT4gdW5pdCBPcl9lcnJvci50XG4gIGVuZFxuXG4gIHZhbCBmb2xkX3VudGlsXG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYlxuICAgIC0+IGY6KCdiIC0+ICdhIC0+ICgnYiwgJ2ZpbmFsKSBDb250YWluZXIuQ29udGludWVfb3Jfc3RvcC50KVxuICAgIC0+IGZpbmlzaDooJ2IgLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCBfKSB0IC0+IGluaXQ6J2IgLT4gZjooJ2EgLT4gJ2IgLT4gJ2IpIC0+ICdiXG5cbiAgdmFsIGl0ZXIyXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZjooWyBgTGVmdCBvZiAnYSB8IGBSaWdodCBvZiAnYSB8IGBCb3RoIG9mICdhICogJ2EgXSAtPiB1bml0KVxuICAgIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgcGFydGl0aW9uX3RmIDogKCdhLCAnY21wKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCAqICgnYSwgJ2NtcCkgdFxuICB2YWwgZWxlbWVudHMgOiAoJ2EsIF8pIHQgLT4gJ2EgbGlzdFxuICB2YWwgbWluX2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1pbl9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG4gIHZhbCBtYXhfZWx0IDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuICB2YWwgbWF4X2VsdF9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcbiAgdmFsIGNob29zZSA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIGNob29zZV9leG4gOiAoJ2EsIF8pIHQgLT4gJ2FcbiAgdmFsIHNwbGl0IDogKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdCAqICdhIG9wdGlvbiAqICgnYSwgJ2NtcCkgdFxuICB2YWwgZ3JvdXBfYnkgOiAoJ2EsICdjbXApIHQgLT4gZXF1aXY6KCdhIC0+ICdhIC0+IGJvb2wpIC0+ICgnYSwgJ2NtcCkgdCBsaXN0XG4gIHZhbCBmaW5kX2V4biA6ICgnYSwgXykgdCAtPiBmOignYSAtPiBib29sKSAtPiAnYVxuICB2YWwgbnRoIDogKCdhLCBfKSB0IC0+IGludCAtPiAnYSBvcHRpb25cbiAgdmFsIHJlbW92ZV9pbmRleCA6ICgnYSwgJ2NtcCkgdCAtPiBpbnQgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCB0b190cmVlIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdHJlZVxuXG4gIHZhbCB0b19zZXF1ZW5jZVxuICAgIDogID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOignYSAtPiAna2V5IC0+IGludClcbiAgICAtPiBCaW5hcnlfc2VhcmNoYWJsZS5XaGljaF90YXJnZXRfYnlfa2V5LnRcbiAgICAtPiAna2V5XG4gICAgLT4gJ2Egb3B0aW9uXG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkXG4gICAgOiAgKCdhLCAnY21wKSB0XG4gICAgLT4gc2VnbWVudF9vZjooJ2EgLT4gWyBgTGVmdCB8IGBSaWdodCBdKVxuICAgIC0+IEJpbmFyeV9zZWFyY2hhYmxlLldoaWNoX3RhcmdldF9ieV9zZWdtZW50LnRcbiAgICAtPiAnYSBvcHRpb25cblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYSkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBBY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICBpbmNsdWRlIENvbnRhaW5lci5TMV9waGFudG9tX2ludmFyaWFudFxuXG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIGludmFyaWFudHMgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCAtPiBib29sXG4gIHZhbCBtZW0gOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiBib29sXG4gIHZhbCBhZGQgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICgnYSwgJ2NtcCkgdCAtPiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHJlbW92ZSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gKCdhLCAnY21wKSB0IC0+ICdhIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCB1bmlvblxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgaW50ZXJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIGRpZmZcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIHN5bW1ldHJpY19kaWZmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICgnYSwgJ2EpIEVpdGhlci50IFNlcXVlbmNlLnRcblxuICB2YWwgY29tcGFyZV9kaXJlY3RcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gaW50XG5cbiAgdmFsIGVxdWFsIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICB2YWwgaXNfc3Vic2V0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IG9mXzooJ2EsICdjbXApIHRcbiAgICAtPiBib29sXG5cbiAgdmFsIGFyZV9kaXNqb2ludFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBib29sXG5cbiAgdHlwZSAoJ2EsICdjbXApIG5hbWVkXG5cbiAgbW9kdWxlIE5hbWVkIDogc2lnXG4gICAgdmFsIGlzX3N1YnNldFxuICAgICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgLT4gKCdhLCAnY21wKSBuYW1lZFxuICAgICAgLT4gb2ZfOignYSwgJ2NtcCkgbmFtZWRcbiAgICAgIC0+IHVuaXQgT3JfZXJyb3IudFxuXG4gICAgdmFsIGVxdWFsXG4gICAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgICAtPiAoJ2EsICdjbXApIG5hbWVkXG4gICAgICAtPiAoJ2EsICdjbXApIG5hbWVkXG4gICAgICAtPiB1bml0IE9yX2Vycm9yLnRcbiAgZW5kXG5cbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG4gIHZhbCBmb2xkX3JpZ2h0IDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhIC0+ICdhY2N1bSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gIHZhbCBpdGVyMlxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBmOihbIGBMZWZ0IG9mICdhIHwgYFJpZ2h0IG9mICdhIHwgYEJvdGggb2YgJ2EgKiAnYSBdIC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gIHZhbCBmaWx0ZXJcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gZjooJ2EgLT4gYm9vbClcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgcGFydGl0aW9uX3RmXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGY6KCdhIC0+IGJvb2wpXG4gICAgLT4gKCdhLCAnY21wKSB0ICogKCdhLCAnY21wKSB0XG5cbiAgdmFsIGVsZW1lbnRzIDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYVxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG4gIHZhbCBjaG9vc2UgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG4gIHZhbCBjaG9vc2VfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG5cbiAgdmFsIHNwbGl0XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICdhXG4gICAgLT4gKCdhLCAnY21wKSB0ICogJ2Egb3B0aW9uICogKCdhLCAnY21wKSB0XG5cbiAgdmFsIGdyb3VwX2J5XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+IGVxdWl2OignYSAtPiAnYSAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2NtcCkgdCBsaXN0XG5cbiAgdmFsIGZpbmRfZXhuIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhXG4gIHZhbCBudGggOiAoJ2EsIF8pIHQgLT4gaW50IC0+ICdhIG9wdGlvblxuXG4gIHZhbCByZW1vdmVfaW5kZXhcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gaW50XG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgdmFsIHRvX3RyZWUgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ID9vcmRlcjpbIGBJbmNyZWFzaW5nIHwgYERlY3JlYXNpbmcgXVxuICAgIC0+ID9ncmVhdGVyX29yX2VxdWFsX3RvOidhXG4gICAgLT4gP2xlc3Nfb3JfZXF1YWxfdG86J2FcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiAnYSBTZXF1ZW5jZS50XG5cbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gY29tcGFyZTooJ2EgLT4gJ2tleSAtPiBpbnQpXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X2tleS50XG4gICAgLT4gJ2tleVxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBzZWdtZW50X29mOignYSAtPiBbIGBMZWZ0IHwgYFJpZ2h0IF0pXG4gICAgLT4gQmluYXJ5X3NlYXJjaGFibGUuV2hpY2hfdGFyZ2V0X2J5X3NlZ21lbnQudFxuICAgIC0+ICdhIG9wdGlvblxuXG4gIHZhbCBtZXJnZV90b19zZXF1ZW5jZVxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiA/b3JkZXI6WyBgSW5jcmVhc2luZyB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYSkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnRcbmVuZFxuXG4oKiogQ29uc2lzdGVuY3kgY2hlY2tzIChzYW1lIGFzIGluIFtDb250YWluZXJdKS4gKilcbm1vZHVsZSBDaGVja19hY2Nlc3NvcnNcbiAgICAoVCA6IFQyKVxuICAgIChUcmVlIDogVDIpXG4gICAgKEVsdCA6IFQxKVxuICAgIChOYW1lZCA6IFQyKVxuICAgIChDbXAgOiBUMSlcbiAgICAoT3B0aW9ucyA6IFQzKVxuICAgIChfIDogQWNjZXNzb3JzX2dlbmVyaWNcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBPcHRpb25zLnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgVC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIFRyZWUudFxuICAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIEVsdC50XG4gICAgIHdpdGggdHlwZSAnY21wIGNtcCA6PSAnY21wIENtcC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiKSBuYW1lZCA6PSAoJ2EsICdiKSBOYW1lZC50KSA9XG5zdHJ1Y3QgZW5kXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMwIChNIDogQWNjZXNzb3JzMCkgPVxuICBDaGVja19hY2Nlc3NvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uZWx0XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9IE0ubmFtZWRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2FjY2Vzc29yczEgKE0gOiBBY2Nlc3NvcnMxKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gJ2EgTS5uYW1lZFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfYWNjZXNzb3JzMiAoTSA6IEFjY2Vzc29yczIpID1cbiAgQ2hlY2tfYWNjZXNzb3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLm5hbWVkXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG4gICAgZW5kKVxuICAgIChXaXRob3V0X2NvbXBhcmF0b3IpXG4gICAgKE0pXG5cbm1vZHVsZSBDaGVja19hY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciAoTSA6IEFjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yKSA9XG4gIENoZWNrX2FjY2Vzc29yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAoJ2EsICdiKSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS5uYW1lZFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoV2l0aF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19nZW5lcmljID0gc2lnXG4gIHR5cGUgKCdhLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnY21wKSBzZXRcbiAgdHlwZSAoJ2EsICdjbXApIHRyZWVcbiAgdHlwZSAnYSBlbHRcbiAgdHlwZSAoJ2EsICdjbXAsICd6KSBvcHRpb25zXG4gIHR5cGUgJ2NtcCBjbXBcblxuICB2YWwgZW1wdHkgOiAoJ2EsICdjbXAsICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgc2luZ2xldG9uIDogKCdhLCAnY21wLCAnYSBlbHQgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG4gIHZhbCB1bmlvbl9saXN0IDogKCdhLCAnY21wLCAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG9mX2xpc3QgOiAoJ2EsICdjbXAsICdhIGVsdCBsaXN0IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgb2Zfc2VxdWVuY2UgOiAoJ2EsICdjbXAsICdhIGVsdCBTZXF1ZW5jZS50IC0+ICgnYSwgJ2NtcCkgdCkgb3B0aW9uc1xuICB2YWwgb2ZfYXJyYXkgOiAoJ2EsICdjbXAsICdhIGVsdCBhcnJheSAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6ICgnYSwgJ2NtcCwgJ2EgZWx0IGFycmF5IC0+ICgnYSwgJ2NtcCkgdCBPcl9lcnJvci50KSBvcHRpb25zXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogKCdhLCAnY21wLCAnYSBlbHQgYXJyYXkgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkXG4gICAgOiAoJ2EsICdjbXAsIGxlbjppbnQgLT4gZjooaW50IC0+ICdhIGVsdCkgLT4gKCdhLCAnY21wKSB0KSBvcHRpb25zXG5cbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogKCdhLCBfLCAnYSBlbHQgbGlzdCAtPiAnYSBlbHQgbGlzdCkgb3B0aW9uc1xuXG4gICgqKiBUaGUgdHlwZXMgb2YgW21hcF0gYW5kIFtmaWx0ZXJfbWFwXSBhcmUgc3VidGxlLiAgVGhlIGlucHV0IHNldCwgWygnYSwgXykgc2V0XSxcbiAgICAgIHJlZmxlY3RzIHRoZSBmYWN0IHRoYXQgdGhlc2UgZnVuY3Rpb25zIHRha2UgYSBzZXQgb2YgKmFueSogdHlwZSwgd2l0aCBhbnlcbiAgICAgIGNvbXBhcmF0b3IsIHdoaWxlIHRoZSBvdXRwdXQgc2V0LCBbKCdiLCAnY21wKSB0XSwgcmVmbGVjdHMgdGhhdCB0aGUgb3V0cHV0IHNldCBoYXNcbiAgICAgIHRoZSBwYXJ0aWN1bGFyIFsnY21wXSBvZiB0aGUgY3JlYXRpb24gZnVuY3Rpb24uICBUaGUgY29tcGFyYXRvciBjYW4gY29tZSBpbiBvbmUgb2ZcbiAgICAgIHRocmVlIHdheXMsIGRlcGVuZGluZyBvbiB3aGljaCBzZXQgbW9kdWxlIGlzIHVzZWRcblxuICAgICAgLSBbU2V0Lm1hcF0gLS0gY29tcGFyYXRvciBjb21lcyBhcyBhbiBhcmd1bWVudFxuICAgICAgLSBbU2V0LlBvbHkubWFwXSAtLSBjb21wYXJhdG9yIGlzIHBvbHltb3JwaGljIGNvbXBhcmlzb25cbiAgICAgIC0gW0Zvby5TZXQubWFwXSAtLSBjb21wYXJhdG9yIGlzIFtGb28uY29tcGFyYXRvcl0gKilcbiAgdmFsIG1hcCA6ICgnYiwgJ2NtcCwgKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2IgZWx0KSAtPiAoJ2IsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgZmlsdGVyX21hcFxuICAgIDogKCdiLCAnY21wLCAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYiBlbHQgb3B0aW9uKSAtPiAoJ2IsICdjbXApIHQpIG9wdGlvbnNcblxuICB2YWwgb2ZfdHJlZSA6ICgnYSwgJ2NtcCwgKCdhIGVsdCwgJ2NtcCkgdHJlZSAtPiAoJ2EsICdjbXApIHQpIG9wdGlvbnNcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yczAgPSBzaWdcbiAgdHlwZSAoJ2EsICdjbXApIHNldFxuICB0eXBlIHRcbiAgdHlwZSB0cmVlXG4gIHR5cGUgZWx0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG5cbiAgdmFsIGVtcHR5IDogdFxuICB2YWwgc2luZ2xldG9uIDogZWx0IC0+IHRcbiAgdmFsIHVuaW9uX2xpc3QgOiB0IGxpc3QgLT4gdFxuICB2YWwgb2ZfbGlzdCA6IGVsdCBsaXN0IC0+IHRcbiAgdmFsIG9mX3NlcXVlbmNlIDogZWx0IFNlcXVlbmNlLnQgLT4gdFxuICB2YWwgb2ZfYXJyYXkgOiBlbHQgYXJyYXkgLT4gdFxuICB2YWwgb2Zfc29ydGVkX2FycmF5IDogZWx0IGFycmF5IC0+IHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6IGVsdCBhcnJheSAtPiB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCA6IGxlbjppbnQgLT4gZjooaW50IC0+IGVsdCkgLT4gdFxuICB2YWwgc3RhYmxlX2RlZHVwX2xpc3QgOiBlbHQgbGlzdCAtPiBlbHQgbGlzdFxuICB2YWwgbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gZWx0KSAtPiB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gZWx0IG9wdGlvbikgLT4gdFxuICB2YWwgb2ZfdHJlZSA6IHRyZWUgLT4gdFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzMSA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIHRyZWVcbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcblxuICB2YWwgZW1wdHkgOiAnYSB0XG4gIHZhbCBzaW5nbGV0b24gOiAnYSAtPiAnYSB0XG4gIHZhbCB1bmlvbl9saXN0IDogJ2EgdCBsaXN0IC0+ICdhIHRcbiAgdmFsIG9mX2xpc3QgOiAnYSBsaXN0IC0+ICdhIHRcbiAgdmFsIG9mX3NlcXVlbmNlIDogJ2EgU2VxdWVuY2UudCAtPiAnYSB0XG4gIHZhbCBvZl9hcnJheSA6ICdhIGFycmF5IC0+ICdhIHRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6ICdhIGFycmF5IC0+ICdhIHQgT3JfZXJyb3IudFxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCA6ICdhIGFycmF5IC0+ICdhIHRcbiAgdmFsIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIDogbGVuOmludCAtPiBmOihpbnQgLT4gJ2EpIC0+ICdhIHRcbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogJ2EgbGlzdCAtPiAnYSBsaXN0XG4gIHZhbCBtYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYikgLT4gJ2IgdFxuICB2YWwgZmlsdGVyX21hcCA6ICgnYSwgXykgc2V0IC0+IGY6KCdhIC0+ICdiIG9wdGlvbikgLT4gJ2IgdFxuICB2YWwgb2ZfdHJlZSA6ICdhIHRyZWUgLT4gJ2EgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzMiA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgKCdhLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIGVtcHR5IDogKCdhLCAnY21wKSB0XG4gIHZhbCBzaW5nbGV0b24gOiAnYSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHVuaW9uX2xpc3QgOiAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2xpc3QgOiAnYSBsaXN0IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2Zfc2VxdWVuY2UgOiAnYSBTZXF1ZW5jZS50IC0+ICgnYSwgJ2NtcCkgdFxuICB2YWwgb2ZfYXJyYXkgOiAnYSBhcnJheSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX3NvcnRlZF9hcnJheSA6ICdhIGFycmF5IC0+ICgnYSwgJ2NtcCkgdCBPcl9lcnJvci50XG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIDogJ2EgYXJyYXkgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCA6IGxlbjppbnQgLT4gZjooaW50IC0+ICdhKSAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHN0YWJsZV9kZWR1cF9saXN0IDogJ2EgbGlzdCAtPiAnYSBsaXN0XG4gIHZhbCBtYXAgOiAoJ2EsIF8pIHNldCAtPiBmOignYSAtPiAnYikgLT4gKCdiLCAnY21wKSB0XG4gIHZhbCBmaWx0ZXJfbWFwIDogKCdhLCBfKSBzZXQgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKSAtPiAoJ2IsICdjbXApIHRcbiAgdmFsIG9mX3RyZWUgOiAoJ2EsICdjbXApIHRyZWUgLT4gKCdhLCAnY21wKSB0XG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICB0eXBlICgnYSwgJ2NtcCkgc2V0XG4gIHR5cGUgKCdhLCAnY21wKSB0XG4gIHR5cGUgKCdhLCAnY21wKSB0cmVlXG5cbiAgdmFsIGVtcHR5IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIHNpbmdsZXRvbiA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCB1bmlvbl9saXN0IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2xpc3QgOiBjb21wYXJhdG9yOignYSwgJ2NtcCkgQ29tcGFyYXRvci50IC0+ICdhIGxpc3QgLT4gKCdhLCAnY21wKSB0XG4gIHZhbCBvZl9zZXF1ZW5jZSA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgU2VxdWVuY2UudCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2FycmF5IDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAnYSBhcnJheSAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5XG4gICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICdhIGFycmF5XG4gICAgLT4gKCdhLCAnY21wKSB0IE9yX2Vycm9yLnRcblxuICB2YWwgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAnYSBhcnJheVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiBsZW46aW50XG4gICAgLT4gZjooaW50IC0+ICdhKVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuXG4gIHZhbCBzdGFibGVfZGVkdXBfbGlzdCA6IGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnQgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0XG5cbiAgdmFsIG1hcFxuICAgIDogIGNvbXBhcmF0b3I6KCdiLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAtPiAoJ2EsIF8pIHNldFxuICAgIC0+IGY6KCdhIC0+ICdiKVxuICAgIC0+ICgnYiwgJ2NtcCkgdFxuXG4gIHZhbCBmaWx0ZXJfbWFwXG4gICAgOiAgY29tcGFyYXRvcjooJ2IsICdjbXApIENvbXBhcmF0b3IudFxuICAgIC0+ICgnYSwgXykgc2V0XG4gICAgLT4gZjooJ2EgLT4gJ2Igb3B0aW9uKVxuICAgIC0+ICgnYiwgJ2NtcCkgdFxuXG4gIHZhbCBvZl90cmVlIDogY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudCAtPiAoJ2EsICdjbXApIHRyZWUgLT4gKCdhLCAnY21wKSB0XG5lbmRcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzXG4gICAgKFQgOiBUMilcbiAgICAoVHJlZSA6IFQyKVxuICAgIChFbHQgOiBUMSlcbiAgICAoQ21wIDogVDEpXG4gICAgKE9wdGlvbnMgOiBUMylcbiAgICAoXyA6IENyZWF0b3JzX2dlbmVyaWNcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBvcHRpb25zIDo9ICgnYSwgJ2IsICdjKSBPcHRpb25zLnRcbiAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgVC50XG4gICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIFRyZWUudFxuICAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIEVsdC50XG4gICAgIHdpdGggdHlwZSAnY21wIGNtcCA6PSAnY21wIENtcC50KSA9XG5zdHJ1Y3QgZW5kXG5cbm1vZHVsZSBDaGVja19jcmVhdG9yczAgKE0gOiBDcmVhdG9yczApID1cbiAgQ2hlY2tfY3JlYXRvcnNcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSBNLnRcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gTS50cmVlXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9IE0uZWx0XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2NtcCB0ID0gTS5jb21wYXJhdG9yX3dpdG5lc3NcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMSAoTSA6IENyZWF0b3JzMSkgPVxuICBDaGVja19jcmVhdG9yc1xuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICdhIE0udFxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICgnYSwgJ2IpIHQgPSAnYSBNLnRyZWVcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnYSB0ID0gJ2FcbiAgICBlbmQpXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAnY21wIHQgPSBNLmNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZClcbiAgICAoV2l0aG91dF9jb21wYXJhdG9yKVxuICAgIChNKVxuXG5tb2R1bGUgQ2hlY2tfY3JlYXRvcnMyIChNIDogQ3JlYXRvcnMyKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdjbXAgdCA9ICdjbXBcbiAgICBlbmQpXG4gICAgKFdpdGhvdXRfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIENoZWNrX2NyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3IgKE0gOiBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yKSA9XG4gIENoZWNrX2NyZWF0b3JzXG4gICAgKHN0cnVjdFxuICAgICAgdHlwZSAoJ2EsICdiKSB0ID0gKCdhLCAnYikgTS50XG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIE0udHJlZVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuICAgIGVuZClcbiAgICAoc3RydWN0XG4gICAgICB0eXBlICdjbXAgdCA9ICdjbXBcbiAgICBlbmQpXG4gICAgKFdpdGhfY29tcGFyYXRvcilcbiAgICAoTSlcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yc19nZW5lcmljID0gc2lnXG4gIGluY2x1ZGUgQWNjZXNzb3JzX2dlbmVyaWNcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAoJ2EsICdiLCAnYykgb3B0aW9ucyA6PSAoJ2EsICdiLCAnYykgb3B0aW9uc1xuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdHJlZSA6PSAoJ2EsICdiKSB0cmVlXG4gICAgd2l0aCB0eXBlICdhIGVsdCA6PSAnYSBlbHRcbiAgICB3aXRoIHR5cGUgJ2NtcCBjbXAgOj0gJ2NtcCBjbXBcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMCA9IHNpZ1xuICBpbmNsdWRlIEFjY2Vzc29yczBcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnMwXG4gICAgd2l0aCB0eXBlIHQgOj0gdFxuICAgIHdpdGggdHlwZSB0cmVlIDo9IHRyZWVcbiAgICB3aXRoIHR5cGUgZWx0IDo9IGVsdFxuICAgIHdpdGggdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgOj0gY29tcGFyYXRvcl93aXRuZXNzXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczEgPSBzaWdcbiAgaW5jbHVkZSBBY2Nlc3NvcnMxXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzMVxuICAgIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgICB3aXRoIHR5cGUgJ2EgdHJlZSA6PSAnYSB0cmVlXG4gICAgd2l0aCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA6PSBjb21wYXJhdG9yX3dpdG5lc3NcbmVuZFxuXG5tb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMiA9IHNpZ1xuICBpbmNsdWRlIEFjY2Vzc29yczJcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdHJlZVxuZW5kXG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciA9IHNpZ1xuICBpbmNsdWRlIEFjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yXG5cbiAgaW5jbHVkZVxuICAgIENyZWF0b3JzMl93aXRoX2NvbXBhcmF0b3JcbiAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgdHJlZVxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfcG9seSA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxXG5cbm1vZHVsZSB0eXBlIEZvcl9kZXJpdmluZyA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcblxuICBtb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90IDogdCAtPiBTZXhwbGliMC5TZXhwLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIE1fb2Zfc2V4cCA9IHNpZ1xuICAgIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICAgIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gICAgW0BAQGVuZF1cblxuICAgIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICAgIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcbiAgbW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG4gIHZhbCBzZXhwX29mX21fX3QgOiAobW9kdWxlIFNleHBfb2ZfbSB3aXRoIHR5cGUgdCA9ICdlbHQpIC0+ICgnZWx0LCAnY21wKSB0IC0+IFNleHAudFxuXG4gIHZhbCBtX190X29mX3NleHBcbiAgICA6ICAobW9kdWxlIE1fb2Zfc2V4cCB3aXRoIHR5cGUgdCA9ICdlbHQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gJ2NtcClcbiAgICAtPiBTZXhwLnRcbiAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuXG4gIHZhbCBtX190X3NleHBfZ3JhbW1hclxuICAgIDogIChtb2R1bGUgTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSAnZWx0KVxuICAgIC0+ICgnZWx0LCAnY21wKSB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgdmFsIGNvbXBhcmVfbV9fdCA6IChtb2R1bGUgQ29tcGFyZV9tKSAtPiAoJ2VsdCwgJ2NtcCkgdCAtPiAoJ2VsdCwgJ2NtcCkgdCAtPiBpbnRcbiAgdmFsIGVxdWFsX21fX3QgOiAobW9kdWxlIEVxdWFsX20pIC0+ICgnZWx0LCAnY21wKSB0IC0+ICgnZWx0LCAnY21wKSB0IC0+IGJvb2xcblxuICB2YWwgaGFzaF9mb2xkX21fX3RcbiAgICA6ICAobW9kdWxlIEhhc2hfZm9sZF9tIHdpdGggdHlwZSB0ID0gJ2VsdClcbiAgICAtPiBIYXNoLnN0YXRlXG4gICAgLT4gKCdlbHQsIF8pIHRcbiAgICAtPiBIYXNoLnN0YXRlXG5cbiAgdmFsIGhhc2hfbV9fdCA6IChtb2R1bGUgSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSAnZWx0KSAtPiAoJ2VsdCwgXykgdCAtPiBpbnRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXQgPSBzaWdcbiAgKCoqIFNldHMgYmFzZWQgb24geyFDb21wYXJhdG9yLlN9LlxuXG4gICAgICBDcmVhdG9ycyByZXF1aXJlIGEgY29tcGFyYXRvciBhcmd1bWVudCB0byBiZSBwYXNzZWQgaW4sIHdoZXJlYXMgYWNjZXNzb3JzIHVzZSB0aGVcbiAgICAgIGNvbXBhcmF0b3IgcHJvdmlkZWQgYnkgdGhlIGlucHV0IHNldC4gKilcblxuICAoKiogVGhlIHR5cGUgb2YgYSBzZXQuICBUaGUgZmlyc3QgdHlwZSBwYXJhbWV0ZXIgaWRlbnRpZmllcyB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudCwgYW5kXG4gICAgICB0aGUgc2Vjb25kIGlkZW50aWZpZXMgdGhlIGNvbXBhcmF0b3IsIHdoaWNoIGRldGVybWluZXMgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb24gdGhhdFxuICAgICAgaXMgdXNlZCBmb3Igb3JkZXJpbmcgZWxlbWVudHMgaW4gdGhpcyBzZXQuICBNYW55IG9wZXJhdGlvbnMgKGUuZy4sIHshdW5pb259KSxcbiAgICAgIHJlcXVpcmUgdGhhdCB0aGV5IGJlIHBhc3NlZCBzZXRzIHdpdGggdGhlIHNhbWUgZWxlbWVudCB0eXBlIGFuZCB0aGUgc2FtZSBjb21wYXJhdG9yXG4gICAgICB0eXBlLiAqKVxuICB0eXBlICgnZWx0LCAnY21wKSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlXVxuXG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkNvbXBhcmFibGUuUzIgd2l0aCB0eXBlICgnZWx0LCAnY21wKSB0IDo9ICgnZWx0LCAnY21wKSB0XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlICgnaywgJ2NtcCkgY29tcGFyYXRvciA9ICgnaywgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMjEtMTJdIHVzZSBbQ29tcGFyYXRvci5Nb2R1bGUudF0gaW5zdGVhZFwiXVxuXG4gICgqKiBUZXN0cyBpbnRlcm5hbCBpbnZhcmlhbnRzIG9mIHRoZSBzZXQgZGF0YSBzdHJ1Y3R1cmUuICBSZXR1cm5zIHRydWUgb24gc3VjY2Vzcy4gKilcbiAgdmFsIGludmFyaWFudHMgOiAoXywgXykgdCAtPiBib29sXG5cbiAgKCoqIFJldHVybnMgYSBmaXJzdC1jbGFzcyBtb2R1bGUgdGhhdCBjYW4gYmUgdXNlZCB0byBidWlsZCBvdGhlciBtYXAvc2V0L2V0Y1xuICAgICAgd2l0aCB0aGUgc2FtZSBub3Rpb24gb2YgY29tcGFyaXNvbi4gKilcbiAgdmFsIGNvbXBhcmF0b3JfcyA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcblxuICB2YWwgY29tcGFyYXRvciA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIENvbXBhcmF0b3IudFxuXG4gICgqKiBDcmVhdGVzIGFuIGVtcHR5IHNldCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY29tcGFyYXRvci4gKilcbiAgdmFsIGVtcHR5IDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBDcmVhdGVzIGEgc2V0IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjb21wYXJhdG9yIHRoYXQgY29udGFpbnMgb25seSB0aGUgcHJvdmlkZWRcbiAgICAgIGVsZW1lbnQuICopXG4gIHZhbCBzaW5nbGV0b24gOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFJldHVybnMgdGhlIGNhcmRpbmFsaXR5IG9mIHRoZSBzZXQuIFtPKDEpXS4gKilcbiAgdmFsIGxlbmd0aCA6IChfLCBfKSB0IC0+IGludFxuXG4gICgqKiBbaXNfZW1wdHkgdF0gaXMgW3RydWVdIGlmZiBbdF0gaXMgZW1wdHkuICBbTygxKV0uICopXG4gIHZhbCBpc19lbXB0eSA6IChfLCBfKSB0IC0+IGJvb2xcblxuICAoKiogW21lbSB0IGFdIHJldHVybnMgW3RydWVdIGlmZiBbYV0gaXMgaW4gW3RdLiAgW08obG9nIG4pXS4gKilcbiAgdmFsIG1lbSA6ICgnYSwgXykgdCAtPiAnYSAtPiBib29sXG5cbiAgKCoqIFthZGQgdCBhXSByZXR1cm5zIGEgbmV3IHNldCB3aXRoIFthXSBhZGRlZCB0byBbdF0sIG9yIHJldHVybnMgW3RdIGlmIFttZW0gdCBhXS5cbiAgICAgIFtPKGxvZyBuKV0uICopXG4gIHZhbCBhZGQgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtyZW1vdmUgdCBhXSByZXR1cm5zIGEgbmV3IHNldCB3aXRoIFthXSByZW1vdmVkIGZyb20gW3RdIGlmIFttZW0gdCBhXSwgb3IgcmV0dXJucyBbdF1cbiAgICAgIG90aGVyd2lzZS4gIFtPKGxvZyBuKV0uICopXG4gIHZhbCByZW1vdmUgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFt1bmlvbiB0MSB0Ml0gcmV0dXJucyB0aGUgdW5pb24gb2YgdGhlIHR3byBzZXRzLiAgW08obGVuZ3RoIHQxICsgbGVuZ3RoIHQyKV0uICopXG4gIHZhbCB1bmlvbiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFt1bmlvbiBjIGxpc3RdIHJldHVybnMgdGhlIHVuaW9uIG9mIGFsbCB0aGUgc2V0cyBpbiBbbGlzdF0uICBUaGVcbiAgICAgIFtjb21wYXJhdG9yXSBhcmd1bWVudCBpcyByZXF1aXJlZCBmb3IgdGhlIGNhc2Ugd2hlcmUgW2xpc3RdIGlzIGVtcHR5LlxuICAgICAgW08obWF4KExpc3QubGVuZ3RoIGxpc3QsIG4gbG9nIG4pKV0sIHdoZXJlIFtuXSBpcyB0aGUgc3VtIG9mIHNpemVzIG9mIHRoZSBpbnB1dCBzZXRzLiAqKVxuICB2YWwgdW5pb25fbGlzdCA6ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EsICdjbXApIHQgbGlzdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2ludGVyIHQxIHQyXSBjb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHNldHMgW3QxXSBhbmQgW3QyXS4gIFtPKGxlbmd0aCB0MSArXG4gICAgICBsZW5ndGggdDIpXS4gKilcbiAgdmFsIGludGVyIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2RpZmYgdDEgdDJdIGNvbXB1dGVzIHRoZSBzZXQgZGlmZmVyZW5jZSBbdDEgLSB0Ml0sIGkuZS4sIHRoZSBzZXQgY29udGFpbmluZyBhbGxcbiAgICAgIGVsZW1lbnRzIGluIFt0MV0gdGhhdCBhcmUgbm90IGluIFt0Ml0uICBbTyhsZW5ndGggdDEgKyBsZW5ndGggdDIpXS4gKilcbiAgdmFsIGRpZmYgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbc3ltbWV0cmljX2RpZmYgdDEgdDJdIHJldHVybnMgYSBzZXF1ZW5jZSBvZiBjaGFuZ2VzIGJldHdlZW4gW3QxXSBhbmQgW3QyXS4gSXQgaXNcbiAgICAgIGludGVuZGVkIHRvIGJlIGVmZmljaWVudCBpbiB0aGUgY2FzZSB3aGVyZSBbdDFdIGFuZCBbdDJdIHNoYXJlIGEgbGFyZ2UgYW1vdW50IG9mXG4gICAgICBzdHJ1Y3R1cmUuICopXG4gIHZhbCBzeW1tZXRyaWNfZGlmZiA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnYSkgRWl0aGVyLnQgU2VxdWVuY2UudFxuXG4gICgqKiBbY29tcGFyZV9kaXJlY3QgdDEgdDJdIGNvbXBhcmVzIHRoZSBzZXRzIFt0MV0gYW5kIFt0Ml0uICBJdCByZXR1cm5zIHRoZSBzYW1lIHJlc3VsdFxuICAgICAgYXMgW2NvbXBhcmVdLCBidXQgdW5saWtlIGNvbXBhcmUsIGRvZXNuJ3QgcmVxdWlyZSBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIGluIGZvciB0aGVcbiAgICAgIHR5cGUgcGFyYW1ldGVycyBvZiB0aGUgc2V0LiAgW08obGVuZ3RoIHQxICsgbGVuZ3RoIHQyKV0uICopXG4gIHZhbCBjb21wYXJlX2RpcmVjdCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gaW50XG5cbiAgKCoqIEhhc2ggZnVuY3Rpb246IGEgYnVpbGRpbmcgYmxvY2sgdG8gdXNlIHdoZW4gaGFzaGluZyBkYXRhIHN0cnVjdHVyZXMgY29udGFpbmluZyBzZXRzIGluXG4gICAgICB0aGVtLiBbaGFzaF9mb2xkX2RpcmVjdCBoYXNoX2ZvbGRfa2V5XSBpcyBjb21wYXRpYmxlIHdpdGggW2NvbXBhcmVfZGlyZWN0XSBpZmZcbiAgICAgIFtoYXNoX2ZvbGRfa2V5XSBpcyBjb21wYXRpYmxlIHdpdGggWyhjb21wYXJhdG9yIHMpLmNvbXBhcmVdIG9mIHRoZSBzZXQgW3NdIGJlaW5nXG4gICAgICBoYXNoZWQuICopXG4gIHZhbCBoYXNoX2ZvbGRfZGlyZWN0IDogJ2EgSGFzaC5mb2xkZXIgLT4gKCdhLCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgKCoqIFtlcXVhbCB0MSB0Ml0gcmV0dXJucyBbdHJ1ZV0gaWZmIHRoZSB0d28gc2V0cyBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzLiAgW08obGVuZ3RoIHQxICtcbiAgICAgIGxlbmd0aCB0MildICopXG4gIHZhbCBlcXVhbCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBbZXhpc3RzIHQgfmZdIHJldHVybnMgW3RydWVdIGlmZiB0aGVyZSBleGlzdHMgYW4gW2FdIGluIFt0XSBmb3Igd2hpY2ggW2YgYV0uICBbTyhuKV0sXG4gICAgICBidXQgcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIGFuIFthXSBmb3Igd2hpY2ggW2YgYV0uICopXG4gIHZhbCBleGlzdHMgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBbZm9yX2FsbCB0IH5mXSByZXR1cm5zIFt0cnVlXSBpZmYgZm9yIGFsbCBbYV0gaW4gW3RdLCBbZiBhXS4gIFtPKG4pXSwgYnV0IHJldHVybnMgYXNcbiAgICAgIHNvb24gYXMgaXQgZmluZHMgYW4gW2FdIGZvciB3aGljaCBbbm90IChmIGEpXS4gKilcbiAgdmFsIGZvcl9hbGwgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gYm9vbFxuXG4gICgqKiBbY291bnQgdF0gcmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIFt0XSBmb3Igd2hpY2ggW2ZdIHJldHVybnMgW3RydWVdLlxuICAgICAgW08obildLiAqKVxuICB2YWwgY291bnQgOiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gaW50XG5cbiAgKCoqIFtzdW0gdF0gcmV0dXJucyB0aGUgc3VtIG9mIFtmIHRdIGZvciBlYWNoIFt0XSBpbiB0aGUgc2V0LlxuICAgICAgW08obildLiAqKVxuICB2YWwgc3VtXG4gICAgOiAgKG1vZHVsZSBDb250YWluZXIuU3VtbWFibGUgd2l0aCB0eXBlIHQgPSAnc3VtKVxuICAgIC0+ICgnYSwgXykgdFxuICAgIC0+IGY6KCdhIC0+ICdzdW0pXG4gICAgLT4gJ3N1bVxuXG4gICgqKiBbZmluZCB0IGZdIHJldHVybnMgYW4gZWxlbWVudCBvZiBbdF0gZm9yIHdoaWNoIFtmXSByZXR1cm5zIHRydWUsIHdpdGggbm8gZ3VhcmFudGVlIGFzXG4gICAgICB0byB3aGljaCBlbGVtZW50IGlzIHJldHVybmVkLiAgW08obildLCBidXQgcmV0dXJucyBhcyBzb29uIGFzIGEgc3VpdGFibGUgZWxlbWVudCBpc1xuICAgICAgZm91bmQuICopXG4gIHZhbCBmaW5kIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvblxuXG4gICgqKiBbZmluZF9tYXAgdCBmXSByZXR1cm5zIFtiXSBmb3Igc29tZSBbYV0gaW4gW3RdIGZvciB3aGljaCBbZiBhID0gU29tZSBiXS4gIElmIG5vIHN1Y2hcbiAgICAgIFthXSBleGlzdHMsIHRoZW4gW2ZpbmRdIHJldHVybnMgW05vbmVdLiAgW08obildLCBidXQgcmV0dXJucyBhcyBzb29uIGFzIGEgc3VpdGFibGVcbiAgICAgIGVsZW1lbnQgaXMgZm91bmQuICopXG4gIHZhbCBmaW5kX21hcCA6ICgnYSwgXykgdCAtPiBmOignYSAtPiAnYiBvcHRpb24pIC0+ICdiIG9wdGlvblxuXG4gICgqKiBMaWtlIFtmaW5kXSwgYnV0IHRocm93cyBhbiBleGNlcHRpb24gb24gZmFpbHVyZS4gKilcbiAgdmFsIGZpbmRfZXhuIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IGJvb2wpIC0+ICdhXG5cbiAgKCoqIFtudGggdCBpXSByZXR1cm5zIHRoZSBbaV10aCBzbWFsbGVzdCBlbGVtZW50IG9mIFt0XSwgaW4gW08obG9nIG4pXSB0aW1lLiAgVGhlXG4gICAgICBzbWFsbGVzdCBlbGVtZW50IGhhcyBbaSA9IDBdLiAgUmV0dXJucyBbTm9uZV0gaWYgW2kgPCAwXSBvciBbaSA+PSBsZW5ndGggdF0uICopXG4gIHZhbCBudGggOiAoJ2EsIF8pIHQgLT4gaW50IC0+ICdhIG9wdGlvblxuXG4gICgqKiBbcmVtb3ZlX2luZGV4IHQgaV0gcmV0dXJucyBhIHZlcnNpb24gb2YgW3RdIHdpdGggdGhlIFtpXXRoIHNtYWxsZXN0IGVsZW1lbnQgcmVtb3ZlZCxcbiAgICAgIGluIFtPKGxvZyBuKV0gdGltZS4gIFRoZSBzbWFsbGVzdCBlbGVtZW50IGhhcyBbaSA9IDBdLiAgUmV0dXJucyBbdF0gaWYgW2kgPCAwXSBvclxuICAgICAgW2kgPj0gbGVuZ3RoIHRdLiAqKVxuICB2YWwgcmVtb3ZlX2luZGV4IDogKCdhLCAnY21wKSB0IC0+IGludCAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2lzX3N1YnNldCB0MSB+b2ZfOnQyXSByZXR1cm5zIHRydWUgaWZmIFt0MV0gaXMgYSBzdWJzZXQgb2YgW3QyXS4gKilcbiAgdmFsIGlzX3N1YnNldCA6ICgnYSwgJ2NtcCkgdCAtPiBvZl86KCdhLCAnY21wKSB0IC0+IGJvb2xcblxuICAoKiogW2FyZV9kaXNqb2ludCB0MSB0Ml0gcmV0dXJucyBbdHJ1ZV0gaWZmIFtpc19lbXB0eSAoaW50ZXIgdDEgdDIpXSwgYnV0IGlzIG1vcmVcbiAgICAgIGVmZmljaWVudC4gKilcbiAgdmFsIGFyZV9kaXNqb2ludCA6ICgnYSwgJ2NtcCkgdCAtPiAoJ2EsICdjbXApIHQgLT4gYm9vbFxuXG4gICgqKiBbTmFtZWRdIGFsbG93cyB0aGUgdmFsaWRhdGlvbiBvZiBzdWJzZXQgYW5kIGVxdWFsaXR5IHJlbGF0aW9uc2hpcHMgYmV0d2VlbiBzZXRzLiAgQVxuICAgICAgW05hbWVkLnRdIGlzIGEgcmVjb3JkIG9mIGEgc2V0IGFuZCBhIG5hbWUsIHdoZXJlIHRoZSBuYW1lIGlzIHVzZWQgaW4gZXJyb3IgbWVzc2FnZXMsXG4gICAgICBhbmQgW05hbWVkLmlzX3N1YnNldF0gYW5kIFtOYW1lZC5lcXVhbF0gdmFsaWRhdGUgc3Vic2V0IGFuZCBlcXVhbGl0eSByZWxhdGlvbnNoaXBzXG4gICAgICByZXNwZWN0aXZlbHkuXG5cbiAgICAgIFRoZSBlcnJvciBtZXNzYWdlIGZvciwgZS5nLixcbiAgICAgIHtbXG4gICAgICAgIE5hbWVkLmlzX3N1YnNldCB7IHNldCA9IHNldDE7IG5hbWUgPSBcInNldDFcIiB9IH5vZl86e3NldCA9IHNldDI7IG5hbWUgPSBcInNldDJcIiB9XG4gICAgICBdfVxuXG4gICAgICBsb29rcyBsaWtlXG4gICAgICB7dlxuICAgICAgICAoXCJzZXQxIGlzIG5vdCBhIHN1YnNldCBvZiBzZXQyXCIgKGludmFsaWRfZWxlbWVudHMgKC4uLmVsZW1lbnRzIG9mIHNldDEgLSBzZXQyLi4uKSkpXG4gICAgIHZ9XG5cbiAgICAgIHNvIFtuYW1lXSBzaG91bGQgYmUgYSBub3VuIHBocmFzZSB0aGF0IGRvZXNuJ3Qgc291bmQgYXdrd2FyZCBpbiB0aGUgYWJvdmUgZXJyb3JcbiAgICAgIG1lc3NhZ2UuICBFdmVuIHRob3VnaCBpdCBhZGRzIHZlcmJvc2l0eSwgY2hvb3NpbmcgW25hbWVdcyB0aGF0IHN0YXJ0IHdpdGggdGhlIHBocmFzZVxuICAgICAgXCJ0aGUgc2V0IG9mXCIgb2Z0ZW4gbWFrZXMgdGhlIGVycm9yIG1lc3NhZ2Ugc291bmQgbW9yZSBuYXR1cmFsLlxuICAqKVxuICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyAoJ2EsICdjbXApIHQgPVxuICAgICAgeyBzZXQgOiAoJ2EsICdjbXApIHRcbiAgICAgIDsgbmFtZSA6IHN0cmluZ1xuICAgICAgfVxuXG4gICAgKCoqIFtpc19zdWJzZXQgdDEgfm9mXzp0Ml0gcmV0dXJucyBbT2sgKCldIGlmIFt0MV0gaXMgYSBzdWJzZXQgb2YgW3QyXSBhbmQgYVxuICAgICAgICBodW1hbi1yZWFkYWJsZSBlcnJvciBvdGhlcndpc2UuICAqKVxuICAgIHZhbCBpc19zdWJzZXQgOiAoJ2EsICdjbXApIHQgLT4gb2ZfOignYSwgJ2NtcCkgdCAtPiB1bml0IE9yX2Vycm9yLnRcblxuICAgICgqKiBbZXF1YWwgdDEgdDJdIHJldHVybnMgW09rICgpXSBpZiBbdDFdIGlzIGVxdWFsIHRvIFt0Ml0gYW5kIGEgaHVtYW4tcmVhZGFibGVcbiAgICAgICAgZXJyb3Igb3RoZXJ3aXNlLiAgKilcbiAgICB2YWwgZXF1YWwgOiAoJ2EsICdjbXApIHQgLT4gKCdhLCAnY21wKSB0IC0+IHVuaXQgT3JfZXJyb3IudFxuICBlbmRcblxuICAoKiogVGhlIGxpc3Qgb3IgYXJyYXkgZ2l2ZW4gdG8gW29mX2xpc3RdIGFuZCBbb2ZfYXJyYXldIG5lZWQgbm90IGJlIHNvcnRlZC4gKilcbiAgdmFsIG9mX2xpc3QgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgbGlzdCAtPiAoJ2EsICdjbXApIHRcblxuICB2YWwgb2Zfc2VxdWVuY2UgOiAoJ2EsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnQgLT4gJ2EgU2VxdWVuY2UudCAtPiAoJ2EsICdjbXApIHRcbiAgdmFsIG9mX2FycmF5IDogKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50IC0+ICdhIGFycmF5IC0+ICgnYSwgJ2NtcCkgdFxuXG4gICgqKiBbdG9fbGlzdF0gYW5kIFt0b19hcnJheV0gcHJvZHVjZSBzZXF1ZW5jZXMgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBhY2NvcmRpbmcgdG8gdGhlXG4gICAgICBjb21wYXJhdG9yLiAqKVxuICB2YWwgdG9fbGlzdCA6ICgnYSwgXykgdCAtPiAnYSBsaXN0XG5cbiAgdmFsIHRvX2FycmF5IDogKCdhLCBfKSB0IC0+ICdhIGFycmF5XG5cbiAgKCoqIENyZWF0ZSBzZXQgZnJvbSBzb3J0ZWQgYXJyYXkuICBUaGUgaW5wdXQgbXVzdCBiZSBzb3J0ZWQgKGVpdGhlciBpbiBhc2NlbmRpbmcgb3JcbiAgICAgIGRlc2NlbmRpbmcgb3JkZXIgYXMgZ2l2ZW4gYnkgdGhlIGNvbXBhcmF0b3IpIGFuZCBjb250YWluIG5vIGR1cGxpY2F0ZXMsIG90aGVyd2lzZSB0aGVcbiAgICAgIHJlc3VsdCBpcyBhbiBlcnJvci4gIFRoZSBjb21wbGV4aXR5IG9mIHRoaXMgZnVuY3Rpb24gaXMgW08obildLiAqKVxuICB2YWwgb2Zfc29ydGVkX2FycmF5XG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ2EgYXJyYXlcbiAgICAtPiAoJ2EsICdjbXApIHQgT3JfZXJyb3IudFxuXG4gICgqKiBTaW1pbGFyIHRvIFtvZl9zb3J0ZWRfYXJyYXldLCBidXQgd2l0aG91dCBjaGVja2luZyB0aGUgaW5wdXQgYXJyYXkuICopXG4gIHZhbCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkXG4gICAgOiAgKCdhLCAnY21wKSBDb21wYXJhdG9yLk1vZHVsZS50XG4gICAgLT4gJ2EgYXJyYXlcbiAgICAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW29mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIGMgfmxlbiB+Zl0gYmVoYXZlcyBsaWtlIFtvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGNcbiAgICAgIChBcnJheS5pbml0IGxlbiB+ZildLCB3aXRoIHRoZSBhZGRpdGlvbmFsIHJlc3RyaWN0aW9uIHRoYXQgYSBkZWNyZWFzaW5nIG9yZGVyIGlzIG5vdFxuICAgICAgc3VwcG9ydGVkLiAgVGhlIGFkdmFudGFnZSBpcyBub3QgcmVxdWlyaW5nIHlvdSB0byBhbGxvY2F0ZSBhbiBpbnRlcm1lZGlhdGUgYXJyYXkuICBbZl1cbiAgICAgIHdpbGwgYmUgY2FsbGVkIHdpdGggMCwgMSwgLi4uIFtsZW4gLSAxXSwgaW4gb3JkZXIuICopXG4gIHZhbCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZFxuICAgIDogICgnYSwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudFxuICAgIC0+IGxlbjppbnRcbiAgICAtPiBmOihpbnQgLT4gJ2EpXG4gICAgLT4gKCdhLCAnY21wKSB0XG5cbiAgKCoqIFtzdGFibGVfZGVkdXBfbGlzdF0gaXMgaGVyZSByYXRoZXIgdGhhbiBpbiB0aGUgW0xpc3RdIG1vZHVsZSBiZWNhdXNlIHRoZVxuICAgICAgaW1wbGVtZW50YXRpb24gcmVsaWVzIGNydWNpYWxseSBvbiBzZXRzLCBhbmQgYmVjYXVzZSBkb2luZyBzbyBhbGxvd3Mgb25lIHRvIGF2b2lkIHVzZXNcbiAgICAgIG9mIHBvbHltb3JwaGljIGNvbXBhcmlzb24gYnkgaW5zdGFudGlhdGluZyB0aGUgZnVuY3RvciBhdCBhIGRpZmZlcmVudCBpbXBsZW1lbnRhdGlvblxuICAgICAgb2YgW0NvbXBhcmF0b3JdIGFuZCB1c2luZyB0aGUgcmVzdWx0aW5nIFtzdGFibGVfZGVkdXBfbGlzdF0uICopXG4gIHZhbCBzdGFibGVfZGVkdXBfbGlzdCA6ICgnYSwgXykgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAnYSBsaXN0IC0+ICdhIGxpc3RcblxuICAoKiogW21hcCBjIHQgfmZdIHJldHVybnMgYSBuZXcgc2V0IGNyZWF0ZWQgYnkgYXBwbHlpbmcgW2ZdIHRvIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICAgIFt0XS4gIFRoZSByZXR1cm5lZCBzZXQgaXMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIFtjb21wYXJhdG9yXS4gIFtPKG4gbG9nIG4pXS4gKilcbiAgdmFsIG1hcCA6ICgnYiwgJ2NtcCkgQ29tcGFyYXRvci5Nb2R1bGUudCAtPiAoJ2EsIF8pIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICgnYiwgJ2NtcCkgdFxuXG4gICgqKiBMaWtlIHshbWFwfSwgZXhjZXB0IGVsZW1lbnRzIGZvciB3aGljaCBbZl0gcmV0dXJucyBbTm9uZV0gd2lsbCBiZSBkcm9wcGVkLiAgKilcbiAgdmFsIGZpbHRlcl9tYXBcbiAgICA6ICAoJ2IsICdjbXApIENvbXBhcmF0b3IuTW9kdWxlLnRcbiAgICAtPiAoJ2EsIF8pIHRcbiAgICAtPiBmOignYSAtPiAnYiBvcHRpb24pXG4gICAgLT4gKCdiLCAnY21wKSB0XG5cbiAgKCoqIFtmaWx0ZXIgdCB+Zl0gcmV0dXJucyB0aGUgc3Vic2V0IG9mIFt0XSBmb3Igd2hpY2ggW2ZdIGV2YWx1YXRlcyB0byB0cnVlLiAgW08obiBsb2dcbiAgICAgIG4pXS4gKilcbiAgdmFsIGZpbHRlciA6ICgnYSwgJ2NtcCkgdCAtPiBmOignYSAtPiBib29sKSAtPiAoJ2EsICdjbXApIHRcblxuICAoKiogW2ZvbGQgdCB+aW5pdCB+Zl0gZm9sZHMgb3ZlciB0aGUgZWxlbWVudHMgb2YgdGhlIHNldCBmcm9tIHNtYWxsZXN0IHRvIGxhcmdlc3QuICopXG4gIHZhbCBmb2xkIDogKCdhLCBfKSB0IC0+IGluaXQ6J2FjY3VtIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAnYWNjdW0pIC0+ICdhY2N1bVxuXG4gICgqKiBbZm9sZF9yZXN1bHQgfmluaXQgfmZdIGZvbGRzIG92ZXIgdGhlIGVsZW1lbnRzIG9mIHRoZSBzZXQgZnJvbSBzbWFsbGVzdCB0b1xuICAgICAgbGFyZ2VzdCwgc2hvcnQgY2lyY3VpdGluZyB0aGUgZm9sZCBpZiBbZiBhY2N1bSB4XSBpcyBhbiBbRXJyb3IgX10gKilcbiAgdmFsIGZvbGRfcmVzdWx0XG4gICAgOiAgKCdhLCBfKSB0XG4gICAgLT4gaW5pdDonYWNjdW1cbiAgICAtPiBmOignYWNjdW0gLT4gJ2EgLT4gKCdhY2N1bSwgJ2UpIFJlc3VsdC50KVxuICAgIC0+ICgnYWNjdW0sICdlKSBSZXN1bHQudFxuXG4gICgqKiBbZm9sZF91bnRpbCB0IH5pbml0IH5mXSBpcyBhIHNob3J0LWNpcmN1aXRpbmcgdmVyc2lvbiBvZiBbZm9sZF0uIElmIFtmXVxuICAgICAgcmV0dXJucyBbU3RvcCBfXSB0aGUgY29tcHV0YXRpb24gY2Vhc2VzIGFuZCByZXN1bHRzIGluIHRoYXQgdmFsdWUuIElmIFtmXSByZXR1cm5zXG4gICAgICBbQ29udGludWUgX10sIHRoZSBmb2xkIHdpbGwgcHJvY2VlZC4gKilcbiAgdmFsIGZvbGRfdW50aWxcbiAgICA6ICAoJ2EsIF8pIHRcbiAgICAtPiBpbml0OidhY2N1bVxuICAgIC0+IGY6KCdhY2N1bSAtPiAnYSAtPiAoJ2FjY3VtLCAnZmluYWwpIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQpXG4gICAgLT4gZmluaXNoOignYWNjdW0gLT4gJ2ZpbmFsKVxuICAgIC0+ICdmaW5hbFxuXG5cbiAgKCoqIExpa2UgeyFmb2xkfSwgZXhjZXB0IHRoYXQgaXQgZ29lcyBmcm9tIHRoZSBsYXJnZXN0IHRvIHRoZSBzbWFsbGVzdCBlbGVtZW50LiAqKVxuICB2YWwgZm9sZF9yaWdodCA6ICgnYSwgXykgdCAtPiBpbml0OidhY2N1bSAtPiBmOignYSAtPiAnYWNjdW0gLT4gJ2FjY3VtKSAtPiAnYWNjdW1cblxuICAoKiogW2l0ZXIgdCB+Zl0gY2FsbHMgW2ZdIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgW3RdLCBnb2luZyBpbiBvcmRlciBmcm9tIHRoZSBzbWFsbGVzdCB0b1xuICAgICAgbGFyZ2VzdC4gICopXG4gIHZhbCBpdGVyIDogKCdhLCBfKSB0IC0+IGY6KCdhIC0+IHVuaXQpIC0+IHVuaXRcblxuICAoKiogSXRlcmF0ZSB0d28gc2V0cyBzaWRlIGJ5IHNpZGUuICBDb21wbGV4aXR5IGlzIFtPKG0rbildIHdoZXJlIFttXSBhbmQgW25dIGFyZSB0aGUgc2l6ZXNcbiAgICAgIG9mIHRoZSB0d28gaW5wdXQgc2V0cy4gIEFzIGFuIGV4YW1wbGUsIHdpdGggdGhlIGlucHV0cyBbMDsgMV0gYW5kIFsxOyAyXSwgW2ZdIHdpbGwgYmVcbiAgICAgIGNhbGxlZCB3aXRoIFtgTGVmdCAwXTsgW2BCb3RoICgxLCAxKV07IGFuZCBbYFJpZ2h0IDJdLiAqKVxuICB2YWwgaXRlcjJcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAtPiBmOihbIGBMZWZ0IG9mICdhIHwgYFJpZ2h0IG9mICdhIHwgYEJvdGggb2YgJ2EgKiAnYSBdIC0+IHVuaXQpXG4gICAgLT4gdW5pdFxuXG4gICgqKiBpZiBbYSwgYiA9IHBhcnRpdGlvbl90ZiBzZXQgfmZdIHRoZW4gW2FdIGlzIHRoZSBlbGVtZW50cyBvbiB3aGljaCBbZl0gcHJvZHVjZWQgW3RydWVdLFxuICAgICAgYW5kIFtiXSBpcyB0aGUgZWxlbWVudHMgb24gd2hpY2ggW2ZdIHByb2R1Y2VzIFtmYWxzZV0uICopXG4gIHZhbCBwYXJ0aXRpb25fdGYgOiAoJ2EsICdjbXApIHQgLT4gZjooJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0ICogKCdhLCAnY21wKSB0XG5cbiAgKCoqIFNhbWUgYXMgeyF0b19saXN0fS4gKilcbiAgdmFsIGVsZW1lbnRzIDogKCdhLCBfKSB0IC0+ICdhIGxpc3RcblxuICAoKiogUmV0dXJucyB0aGUgc21hbGxlc3QgZWxlbWVudCBvZiB0aGUgc2V0LiAgW08obG9nIG4pXS4gKilcbiAgdmFsIG1pbl9lbHQgOiAoJ2EsIF8pIHQgLT4gJ2Egb3B0aW9uXG5cbiAgKCoqIExpa2UgeyFtaW5fZWx0fSwgYnV0IHRocm93cyBhbiBleGNlcHRpb24gd2hlbiBnaXZlbiBhbiBlbXB0eSBzZXQuICopXG4gIHZhbCBtaW5fZWx0X2V4biA6ICgnYSwgXykgdCAtPiAnYVxuXG4gICgqKiBSZXR1cm5zIHRoZSBsYXJnZXN0IGVsZW1lbnQgb2YgdGhlIHNldC4gIFtPKGxvZyBuKV0uICAqKVxuICB2YWwgbWF4X2VsdCA6ICgnYSwgXykgdCAtPiAnYSBvcHRpb25cblxuICAoKiogTGlrZSB7IW1heF9lbHR9LCBidXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiB3aGVuIGdpdmVuIGFuIGVtcHR5IHNldC4gKilcbiAgdmFsIG1heF9lbHRfZXhuIDogKCdhLCBfKSB0IC0+ICdhXG5cbiAgKCoqIHJldHVybnMgYW4gYXJiaXRyYXJ5IGVsZW1lbnQsIG9yIFtOb25lXSBpZiB0aGUgc2V0IGlzIGVtcHR5LiAqKVxuICB2YWwgY2hvb3NlIDogKCdhLCBfKSB0IC0+ICdhIG9wdGlvblxuXG4gICgqKiBMaWtlIHshY2hvb3NlfSwgYnV0IHRocm93cyBhbiBleGNlcHRpb24gb24gYW4gZW1wdHkgc2V0LiAqKVxuICB2YWwgY2hvb3NlX2V4biA6ICgnYSwgXykgdCAtPiAnYVxuXG4gICgqKiBbc3BsaXQgdCB4XSBwcm9kdWNlcyBhIHRyaXBsZSBbKHQxLCBtYXliZV94LCB0MildIHdoZXJlIFt0MV0gaXMgdGhlIHNldCBvZiBlbGVtZW50c1xuICAgICAgc3RyaWN0bHkgbGVzcyB0aGFuIFt4XSwgW21heWJlX3hdIGlzIHRoZSBtZW1iZXIgKGlmIGFueSkgb2YgW3RdIHdoaWNoIGNvbXBhcmVzIGVxdWFsXG4gICAgICB0byBbeF0sIGFuZCBbdDJdIGlzIHRoZSBzZXQgb2YgZWxlbWVudHMgc3RyaWN0bHkgbGFyZ2VyIHRoYW4gW3hdLiAqKVxuICB2YWwgc3BsaXQgOiAoJ2EsICdjbXApIHQgLT4gJ2EgLT4gKCdhLCAnY21wKSB0ICogJ2Egb3B0aW9uICogKCdhLCAnY21wKSB0XG5cbiAgKCoqIGlmIFtlcXVpdl0gaXMgYW4gZXF1aXZhbGVuY2UgcHJlZGljYXRlLCB0aGVuIFtncm91cF9ieSBzZXQgfmVxdWl2XSBwcm9kdWNlcyBhIGxpc3RcbiAgICAgIG9mIGVxdWl2YWxlbmNlIGNsYXNzZXMgKGkuZS4sIGEgc2V0LXRoZW9yZXRpYyBxdW90aWVudCkuICBFLmcuLFxuXG4gICAgICB7W1xuICAgICAgICBsZXQgY2hhcnMgPSBTZXQub2ZfbGlzdCBbJ0EnOyAnYSc7ICdiJzsgJ2MnXSBpblxuICAgICAgICBsZXQgZXF1aXYgYyBjJyA9IENoYXIuZXF1YWwgKENoYXIudXBwZXJjYXNlIGMpIChDaGFyLnVwcGVyY2FzZSBjJykgaW5cbiAgICAgICAgZ3JvdXBfYnkgY2hhcnMgfmVxdWl2XG4gICAgICBdfVxuXG4gICAgICBwcm9kdWNlczpcblxuICAgICAge1tcbiAgICAgICAgW1NldC5vZl9saXN0IFsnQSc7J2EnXTsgU2V0LnNpbmdsZXRvbiAnYic7IFNldC5zaW5nbGV0b24gJ2MnXVxuICAgICAgXX1cblxuICAgICAgW2dyb3VwX2J5XSBydW5zIGluIE8obl4yKSB0aW1lLCBzbyBpZiB5b3UgaGF2ZSBhIGNvbXBhcmlzb24gZnVuY3Rpb24sIGl0J3MgdXN1YWxseVxuICAgICAgbXVjaCBmYXN0ZXIgdG8gdXNlIFtTZXQub2ZfbGlzdF0uICopXG4gIHZhbCBncm91cF9ieSA6ICgnYSwgJ2NtcCkgdCAtPiBlcXVpdjooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gKCdhLCAnY21wKSB0IGxpc3RcblxuICAoKiogW3RvX3NlcXVlbmNlIHRdIGNvbnZlcnRzIHRoZSBzZXQgW3RdIHRvIGEgc2VxdWVuY2Ugb2YgdGhlIGVsZW1lbnRzIGJldHdlZW5cbiAgICAgIFtncmVhdGVyX29yX2VxdWFsX3RvXSBhbmQgW2xlc3Nfb3JfZXF1YWxfdG9dIGluY2x1c2l2ZSBpbiB0aGUgb3JkZXIgaW5kaWNhdGVkIGJ5XG4gICAgICBbb3JkZXJdLiAgSWYgW2dyZWF0ZXJfb3JfZXF1YWxfdG8gPiBsZXNzX29yX2VxdWFsX3RvXSB0aGUgc2VxdWVuY2UgaXMgZW1wdHkuICBDb3N0IGlzXG4gICAgICBPKGxvZyBuKSB1cCBmcm9udCBhbmQgYW1vcnRpemVkIE8oMSkgZm9yIGVhY2ggZWxlbWVudCBwcm9kdWNlZC4gKilcbiAgdmFsIHRvX3NlcXVlbmNlXG4gICAgOiAgP29yZGVyOlsgYEluY3JlYXNpbmcgKCoqIGRlZmF1bHQgKikgfCBgRGVjcmVhc2luZyBdXG4gICAgLT4gP2dyZWF0ZXJfb3JfZXF1YWxfdG86J2FcbiAgICAtPiA/bGVzc19vcl9lcXVhbF90bzonYVxuICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgIC0+ICdhIFNlcXVlbmNlLnRcblxuICAoKiogW2JpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSB3aGljaCBlbHRdIHJldHVybnMgdGhlIGVsZW1lbnQgaW4gW3RdIHNwZWNpZmllZCBieVxuICAgICAgW2NvbXBhcmVdIGFuZCBbd2hpY2hdLCBpZiBvbmUgZXhpc3RzLlxuXG4gICAgICBbdF0gbXVzdCBiZSBzb3J0ZWQgaW4gaW5jcmVhc2luZyBvcmRlciBhY2NvcmRpbmcgdG8gW2NvbXBhcmVdLCB3aGVyZSBbY29tcGFyZV0gYW5kXG4gICAgICBbZWx0XSBkaXZpZGUgW3RdIGludG8gdGhyZWUgKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCAgPCBlbHQgIHwgID0gZWx0ICB8ICA+IGVsdCAgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hdIHJldHVybnMgYW4gZWxlbWVudCBvbiB0aGUgYm91bmRhcnkgb2Ygc2VnbWVudHMgYXMgc3BlY2lmaWVkIGJ5XG4gICAgICBbd2hpY2hdLiAgU2VlIHRoZSBkaWFncmFtIGJlbG93IG5leHQgdG8gdGhlIFt3aGljaF0gdmFyaWFudHMuXG5cbiAgICAgIFtiaW5hcnlfc2VhcmNoXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtjb21wYXJlXSBvcmRlcnMgW3RdLCBhbmQgYmVoYXZpb3IgaXNcbiAgICAgIHVuc3BlY2lmaWVkIGlmIFtjb21wYXJlXSBkb2Vzbid0IG9yZGVyIFt0XS4gIEJlaGF2aW9yIGlzIGFsc28gdW5zcGVjaWZpZWQgaWZcbiAgICAgIFtjb21wYXJlXSBtdXRhdGVzIFt0XS4gKilcbiAgdmFsIGJpbmFyeV9zZWFyY2hcbiAgICA6ICAoJ2EsICdjbXApIHRcbiAgICAtPiBjb21wYXJlOignYSAtPiAna2V5IC0+IGludClcbiAgICAtPiBbIGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAoKiogICAgICAgIHt2IHwgPCBlbHQgWCB8ICAgICAgICAgICAgICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvICgqKiAgICAge3YgfCAgICAgIDw9IGVsdCAgICAgICBYIHwgICAgICAgICAgIHZ9ICopXG4gICAgICAgfCBgTGFzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgICB7diAgICAgICAgICAgfCAgID0gZWx0IFggfCAgICAgICAgICAgdn0gKilcbiAgICAgICB8IGBGaXJzdF9lcXVhbF90byAoKiogICAgICAgICAgICAgICAgIHt2ICAgICAgICAgICB8IFggPSBlbHQgICB8ICAgICAgICAgICB2fSAqKVxuICAgICAgIHwgYEZpcnN0X2dyZWF0ZXJfdGhhbl9vcl9lcXVhbF90byAoKioge3YgICAgICAgICAgIHwgWCAgICAgICA+PSBlbHQgICAgICB8IHZ9ICopXG4gICAgICAgfCBgRmlyc3Rfc3RyaWN0bHlfZ3JlYXRlcl90aGFuICgqKiAgICB7diAgICAgICAgICAgICAgICAgICAgICAgfCBYID4gZWx0IHwgdn0gKilcbiAgICAgICBdXG4gICAgLT4gJ2tleVxuICAgIC0+ICdhIG9wdGlvblxuXG4gICgqKiBbYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdCB+c2VnbWVudF9vZiB3aGljaF0gdGFrZXMgYSBbc2VnbWVudF9vZl0gZnVuY3Rpb24gdGhhdFxuICAgICAgZGl2aWRlcyBbdF0gaW50byB0d28gKHBvc3NpYmx5IGVtcHR5KSBzZWdtZW50czpcblxuICAgICAge3ZcbiAgICAgICAgfCBzZWdtZW50X29mIGVsdCA9IGBMZWZ0IHwgc2VnbWVudF9vZiBlbHQgPSBgUmlnaHQgfFxuICAgICAgdn1cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSByZXR1cm5zIHRoZSBlbGVtZW50IG9uIHRoZSBib3VuZGFyeSBvZiB0aGUgc2VnbWVudHMgYXNcbiAgICAgIHNwZWNpZmllZCBieSBbd2hpY2hdOiBbYExhc3Rfb25fbGVmdF0geWllbGRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGxlZnQgc2VnbWVudCxcbiAgICAgIHdoaWxlIFtgRmlyc3Rfb25fcmlnaHRdIHlpZWxkcyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgcmlnaHQgc2VnbWVudC4gIEl0IHJldHVybnNcbiAgICAgIFtOb25lXSBpZiB0aGUgc2VnbWVudCBpcyBlbXB0eS5cblxuICAgICAgW2JpbmFyeV9zZWFyY2hfc2VnbWVudGVkXSBkb2VzIG5vdCBjaGVjayB0aGF0IFtzZWdtZW50X29mXSBzZWdtZW50cyBbdF0gYXMgaW4gdGhlXG4gICAgICBkaWFncmFtLCBhbmQgYmVoYXZpb3IgaXMgdW5zcGVjaWZpZWQgaWYgW3NlZ21lbnRfb2ZdIGRvZXNuJ3Qgc2VnbWVudCBbdF0uICBCZWhhdmlvclxuICAgICAgaXMgYWxzbyB1bnNwZWNpZmllZCBpZiBbc2VnbWVudF9vZl0gbXV0YXRlcyBbdF0uICopXG4gIHZhbCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZFxuICAgIDogICgnYSwgJ2NtcCkgdFxuICAgIC0+IHNlZ21lbnRfb2Y6KCdhIC0+IFsgYExlZnQgfCBgUmlnaHQgXSlcbiAgICAtPiBbIGBMYXN0X29uX2xlZnQgfCBgRmlyc3Rfb25fcmlnaHQgXVxuICAgIC0+ICdhIG9wdGlvblxuXG4gICgqKiBQcm9kdWNlcyB0aGUgZWxlbWVudHMgb2YgdGhlIHR3byBzZXRzIGJldHdlZW4gW2dyZWF0ZXJfb3JfZXF1YWxfdG9dIGFuZFxuICAgICAgW2xlc3Nfb3JfZXF1YWxfdG9dIGluIFtvcmRlcl0sIG5vdGluZyB3aGV0aGVyIGVhY2ggZWxlbWVudCBhcHBlYXJzIGluIHRoZSBsZWZ0IHNldCxcbiAgICAgIHRoZSByaWdodCBzZXQsIG9yIGJvdGguICBJbiB0aGUgYm90aCBjYXNlLCBib3RoIGVsZW1lbnRzIGFyZSByZXR1cm5lZCwgaW4gY2FzZSB0aGVcbiAgICAgIGNhbGxlciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlbiBlbGVtZW50cyB0aGF0IGFyZSBlcXVhbCB0byB0aGUgc2V0cycgY29tcGFyYXRvci4gIFJ1bnNcbiAgICAgIGluIE8obGVuZ3RoIHQgKyBsZW5ndGggdCcpLiAqKVxuICBtb2R1bGUgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudCA6IHNpZ1xuICAgIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIFNlcXVlbmNlLk1lcmdlX3dpdGhfZHVwbGljYXRlc19lbGVtZW50LnQgPVxuICAgICAgfCBMZWZ0IG9mICdhXG4gICAgICB8IFJpZ2h0IG9mICdiXG4gICAgICB8IEJvdGggb2YgJ2EgKiAnYlxuICAgIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMiB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICB2YWwgbWVyZ2VfdG9fc2VxdWVuY2VcbiAgICA6ICA/b3JkZXI6WyBgSW5jcmVhc2luZyAoKiogZGVmYXVsdCAqKSB8IGBEZWNyZWFzaW5nIF1cbiAgICAtPiA/Z3JlYXRlcl9vcl9lcXVhbF90bzonYVxuICAgIC0+ID9sZXNzX29yX2VxdWFsX3RvOidhXG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnY21wKSB0XG4gICAgLT4gKCdhLCAnYSkgTWVyZ2VfdG9fc2VxdWVuY2VfZWxlbWVudC50IFNlcXVlbmNlLnRcblxuICAoKiogW01dIGlzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBPQ2FtbCBhcHBsaWNhdGl2ZSBmdW5jdG9yIHR5cGVzOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ19zZXQgPSBTZXQuTShTdHJpbmcpLnRcbiAgICAgIF19XG5cbiAgICAgIHdoaWNoIHN0YW5kcyBmb3I6XG5cbiAgICAgIHtbXG4gICAgICAgIHR5cGUgc3RyaW5nX3NldCA9IChTdHJpbmcudCwgU3RyaW5nLmNvbXBhcmF0b3Jfd2l0bmVzcykgU2V0LnRcbiAgICAgIF19XG5cbiAgICAgIFRoZSBwb2ludCBpcyB0aGF0IFtTZXQuTShTdHJpbmcpLnRdIHN1cHBvcnRzIGRlcml2aW5nLCB3aGVyZWFzIHRoZSBzZWNvbmQgc3ludGF4XG4gICAgICBkb2Vzbid0IChiZWNhdXNlIHRoZXJlIGlzIG5vIHN1Y2ggdGhpbmcgYXMsIHNheSwgU3RyaW5nLnNleHBfb2ZfY29tcGFyYXRvcl93aXRuZXNzLFxuICAgICAgaW5zdGVhZCB5b3Ugd291bGQgd2FudCB0byBwYXNzIHRoZSBjb21wYXJhdG9yIGRpcmVjdGx5KS4gKilcbiAgbW9kdWxlIE0gKEVsdCA6IHNpZ1xuICAgICAgdHlwZSB0XG4gICAgICB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzc1xuICAgIGVuZCkgOiBzaWdcbiAgICB0eXBlIG5vbnJlYyB0ID0gKEVsdC50LCBFbHQuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIGVuZFxuXG4gIGluY2x1ZGUgRm9yX2Rlcml2aW5nIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICAoKiogQSBwb2x5bW9ycGhpYyBTZXQuICopXG4gIG1vZHVsZSBQb2x5IDogU19wb2x5IHdpdGggdHlwZSAnZWx0IHQgPSAoJ2VsdCwgQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuXG4gICgqKiBVc2luZyBjb21wYXJhdG9yIGlzIGEgc2ltaWxhciBpbnRlcmZhY2UgYXMgdGhlIHRvcGxldmVsIG9mIFtTZXRdLCBleGNlcHQgdGhlIGZ1bmN0aW9uc1xuICAgICAgdGFrZSBhIFt+Y29tcGFyYXRvcjooJ2VsdCwgJ2NtcCkgQ29tcGFyYXRvci50XSB3aGVyZSB0aGUgZnVuY3Rpb25zIGF0IHRoZSB0b3BsZXZlbCBvZlxuICAgICAgW1NldF0gdGFrZXMgYSBbKCdlbHQsICdjbXApIGNvbXBhcmF0b3JdLiAqKVxuICBtb2R1bGUgVXNpbmdfY29tcGFyYXRvciA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICgnZWx0LCAnY21wKSB0ID0gKCdlbHQsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICB2YWwgc2V4cF9vZl90XG4gICAgICA6ICAoJ2VsdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2NtcCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgdmFsIHRfb2Zfc2V4cF9kaXJlY3RcbiAgICAgIDogIGNvbXBhcmF0b3I6KCdlbHQsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgLT4gKFNleHAudCAtPiAnZWx0KVxuICAgICAgLT4gU2V4cC50XG4gICAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuXG4gICAgbW9kdWxlIFRyZWUgOiBzaWdcbiAgICAgICgqKiBBIFtUcmVlLnRdIGNvbnRhaW5zIGp1c3QgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmUgdGhhdCBhIHNldCBpcyBiYXNlZCBvbiwgd2l0aG91dFxuICAgICAgICAgIGluY2x1ZGluZyB0aGUgY29tcGFyYXRvci4gIEFjY29yZGluZ2x5LCBhbnkgb3BlcmF0aW9uIG9uIGEgW1RyZWUudF0gbXVzdCBhbHNvIHRha2VcbiAgICAgICAgICBhcyBhbiBhcmd1bWVudCB0aGUgY29ycmVzcG9uZGluZyBjb21wYXJhdG9yLiAqKVxuICAgICAgdHlwZSAoJ2EsICdjbXApIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgICAgIHZhbCBzZXhwX29mX3RcbiAgICAgICAgOiAgKCdhIC0+IFNleHBsaWIwLlNleHAudClcbiAgICAgICAgLT4gKCdjbXAgLT4gU2V4cGxpYjAuU2V4cC50KVxuICAgICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgICAgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICAgIFtAQEBlbmRdXG5cbiAgICAgIHZhbCB0X29mX3NleHBfZGlyZWN0XG4gICAgICAgIDogIGNvbXBhcmF0b3I6KCdlbHQsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgICAtPiAoU2V4cC50IC0+ICdlbHQpXG4gICAgICAgIC0+IFNleHAudFxuICAgICAgICAtPiAoJ2VsdCwgJ2NtcCkgdFxuXG4gICAgICBtb2R1bGUgTmFtZWQgOiBzaWdcbiAgICAgICAgdHlwZSBub25yZWMgKCdhLCAnY21wKSB0ID1cbiAgICAgICAgICB7IHRyZWUgOiAoJ2EsICdjbXApIHRcbiAgICAgICAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICAgICAgICB9XG5cbiAgICAgICAgdmFsIGlzX3N1YnNldFxuICAgICAgICAgIDogIGNvbXBhcmF0b3I6KCdhLCAnY21wKSBDb21wYXJhdG9yLnRcbiAgICAgICAgICAtPiAoJ2EsICdjbXApIHRcbiAgICAgICAgICAtPiBvZl86KCdhLCAnY21wKSB0XG4gICAgICAgICAgLT4gdW5pdCBPcl9lcnJvci50XG5cbiAgICAgICAgdmFsIGVxdWFsXG4gICAgICAgICAgOiAgY29tcGFyYXRvcjooJ2EsICdjbXApIENvbXBhcmF0b3IudFxuICAgICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAgIC0+ICgnYSwgJ2NtcCkgdFxuICAgICAgICAgIC0+IHVuaXQgT3JfZXJyb3IudFxuICAgICAgZW5kXG5cbiAgICAgIGluY2x1ZGVcbiAgICAgICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yXG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSBzZXQgOj0gKCdhLCAnYikgdFxuICAgICAgICB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG4gICAgICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0cmVlIDo9ICgnYSwgJ2IpIHRcbiAgICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIG5hbWVkIDo9ICgnYSwgJ2IpIE5hbWVkLnRcbiAgICAgICAgd2l0aCBtb2R1bGUgTmFtZWQgOj0gTmFtZWRcblxuICAgICAgdmFsIGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gOiAoXywgXykgdFxuICAgIGVuZFxuXG4gICAgaW5jbHVkZVxuICAgICAgQWNjZXNzb3JzMlxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgVHJlZS50XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgbmFtZWQgOj0gKCdhLCAnYikgTmFtZWQudFxuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvclxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHRyZWUgOj0gKCdhLCAnYikgVHJlZS50XG4gICAgICB3aXRoIHR5cGUgKCdhLCAnYikgc2V0IDo9ICgnYSwgJ2IpIHRcblxuICAgIHZhbCBjb21wYXJhdG9yIDogKCdhLCAnY21wKSB0IC0+ICgnYSwgJ2NtcCkgQ29tcGFyYXRvci50XG4gICAgdmFsIGhhc2hfZm9sZF9kaXJlY3QgOiAnZWx0IEhhc2guZm9sZGVyIC0+ICgnZWx0LCAnY21wKSB0IEhhc2guZm9sZGVyXG5cbiAgICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoRWx0IDogQ29tcGFyYXRvci5TMSkgOiBzaWdcbiAgICAgIHZhbCBlbXB0eSA6ICgnYSBFbHQudCwgRWx0LmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICAgIGVuZFxuICBlbmRcblxuICAoKiogezIgTW9kdWxlcyBhbmQgbW9kdWxlIHR5cGVzIGZvciBleHRlbmRpbmcgW1NldF19XG5cbiAgICAgIEZvciB1c2UgaW4gZXh0ZW5zaW9ucyBvZiBCYXNlLCBsaWtlIFtDb3JlXS4gKilcblxuICBtb2R1bGUgV2l0aF9jb21wYXJhdG9yID0gV2l0aF9jb21wYXJhdG9yXG4gIG1vZHVsZSBXaXRoX2ZpcnN0X2NsYXNzX21vZHVsZSA9IFdpdGhfZmlyc3RfY2xhc3NfbW9kdWxlXG4gIG1vZHVsZSBXaXRob3V0X2NvbXBhcmF0b3IgPSBXaXRob3V0X2NvbXBhcmF0b3JcblxuICBtb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBGb3JfZGVyaXZpbmdcbiAgbW9kdWxlIHR5cGUgU19wb2x5ID0gU19wb2x5XG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczAgPSBBY2Nlc3NvcnMwXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczEgPSBBY2Nlc3NvcnMxXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczIgPSBBY2Nlc3NvcnMyXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yID0gQWNjZXNzb3JzMl93aXRoX2NvbXBhcmF0b3JcbiAgbW9kdWxlIHR5cGUgQWNjZXNzb3JzX2dlbmVyaWMgPSBBY2Nlc3NvcnNfZ2VuZXJpY1xuICBtb2R1bGUgdHlwZSBDcmVhdG9yczAgPSBDcmVhdG9yczBcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnMxID0gQ3JlYXRvcnMxXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzMiA9IENyZWF0b3JzMlxuICBtb2R1bGUgdHlwZSBDcmVhdG9yczJfd2l0aF9jb21wYXJhdG9yID0gQ3JlYXRvcnMyX3dpdGhfY29tcGFyYXRvclxuICBtb2R1bGUgdHlwZSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMCA9IENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMwXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMxID0gQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczFcbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczIgPSBDcmVhdG9yc19hbmRfYWNjZXNzb3JzMlxuXG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2FuZF9hY2Nlc3NvcnMyX3dpdGhfY29tcGFyYXRvciA9XG4gICAgQ3JlYXRvcnNfYW5kX2FjY2Vzc29yczJfd2l0aF9jb21wYXJhdG9yXG5cbiAgbW9kdWxlIHR5cGUgQ3JlYXRvcnNfZ2VuZXJpYyA9IENyZWF0b3JzX2dlbmVyaWNcbiAgbW9kdWxlIHR5cGUgRWx0X3BsYWluID0gRWx0X3BsYWluXG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKilcbigqICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKilcbigqICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEFwYWNoZSAyLjAgbGljZW5zZS4gU2VlIC4uL1RISVJELVBBUlRZLnR4dCAgKilcbigqICBmb3IgZGV0YWlscy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogU2V0cyBvdmVyIG9yZGVyZWQgdHlwZXMgKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIFNldF9pbnRmXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cblxubW9kdWxlIFRyZWUwID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBFbXB0eVxuICAgICgqIChMZWFmIHgpIGlzIHRoZSBzYW1lIGFzIChOb2RlIChFbXB0eSwgeCwgRW1wdHksIDEsIDEpKSBidXQgdXNlcyBsZXNzIHNwYWNlLiAqKVxuICAgIHwgTGVhZiBvZiAnYVxuICAgICgqIGZpcnN0IGludCBpcyBoZWlnaHQsIHNlY29uZCBpcyBzdWItdHJlZSBzaXplICopXG4gICAgfCBOb2RlIG9mICdhIHQgKiAnYSAqICdhIHQgKiBpbnQgKiBpbnRcblxuICB0eXBlICdhIHRyZWUgPSAnYSB0XG5cbiAgKCogU2V0cyBhcmUgcmVwcmVzZW50ZWQgYnkgYmFsYW5jZWQgYmluYXJ5IHRyZWVzICh0aGUgaGVpZ2h0cyBvZiB0aGUgY2hpbGRyZW4gZGlmZmVyIGJ5XG4gICAgIGF0IG1vc3QgMi4gKilcbiAgbGV0IGhlaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAwXG4gICAgfCBMZWFmIF8gLT4gMVxuICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICA7O1xuXG4gIGxldCBsZW5ndGggPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiBfIC0+IDFcbiAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgOztcblxuICBsZXQgaW52YXJpYW50cyA9XG4gICAgbGV0IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHYgPVxuICAgICAgKG1hdGNoIGxvd2VyIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgIHwgU29tZSBsb3dlciAtPiBjb21wYXJlX2VsdCBsb3dlciB2IDwgMClcbiAgICAgICYmXG4gICAgICBtYXRjaCB1cHBlciB3aXRoXG4gICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgfCBTb21lIHVwcGVyIC0+IGNvbXBhcmVfZWx0IHYgdXBwZXIgPCAwXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3AgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBMZWFmIHYgLT4gaW5fcmFuZ2UgbG93ZXIgdXBwZXIgY29tcGFyZV9lbHQgdlxuICAgICAgfCBOb2RlIChsLCB2LCByLCBoLCBuKSAtPlxuICAgICAgICBsZXQgaGwgPSBoZWlnaHQgbFxuICAgICAgICBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgICAgICBhYnMgKGhsIC0gaHIpIDw9IDJcbiAgICAgICAgJiYgaCA9IG1heCBobCBociArIDFcbiAgICAgICAgJiYgbiA9IGxlbmd0aCBsICsgbGVuZ3RoIHIgKyAxXG4gICAgICAgICYmIGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfZWx0IHZcbiAgICAgICAgJiYgbG9vcCBsb3dlciAoU29tZSB2KSBjb21wYXJlX2VsdCBsXG4gICAgICAgICYmIGxvb3AgKFNvbWUgdikgdXBwZXIgY29tcGFyZV9lbHQgclxuICAgIGluXG4gICAgZnVuIHQgfmNvbXBhcmVfZWx0IC0+IGxvb3AgTm9uZSBOb25lIGNvbXBhcmVfZWx0IHRcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgIHwgTGVhZiBfIHwgTm9kZSBfIC0+IGZhbHNlXG4gIDs7XG5cbiAgKCogQ3JlYXRlcyBhIG5ldyBub2RlIHdpdGggbGVmdCBzb24gbCwgdmFsdWUgdiBhbmQgcmlnaHQgc29uIHIuXG4gICAgIFdlIG11c3QgaGF2ZSBhbGwgZWxlbWVudHMgb2YgbCA8IHYgPCBhbGwgZWxlbWVudHMgb2Ygci5cbiAgICAgbCBhbmQgciBtdXN0IGJlIGJhbGFuY2VkIGFuZCB8IGhlaWdodCBsIC0gaGVpZ2h0IHIgfCA8PSAyLlxuICAgICBJbmxpbmUgZXhwYW5zaW9uIG9mIGhlaWdodCBmb3IgYmV0dGVyIHNwZWVkLiAqKVxuXG4gIGxldCBjcmVhdGUgbCB2IHIgPVxuICAgIGxldCBobCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gICAgaW5cbiAgICBsZXQgaHIgPVxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IDBcbiAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICAgIGluXG4gICAgbGV0IGggPSBpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSBpblxuICAgIGlmIGggPSAxXG4gICAgdGhlbiBMZWFmIHZcbiAgICBlbHNlIChcbiAgICAgIGxldCBzbCA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IDBcbiAgICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgICAgIGluXG4gICAgICBsZXQgc3IgPVxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgICAgfCBOb2RlIChfLCBfLCBfLCBfLCBzKSAtPiBzXG4gICAgICBpblxuICAgICAgTm9kZSAobCwgdiwgciwgaCwgc2wgKyBzciArIDEpKVxuICA7O1xuXG4gICgqIFdlIG11c3QgY2FsbCBbZl0gd2l0aCBpbmNyZWFzaW5nIGluZGV4ZXMsIGJlY2F1c2UgdGhlIGJpbl9wcm90IHJlYWRlciBpblxuICAgICBDb3JlLlNldCBuZWVkcyBpdC4gKilcbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgPVxuICAgIGxldCByZWMgbG9vcCBuIH5mIGkgPVxuICAgICAgbWF0Y2ggbiB3aXRoXG4gICAgICB8IDAgLT4gRW1wdHlcbiAgICAgIHwgMSAtPlxuICAgICAgICBsZXQgayA9IGYgaSBpblxuICAgICAgICBMZWFmIGtcbiAgICAgIHwgMiAtPlxuICAgICAgICBsZXQga2wgPSBmIGkgaW5cbiAgICAgICAgbGV0IGsgPSBmIChpICsgMSkgaW5cbiAgICAgICAgY3JlYXRlIChMZWFmIGtsKSBrIEVtcHR5XG4gICAgICB8IDMgLT5cbiAgICAgICAgbGV0IGtsID0gZiBpIGluXG4gICAgICAgIGxldCBrID0gZiAoaSArIDEpIGluXG4gICAgICAgIGxldCBrciA9IGYgKGkgKyAyKSBpblxuICAgICAgICBjcmVhdGUgKExlYWYga2wpIGsgKExlYWYga3IpXG4gICAgICB8IG4gLT5cbiAgICAgICAgbGV0IGxlZnRfbGVuZ3RoID0gbiBsc3IgMSBpblxuICAgICAgICBsZXQgcmlnaHRfbGVuZ3RoID0gbiAtIGxlZnRfbGVuZ3RoIC0gMSBpblxuICAgICAgICBsZXQgbGVmdCA9IGxvb3AgbGVmdF9sZW5ndGggfmYgaSBpblxuICAgICAgICBsZXQgayA9IGYgKGkgKyBsZWZ0X2xlbmd0aCkgaW5cbiAgICAgICAgbGV0IHJpZ2h0ID0gbG9vcCByaWdodF9sZW5ndGggfmYgKGkgKyBsZWZ0X2xlbmd0aCArIDEpIGluXG4gICAgICAgIGNyZWF0ZSBsZWZ0IGsgcmlnaHRcbiAgICBpblxuICAgIGxvb3AgbGVuIH5mIDBcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCBhcnJheV9sZW5ndGggPSBBcnJheS5sZW5ndGggYXJyYXkgaW5cbiAgICBsZXQgbmV4dCA9XG4gICAgICAoKiBXZSBkb24ndCBjaGVjayBpZiB0aGUgYXJyYXkgaXMgc29ydGVkIG9yIGtleXMgYXJlIGR1cGxpY2F0ZWQsIGJlY2F1c2UgdGhhdFxuICAgICAgICAgY2hlY2tpbmcgaXMgc2xvd2VyIHRoYW4gdGhlIHdob2xlIFtvZl9zb3J0ZWRfYXJyYXldIGZ1bmN0aW9uICopXG4gICAgICBpZiBhcnJheV9sZW5ndGggPCAyIHx8IGNvbXBhcmVfZWx0IGFycmF5LigwKSBhcnJheS4oMSkgPCAwXG4gICAgICB0aGVuIGZ1biBpIC0+IGFycmF5LihpKVxuICAgICAgZWxzZSBmdW4gaSAtPiBhcnJheS4oYXJyYXlfbGVuZ3RoIC0gMSAtIGkpXG4gICAgaW5cbiAgICBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+bGVuOmFycmF5X2xlbmd0aCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIGFycmF5IHdpdGhcbiAgICB8IFt8fF0gfCBbfCBfIHxdIC0+IFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQpXG4gICAgfCBfIC0+XG4gICAgICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICAgICAgbGV0IGluY3JlYXNpbmcgPVxuICAgICAgICAgIG1hdGNoIGNvbXBhcmVfZWx0IGFycmF5LigwKSBhcnJheS4oMSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+IGkgPCAwXG4gICAgICAgIGluXG4gICAgICAgIGZvciBpID0gMSB0byBBcnJheS5sZW5ndGggYXJyYXkgLSAyIGRvXG4gICAgICAgICAgbWF0Y2ggY29tcGFyZV9lbHQgYXJyYXkuKGkpIGFycmF5LihpICsgMSkgd2l0aFxuICAgICAgICAgIHwgMCAtPiByLnJldHVybiAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBkdXBsaWNhdGVkIGVsZW1lbnRzXCIpXG4gICAgICAgICAgfCBpIC0+XG4gICAgICAgICAgICBpZiBQb2x5LiggPD4gKSAoaSA8IDApIGluY3JlYXNpbmdcbiAgICAgICAgICAgIHRoZW5cbiAgICAgICAgICAgICAgci5yZXR1cm5cbiAgICAgICAgICAgICAgICAoT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwib2Zfc29ydGVkX2FycmF5OiBlbGVtZW50cyBhcmUgbm90IG9yZGVyZWRcIilcbiAgICAgICAgZG9uZTtcbiAgICAgICAgUmVzdWx0Lk9rIChvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2VsdCkpXG4gIDs7XG5cbiAgKCogU2FtZSBhcyBjcmVhdGUsIGJ1dCBwZXJmb3JtcyBvbmUgc3RlcCBvZiByZWJhbGFuY2luZyBpZiBuZWNlc3NhcnkuXG4gICAgIEFzc3VtZXMgbCBhbmQgciBiYWxhbmNlZCBhbmQgfCBoZWlnaHQgbCAtIGhlaWdodCByIHwgPD0gMy5cbiAgICAgSW5saW5lIGV4cGFuc2lvbiBvZiBjcmVhdGUgZm9yIGJldHRlciBzcGVlZCBpbiB0aGUgbW9zdCBmcmVxdWVudCBjYXNlXG4gICAgIHdoZXJlIG5vIHJlYmFsYW5jaW5nIGlzIHJlcXVpcmVkLiAqKVxuXG4gIGxldCBiYWwgbCB2IHIgPVxuICAgIGxldCBobCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gMFxuICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgfCBOb2RlIChfLCBfLCBfLCBoLCBfKSAtPiBoXG4gICAgaW5cbiAgICBsZXQgaHIgPVxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IDBcbiAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgIHwgTm9kZSAoXywgXywgXywgaCwgXykgLT4gaFxuICAgIGluXG4gICAgaWYgaGwgPiBociArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZSAoKiBiZWNhdXNlIGgobCk+aChyKSsyIGFuZCBoKGxlYWYpPTEgKilcbiAgICAgIHwgTm9kZSAobGwsIGx2LCBsciwgXywgXykgLT5cbiAgICAgICAgaWYgaGVpZ2h0IGxsID49IGhlaWdodCBsclxuICAgICAgICB0aGVuIGNyZWF0ZSBsbCBsdiAoY3JlYXRlIGxyIHYgcilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgfCBMZWFmIGxydiAtPlxuICAgICAgICAgICAgYXNzZXJ0IChpc19lbXB0eSBsbCk7XG4gICAgICAgICAgICBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBFbXB0eSkgbHJ2IChjcmVhdGUgRW1wdHkgdiByKVxuICAgICAgICAgIHwgTm9kZSAobHJsLCBscnYsIGxyciwgXywgXykgLT4gY3JlYXRlIChjcmVhdGUgbGwgbHYgbHJsKSBscnYgKGNyZWF0ZSBscnIgdiByKSkpXG4gICAgZWxzZSBpZiBociA+IGhsICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGFzc2VydCBmYWxzZVxuICAgICAgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlICgqIGJlY2F1c2UgaChyKT5oKGwpKzIgYW5kIGgobGVhZik9MSAqKVxuICAgICAgfCBOb2RlIChybCwgcnYsIHJyLCBfLCBfKSAtPlxuICAgICAgICBpZiBoZWlnaHQgcnIgPj0gaGVpZ2h0IHJsXG4gICAgICAgIHRoZW4gY3JlYXRlIChjcmVhdGUgbCB2IHJsKSBydiByclxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBtYXRjaCBybCB3aXRoXG4gICAgICAgICAgfCBFbXB0eSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICAgICB8IExlYWYgcmx2IC0+XG4gICAgICAgICAgICBhc3NlcnQgKGlzX2VtcHR5IHJyKTtcbiAgICAgICAgICAgIGNyZWF0ZSAoY3JlYXRlIGwgdiBFbXB0eSkgcmx2IChjcmVhdGUgRW1wdHkgcnYgcnIpXG4gICAgICAgICAgfCBOb2RlIChybGwsIHJsdiwgcmxyLCBfLCBfKSAtPiBjcmVhdGUgKGNyZWF0ZSBsIHYgcmxsKSBybHYgKGNyZWF0ZSBybHIgcnYgcnIpKSlcbiAgICBlbHNlIChcbiAgICAgIGxldCBoID0gaWYgaGwgPj0gaHIgdGhlbiBobCArIDEgZWxzZSBociArIDEgaW5cbiAgICAgIGxldCBzbCA9XG4gICAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IDBcbiAgICAgICAgfCBMZWFmIF8gLT4gMVxuICAgICAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIHMpIC0+IHNcbiAgICAgIGluXG4gICAgICBsZXQgc3IgPVxuICAgICAgICBtYXRjaCByIHdpdGhcbiAgICAgICAgfCBFbXB0eSAtPiAwXG4gICAgICAgIHwgTGVhZiBfIC0+IDFcbiAgICAgICAgfCBOb2RlIChfLCBfLCBfLCBfLCBzKSAtPiBzXG4gICAgICBpblxuICAgICAgaWYgaCA9IDEgdGhlbiBMZWFmIHYgZWxzZSBOb2RlIChsLCB2LCByLCBoLCBzbCArIHNyICsgMSkpXG4gIDs7XG5cbiAgKCogSW5zZXJ0aW9uIG9mIG9uZSBlbGVtZW50ICopXG5cbiAgZXhjZXB0aW9uIFNhbWVcblxuICBsZXQgYWRkIHQgeCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgYXV4ID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gTGVhZiB4XG4gICAgICB8IExlYWYgdiAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIHJhaXNlIFNhbWVcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIGNyZWF0ZSAoTGVhZiB4KSB2IEVtcHR5XG4gICAgICAgIGVsc2UgY3JlYXRlIEVtcHR5IHYgKExlYWYgeClcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDAgdGhlbiByYWlzZSBTYW1lIGVsc2UgaWYgYyA8IDAgdGhlbiBiYWwgKGF1eCBsKSB2IHIgZWxzZSBiYWwgbCB2IChhdXggcilcbiAgICBpblxuICAgIHRyeSBhdXggdCB3aXRoXG4gICAgfCBTYW1lIC0+IHRcbiAgOztcblxuICAoKiBTYW1lIGFzIGNyZWF0ZSBhbmQgYmFsLCBidXQgbm8gYXNzdW1wdGlvbnMgYXJlIG1hZGUgb24gdGhlIHJlbGF0aXZlIGhlaWdodHMgb2YgbCBhbmRcbiAgICAgci4gKilcbiAgbGV0IHJlYyBqb2luIGwgdiByIH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggbCwgciB3aXRoXG4gICAgfCBFbXB0eSwgXyAtPiBhZGQgciB2IH5jb21wYXJlX2VsdFxuICAgIHwgXywgRW1wdHkgLT4gYWRkIGwgdiB+Y29tcGFyZV9lbHRcbiAgICB8IExlYWYgbHYsIF8gLT4gYWRkIChhZGQgciB2IH5jb21wYXJlX2VsdCkgbHYgfmNvbXBhcmVfZWx0XG4gICAgfCBfLCBMZWFmIHJ2IC0+IGFkZCAoYWRkIGwgdiB+Y29tcGFyZV9lbHQpIHJ2IH5jb21wYXJlX2VsdFxuICAgIHwgTm9kZSAobGwsIGx2LCBsciwgbGgsIF8pLCBOb2RlIChybCwgcnYsIHJyLCByaCwgXykgLT5cbiAgICAgIGlmIGxoID4gcmggKyAyXG4gICAgICB0aGVuIGJhbCBsbCBsdiAoam9pbiBsciB2IHIgfmNvbXBhcmVfZWx0KVxuICAgICAgZWxzZSBpZiByaCA+IGxoICsgMlxuICAgICAgdGhlbiBiYWwgKGpvaW4gbCB2IHJsIH5jb21wYXJlX2VsdCkgcnYgcnJcbiAgICAgIGVsc2UgY3JlYXRlIGwgdiByXG4gIDs7XG5cbiAgKCogU21hbGxlc3QgYW5kIGdyZWF0ZXN0IGVsZW1lbnQgb2YgYSBzZXQgKilcbiAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiB8IE5vZGUgKEVtcHR5LCB2LCBfLCBfLCBfKSAtPiBTb21lIHZcbiAgICB8IE5vZGUgKGwsIF8sIF8sIF8sIF8pIC0+IG1pbl9lbHQgbFxuICA7O1xuXG4gIGV4Y2VwdGlvbiBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0XVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgU2V0X21pbl9lbHRfZXhuX29mX2VtcHR5X3NldCAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuQXRvbSBcInNldC5tbC5UcmVlMC5TZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGV4Y2VwdGlvbiBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBTZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0XVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldCAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuQXRvbSBcInNldC5tbC5UcmVlMC5TZXRfbWF4X2VsdF9leG5fb2ZfZW1wdHlfc2V0XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCBtaW5fZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtaW5fZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBTZXRfbWluX2VsdF9leG5fb2ZfZW1wdHlfc2V0XG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9XG4gICAgbGV0IHJlYyBmb2xkX3VudGlsX2hlbHBlciB+ZiB0IGFjYyA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gQ29udGFpbmVyLkNvbnRpbnVlX29yX3N0b3AuQ29udGludWUgYWNjXG4gICAgICB8IExlYWYgdmFsdWUgLT4gZiBhY2MgdmFsdWVcbiAgICAgIHwgTm9kZSAobGVmdCwgdmFsdWUsIHJpZ2h0LCBfLCBfKSAtPlxuICAgICAgICAobWF0Y2ggZm9sZF91bnRpbF9oZWxwZXIgfmYgbGVmdCBhY2Mgd2l0aFxuICAgICAgICAgfCBTdG9wIF9hIGFzIHggLT4geFxuICAgICAgICAgfCBDb250aW51ZSBhY2MgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgYWNjIHZhbHVlIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCBfYSBhcyB4IC0+IHhcbiAgICAgICAgICAgIHwgQ29udGludWUgYSAtPiBmb2xkX3VudGlsX2hlbHBlciB+ZiByaWdodCBhKSlcbiAgICBpblxuICAgIG1hdGNoIGZvbGRfdW50aWxfaGVscGVyIH5mIHQgaW5pdCB3aXRoXG4gICAgfCBDb250aW51ZSB4IC0+IGZpbmlzaCB4XG4gICAgfCBTdG9wIHggLT4geFxuICA7O1xuXG4gIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgfCBOb2RlIChfLCB2LCBFbXB0eSwgXywgXykgLT4gU29tZSB2XG4gICAgfCBOb2RlIChfLCBfLCByLCBfLCBfKSAtPiBtYXhfZWx0IHJcbiAgOztcblxuICBsZXQgbWF4X2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWF4X2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgU2V0X21heF9lbHRfZXhuX29mX2VtcHR5X3NldFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICAoKiBSZW1vdmUgdGhlIHNtYWxsZXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIHNldCAqKVxuXG4gIGxldCByZWMgcmVtb3ZlX21pbl9lbHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJTZXQucmVtb3ZlX21pbl9lbHRcIlxuICAgIHwgTGVhZiBfIC0+IEVtcHR5XG4gICAgfCBOb2RlIChFbXB0eSwgXywgciwgXywgXykgLT4gclxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gYmFsIChyZW1vdmVfbWluX2VsdCBsKSB2IHJcbiAgOztcblxuICAoKiBNZXJnZSB0d28gdHJlZXMgbCBhbmQgciBpbnRvIG9uZS4gIEFsbCBlbGVtZW50cyBvZiBsIG11c3QgcHJlY2VkZSB0aGUgZWxlbWVudHMgb2Ygci5cbiAgICAgQXNzdW1lIHwgaGVpZ2h0IGwgLSBoZWlnaHQgciB8IDw9IDIuICopXG4gIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT4gYmFsIHQxIChtaW5fZWx0X2V4biB0MikgKHJlbW92ZV9taW5fZWx0IHQyKVxuICA7O1xuXG4gICgqIE1lcmdlIHR3byB0cmVlcyBsIGFuZCByIGludG8gb25lLiAgQWxsIGVsZW1lbnRzIG9mIGwgbXVzdCBwcmVjZWRlIHRoZSBlbGVtZW50cyBvZiByLlxuICAgICBObyBhc3N1bXB0aW9uIG9uIHRoZSBoZWlnaHRzIG9mIGwgYW5kIHIuICopXG4gIGxldCBjb25jYXQgdDEgdDIgfmNvbXBhcmVfZWx0ID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgfCB0LCBFbXB0eSAtPiB0XG4gICAgfCBfLCBfIC0+IGpvaW4gdDEgKG1pbl9lbHRfZXhuIHQyKSAocmVtb3ZlX21pbl9lbHQgdDIpIH5jb21wYXJlX2VsdFxuICA7O1xuXG4gIGxldCBzcGxpdCB0IHggfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIHNwbGl0IHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IEVtcHR5LCBOb25lLCBFbXB0eVxuICAgICAgfCBMZWFmIHYgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBFbXB0eSwgU29tZSB2LCBFbXB0eVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gRW1wdHksIE5vbmUsIExlYWYgdlxuICAgICAgICBlbHNlIExlYWYgdiwgTm9uZSwgRW1wdHlcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2VsdCB4IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiBsLCBTb21lIHYsIHJcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbGwsIG1heWJlX2VsdCwgcmwgPSBzcGxpdCBsIGluXG4gICAgICAgICAgbGwsIG1heWJlX2VsdCwgam9pbiBybCB2IHIgfmNvbXBhcmVfZWx0KVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgbHIsIG1heWJlX2VsdCwgcnIgPSBzcGxpdCByIGluXG4gICAgICAgICAgam9pbiBsIHYgbHIgfmNvbXBhcmVfZWx0LCBtYXliZV9lbHQsIHJyKVxuICAgIGluXG4gICAgc3BsaXQgdFxuICA7O1xuXG4gICgqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBzZXQgb3BlcmF0aW9ucyAqKVxuXG4gIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgbGV0IHJlYyBtZW0gdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBmYWxzZVxuICAgIHwgTGVhZiB2IC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgYyA9IDBcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgYyA9IDAgfHwgbWVtIChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKSB4IH5jb21wYXJlX2VsdFxuICA7O1xuXG4gIGxldCBzaW5nbGV0b24geCA9IExlYWYgeFxuXG4gIGxldCByZW1vdmUgdCB4IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBhdXggdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgU2FtZVxuICAgICAgfCBMZWFmIHYgLT4gaWYgY29tcGFyZV9lbHQgeCB2ID0gMCB0aGVuIEVtcHR5IGVsc2UgcmFpc2UgU2FtZVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHggdiBpblxuICAgICAgICBpZiBjID0gMCB0aGVuIG1lcmdlIGwgciBlbHNlIGlmIGMgPCAwIHRoZW4gYmFsIChhdXggbCkgdiByIGVsc2UgYmFsIGwgdiAoYXV4IHIpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgd2l0aFxuICAgIHwgU2FtZSAtPiB0XG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9pbmRleCB0IGkgfmNvbXBhcmVfZWx0Ol8gPVxuICAgIGxldCByZWMgYXV4IHQgaSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gcmFpc2UgU2FtZVxuICAgICAgfCBMZWFmIF8gLT4gaWYgaSA9IDAgdGhlbiBFbXB0eSBlbHNlIHJhaXNlIFNhbWVcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgbGV0IGxfc2l6ZSA9IGxlbmd0aCBsIGluXG4gICAgICAgIGxldCBjID0gUG9seS5jb21wYXJlIGkgbF9zaXplIGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gbWVyZ2UgbCByXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBiYWwgKGF1eCBsIGkpIHYgclxuICAgICAgICBlbHNlIGJhbCBsIHYgKGF1eCByIChpIC0gbF9zaXplIC0gMSkpXG4gICAgaW5cbiAgICB0cnkgYXV4IHQgaSB3aXRoXG4gICAgfCBTYW1lIC0+IHRcbiAgOztcblxuICBsZXQgdW5pb24gczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIHVuaW9uIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gczFcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCB0IHwgdCwgRW1wdHkgLT4gdFxuICAgICAgICB8IExlYWYgdjEsIF8gLT4gdW5pb24gKE5vZGUgKEVtcHR5LCB2MSwgRW1wdHksIDEsIDEpKSBzMlxuICAgICAgICB8IF8sIExlYWYgdjIgLT4gdW5pb24gczEgKE5vZGUgKEVtcHR5LCB2MiwgRW1wdHksIDEsIDEpKVxuICAgICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIGgxLCBfKSwgTm9kZSAobDIsIHYyLCByMiwgaDIsIF8pIC0+XG4gICAgICAgICAgaWYgaDEgPj0gaDJcbiAgICAgICAgICB0aGVuXG4gICAgICAgICAgICBpZiBoMiA9IDFcbiAgICAgICAgICAgIHRoZW4gYWRkIHMxIHYyIH5jb21wYXJlX2VsdFxuICAgICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICAgIGxldCBsMiwgXywgcjIgPSBzcGxpdCBzMiB2MSB+Y29tcGFyZV9lbHQgaW5cbiAgICAgICAgICAgICAgam9pbiAodW5pb24gbDEgbDIpIHYxICh1bmlvbiByMSByMikgfmNvbXBhcmVfZWx0KVxuICAgICAgICAgIGVsc2UgaWYgaDEgPSAxXG4gICAgICAgICAgdGhlbiBhZGQgczIgdjEgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgbDEsIF8sIHIxID0gc3BsaXQgczEgdjIgfmNvbXBhcmVfZWx0IGluXG4gICAgICAgICAgICBqb2luICh1bmlvbiBsMSBsMikgdjIgKHVuaW9uIHIxIHIyKSB+Y29tcGFyZV9lbHQpKVxuICAgIGluXG4gICAgdW5pb24gczEgczJcbiAgOztcblxuICBsZXQgdW5pb25fbGlzdCB+Y29tcGFyYXRvciB+dG9fdHJlZSB4cyA9XG4gICAgbGV0IGNvbXBhcmVfZWx0ID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgaW5cbiAgICBMaXN0LmZvbGQgeHMgfmluaXQ6ZW1wdHkgfmY6KGZ1biBhYyB4IC0+IHVuaW9uIGFjICh0b190cmVlIHgpIH5jb21wYXJlX2VsdClcbiAgOztcblxuICBsZXQgaW50ZXIgczEgczIgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGludGVyIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gczFcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCBfIHwgXywgRW1wdHkgLT4gRW1wdHlcbiAgICAgICAgfCAoTGVhZiBlbHQgYXMgc2luZ2xldG9uKSwgb3RoZXJfc2V0IHwgb3RoZXJfc2V0LCAoTGVhZiBlbHQgYXMgc2luZ2xldG9uKSAtPlxuICAgICAgICAgIGlmIG1lbSBvdGhlcl9zZXQgZWx0IH5jb21wYXJlX2VsdCB0aGVuIHNpbmdsZXRvbiBlbHNlIEVtcHR5XG4gICAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIHQyIC0+XG4gICAgICAgICAgKG1hdGNoIHNwbGl0IHQyIHYxIH5jb21wYXJlX2VsdCB3aXRoXG4gICAgICAgICAgIHwgbDIsIE5vbmUsIHIyIC0+IGNvbmNhdCAoaW50ZXIgbDEgbDIpIChpbnRlciByMSByMikgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgIHwgbDIsIFNvbWUgdjEsIHIyIC0+IGpvaW4gKGludGVyIGwxIGwyKSB2MSAoaW50ZXIgcjEgcjIpIH5jb21wYXJlX2VsdCkpXG4gICAgaW5cbiAgICBpbnRlciBzMSBzMlxuICA7O1xuXG4gIGxldCBkaWZmIHMxIHMyIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBkaWZmIHMxIHMyID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgczEgczJcbiAgICAgIHRoZW4gRW1wdHlcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBzMSwgczIgd2l0aFxuICAgICAgICB8IEVtcHR5LCBfIC0+IEVtcHR5XG4gICAgICAgIHwgdDEsIEVtcHR5IC0+IHQxXG4gICAgICAgIHwgTGVhZiB2MSwgdDIgLT4gZGlmZiAoTm9kZSAoRW1wdHksIHYxLCBFbXB0eSwgMSwgMSkpIHQyXG4gICAgICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIHQyIC0+XG4gICAgICAgICAgKG1hdGNoIHNwbGl0IHQyIHYxIH5jb21wYXJlX2VsdCB3aXRoXG4gICAgICAgICAgIHwgbDIsIE5vbmUsIHIyIC0+IGpvaW4gKGRpZmYgbDEgbDIpIHYxIChkaWZmIHIxIHIyKSB+Y29tcGFyZV9lbHRcbiAgICAgICAgICAgfCBsMiwgU29tZSBfLCByMiAtPiBjb25jYXQgKGRpZmYgbDEgbDIpIChkaWZmIHIxIHIyKSB+Y29tcGFyZV9lbHQpKVxuICAgIGluXG4gICAgZGlmZiBzMSBzMlxuICA7O1xuXG4gIG1vZHVsZSBFbnVtID0gc3RydWN0XG4gICAgdHlwZSBpbmNyZWFzaW5nXG4gICAgdHlwZSBkZWNyZWFzaW5nXG5cbiAgICB0eXBlICgnYSwgJ2RpcmVjdGlvbikgdCA9XG4gICAgICB8IEVuZFxuICAgICAgfCBNb3JlIG9mICdhICogJ2EgdHJlZSAqICgnYSwgJ2RpcmVjdGlvbikgdFxuXG4gICAgbGV0IHJlYyBjb25zIHMgKGUgOiAoXywgaW5jcmVhc2luZykgdCkgOiAoXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBtYXRjaCBzIHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgfCBMZWFmIHYgLT4gTW9yZSAodiwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGNvbnMgbCAoTW9yZSAodiwgciwgZSkpXG4gICAgOztcblxuICAgIGxldCByZWMgY29uc19yaWdodCBzIChlIDogKF8sIGRlY3JlYXNpbmcpIHQpIDogKF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggcyB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiB2IC0+IE1vcmUgKHYsIEVtcHR5LCBlKVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBjb25zX3JpZ2h0IHIgKE1vcmUgKHYsIGwsIGUpKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc2V0IHMgOiAoXywgaW5jcmVhc2luZykgdCA9IGNvbnMgcyBFbmRcbiAgICBsZXQgb2Zfc2V0X3JpZ2h0IHMgOiAoXywgZGVjcmVhc2luZykgdCA9IGNvbnNfcmlnaHQgcyBFbmRcblxuICAgIGxldCBzdGFydGluZ19hdF9pbmNyZWFzaW5nIHQga2V5IGNvbXBhcmUgOiAoXywgaW5jcmVhc2luZykgdCA9XG4gICAgICBsZXQgcmVjIGxvb3AgdCBlID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgRW1wdHkgLT4gZVxuICAgICAgICB8IExlYWYgdiAtPiBsb29wIChOb2RlIChFbXB0eSwgdiwgRW1wdHksIDEsIDEpKSBlXG4gICAgICAgIHwgTm9kZSAoXywgdiwgciwgXywgXykgd2hlbiBjb21wYXJlIHYga2V5IDwgMCAtPiBsb29wIHIgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGxvb3AgbCAoTW9yZSAodiwgciwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmIHYgLT4gbG9vcCAoTm9kZSAoRW1wdHksIHYsIEVtcHR5LCAxLCAxKSkgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIF8sIF8sIF8pIHdoZW4gY29tcGFyZSB2IGtleSA+IDAgLT4gbG9vcCBsIGVcbiAgICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPiBsb29wIHIgKE1vcmUgKHYsIGwsIGUpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdCBFbmRcbiAgICA7O1xuXG4gICAgbGV0IGNvbXBhcmUgY29tcGFyZV9lbHQgZTEgZTIgPVxuICAgICAgbGV0IHJlYyBsb29wIGUxIGUyID1cbiAgICAgICAgbWF0Y2ggZTEsIGUyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiAwXG4gICAgICAgIHwgRW5kLCBfIC0+IC0xXG4gICAgICAgIHwgXywgRW5kIC0+IDFcbiAgICAgICAgfCBNb3JlICh2MSwgcjEsIGUxKSwgTW9yZSAodjIsIHIyLCBlMikgLT5cbiAgICAgICAgICBsZXQgYyA9IGNvbXBhcmVfZWx0IHYxIHYyIGluXG4gICAgICAgICAgaWYgYyA8PiAwXG4gICAgICAgICAgdGhlbiBjXG4gICAgICAgICAgZWxzZSBpZiBwaHlzX2VxdWFsIHIxIHIyXG4gICAgICAgICAgdGhlbiBsb29wIGUxIGUyXG4gICAgICAgICAgZWxzZSBsb29wIChjb25zIHIxIGUxKSAoY29ucyByMiBlMilcbiAgICAgIGluXG4gICAgICBsb29wIGUxIGUyXG4gICAgOztcblxuICAgIGxldCByZWMgaXRlciB+ZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVuZCAtPiAoKVxuICAgICAgfCBNb3JlIChhLCB0cmVlLCBlbnVtKSAtPlxuICAgICAgICBmIGE7XG4gICAgICAgIGl0ZXIgKGNvbnMgdHJlZSBlbnVtKSB+ZlxuICAgIDs7XG5cbiAgICBsZXQgaXRlcjIgY29tcGFyZV9lbHQgdDEgdDIgfmYgPVxuICAgICAgbGV0IHJlYyBsb29wIHQxIHQyID1cbiAgICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiAoKVxuICAgICAgICB8IEVuZCwgXyAtPiBpdGVyIHQyIH5mOihmdW4gYSAtPiBmIChgUmlnaHQgYSkpXG4gICAgICAgIHwgXywgRW5kIC0+IGl0ZXIgdDEgfmY6KGZ1biBhIC0+IGYgKGBMZWZ0IGEpKVxuICAgICAgICB8IE1vcmUgKGExLCB0cmVlMSwgZW51bTEpLCBNb3JlIChhMiwgdHJlZTIsIGVudW0yKSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfZWx0IGExIGEyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBmIChgQm90aCAoYTEsIGEyKSk7XG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSAoY29ucyB0cmVlMiBlbnVtMikpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGYgKGBMZWZ0IGExKTtcbiAgICAgICAgICAgIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIHQyKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgZiAoYFJpZ2h0IGEyKTtcbiAgICAgICAgICAgIGxvb3AgdDEgKGNvbnMgdHJlZTIgZW51bTIpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDJcbiAgICA7O1xuXG4gICAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2VsdCA9XG4gICAgICBsZXQgc3RlcCBzdGF0ZSA6ICgoXywgXykgRWl0aGVyLnQsIF8pIFNlcXVlbmNlLlN0ZXAudCA9XG4gICAgICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiBEb25lXG4gICAgICAgIHwgRW5kLCBNb3JlIChlbHQsIHRyZWUsIGVudW0pIC0+IFlpZWxkIChTZWNvbmQgZWx0LCAoRW5kLCBjb25zIHRyZWUgZW51bSkpXG4gICAgICAgIHwgTW9yZSAoZWx0LCB0cmVlLCBlbnVtKSwgRW5kIC0+IFlpZWxkIChGaXJzdCBlbHQsIChjb25zIHRyZWUgZW51bSwgRW5kKSlcbiAgICAgICAgfCAoTW9yZSAoYTEsIHRyZWUxLCBlbnVtMSkgYXMgbGVmdCksIChNb3JlIChhMiwgdHJlZTIsIGVudW0yKSBhcyByaWdodCkgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2VsdCBhMSBhMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5leHRfc3RhdGUgPVxuICAgICAgICAgICAgICBpZiBwaHlzX2VxdWFsIHRyZWUxIHRyZWUyXG4gICAgICAgICAgICAgIHRoZW4gZW51bTEsIGVudW0yXG4gICAgICAgICAgICAgIGVsc2UgY29ucyB0cmVlMSBlbnVtMSwgY29ucyB0cmVlMiBlbnVtMlxuICAgICAgICAgICAgaW5cbiAgICAgICAgICAgIFNraXAgbmV4dF9zdGF0ZSlcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gWWllbGQgKEZpcnN0IGExLCAoY29ucyB0cmVlMSBlbnVtMSwgcmlnaHQpKVxuICAgICAgICAgIGVsc2UgWWllbGQgKFNlY29uZCBhMiwgKGxlZnQsIGNvbnMgdHJlZTIgZW51bTIpKVxuICAgICAgaW5cbiAgICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0OihvZl9zZXQgdDEsIG9mX3NldCB0MikgfmY6c3RlcFxuICAgIDs7XG4gIGVuZFxuXG4gIGxldCB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fZWx0IHQgPVxuICAgIGxldCBuZXh0IGVudW0gPVxuICAgICAgbWF0Y2ggZW51bSB3aXRoXG4gICAgICB8IEVudW0uRW5kIC0+IFNlcXVlbmNlLlN0ZXAuRG9uZVxuICAgICAgfCBFbnVtLk1vcmUgKGssIHQsIGUpIC0+IFNlcXVlbmNlLlN0ZXAuWWllbGQgKGssIEVudW0uY29ucyB0IGUpXG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2VsdCB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl9zZXQgdFxuICAgICAgfCBTb21lIGtleSAtPiBFbnVtLnN0YXJ0aW5nX2F0X2luY3JlYXNpbmcgdCBrZXkgY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIFNlcXVlbmNlLnVuZm9sZF9zdGVwIH5pbml0IH5mOm5leHRcbiAgOztcblxuICBsZXQgdG9fc2VxdWVuY2VfZGVjcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdCB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB0LCBlKSAtPiBTZXF1ZW5jZS5TdGVwLllpZWxkIChrLCBFbnVtLmNvbnNfcmlnaHQgdCBlKVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9lbHQgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2Zfc2V0X3JpZ2h0IHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9kZWNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlXG4gICAgICAgIGNvbXBhcmF0b3JcbiAgICAgICAgPyhvcmRlciA9IGBJbmNyZWFzaW5nKVxuICAgICAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgICA/bGVzc19vcl9lcXVhbF90b1xuICAgICAgICB0XG4gICAgPVxuICAgIGxldCBpbmNsdXNpdmVfYm91bmQgc2lkZSB0IGJvdW5kID1cbiAgICAgIGxldCBjb21wYXJlX2VsdCA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgICBsZXQgbCwgbWF5YmUsIHIgPSBzcGxpdCB0IGJvdW5kIH5jb21wYXJlX2VsdCBpblxuICAgICAgbGV0IHQgPSBzaWRlIChsLCByKSBpblxuICAgICAgbWF0Y2ggbWF5YmUgd2l0aFxuICAgICAgfCBOb25lIC0+IHRcbiAgICAgIHwgU29tZSBlbHQgLT4gYWRkIHQgZWx0IH5jb21wYXJlX2VsdFxuICAgIGluXG4gICAgbWF0Y2ggb3JkZXIgd2l0aFxuICAgIHwgYEluY3JlYXNpbmcgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQgbGVzc19vcl9lcXVhbF90byB+aW5pdDp0IH5mOihpbmNsdXNpdmVfYm91bmQgZnN0KSBpblxuICAgICAgdG9fc2VxdWVuY2VfaW5jcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2VsdDpncmVhdGVyX29yX2VxdWFsX3RvIHRcbiAgICB8IGBEZWNyZWFzaW5nIC0+XG4gICAgICBsZXQgdCA9IE9wdGlvbi5mb2xkIGdyZWF0ZXJfb3JfZXF1YWxfdG8gfmluaXQ6dCB+ZjooaW5jbHVzaXZlX2JvdW5kIHNuZCkgaW5cbiAgICAgIHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9lbHQ6bGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cblxuICBsZXQgcmVjIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIGwgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSB2XG4gICAgICAgIHwgU29tZSBfIGFzIHggLT4geClcbiAgICAgIGVsc2UgZmluZF9maXJzdF9zYXRpc2Z5aW5nIHIgfmZcbiAgOztcblxuICBsZXQgcmVjIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGlmIGYgdiB0aGVuIFNvbWUgdiBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICBpZiBmIHZcbiAgICAgIHRoZW4gKFxuICAgICAgICBtYXRjaCBmaW5kX2xhc3Rfc2F0aXNmeWluZyByIH5mIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IFNvbWUgdlxuICAgICAgICB8IFNvbWUgXyBhcyB4IC0+IHgpXG4gICAgICBlbHNlIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIGwgfmZcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2ID1cbiAgICBtYXRjaCBob3cgd2l0aFxuICAgIHwgYExhc3Rfc3RyaWN0bHlfbGVzc190aGFuIC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDwgMClcbiAgICB8IGBMYXN0X2xlc3NfdGhhbl9vcl9lcXVhbF90byAtPiBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA8PSAwKVxuICAgIHwgYEZpcnN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2ID49IDApIHdpdGhcbiAgICAgICB8IFNvbWUgeCBhcyBlbHQgd2hlbiBjb21wYXJlIHggdiA9IDAgLT4gZWx0XG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgTGFzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB4IC0+IGNvbXBhcmUgeCB2IDw9IDApIHdpdGhcbiAgICAgICB8IFNvbWUgeCBhcyBlbHQgd2hlbiBjb21wYXJlIHggdiA9IDAgLT4gZWx0XG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIHggLT4gY29tcGFyZSB4IHYgPj0gMClcbiAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4geCAtPiBjb21wYXJlIHggdiA+IDApXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBsZXQgaXNfbGVmdCB4ID1cbiAgICAgIG1hdGNoIHNlZ21lbnRfb2YgeCB3aXRoXG4gICAgICB8IGBMZWZ0IC0+IHRydWVcbiAgICAgIHwgYFJpZ2h0IC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgaXNfcmlnaHQgeCA9IG5vdCAoaXNfbGVmdCB4KSBpblxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9vbl9sZWZ0IC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfbGVmdFxuICAgIHwgYEZpcnN0X29uX3JpZ2h0IC0+IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOmlzX3JpZ2h0XG4gIDs7XG5cbiAgbGV0IG1lcmdlX3RvX3NlcXVlbmNlXG4gICAgICAgIGNvbXBhcmF0b3JcbiAgICAgICAgPyhvcmRlciA9IGBJbmNyZWFzaW5nKVxuICAgICAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgICA/bGVzc19vcl9lcXVhbF90b1xuICAgICAgICB0XG4gICAgICAgIHQnXG4gICAgPVxuICAgIFNlcXVlbmNlLm1lcmdlX3dpdGhfZHVwbGljYXRlc1xuICAgICAgKHRvX3NlcXVlbmNlIGNvbXBhcmF0b3Igfm9yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQpXG4gICAgICAodG9fc2VxdWVuY2UgY29tcGFyYXRvciB+b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCcpXG4gICAgICB+Y29tcGFyZTpcbiAgICAgICAgKG1hdGNoIG9yZGVyIHdpdGhcbiAgICAgICAgIHwgYEluY3JlYXNpbmcgLT4gY29tcGFyYXRvci5jb21wYXJlXG4gICAgICAgICB8IGBEZWNyZWFzaW5nIC0+IEZuLmZsaXAgY29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBjb21wYXJlIGNvbXBhcmVfZWx0IHMxIHMyID1cbiAgICBFbnVtLmNvbXBhcmUgY29tcGFyZV9lbHQgKEVudW0ub2Zfc2V0IHMxKSAoRW51bS5vZl9zZXQgczIpXG4gIDs7XG5cbiAgbGV0IGl0ZXIyIHMxIHMyIH5jb21wYXJlX2VsdCA9IEVudW0uaXRlcjIgY29tcGFyZV9lbHQgKEVudW0ub2Zfc2V0IHMxKSAoRW51bS5vZl9zZXQgczIpXG4gIGxldCBlcXVhbCBzMSBzMiB+Y29tcGFyZV9lbHQgPSBjb21wYXJlIGNvbXBhcmVfZWx0IHMxIHMyID0gMFxuXG4gIGxldCBpc19zdWJzZXQgczEgfm9mXzpzMiB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgaXNfc3Vic2V0IHMxIH5vZl86czIgPVxuICAgICAgbWF0Y2ggczEsIHMyIHdpdGhcbiAgICAgIHwgRW1wdHksIF8gLT4gdHJ1ZVxuICAgICAgfCBfLCBFbXB0eSAtPiBmYWxzZVxuICAgICAgfCBMZWFmIHYxLCB0MiAtPiBtZW0gdDIgdjEgfmNvbXBhcmVfZWx0XG4gICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIF8sIF8pLCBMZWFmIHYyIC0+XG4gICAgICAgIChtYXRjaCBsMSwgcjEgd2l0aFxuICAgICAgICAgfCBFbXB0eSwgRW1wdHkgLT5cbiAgICAgICAgICAgKCogVGhpcyBjYXNlIHNob3VsZG4ndCBvY2N1ciBpbiBwcmFjdGljZSBiZWNhdXNlIHdlIHNob3VsZCBoYXZlIGNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgIGEgTGVhZiByYXRoZXIgdGhhbiBhIE5vZGUgd2l0aCB0d28gRW1wdHkgc3VidHJlZXMgKilcbiAgICAgICAgICAgY29tcGFyZV9lbHQgdjEgdjIgPSAwXG4gICAgICAgICB8IF8sIF8gLT4gZmFsc2UpXG4gICAgICB8IE5vZGUgKGwxLCB2MSwgcjEsIF8sIF8pLCAoTm9kZSAobDIsIHYyLCByMiwgXywgXykgYXMgdDIpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9lbHQgdjEgdjIgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgIHBoeXNfZXF1YWwgczEgczIgfHwgKGlzX3N1YnNldCBsMSB+b2ZfOmwyICYmIGlzX3N1YnNldCByMSB+b2ZfOnIyKVxuICAgICAgICAgICgqIE5vdGUgdGhhdCBoZWlnaHQgYW5kIHNpemUgZG9uJ3QgbWF0dGVyIGhlcmUuICopXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBpc19zdWJzZXQgKE5vZGUgKGwxLCB2MSwgRW1wdHksIDAsIDApKSB+b2ZfOmwyICYmIGlzX3N1YnNldCByMSB+b2ZfOnQyXG4gICAgICAgIGVsc2UgaXNfc3Vic2V0IChOb2RlIChFbXB0eSwgdjEsIHIxLCAwLCAwKSkgfm9mXzpyMiAmJiBpc19zdWJzZXQgbDEgfm9mXzp0MlxuICAgIGluXG4gICAgaXNfc3Vic2V0IHMxIH5vZl86czJcbiAgOztcblxuICBsZXQgcmVjIGFyZV9kaXNqb2ludCBzMSBzMiB+Y29tcGFyZV9lbHQgPVxuICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgfCBFbXB0eSwgXyB8IF8sIEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgZWx0LCBvdGhlcl9zZXQgfCBvdGhlcl9zZXQsIExlYWYgZWx0IC0+IG5vdCAobWVtIG90aGVyX3NldCBlbHQgfmNvbXBhcmVfZWx0KVxuICAgIHwgTm9kZSAobDEsIHYxLCByMSwgXywgXyksIHQyIC0+XG4gICAgICBpZiBwaHlzX2VxdWFsIHMxIHMyXG4gICAgICB0aGVuIGZhbHNlXG4gICAgICBlbHNlIChcbiAgICAgICAgbWF0Y2ggc3BsaXQgdDIgdjEgfmNvbXBhcmVfZWx0IHdpdGhcbiAgICAgICAgfCBsMiwgTm9uZSwgcjIgLT5cbiAgICAgICAgICBhcmVfZGlzam9pbnQgbDEgbDIgfmNvbXBhcmVfZWx0ICYmIGFyZV9kaXNqb2ludCByMSByMiB+Y29tcGFyZV9lbHRcbiAgICAgICAgfCBfLCBTb21lIF8sIF8gLT4gZmFsc2UpXG4gIDs7XG5cbiAgbGV0IGl0ZXIgdCB+ZiA9XG4gICAgbGV0IHJlYyBpdGVyID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgIHwgTGVhZiB2IC0+IGYgdlxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBpdGVyIGw7XG4gICAgICAgIGYgdjtcbiAgICAgICAgaXRlciByXG4gICAgaW5cbiAgICBpdGVyIHRcbiAgOztcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgPSBFbnVtLnN5bW1ldHJpY19kaWZmXG5cbiAgbGV0IHJlYyBmb2xkIHMgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmIHYgLT4gZiBhY2N1IHZcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGZvbGQgfmYgciB+aW5pdDooZiAoZm9sZCB+ZiBsIH5pbml0OmFjY3UpIHYpXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF90X2lnbm9yaW5nX3N0cnVjdHVyZSBoYXNoX2ZvbGRfZWxlbSBzdGF0ZSB0ID1cbiAgICBmb2xkIHQgfmluaXQ6KGhhc2hfZm9sZF9pbnQgc3RhdGUgKGxlbmd0aCB0KSkgfmY6aGFzaF9mb2xkX2VsZW1cbiAgOztcblxuICBsZXQgY291bnQgdCB+ZiA9IENvbnRhaW5lci5jb3VudCB+Zm9sZCB0IH5mXG4gIGxldCBzdW0gbSB0IH5mID0gQ29udGFpbmVyLnN1bSB+Zm9sZCBtIHQgfmZcblxuICBsZXQgcmVjIGZvbGRfcmlnaHQgcyB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgdiAtPiBmIHYgYWNjdVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gZm9sZF9yaWdodCB+ZiBsIH5pbml0OihmIHYgKGZvbGRfcmlnaHQgfmYgciB+aW5pdDphY2N1KSlcbiAgOztcblxuICBsZXQgcmVjIGZvcl9hbGwgdCB+ZjpwID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IExlYWYgdiAtPiBwIHZcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IHAgdiAmJiBmb3JfYWxsIH5mOnAgbCAmJiBmb3JfYWxsIH5mOnAgclxuICA7O1xuXG4gIGxldCByZWMgZXhpc3RzIHQgfmY6cCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBmYWxzZVxuICAgIHwgTGVhZiB2IC0+IHAgdlxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT4gcCB2IHx8IGV4aXN0cyB+ZjpwIGwgfHwgZXhpc3RzIH5mOnAgclxuICA7O1xuXG4gIGxldCBmaWx0ZXIgcyB+ZjpwIH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBmaWx0IGFjY3UgPSBmdW5jdGlvblxuICAgICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgICB8IExlYWYgdiAtPiBpZiBwIHYgdGhlbiBhZGQgYWNjdSB2IH5jb21wYXJlX2VsdCBlbHNlIGFjY3VcbiAgICAgIHwgTm9kZSAobCwgdiwgciwgXywgXykgLT5cbiAgICAgICAgZmlsdCAoZmlsdCAoaWYgcCB2IHRoZW4gYWRkIGFjY3UgdiB+Y29tcGFyZV9lbHQgZWxzZSBhY2N1KSBsKSByXG4gICAgaW5cbiAgICBmaWx0IEVtcHR5IHNcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCBzIH5mOnAgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGZpbHQgYWNjdSA9IGZ1bmN0aW9uXG4gICAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICAgIHwgTGVhZiB2IC0+XG4gICAgICAgIChtYXRjaCBwIHYgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IGFjY3VcbiAgICAgICAgIHwgU29tZSB2IC0+IGFkZCBhY2N1IHYgfmNvbXBhcmVfZWx0KVxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBmaWx0XG4gICAgICAgICAgKGZpbHRcbiAgICAgICAgICAgICAobWF0Y2ggcCB2IHdpdGhcbiAgICAgICAgICAgICAgfCBOb25lIC0+IGFjY3VcbiAgICAgICAgICAgICAgfCBTb21lIHYgLT4gYWRkIGFjY3UgdiB+Y29tcGFyZV9lbHQpXG4gICAgICAgICAgICAgbClcbiAgICAgICAgICByXG4gICAgaW5cbiAgICBmaWx0IEVtcHR5IHNcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIHMgfmY6cCB+Y29tcGFyZV9lbHQgPVxuICAgIGxldCByZWMgcGFydCAoKHQsIGYpIGFzIGFjY3UpID0gZnVuY3Rpb25cbiAgICAgIHwgRW1wdHkgLT4gYWNjdVxuICAgICAgfCBMZWFmIHYgLT4gaWYgcCB2IHRoZW4gYWRkIHQgdiB+Y29tcGFyZV9lbHQsIGYgZWxzZSB0LCBhZGQgZiB2IH5jb21wYXJlX2VsdFxuICAgICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgICBwYXJ0IChwYXJ0IChpZiBwIHYgdGhlbiBhZGQgdCB2IH5jb21wYXJlX2VsdCwgZiBlbHNlIHQsIGFkZCBmIHYgfmNvbXBhcmVfZWx0KSBsKSByXG4gICAgaW5cbiAgICBwYXJ0IChFbXB0eSwgRW1wdHkpIHNcbiAgOztcblxuICBsZXQgcmVjIGVsZW1lbnRzX2F1eCBhY2N1ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgdiAtPiB2IDo6IGFjY3VcbiAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+IGVsZW1lbnRzX2F1eCAodiA6OiBlbGVtZW50c19hdXggYWNjdSByKSBsXG4gIDs7XG5cbiAgbGV0IGVsZW1lbnRzIHMgPSBlbGVtZW50c19hdXggW10gc1xuXG4gIGxldCBjaG9vc2UgdCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gU29tZSB2XG4gICAgfCBOb2RlIChfLCB2LCBfLCBfLCBfKSAtPiBTb21lIHZcbiAgOztcblxuICBsZXQgY2hvb3NlX2V4biA9XG4gICAgbGV0IG5vdF9mb3VuZCA9IE5vdF9mb3VuZF9zIChBdG9tIFwiU2V0LmNob29zZV9leG46IGVtcHR5IHNldFwiKSBpblxuICAgIGxldCBjaG9vc2VfZXhuIHQgPVxuICAgICAgbWF0Y2ggY2hvb3NlIHQgd2l0aFxuICAgICAgfCBOb25lIC0+IHJhaXNlIG5vdF9mb3VuZFxuICAgICAgfCBTb21lIHYgLT4gdlxuICAgIGluXG4gICAgKCogbmFtZWQgdG8gcHJlc2VydmUgc3ltYm9sIGluIGNvbXBpbGVkIGJpbmFyeSAqKVxuICAgIGNob29zZV9leG5cbiAgOztcblxuICBsZXQgb2ZfbGlzdCBsc3QgfmNvbXBhcmVfZWx0ID1cbiAgICBMaXN0LmZvbGQgbHN0IH5pbml0OmVtcHR5IH5mOihmdW4gdCB4IC0+IGFkZCB0IHggfmNvbXBhcmVfZWx0KVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSBzZXF1ZW5jZSB+Y29tcGFyZV9lbHQgPVxuICAgIFNlcXVlbmNlLmZvbGQgc2VxdWVuY2UgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgeCB+Y29tcGFyZV9lbHQpXG4gIDs7XG5cbiAgbGV0IHRvX2xpc3QgcyA9IGVsZW1lbnRzIHNcblxuICBsZXQgb2ZfYXJyYXkgYSB+Y29tcGFyZV9lbHQgPVxuICAgIEFycmF5LmZvbGQgYSB+aW5pdDplbXB0eSB+ZjooZnVuIHQgeCAtPiBhZGQgdCB4IH5jb21wYXJlX2VsdClcbiAgOztcblxuICAoKiBmYXN0ZXIgYnV0IGVxdWl2YWxlbnQgdG8gW0FycmF5Lm9mX2xpc3QgKHRvX2xpc3QgdCldICopXG4gIGxldCB0b19hcnJheSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBbfHxdXG4gICAgfCBMZWFmIHYgLT4gW3wgdiB8XVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgcykgLT5cbiAgICAgIGxldCByZXMgPSBBcnJheS5jcmVhdGUgfmxlbjpzIHYgaW5cbiAgICAgIGxldCBwb3NfcmVmID0gcmVmIDAgaW5cbiAgICAgIGxldCByZWMgbG9vcCA9IGZ1bmN0aW9uXG4gICAgICAgICgqIEludmFyaWFudDogb24gZW50cnkgYW5kIG9uIGV4aXQgdG8gW2xvb3BdLCAhcG9zX3JlZiBpcyB0aGUgbmV4dFxuICAgICAgICAgICBhdmFpbGFibGUgY2VsbCBpbiB0aGUgYXJyYXkuICopXG4gICAgICAgIHwgRW1wdHkgLT4gKClcbiAgICAgICAgfCBMZWFmIHYgLT5cbiAgICAgICAgICByZXMuKCFwb3NfcmVmKSA8LSB2O1xuICAgICAgICAgIGluY3IgcG9zX3JlZlxuICAgICAgICB8IE5vZGUgKGwsIHYsIHIsIF8sIF8pIC0+XG4gICAgICAgICAgbG9vcCBsO1xuICAgICAgICAgIHJlcy4oIXBvc19yZWYpIDwtIHY7XG4gICAgICAgICAgaW5jciBwb3NfcmVmO1xuICAgICAgICAgIGxvb3AgclxuICAgICAgaW5cbiAgICAgIGxvb3AgbDtcbiAgICAgICgqIHJlcy4oIXBvc19yZWYpIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQgKGJ5IEFycmF5LmNyZWF0ZSB+bGVuOmFib3ZlKS4gKilcbiAgICAgIGluY3IgcG9zX3JlZjtcbiAgICAgIGxvb3AgcjtcbiAgICAgIHJlc1xuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiB+Y29tcGFyZV9lbHQgPSBmb2xkIHQgfmluaXQ6ZW1wdHkgfmY6KGZ1biB0IHggLT4gYWRkIHQgKGYgeCkgfmNvbXBhcmVfZWx0KVxuXG4gIGxldCBncm91cF9ieSBzZXQgfmVxdWl2IH5jb21wYXJlX2VsdCA9XG4gICAgbGV0IHJlYyBsb29wIHNldCBlcXVpdl9jbGFzc2VzID1cbiAgICAgIGlmIGlzX2VtcHR5IHNldFxuICAgICAgdGhlbiBlcXVpdl9jbGFzc2VzXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHggPSBjaG9vc2VfZXhuIHNldCBpblxuICAgICAgICBsZXQgZXF1aXZfeCwgbm90X2VxdWl2X3ggPVxuICAgICAgICAgIHBhcnRpdGlvbl90ZiBzZXQgfmY6KGZ1biBlbHQgLT4gcGh5c19lcXVhbCB4IGVsdCB8fCBlcXVpdiB4IGVsdCkgfmNvbXBhcmVfZWx0XG4gICAgICAgIGluXG4gICAgICAgIGxvb3Agbm90X2VxdWl2X3ggKGVxdWl2X3ggOjogZXF1aXZfY2xhc3NlcykpXG4gICAgaW5cbiAgICBsb29wIHNldCBbXVxuICA7O1xuXG4gIGxldCByZWMgZmluZCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgdiAtPiBpZiBmIHYgdGhlbiBTb21lIHYgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgaWYgZiB2XG4gICAgICB0aGVuIFNvbWUgdlxuICAgICAgZWxzZSAoXG4gICAgICAgIG1hdGNoIGZpbmQgbCB+ZiB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiBmaW5kIHIgfmZcbiAgICAgICAgfCBTb21lIF8gYXMgciAtPiByKVxuICA7O1xuXG4gIGxldCByZWMgZmluZF9tYXAgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIHYgLT4gZiB2XG4gICAgfCBOb2RlIChsLCB2LCByLCBfLCBfKSAtPlxuICAgICAgKG1hdGNoIGYgdiB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgciAtPiByXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICAobWF0Y2ggZmluZF9tYXAgbCB+ZiB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGZpbmRfbWFwIHIgfmZcbiAgICAgICAgICB8IFNvbWUgXyBhcyByIC0+IHIpKVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB0IH5mID1cbiAgICBtYXRjaCBmaW5kIHQgfmYgd2l0aFxuICAgIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlNldC5maW5kX2V4biBmYWlsZWQgdG8gZmluZCBhIG1hdGNoaW5nIGVsZW1lbnRcIlxuICAgIHwgU29tZSBlIC0+IGVcbiAgOztcblxuICBsZXQgcmVjIG50aCB0IGkgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gTm9uZVxuICAgIHwgTGVhZiB2IC0+IGlmIGkgPSAwIHRoZW4gU29tZSB2IGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgdiwgciwgXywgcykgLT5cbiAgICAgIGlmIGkgPj0gc1xuICAgICAgdGhlbiBOb25lXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGxfc2l6ZSA9IGxlbmd0aCBsIGluXG4gICAgICAgIGxldCBjID0gUG9seS5jb21wYXJlIGkgbF9zaXplIGluXG4gICAgICAgIGlmIGMgPCAwIHRoZW4gbnRoIGwgaSBlbHNlIGlmIGMgPSAwIHRoZW4gU29tZSB2IGVsc2UgbnRoIHIgKGkgLSBsX3NpemUgLSAxKSlcbiAgOztcblxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgeHMgfmNvbXBhcmVfZWx0ID1cbiAgICBsZXQgcmVjIGxvb3AgeHMgbGVmdG92ZXJzIGFscmVhZHlfc2VlbiA9XG4gICAgICBtYXRjaCB4cyB3aXRoXG4gICAgICB8IFtdIC0+IExpc3QucmV2IGxlZnRvdmVyc1xuICAgICAgfCBoZCA6OiB0bCAtPlxuICAgICAgICBpZiBtZW0gYWxyZWFkeV9zZWVuIGhkIH5jb21wYXJlX2VsdFxuICAgICAgICB0aGVuIGxvb3AgdGwgbGVmdG92ZXJzIGFscmVhZHlfc2VlblxuICAgICAgICBlbHNlIGxvb3AgdGwgKGhkIDo6IGxlZnRvdmVycykgKGFkZCBhbHJlYWR5X3NlZW4gaGQgfmNvbXBhcmVfZWx0KVxuICAgIGluXG4gICAgbG9vcCB4cyBbXSBlbXB0eVxuICA7O1xuXG4gIGxldCB0X29mX3NleHBfZGlyZWN0IGFfb2Zfc2V4cCBzZXhwIH5jb21wYXJlX2VsdCA9XG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBTZXhwLkxpc3QgbHN0IC0+XG4gICAgICBsZXQgZWx0X2xzdCA9IExpc3QubWFwIGxzdCB+ZjphX29mX3NleHAgaW5cbiAgICAgIGxldCBzZXQgPSBvZl9saXN0IGVsdF9sc3QgfmNvbXBhcmVfZWx0IGluXG4gICAgICBpZiBsZW5ndGggc2V0ID0gTGlzdC5sZW5ndGggbHN0XG4gICAgICB0aGVuIHNldFxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBzZXQgPSByZWYgZW1wdHkgaW5cbiAgICAgICAgTGlzdC5pdGVyMl9leG4gbHN0IGVsdF9sc3QgfmY6KGZ1biBlbF9zZXhwIGVsIC0+XG4gICAgICAgICAgaWYgbWVtICFzZXQgZWwgfmNvbXBhcmVfZWx0XG4gICAgICAgICAgdGhlbiBvZl9zZXhwX2Vycm9yIFwiU2V0LnRfb2Zfc2V4cDogZHVwbGljYXRlIGVsZW1lbnQgaW4gc2V0XCIgZWxfc2V4cFxuICAgICAgICAgIGVsc2Ugc2V0IDo9IGFkZCAhc2V0IGVsIH5jb21wYXJlX2VsdCk7XG4gICAgICAgIGFzc2VydCBmYWxzZSlcbiAgICB8IHNleHAgLT4gb2Zfc2V4cF9lcnJvciBcIlNldC50X29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPVxuICAgIFNleHAuTGlzdCAoZm9sZF9yaWdodCB0IH5pbml0OltdIH5mOihmdW4gZWwgYWNjIC0+IHNleHBfb2ZfYSBlbCA6OiBhY2MpKVxuICA7O1xuXG4gIG1vZHVsZSBOYW1lZCA9IHN0cnVjdFxuICAgIHR5cGUgbm9ucmVjICgnYSwgJ2NtcCkgdCA9XG4gICAgICB7IHRyZWUgOiAnYSB0XG4gICAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICAgIH1cblxuICAgIGxldCBpc19zdWJzZXQgKHN1YnNldCA6IF8gdCkgfm9mXzooc3VwZXJzZXQgOiBfIHQpIH5zZXhwX29mX2VsdCB+Y29tcGFyZV9lbHQgPVxuICAgICAgbGV0IGludmFsaWRfZWxlbWVudHMgPSBkaWZmIHN1YnNldC50cmVlIHN1cGVyc2V0LnRyZWUgfmNvbXBhcmVfZWx0IGluXG4gICAgICBpZiBpc19lbXB0eSBpbnZhbGlkX2VsZW1lbnRzXG4gICAgICB0aGVuIE9rICgpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IGludmFsaWRfZWxlbWVudHNfc2V4cCA9IHNleHBfb2ZfdCBzZXhwX29mX2VsdCBpbnZhbGlkX2VsZW1lbnRzIGluXG4gICAgICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgKHN1YnNldC5uYW1lIF4gXCIgaXMgbm90IGEgc3Vic2V0IG9mIFwiIF4gc3VwZXJzZXQubmFtZSlcbiAgICAgICAgICAgICBbIFwiaW52YWxpZF9lbGVtZW50c1wiLCBpbnZhbGlkX2VsZW1lbnRzX3NleHAgXSkpXG4gICAgOztcblxuICAgIGxldCBlcXVhbCBzMSBzMiB+c2V4cF9vZl9lbHQgfmNvbXBhcmVfZWx0ID1cbiAgICAgIE9yX2Vycm9yLmNvbWJpbmVfZXJyb3JzX3VuaXRcbiAgICAgICAgWyBpc19zdWJzZXQgczEgfm9mXzpzMiB+c2V4cF9vZl9lbHQgfmNvbXBhcmVfZWx0XG4gICAgICAgIDsgaXNfc3Vic2V0IHMyIH5vZl86czEgfnNleHBfb2ZfZWx0IH5jb21wYXJlX2VsdFxuICAgICAgICBdXG4gICAgOztcbiAgZW5kXG5lbmRcblxudHlwZSAoJ2EsICdjb21wYXJhdG9yKSB0ID1cbiAgeyAoKiBbY29tcGFyYXRvcl0gaXMgdGhlIGZpcnN0IGZpZWxkIHNvIHRoYXQgcG9seW1vcnBoaWMgZXF1YWxpdHkgZmFpbHMgb24gYSBtYXAgZHVlXG4gICAgICAgdG8gdGhlIGZ1bmN0aW9uYWwgdmFsdWUgaW4gdGhlIGNvbXBhcmF0b3IuXG4gICAgICAgTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgYWZmZWN0IHBvbHltb3JwaGljIFtjb21wYXJlXTogdGhhdCBzdGlsbCBwcm9kdWNlc1xuICAgICAgIG5vbnNlbnNlLiAqKVxuICAgIGNvbXBhcmF0b3IgOiAoJ2EsICdjb21wYXJhdG9yKSBDb21wYXJhdG9yLnRcbiAgOyB0cmVlIDogJ2EgVHJlZTAudFxuICB9XG5cbnR5cGUgKCdhLCAnY29tcGFyYXRvcikgdHJlZSA9ICdhIFRyZWUwLnRcblxubGV0IGxpa2UgeyB0cmVlID0gXzsgY29tcGFyYXRvciB9IHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3IgfVxubGV0IGNvbXBhcmVfZWx0IHQgPSB0LmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGNvbXBhcmF0b3IgdCA9IHQuY29tcGFyYXRvclxuICBsZXQgaW52YXJpYW50cyB0ID0gVHJlZTAuaW52YXJpYW50cyB0LnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KVxuICBsZXQgbGVuZ3RoIHQgPSBUcmVlMC5sZW5ndGggdC50cmVlXG4gIGxldCBpc19lbXB0eSB0ID0gVHJlZTAuaXNfZW1wdHkgdC50cmVlXG4gIGxldCBlbGVtZW50cyB0ID0gVHJlZTAuZWxlbWVudHMgdC50cmVlXG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHQudHJlZVxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHQudHJlZVxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0LnRyZWVcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0LnRyZWVcbiAgbGV0IGNob29zZSB0ID0gVHJlZTAuY2hvb3NlIHQudHJlZVxuICBsZXQgY2hvb3NlX2V4biB0ID0gVHJlZTAuY2hvb3NlX2V4biB0LnRyZWVcbiAgbGV0IHRvX2xpc3QgdCA9IFRyZWUwLnRvX2xpc3QgdC50cmVlXG4gIGxldCB0b19hcnJheSB0ID0gVHJlZTAudG9fYXJyYXkgdC50cmVlXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkIHQudHJlZSB+aW5pdCB+ZlxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF91bnRpbCB0LnRyZWUgfmluaXQgfmZcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdC50cmVlIH5pbml0IH5mXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbiAgbGV0IGl0ZXIgdCB+ZiA9IFRyZWUwLml0ZXIgdC50cmVlIH5mXG4gIGxldCBpdGVyMiBhIGIgfmYgPSBUcmVlMC5pdGVyMiBhLnRyZWUgYi50cmVlIH5mIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgYSlcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQudHJlZSB+ZlxuICBsZXQgZm9yX2FsbCB0IH5mID0gVHJlZTAuZm9yX2FsbCB0LnRyZWUgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBUcmVlMC5jb3VudCB0LnRyZWUgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBUcmVlMC5zdW0gbSB0LnRyZWUgfmZcbiAgbGV0IGZpbmQgdCB+ZiA9IFRyZWUwLmZpbmQgdC50cmVlIH5mXG4gIGxldCBmaW5kX2V4biB0IH5mID0gVHJlZTAuZmluZF9leG4gdC50cmVlIH5mXG4gIGxldCBmaW5kX21hcCB0IH5mID0gVHJlZTAuZmluZF9tYXAgdC50cmVlIH5mXG4gIGxldCBtZW0gdCBhID0gVHJlZTAubWVtIHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdClcbiAgbGV0IGZpbHRlciB0IH5mID0gbGlrZSB0IChUcmVlMC5maWx0ZXIgdC50cmVlIH5mIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCBhZGQgdCBhID0gbGlrZSB0IChUcmVlMC5hZGQgdC50cmVlIGEgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSlcbiAgbGV0IHJlbW92ZSB0IGEgPSBsaWtlIHQgKFRyZWUwLnJlbW92ZSB0LnRyZWUgYSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQpKVxuICBsZXQgdW5pb24gdDEgdDIgPSBsaWtlIHQxIChUcmVlMC51bmlvbiB0MS50cmVlIHQyLnRyZWUgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0MSkpXG4gIGxldCBpbnRlciB0MSB0MiA9IGxpa2UgdDEgKFRyZWUwLmludGVyIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKSlcbiAgbGV0IGRpZmYgdDEgdDIgPSBsaWtlIHQxIChUcmVlMC5kaWZmIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKSlcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9lbHQ6KGNvbXBhcmVfZWx0IHQxKVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2RpcmVjdCB0MSB0MiA9IFRyZWUwLmNvbXBhcmUgKGNvbXBhcmVfZWx0IHQxKSB0MS50cmVlIHQyLnRyZWVcbiAgbGV0IGVxdWFsIHQxIHQyID0gVHJlZTAuZXF1YWwgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpXG4gIGxldCBpc19zdWJzZXQgdCB+b2ZfID0gVHJlZTAuaXNfc3Vic2V0IHQudHJlZSB+b2ZfOm9mXy50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdClcblxuICBsZXQgYXJlX2Rpc2pvaW50IHQxIHQyID1cbiAgICBUcmVlMC5hcmVfZGlzam9pbnQgdDEudHJlZSB0Mi50cmVlIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdDEpXG4gIDs7XG5cbiAgbW9kdWxlIE5hbWVkID0gc3RydWN0XG4gICAgdHlwZSBub25yZWMgKCdhLCAnY21wKSB0ID1cbiAgICAgIHsgc2V0IDogKCdhLCAnY21wKSB0XG4gICAgICA7IG5hbWUgOiBzdHJpbmdcbiAgICAgIH1cblxuICAgIGxldCB0b19uYW1lZF90cmVlIHsgc2V0OyBuYW1lIH0gPSB7IFRyZWUwLk5hbWVkLnRyZWUgPSBzZXQudHJlZTsgbmFtZSB9XG5cbiAgICBsZXQgaXNfc3Vic2V0IChzdWJzZXQgOiAoXywgXykgdCkgfm9mXzooc3VwZXJzZXQgOiAoXywgXykgdCkgPVxuICAgICAgVHJlZTAuTmFtZWQuaXNfc3Vic2V0XG4gICAgICAgICh0b19uYW1lZF90cmVlIHN1YnNldClcbiAgICAgICAgfm9mXzoodG9fbmFtZWRfdHJlZSBzdXBlcnNldClcbiAgICAgICAgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCBzdWJzZXQuc2V0KVxuICAgICAgICB+c2V4cF9vZl9lbHQ6c3Vic2V0LnNldC5jb21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgdDEgdDIgPVxuICAgICAgT3JfZXJyb3IuY29tYmluZV9lcnJvcnNfdW5pdCBbIGlzX3N1YnNldCB0MSB+b2ZfOnQyOyBpc19zdWJzZXQgdDIgfm9mXzp0MSBdXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mID1cbiAgICBsZXQgdHJlZV90LCB0cmVlX2YgPSBUcmVlMC5wYXJ0aXRpb25fdGYgdC50cmVlIH5mIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkgaW5cbiAgICBsaWtlIHQgdHJlZV90LCBsaWtlIHQgdHJlZV9mXG4gIDs7XG5cbiAgbGV0IHNwbGl0IHQgYSA9XG4gICAgbGV0IHRyZWUxLCBiLCB0cmVlMiA9IFRyZWUwLnNwbGl0IHQudHJlZSBhIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkgaW5cbiAgICBsaWtlIHQgdHJlZTEsIGIsIGxpa2UgdCB0cmVlMlxuICA7O1xuXG4gIGxldCBncm91cF9ieSB0IH5lcXVpdiA9XG4gICAgTGlzdC5tYXAgKFRyZWUwLmdyb3VwX2J5IHQudHJlZSB+ZXF1aXYgfmNvbXBhcmVfZWx0Oihjb21wYXJlX2VsdCB0KSkgfmY6KGxpa2UgdClcbiAgOztcblxuICBsZXQgbnRoIHQgaSA9IFRyZWUwLm50aCB0LnRyZWUgaVxuICBsZXQgcmVtb3ZlX2luZGV4IHQgaSA9IGxpa2UgdCAoVHJlZTAucmVtb3ZlX2luZGV4IHQudHJlZSBpIH5jb21wYXJlX2VsdDooY29tcGFyZV9lbHQgdCkpXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2EgdC50cmVlXG5cbiAgbGV0IHRvX3NlcXVlbmNlID9vcmRlciA/Z3JlYXRlcl9vcl9lcXVhbF90byA/bGVzc19vcl9lcXVhbF90byB0ID1cbiAgICBUcmVlMC50b19zZXF1ZW5jZSB0LmNvbXBhcmF0b3IgP29yZGVyID9ncmVhdGVyX29yX2VxdWFsX3RvID9sZXNzX29yX2VxdWFsX3RvIHQudHJlZVxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIHQgfmNvbXBhcmUgaG93IHYgPSBUcmVlMC5iaW5hcnlfc2VhcmNoIHQudHJlZSB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvdyA9XG4gICAgVHJlZTAuYmluYXJ5X3NlYXJjaF9zZWdtZW50ZWQgdC50cmVlIH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBtZXJnZV90b19zZXF1ZW5jZSA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCB0JyA9XG4gICAgVHJlZTAubWVyZ2VfdG9fc2VxdWVuY2VcbiAgICAgIHQuY29tcGFyYXRvclxuICAgICAgP29yZGVyXG4gICAgICA/Z3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgP2xlc3Nfb3JfZXF1YWxfdG9cbiAgICAgIHQudHJlZVxuICAgICAgdCcudHJlZVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfZGlyZWN0IGhhc2hfZm9sZF9rZXkgc3RhdGUgdCA9XG4gICAgVHJlZTAuaGFzaF9mb2xkX3RfaWdub3Jpbmdfc3RydWN0dXJlIGhhc2hfZm9sZF9rZXkgc3RhdGUgdC50cmVlXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBBY2Nlc3NvcnNcblxubGV0IGNvbXBhcmUgXyBfIHQxIHQyID0gY29tcGFyZV9kaXJlY3QgdDEgdDJcblxubW9kdWxlIFRyZWUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2EsICdjb21wYXJhdG9yKSB0ID0gKCdhLCAnY29tcGFyYXRvcikgdHJlZVxuXG4gIGxldCBjZSBjb21wYXJhdG9yID0gY29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgdF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvciBhX29mX3NleHAgc2V4cCA9XG4gICAgVHJlZTAudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpIGFfb2Zfc2V4cCBzZXhwXG4gIDs7XG5cbiAgbGV0IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gPSBUcmVlMC5lbXB0eVxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3I6XyA9IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb25cbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvcjpfIGUgPSBUcmVlMC5zaW5nbGV0b24gZVxuICBsZXQgbGVuZ3RoIHQgPSBUcmVlMC5sZW5ndGggdFxuICBsZXQgaW52YXJpYW50cyB+Y29tcGFyYXRvciB0ID0gVHJlZTAuaW52YXJpYW50cyB0IH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGlzX2VtcHR5IHQgPSBUcmVlMC5pc19lbXB0eSB0XG4gIGxldCBlbGVtZW50cyB0ID0gVHJlZTAuZWxlbWVudHMgdFxuICBsZXQgbWluX2VsdCB0ID0gVHJlZTAubWluX2VsdCB0XG4gIGxldCBtaW5fZWx0X2V4biB0ID0gVHJlZTAubWluX2VsdF9leG4gdFxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0XG4gIGxldCBtYXhfZWx0X2V4biB0ID0gVHJlZTAubWF4X2VsdF9leG4gdFxuICBsZXQgY2hvb3NlIHQgPSBUcmVlMC5jaG9vc2UgdFxuICBsZXQgY2hvb3NlX2V4biB0ID0gVHJlZTAuY2hvb3NlX2V4biB0XG4gIGxldCB0b19saXN0IHQgPSBUcmVlMC50b19saXN0IHRcbiAgbGV0IHRvX2FycmF5IHQgPSBUcmVlMC50b19hcnJheSB0XG4gIGxldCBpdGVyIHQgfmYgPSBUcmVlMC5pdGVyIHQgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQgfmZcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdCB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQgfmZcbiAgbGV0IHN1bSBtIHQgfmYgPSBUcmVlMC5zdW0gbSB0IH5mXG4gIGxldCBmaW5kIHQgfmYgPSBUcmVlMC5maW5kIHQgfmZcbiAgbGV0IGZpbmRfZXhuIHQgfmYgPSBUcmVlMC5maW5kX2V4biB0IH5mXG4gIGxldCBmaW5kX21hcCB0IH5mID0gVHJlZTAuZmluZF9tYXAgdCB+ZlxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZCB0IH5pbml0IH5mXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3VudGlsIHQgfmluaXQgfmZcbiAgbGV0IGZvbGRfcmlnaHQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfcmlnaHQgdCB+aW5pdCB+ZlxuICBsZXQgbWFwIH5jb21wYXJhdG9yIHQgfmYgPSBUcmVlMC5tYXAgdCB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBmaWx0ZXIgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLmZpbHRlciB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGZpbHRlcl9tYXAgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLmZpbHRlcl9tYXAgdCB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBwYXJ0aXRpb25fdGYgfmNvbXBhcmF0b3IgdCB+ZiA9IFRyZWUwLnBhcnRpdGlvbl90ZiB0IH5mIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGl0ZXIyIH5jb21wYXJhdG9yIGEgYiB+ZiA9IFRyZWUwLml0ZXIyIGEgYiB+ZiB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBtZW0gfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAubWVtIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBhZGQgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAuYWRkIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCByZW1vdmUgfmNvbXBhcmF0b3IgdCBhID0gVHJlZTAucmVtb3ZlIHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCB1bmlvbiB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLnVuaW9uIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGludGVyIH5jb21wYXJhdG9yIHQxIHQyID0gVHJlZTAuaW50ZXIgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgZGlmZiB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmRpZmYgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuXG4gIGxldCBzeW1tZXRyaWNfZGlmZiB+Y29tcGFyYXRvciB0MSB0MiA9XG4gICAgVHJlZTAuc3ltbWV0cmljX2RpZmYgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBjb21wYXJlX2RpcmVjdCB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmNvbXBhcmUgKGNlIGNvbXBhcmF0b3IpIHQxIHQyXG4gIGxldCBlcXVhbCB+Y29tcGFyYXRvciB0MSB0MiA9IFRyZWUwLmVxdWFsIHQxIHQyIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IGlzX3N1YnNldCB+Y29tcGFyYXRvciB0IH5vZl8gPSBUcmVlMC5pc19zdWJzZXQgdCB+b2ZfIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcblxuICBsZXQgYXJlX2Rpc2pvaW50IH5jb21wYXJhdG9yIHQxIHQyID1cbiAgICBUcmVlMC5hcmVfZGlzam9pbnQgdDEgdDIgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9saXN0IH5jb21wYXJhdG9yIGwgPSBUcmVlMC5vZl9saXN0IGwgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3IgcyA9IFRyZWUwLm9mX3NlcXVlbmNlIHMgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgb2ZfYXJyYXkgfmNvbXBhcmF0b3IgYSA9IFRyZWUwLm9mX2FycmF5IGEgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGEgPVxuICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yOl8gfmxlbiB+ZiA9XG4gICAgVHJlZTAub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZlxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYSA9IFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhIH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgbCA9IFRyZWUwLnVuaW9uX2xpc3QgbCB+dG9fdHJlZTpGbi5pZCB+Y29tcGFyYXRvclxuXG4gIGxldCBzdGFibGVfZGVkdXBfbGlzdCB+Y29tcGFyYXRvciB4cyA9XG4gICAgVHJlZTAuc3RhYmxlX2RlZHVwX2xpc3QgeHMgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBncm91cF9ieSB+Y29tcGFyYXRvciB0IH5lcXVpdiA9IFRyZWUwLmdyb3VwX2J5IHQgfmVxdWl2IH5jb21wYXJlX2VsdDooY2UgY29tcGFyYXRvcilcbiAgbGV0IHNwbGl0IH5jb21wYXJhdG9yIHQgYSA9IFRyZWUwLnNwbGl0IHQgYSB+Y29tcGFyZV9lbHQ6KGNlIGNvbXBhcmF0b3IpXG4gIGxldCBudGggdCBpID0gVHJlZTAubnRoIHQgaVxuICBsZXQgcmVtb3ZlX2luZGV4IH5jb21wYXJhdG9yIHQgaSA9IFRyZWUwLnJlbW92ZV9pbmRleCB0IGkgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfYSBfIHQgPSBUcmVlMC5zZXhwX29mX3Qgc2V4cF9vZl9hIHRcbiAgbGV0IHRvX3RyZWUgdCA9IHRcbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3I6XyB0ID0gdFxuXG4gIGxldCB0b19zZXF1ZW5jZSB+Y29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCA9XG4gICAgVHJlZTAudG9fc2VxdWVuY2UgY29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdFxuICA7O1xuXG4gIGxldCBiaW5hcnlfc2VhcmNoIH5jb21wYXJhdG9yOl8gdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdlxuXG4gIGxldCBiaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB+Y29tcGFyYXRvcjpfIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0IH5zZWdtZW50X29mIGhvd1xuICA7O1xuXG4gIGxldCBtZXJnZV90b19zZXF1ZW5jZSB+Y29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCB0JyA9XG4gICAgVHJlZTAubWVyZ2VfdG9fc2VxdWVuY2UgY29tcGFyYXRvciA/b3JkZXIgP2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2xlc3Nfb3JfZXF1YWxfdG8gdCB0J1xuICA7O1xuXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcblxuICBtb2R1bGUgTmFtZWQgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIFRyZWUwLk5hbWVkXG5cbiAgICBsZXQgaXNfc3Vic2V0IH5jb21wYXJhdG9yIHQxIH5vZl86dDIgPVxuICAgICAgVHJlZTAuTmFtZWQuaXNfc3Vic2V0XG4gICAgICAgIHQxXG4gICAgICAgIH5vZl86dDJcbiAgICAgICAgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICAgICAgICB+c2V4cF9vZl9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG5cbiAgICBsZXQgZXF1YWwgfmNvbXBhcmF0b3IgdDEgdDIgPVxuICAgICAgVHJlZTAuTmFtZWQuZXF1YWxcbiAgICAgICAgdDFcbiAgICAgICAgdDJcbiAgICAgICAgfmNvbXBhcmVfZWx0OihjZSBjb21wYXJhdG9yKVxuICAgICAgICB+c2V4cF9vZl9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdFxuICAgIDs7XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBVc2luZ19jb21wYXJhdG9yID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnZWx0LCAnY21wKSB0ID0gKCdlbHQsICdjbXApIHRcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCB0b190cmVlIHQgPSB0LnRyZWVcbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3IgdHJlZSA9IHsgY29tcGFyYXRvcjsgdHJlZSB9XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3IgYV9vZl9zZXhwIHNleHAgPVxuICAgIG9mX3RyZWVcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5jb21wYXJlIGFfb2Zfc2V4cCBzZXhwKVxuICA7O1xuXG4gIGxldCBlbXB0eSB+Y29tcGFyYXRvciA9IHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLmVtcHR5IH1cblxuICBtb2R1bGUgRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoRWx0IDogQ29tcGFyYXRvci5TMSkgPSBzdHJ1Y3RcbiAgICBsZXQgZW1wdHkgPSB7IGNvbXBhcmF0b3IgPSBFbHQuY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLmVtcHR5IH1cbiAgZW5kXG5cbiAgbGV0IHNpbmdsZXRvbiB+Y29tcGFyYXRvciBlID0geyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAuc2luZ2xldG9uIGUgfVxuXG4gIGxldCB1bmlvbl9saXN0IH5jb21wYXJhdG9yIGwgPVxuICAgIG9mX3RyZWUgfmNvbXBhcmF0b3IgKFRyZWUwLnVuaW9uX2xpc3QgfmNvbXBhcmF0b3IgfnRvX3RyZWUgbClcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgbGV0IHRyZWUgPVxuICAgICAgVHJlZTAub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSB9XG4gIDs7XG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yIH5sZW4gfmYgPVxuICAgIG9mX3RyZWUgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYpXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSB+Y29tcGFyYXRvciBhcnJheSA9XG4gICAgT3JfZXJyb3IuTW9uYWRfaW5maXguKFxuICAgICAgVHJlZTAub2Zfc29ydGVkX2FycmF5IGFycmF5IH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgPj58IGZ1biB0cmVlIC0+IHsgY29tcGFyYXRvcjsgdHJlZSB9KVxuICA7O1xuXG4gIGxldCBvZl9saXN0IH5jb21wYXJhdG9yIGwgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm9mX2xpc3QgbCB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzID1cbiAgICB7IGNvbXBhcmF0b3I7IHRyZWUgPSBUcmVlMC5vZl9zZXF1ZW5jZSBzIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB9XG4gIDs7XG5cbiAgbGV0IG9mX2FycmF5IH5jb21wYXJhdG9yIGEgPVxuICAgIHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLm9mX2FycmF5IGEgfmNvbXBhcmVfZWx0OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIH1cbiAgOztcblxuICBsZXQgc3RhYmxlX2RlZHVwX2xpc3QgfmNvbXBhcmF0b3IgeHMgPVxuICAgIFRyZWUwLnN0YWJsZV9kZWR1cF9saXN0IHhzIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBtYXAgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgeyBjb21wYXJhdG9yOyB0cmVlID0gVHJlZTAubWFwIHQudHJlZSB+ZiB+Y29tcGFyZV9lbHQ6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIHsgY29tcGFyYXRvclxuICAgIDsgdHJlZSA9IFRyZWUwLmZpbHRlcl9tYXAgdC50cmVlIH5mIH5jb21wYXJlX2VsdDpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIH1cbiAgOztcblxuICBtb2R1bGUgVHJlZSA9IFRyZWVcbmVuZFxuXG50eXBlICgnZWx0LCAnY21wKSBjb21wYXJhdG9yID1cbiAgKG1vZHVsZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgPSAnZWx0IGFuZCB0eXBlIGNvbXBhcmF0b3Jfd2l0bmVzcyA9ICdjbXApXG5cbmxldCBjb21wYXJhdG9yX3MgKHR5cGUgayBjbXApIHQgOiAoaywgY21wKSBjb21wYXJhdG9yID1cbiAgKG1vZHVsZSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBrXG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXBcblxuICAgIGxldCBjb21wYXJhdG9yID0gdC5jb21wYXJhdG9yXG4gIGVuZClcbjs7XG5cbmxldCB0b19jb21wYXJhdG9yICh0eXBlIGVsdCBjbXApICgobW9kdWxlIE0pIDogKGVsdCwgY21wKSBjb21wYXJhdG9yKSA9IE0uY29tcGFyYXRvclxubGV0IGVtcHR5IG0gPSBVc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG5sZXQgc2luZ2xldG9uIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCB1bmlvbl9saXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3IudW5pb25fbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgbSB+bGVuIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB+bGVuIH5mXG47O1xuXG5sZXQgb2Zfc29ydGVkX2FycmF5IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9saXN0IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfbGlzdCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2Zfc2VxdWVuY2UgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfYXJyYXkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hcnJheSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBzdGFibGVfZGVkdXBfbGlzdCBtIGEgPVxuICBVc2luZ19jb21wYXJhdG9yLnN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbjs7XG5cbmxldCBtYXAgbSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXAgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYSB+ZlxubGV0IGZpbHRlcl9tYXAgbSBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5maWx0ZXJfbWFwIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmZcblxubW9kdWxlIE0gKEVsdCA6IHNpZ1xuICAgIHR5cGUgdFxuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzXG4gIGVuZCkgPVxuc3RydWN0XG4gIHR5cGUgbm9ucmVjIHQgPSAoRWx0LnQsIEVsdC5jb21wYXJhdG9yX3dpdG5lc3MpIHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBTZXhwX29mX20gPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgTV9vZl9zZXhwID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgb2Zfc2V4cF1cblxuICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICBbQEBAZW5kXVxuXG4gIGluY2x1ZGUgQ29tcGFyYXRvci5TIHdpdGggdHlwZSB0IDo9IHRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNX3NleHBfZ3JhbW1hciA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICB2YWwgdF9zZXhwX2dyYW1tYXIgOiB0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBDb21wYXJlX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBFcXVhbF9tID0gc2lnIGVuZFxubW9kdWxlIHR5cGUgSGFzaF9mb2xkX20gPSBIYXNoZXIuU1xuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBlbHQpIHQgPVxuICBzZXhwX29mX3QgRWx0LnNleHBfb2ZfdCAoZnVuIF8gLT4gU2V4cC5BdG9tIFwiX1wiKSB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwXG4gICAgICAodHlwZSBlbHQgY21wKVxuICAgICAgKG1vZHVsZSBFbHQgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBlbHQgYW5kIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wKVxuICAgICAgc2V4cFxuICA9XG4gIFVzaW5nX2NvbXBhcmF0b3IudF9vZl9zZXhwX2RpcmVjdCB+Y29tcGFyYXRvcjpFbHQuY29tcGFyYXRvciBFbHQudF9vZl9zZXhwIHNleHBcbjs7XG5cbmxldCBtX190X3NleHBfZ3JhbW1hciAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogTV9zZXhwX2dyYW1tYXIgd2l0aCB0eXBlIHQgPSBlbHQpXG4gIDogKGVsdCwgXykgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKGxpc3Rfc2V4cF9ncmFtbWFyIEVsdC50X3NleHBfZ3JhbW1hcilcbjs7XG5cbmxldCBjb21wYXJlX21fX3QgKG1vZHVsZSBfIDogQ29tcGFyZV9tKSB0MSB0MiA9IGNvbXBhcmVfZGlyZWN0IHQxIHQyXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSB0MSB0MiA9IGVxdWFsIHQxIHQyXG5cbmxldCBoYXNoX2ZvbGRfbV9fdCAodHlwZSBlbHQpIChtb2R1bGUgRWx0IDogSGFzaF9mb2xkX20gd2l0aCB0eXBlIHQgPSBlbHQpIHN0YXRlID1cbiAgaGFzaF9mb2xkX2RpcmVjdCBFbHQuaGFzaF9mb2xkX3Qgc3RhdGVcbjs7XG5cbmxldCBoYXNoX21fX3QgZm9sZGVyIHQgPVxuICBsZXQgc3RhdGUgPSBoYXNoX2ZvbGRfbV9fdCBmb2xkZXIgKEhhc2guY3JlYXRlICgpKSB0IGluXG4gIEhhc2guZ2V0X2hhc2hfdmFsdWUgc3RhdGVcbjs7XG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzc1xuICB0eXBlIG5vbnJlYyAoJ2VsdCwgJ2NtcCkgc2V0ID0gKCdlbHQsIGNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuICB0eXBlIG5vbnJlYyAnZWx0IHQgPSAoJ2VsdCwgY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIHR5cGUgbm9ucmVjICdlbHQgdHJlZSA9ICgnZWx0LCBjb21wYXJhdG9yX3dpdG5lc3MpIHRyZWVcbiAgdHlwZSBub25yZWMgJ2VsdCBuYW1lZCA9ICgnZWx0LCBjb21wYXJhdG9yX3dpdG5lc3MpIE5hbWVkLnRcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBjb21wYXJhdG9yID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3JcblxuICBpbmNsdWRlIFVzaW5nX2NvbXBhcmF0b3IuRW1wdHlfd2l0aG91dF92YWx1ZV9yZXN0cmljdGlvbiAoQ29tcGFyYXRvci5Qb2x5KVxuXG4gIGxldCBzaW5nbGV0b24gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yIGFcbiAgbGV0IHVuaW9uX2xpc3QgYSA9IFVzaW5nX2NvbXBhcmF0b3IudW5pb25fbGlzdCB+Y29tcGFyYXRvciBhXG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYSA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiA9XG4gICAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCB+Y29tcGFyYXRvciB+bGVuIH5mXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYVxuICBsZXQgb2ZfbGlzdCBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9saXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX3NlcXVlbmNlIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FycmF5IGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FycmF5IH5jb21wYXJhdG9yIGFcbiAgbGV0IHN0YWJsZV9kZWR1cF9saXN0IGEgPSBVc2luZ19jb21wYXJhdG9yLnN0YWJsZV9kZWR1cF9saXN0IH5jb21wYXJhdG9yIGFcbiAgbGV0IG1hcCBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5tYXAgfmNvbXBhcmF0b3IgYSB+ZlxuICBsZXQgZmlsdGVyX21hcCBhIH5mID0gVXNpbmdfY29tcGFyYXRvci5maWx0ZXJfbWFwIH5jb21wYXJhdG9yIGEgfmZcbiAgbGV0IG9mX3RyZWUgdHJlZSA9IHsgY29tcGFyYXRvcjsgdHJlZSB9XG4gIGxldCB0b190cmVlIHQgPSB0LnRyZWVcbmVuZFxuIiwib3BlbiEgSW1wb3J0XG5cbmluY2x1ZGUgKFxuc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIHJlZiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSB0IC0+ICdhIHQgLT4gaW50ID0gY29tcGFyZV9yZWZcbiAgbGV0IGVxdWFsIDogJ2EuICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSB0IC0+ICdhIHQgLT4gYm9vbCA9IGVxdWFsX3JlZlxuICBsZXQgdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSB0ID0gcmVmX29mX3NleHBcbiAgbGV0IHNleHBfb2ZfdCA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSB0IC0+IFNleHBsaWIwLlNleHAudCA9IHNleHBfb2ZfcmVmXG5cbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiByZWZfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuZW5kIDpcbnNpZ1xuICB0eXBlICdhIHQgPSAnYSByZWYgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG4gIGluY2x1ZGUgUHB4X2NvbXBhcmVfbGliLkVxdWFsLlMxIHdpdGggdHlwZSAnYSB0IDo9ICdhIHRcbiAgaW5jbHVkZSBTZXhwbGliMC5TZXhwYWJsZS5TMSB3aXRoIHR5cGUgJ2EgdCA6PSAnYSB0XG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogJ2EgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQgLT4gJ2EgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmQpXG5cbigqIEluIHRoZSBkZWZpbml0aW9uIG9mIFt0XSwgd2UgZG8gbm90IGhhdmUgW1tAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXSBiZWNhdXNlXG4gICBpbiBnZW5lcmFsLCBzeW50YXggZXh0ZW5zaW9ucyB0ZW5kIHRvIHVzZSB0aGUgaW1wbGVtZW50YXRpb24gd2hlbiBhdmFpbGFibGUgcmF0aGVyIHRoYW5cbiAgIHVzaW5nIHRoZSBhbGlhcy4gIEhlcmUgdGhhdCB3b3VsZCBsZWFkIHRvIHVzZSB0aGUgcmVjb3JkIHJlcHJlc2VudGF0aW9uIFsgeyBtdXRhYmxlXG4gICBjb250ZW50cyA6ICdhIH0gXSB3aGljaCB3b3VsZCByZXN1bHQgaW4gZGlmZmVyZW50IChhbmQgdW53YW50ZWQpIGJlaGF2aW9yLiAgKilcbnR5cGUgJ2EgdCA9ICdhIHJlZiA9IHsgbXV0YWJsZSBjb250ZW50cyA6ICdhIH1cblxuZXh0ZXJuYWwgY3JlYXRlIDogJ2EgLT4gJ2EgdCA9IFwiJW1ha2VtdXRhYmxlXCJcbmV4dGVybmFsICggISApIDogJ2EgdCAtPiAnYSA9IFwiJWZpZWxkMFwiXG5leHRlcm5hbCAoIDo9ICkgOiAnYSB0IC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuXG5sZXQgc3dhcCB0MSB0MiA9XG4gIGxldCB0bXAgPSAhdDEgaW5cbiAgdDEgOj0gIXQyO1xuICB0MiA6PSB0bXBcbjs7XG5cbmxldCByZXBsYWNlIHQgZiA9IHQgOj0gZiAhdFxuXG5sZXQgc2V0X3RlbXBvcmFyaWx5IHQgYSB+ZiA9XG4gIGxldCByZXN0b3JlX3RvID0gIXQgaW5cbiAgdCA6PSBhO1xuICBFeG4ucHJvdGVjdCB+ZiB+ZmluYWxseTooZnVuICgpIC0+IHQgOj0gcmVzdG9yZV90bylcbjs7XG5cbm1vZHVsZSBBbmRfdmFsdWUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVCA6ICdhIHJlZiAqICdhIC0+IHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgc2V0IChUIChyLCBhKSkgPSByIDo9IGFcbiAgbGV0IHNldHMgdHMgPSBMaXN0Lml0ZXIgdHMgfmY6c2V0XG4gIGxldCBzbmFwc2hvdCAoVCAociwgXykpID0gVCAociwgIXIpXG4gIGxldCBzbmFwc2hvdHMgdHMgPSBMaXN0Lm1hcCB0cyB+ZjpzbmFwc2hvdFxuZW5kXG5cbmxldCBzZXRzX3RlbXBvcmFyaWx5IGFuZF92YWx1ZXMgfmYgPVxuICBsZXQgcmVzdG9yZV90byA9IEFuZF92YWx1ZS5zbmFwc2hvdHMgYW5kX3ZhbHVlcyBpblxuICBBbmRfdmFsdWUuc2V0cyBhbmRfdmFsdWVzO1xuICBFeG4ucHJvdGVjdCB+ZiB+ZmluYWxseTooZnVuICgpIC0+IEFuZF92YWx1ZS5zZXRzIHJlc3RvcmVfdG8pXG47O1xuIiwib3BlbiEgSW1wb3J0XG5cblxuKCogW3RdIHN0b3JlcyB0aGUgW3QubGVuZ3RoXSBxdWV1ZSBlbGVtZW50cyBhdCBjb25zZWN1dGl2ZSBpbmNyZWFzaW5nIGluZGljZXMgb2YgW3QuZWx0c10sXG4gICBtb2QgdGhlIGNhcGFjaXR5IG9mIFt0XSwgd2hpY2ggaXMgW09wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzXS4gIFRoZSBjYXBhY2l0eSBpc1xuICAgcmVxdWlyZWQgdG8gYmUgYSBwb3dlciBvZiB0d28gKHVzZXItcmVxdWVzdGVkIGNhcGFjaXRpZXMgYXJlIHJvdW5kZWQgdXAgdG8gdGhlIG5lYXJlc3RcbiAgIHBvd2VyKSwgc28gdGhhdCBtb2QgY2FuIHF1aWNrbHkgYmUgY29tcHV0ZWQgdXNpbmcgW2xhbmQgdC5tYXNrXSwgd2hlcmUgW3QubWFzayA9XG4gICBjYXBhY2l0eSB0IC0gMV0uICBTbywgcXVldWUgZWxlbWVudCBbaV0gaXMgYXQgW3QuZWx0cy4oICh0LmZyb250ICsgaSkgbGFuZCB0Lm1hc2sgKV0uXG5cbiAgIFtudW1fbXV0YXRpb25zXSBpcyB1c2VkIHRvIGRldGVjdCBtb2RpZmljYXRpb24gZHVyaW5nIGl0ZXJhdGlvbi4gKilcbnR5cGUgJ2EgdCA9XG4gIHsgbXV0YWJsZSBudW1fbXV0YXRpb25zIDogaW50XG4gIDsgbXV0YWJsZSBmcm9udCA6IGludFxuICA7IG11dGFibGUgbWFzayA6IGludFxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gIDsgbXV0YWJsZSBlbHRzIDogJ2EgT3B0aW9uX2FycmF5LnRcbiAgfVxuW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbmxldCBzZXhwX29mX3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICBmdW4gX29mX2FfXzAwMV9cbiAgICB7IG51bV9tdXRhdGlvbnMgPSBudW1fbXV0YXRpb25zX18wMDNfXG4gICAgOyBmcm9udCA9IGZyb250X18wMDVfXG4gICAgOyBtYXNrID0gbWFza19fMDA3X1xuICAgIDsgbGVuZ3RoID0gbGVuZ3RoX18wMDlfXG4gICAgOyBlbHRzID0gZWx0c19fMDExX1xuICAgIH0gLT5cbiAgICBsZXQgYm5kc19fMDAyXyA9IFtdIGluXG4gICAgbGV0IGJuZHNfXzAwMl8gPVxuICAgICAgbGV0IGFyZ19fMDEyXyA9IE9wdGlvbl9hcnJheS5zZXhwX29mX3QgX29mX2FfXzAwMV8gZWx0c19fMDExXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwiZWx0c1wiOyBhcmdfXzAxMl8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBsZXQgYm5kc19fMDAyXyA9XG4gICAgICBsZXQgYXJnX18wMTBfID0gc2V4cF9vZl9pbnQgbGVuZ3RoX18wMDlfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJsZW5ndGhcIjsgYXJnX18wMTBfIF0gOjogYm5kc19fMDAyX1xuICAgIGluXG4gICAgbGV0IGJuZHNfXzAwMl8gPVxuICAgICAgbGV0IGFyZ19fMDA4XyA9IHNleHBfb2ZfaW50IG1hc2tfXzAwN18gaW5cbiAgICAgIFNleHBsaWIwLlNleHAuTGlzdCBbIFNleHBsaWIwLlNleHAuQXRvbSBcIm1hc2tcIjsgYXJnX18wMDhfIF0gOjogYm5kc19fMDAyX1xuICAgIGluXG4gICAgbGV0IGJuZHNfXzAwMl8gPVxuICAgICAgbGV0IGFyZ19fMDA2XyA9IHNleHBfb2ZfaW50IGZyb250X18wMDVfIGluXG4gICAgICBTZXhwbGliMC5TZXhwLkxpc3QgWyBTZXhwbGliMC5TZXhwLkF0b20gXCJmcm9udFwiOyBhcmdfXzAwNl8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBsZXQgYm5kc19fMDAyXyA9XG4gICAgICBsZXQgYXJnX18wMDRfID0gc2V4cF9vZl9pbnQgbnVtX211dGF0aW9uc19fMDAzXyBpblxuICAgICAgU2V4cGxpYjAuU2V4cC5MaXN0IFsgU2V4cGxpYjAuU2V4cC5BdG9tIFwibnVtX211dGF0aW9uc1wiOyBhcmdfXzAwNF8gXSA6OiBibmRzX18wMDJfXG4gICAgaW5cbiAgICBTZXhwbGliMC5TZXhwLkxpc3QgYm5kc19fMDAyX1xuOztcblxuW0BAQGVuZF1cblxubW9kdWxlIHR5cGUgUyA9IFF1ZXVlX2ludGYuU1xuXG5sZXQgaW5jX251bV9tdXRhdGlvbnMgdCA9IHQubnVtX211dGF0aW9ucyA8LSB0Lm51bV9tdXRhdGlvbnMgKyAxXG5sZXQgY2FwYWNpdHkgdCA9IHQubWFzayArIDFcbmxldCBlbHRzX2luZGV4IHQgaSA9ICh0LmZyb250ICsgaSkgbGFuZCB0Lm1hc2tcbmxldCB1bnNhZmVfZ2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfZ2V0X3NvbWVfZXhuIHQuZWx0cyAoZWx0c19pbmRleCB0IGkpXG5sZXQgdW5zYWZlX2lzX3NldCB0IGkgPSBPcHRpb25fYXJyYXkudW5zYWZlX2lzX3NvbWUgdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcbmxldCB1bnNhZmVfc2V0IHQgaSBhID0gT3B0aW9uX2FycmF5LnVuc2FmZV9zZXRfc29tZSB0LmVsdHMgKGVsdHNfaW5kZXggdCBpKSBhXG5sZXQgdW5zYWZlX3Vuc2V0IHQgaSA9IE9wdGlvbl9hcnJheS51bnNhZmVfc2V0X25vbmUgdC5lbHRzIChlbHRzX2luZGV4IHQgaSlcblxubGV0IGNoZWNrX2luZGV4X2V4biB0IGkgPVxuICBpZiBpIDwgMCB8fCBpID49IHQubGVuZ3RoXG4gIHRoZW5cbiAgICBFcnJvci5yYWlzZV9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIlF1ZXVlIGluZGV4IG91dCBvZiBib3VuZHNcIlxuICAgICAgICAgWyBcImluZGV4XCIsIGkgfD4gSW50LnNleHBfb2ZfdDsgXCJsZW5ndGhcIiwgdC5sZW5ndGggfD4gSW50LnNleHBfb2ZfdCBdKVxuOztcblxubGV0IGdldCB0IGkgPVxuICBjaGVja19pbmRleF9leG4gdCBpO1xuICB1bnNhZmVfZ2V0IHQgaVxuOztcblxubGV0IHNldCB0IGkgYSA9XG4gIGNoZWNrX2luZGV4X2V4biB0IGk7XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIHVuc2FmZV9zZXQgdCBpIGFcbjs7XG5cbmxldCBpc19lbXB0eSB0ID0gdC5sZW5ndGggPSAwXG5sZXQgbGVuZ3RoIHsgbGVuZ3RoOyBfIH0gPSBsZW5ndGhcblxubGV0IGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnMgPVxuICBpZiB0Lm51bV9tdXRhdGlvbnMgPD4gbnVtX211dGF0aW9uc1xuICB0aGVuXG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJtdXRhdGlvbiBvZiBxdWV1ZSBkdXJpbmcgaXRlcmF0aW9uXCJcbiAgICAgICAgIFsgXCJcIiwgdCB8PiBzZXhwX29mX3QgKGZ1biBfIC0+IFNleHAuQXRvbSBcIl9cIikgXSlcbjs7XG5cbmxldCBjb21wYXJlID1cbiAgbGV0IHJlYyB1bnNhZmVfY29tcGFyZV9mcm9tIGNvbXBhcmVfZWx0IHBvcyB+dDEgfnQyIH5sZW4xIH5sZW4yIH5tdXQxIH5tdXQyID1cbiAgICBtYXRjaCBwb3MgPSBsZW4xLCBwb3MgPSBsZW4yIHdpdGhcbiAgICB8IHRydWUsIHRydWUgLT4gMFxuICAgIHwgdHJ1ZSwgZmFsc2UgLT4gLTFcbiAgICB8IGZhbHNlLCB0cnVlIC0+IDFcbiAgICB8IGZhbHNlLCBmYWxzZSAtPlxuICAgICAgbGV0IHggPSBjb21wYXJlX2VsdCAodW5zYWZlX2dldCB0MSBwb3MpICh1bnNhZmVfZ2V0IHQyIHBvcykgaW5cbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MSBtdXQxO1xuICAgICAgZW5zdXJlX25vX211dGF0aW9uIHQyIG11dDI7XG4gICAgICAobWF0Y2ggeCB3aXRoXG4gICAgICAgfCAwIC0+IHVuc2FmZV9jb21wYXJlX2Zyb20gY29tcGFyZV9lbHQgKHBvcyArIDEpIH50MSB+dDIgfmxlbjEgfmxlbjIgfm11dDEgfm11dDJcbiAgICAgICB8IG4gLT4gbilcbiAgaW5cbiAgZnVuIGNvbXBhcmVfZWx0IHQxIHQyIC0+XG4gICAgaWYgcGh5c19lcXVhbCB0MSB0MlxuICAgIHRoZW4gMFxuICAgIGVsc2VcbiAgICAgIHVuc2FmZV9jb21wYXJlX2Zyb21cbiAgICAgICAgY29tcGFyZV9lbHRcbiAgICAgICAgMFxuICAgICAgICB+dDFcbiAgICAgICAgfnQyXG4gICAgICAgIH5sZW4xOnQxLmxlbmd0aFxuICAgICAgICB+bGVuMjp0Mi5sZW5ndGhcbiAgICAgICAgfm11dDE6dDEubnVtX211dGF0aW9uc1xuICAgICAgICB+bXV0Mjp0Mi5udW1fbXV0YXRpb25zXG47O1xuXG5sZXQgZXF1YWwgPVxuICBsZXQgcmVjIHVuc2FmZV9lcXVhbF9mcm9tIGVxdWFsX2VsdCBwb3MgfnQxIH50MiB+bXV0MSB+bXV0MiB+bGVuID1cbiAgICBwb3MgPSBsZW5cbiAgICB8fFxuICAgIGxldCBiID0gZXF1YWxfZWx0ICh1bnNhZmVfZ2V0IHQxIHBvcykgKHVuc2FmZV9nZXQgdDIgcG9zKSBpblxuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MSBtdXQxO1xuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0MiBtdXQyO1xuICAgIGIgJiYgdW5zYWZlX2VxdWFsX2Zyb20gZXF1YWxfZWx0IChwb3MgKyAxKSB+dDEgfnQyIH5tdXQxIH5tdXQyIH5sZW5cbiAgaW5cbiAgZnVuIGVxdWFsX2VsdCB0MSB0MiAtPlxuICAgIHBoeXNfZXF1YWwgdDEgdDJcbiAgICB8fFxuICAgIGxldCBsZW4xID0gdDEubGVuZ3RoIGluXG4gICAgbGV0IGxlbjIgPSB0Mi5sZW5ndGggaW5cbiAgICBsZW4xID0gbGVuMlxuICAgICYmIHVuc2FmZV9lcXVhbF9mcm9tXG4gICAgICAgICBlcXVhbF9lbHRcbiAgICAgICAgIDBcbiAgICAgICAgIH50MVxuICAgICAgICAgfnQyXG4gICAgICAgICB+bGVuOmxlbjFcbiAgICAgICAgIH5tdXQxOnQxLm51bV9tdXRhdGlvbnNcbiAgICAgICAgIH5tdXQyOnQyLm51bV9tdXRhdGlvbnNcbjs7XG5cbmxldCBpbnZhcmlhbnQgaW52YXJpYW50X2EgdCA9XG4gIGxldCB7IG51bV9tdXRhdGlvbnM7IG1hc2sgPSBfOyBlbHRzOyBmcm9udDsgbGVuZ3RoIH0gPSB0IGluXG4gIGFzc2VydCAoZnJvbnQgPj0gMCk7XG4gIGFzc2VydCAoZnJvbnQgPCBjYXBhY2l0eSB0KTtcbiAgbGV0IGNhcGFjaXR5ID0gY2FwYWNpdHkgdCBpblxuICBhc3NlcnQgKGNhcGFjaXR5ID0gT3B0aW9uX2FycmF5Lmxlbmd0aCBlbHRzKTtcbiAgYXNzZXJ0IChjYXBhY2l0eSA+PSAxKTtcbiAgYXNzZXJ0IChJbnQuaXNfcG93MiBjYXBhY2l0eSk7XG4gIGFzc2VydCAobGVuZ3RoID49IDApO1xuICBhc3NlcnQgKGxlbmd0aCA8PSBjYXBhY2l0eSk7XG4gIGZvciBpID0gMCB0byBjYXBhY2l0eSAtIDEgZG9cbiAgICBpZiBpIDwgdC5sZW5ndGhcbiAgICB0aGVuIChcbiAgICAgIGludmFyaWFudF9hICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgICBlbnN1cmVfbm9fbXV0YXRpb24gdCBudW1fbXV0YXRpb25zKVxuICAgIGVsc2UgYXNzZXJ0IChub3QgKHVuc2FmZV9pc19zZXQgdCBpKSlcbiAgZG9uZVxuOztcblxubGV0IGNyZWF0ZSAodHlwZSBhKSA/Y2FwYWNpdHkgKCkgOiBhIHQgPVxuICBsZXQgY2FwYWNpdHkgPVxuICAgIG1hdGNoIGNhcGFjaXR5IHdpdGhcbiAgICB8IE5vbmUgLT4gMVxuICAgIHwgU29tZSBjYXBhY2l0eSAtPlxuICAgICAgaWYgY2FwYWNpdHkgPCAwXG4gICAgICB0aGVuXG4gICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgXCJjYW5ub3QgaGF2ZSBxdWV1ZSB3aXRoIG5lZ2F0aXZlIGNhcGFjaXR5XCJcbiAgICAgICAgICAgICBbIFwiY2FwYWNpdHlcIiwgY2FwYWNpdHkgfD4gSW50LnNleHBfb2ZfdCBdKVxuICAgICAgZWxzZSBpZiBjYXBhY2l0eSA9IDBcbiAgICAgIHRoZW4gMVxuICAgICAgZWxzZSBJbnQuY2VpbF9wb3cyIGNhcGFjaXR5XG4gIGluXG4gIHsgbnVtX211dGF0aW9ucyA9IDBcbiAgOyBmcm9udCA9IDBcbiAgOyBtYXNrID0gY2FwYWNpdHkgLSAxXG4gIDsgbGVuZ3RoID0gMFxuICA7IGVsdHMgPSBPcHRpb25fYXJyYXkuY3JlYXRlIH5sZW46Y2FwYWNpdHlcbiAgfVxuOztcblxubGV0IGJsaXRfdG9fYXJyYXkgfnNyYyBkc3QgPVxuICBhc3NlcnQgKHNyYy5sZW5ndGggPD0gT3B0aW9uX2FycmF5Lmxlbmd0aCBkc3QpO1xuICBsZXQgZnJvbnRfbGVuID0gSW50Lm1pbiBzcmMubGVuZ3RoIChjYXBhY2l0eSBzcmMgLSBzcmMuZnJvbnQpIGluXG4gIGxldCByZXN0X2xlbiA9IHNyYy5sZW5ndGggLSBmcm9udF9sZW4gaW5cbiAgT3B0aW9uX2FycmF5LmJsaXQgfmxlbjpmcm9udF9sZW4gfnNyYzpzcmMuZWx0cyB+c3JjX3BvczpzcmMuZnJvbnQgfmRzdCB+ZHN0X3BvczowO1xuICBPcHRpb25fYXJyYXkuYmxpdCB+bGVuOnJlc3RfbGVuIH5zcmM6c3JjLmVsdHMgfnNyY19wb3M6MCB+ZHN0IH5kc3RfcG9zOmZyb250X2xlblxuOztcblxubGV0IHNldF9jYXBhY2l0eSB0IGRlc2lyZWRfY2FwYWNpdHkgPVxuICAoKiBXZSBhbGxvdyBhcmd1bWVudHMgbGVzcyB0aGFuIDEgdG8gW3NldF9jYXBhY2l0eV0sIGJ1dCB0cmFuc2xhdGUgdGhlbSB0byAxIHRvIHNpbXBsaWZ5XG4gICAgIHRoZSBjb2RlIHRoYXQgcmVsaWVzIG9uIHRoZSBhcnJheSBsZW5ndGggYmVpbmcgYSBwb3dlciBvZiAyLiAqKVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBsZXQgbmV3X2NhcGFjaXR5ID0gSW50LmNlaWxfcG93MiAobWF4IDEgKG1heCBkZXNpcmVkX2NhcGFjaXR5IHQubGVuZ3RoKSkgaW5cbiAgaWYgbmV3X2NhcGFjaXR5IDw+IGNhcGFjaXR5IHRcbiAgdGhlbiAoXG4gICAgbGV0IGRzdCA9IE9wdGlvbl9hcnJheS5jcmVhdGUgfmxlbjpuZXdfY2FwYWNpdHkgaW5cbiAgICBibGl0X3RvX2FycmF5IH5zcmM6dCBkc3Q7XG4gICAgdC5mcm9udCA8LSAwO1xuICAgIHQubWFzayA8LSBuZXdfY2FwYWNpdHkgLSAxO1xuICAgIHQuZWx0cyA8LSBkc3QpXG47O1xuXG5sZXQgZW5xdWV1ZSB0IGEgPVxuICBpbmNfbnVtX211dGF0aW9ucyB0O1xuICBpZiB0Lmxlbmd0aCA9IGNhcGFjaXR5IHQgdGhlbiBzZXRfY2FwYWNpdHkgdCAoMiAqIHQubGVuZ3RoKTtcbiAgdW5zYWZlX3NldCB0IHQubGVuZ3RoIGE7XG4gIHQubGVuZ3RoIDwtIHQubGVuZ3RoICsgMVxuOztcblxubGV0IGRlcXVldWVfbm9uZW1wdHkgdCA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGxldCBlbHRzID0gdC5lbHRzIGluXG4gIGxldCBmcm9udCA9IHQuZnJvbnQgaW5cbiAgbGV0IHJlcyA9IE9wdGlvbl9hcnJheS5nZXRfc29tZV9leG4gZWx0cyBmcm9udCBpblxuICBPcHRpb25fYXJyYXkuc2V0X25vbmUgZWx0cyBmcm9udDtcbiAgdC5mcm9udCA8LSBlbHRzX2luZGV4IHQgMTtcbiAgdC5sZW5ndGggPC0gdC5sZW5ndGggLSAxO1xuICByZXNcbjs7XG5cbmxldCBkZXF1ZXVlX2V4biB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIHJhaXNlIENhbWwuUXVldWUuRW1wdHkgZWxzZSBkZXF1ZXVlX25vbmVtcHR5IHRcbmxldCBkZXF1ZXVlIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGRlcXVldWVfbm9uZW1wdHkgdClcbmxldCBmcm9udF9ub25lbXB0eSB0ID0gT3B0aW9uX2FycmF5LnVuc2FmZV9nZXRfc29tZV9leG4gdC5lbHRzIHQuZnJvbnRcbmxldCBsYXN0X25vbmVtcHR5IHQgPSB1bnNhZmVfZ2V0IHQgKHQubGVuZ3RoIC0gMSlcbmxldCBwZWVrIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKGZyb250X25vbmVtcHR5IHQpXG5sZXQgcGVla19leG4gdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiByYWlzZSBDYW1sLlF1ZXVlLkVtcHR5IGVsc2UgZnJvbnRfbm9uZW1wdHkgdFxubGV0IGxhc3QgdCA9IGlmIGlzX2VtcHR5IHQgdGhlbiBOb25lIGVsc2UgU29tZSAobGFzdF9ub25lbXB0eSB0KVxubGV0IGxhc3RfZXhuIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gcmFpc2UgQ2FtbC5RdWV1ZS5FbXB0eSBlbHNlIGxhc3Rfbm9uZW1wdHkgdFxuXG5sZXQgY2xlYXIgdCA9XG4gIGluY19udW1fbXV0YXRpb25zIHQ7XG4gIGlmIHQubGVuZ3RoID4gMFxuICB0aGVuIChcbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICB1bnNhZmVfdW5zZXQgdCBpXG4gICAgZG9uZTtcbiAgICB0Lmxlbmd0aCA8LSAwO1xuICAgIHQuZnJvbnQgPC0gMClcbjs7XG5cbmxldCBibGl0X3RyYW5zZmVyIH5zcmMgfmRzdCA/bGVuICgpID1cbiAgaW5jX251bV9tdXRhdGlvbnMgc3JjO1xuICBpbmNfbnVtX211dGF0aW9ucyBkc3Q7XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoXG4gICAgfCBOb25lIC0+IHNyYy5sZW5ndGhcbiAgICB8IFNvbWUgbGVuIC0+XG4gICAgICBpZiBsZW4gPCAwXG4gICAgICB0aGVuXG4gICAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgICAgXCJRdWV1ZS5ibGl0X3RyYW5zZmVyOiBuZWdhdGl2ZSBsZW5ndGhcIlxuICAgICAgICAgICAgIFsgXCJsZW5ndGhcIiwgbGVuIHw+IEludC5zZXhwX29mX3QgXSk7XG4gICAgICBtaW4gbGVuIHNyYy5sZW5ndGhcbiAgaW5cbiAgaWYgbGVuID4gMFxuICB0aGVuIChcbiAgICBzZXRfY2FwYWNpdHkgZHN0IChtYXggKGNhcGFjaXR5IGRzdCkgKGRzdC5sZW5ndGggKyBsZW4pKTtcbiAgICBsZXQgZHN0X3N0YXJ0ID0gZHN0LmZyb250ICsgZHN0Lmxlbmd0aCBpblxuICAgIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgICAoKiBUaGlzIGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIHRoYW4gc2ltcGx5IFtlbnF1ZXVlIGRzdCAoZGVxdWV1ZV9ub25lbXB0eSBzcmMpXSAqKVxuICAgICAgbGV0IHNyY19pID0gKHNyYy5mcm9udCArIGkpIGxhbmQgc3JjLm1hc2sgaW5cbiAgICAgIGxldCBkc3RfaSA9IChkc3Rfc3RhcnQgKyBpKSBsYW5kIGRzdC5tYXNrIGluXG4gICAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lXG4gICAgICAgIGRzdC5lbHRzXG4gICAgICAgIGRzdF9pXG4gICAgICAgIChPcHRpb25fYXJyYXkudW5zYWZlX2dldF9zb21lX2V4biBzcmMuZWx0cyBzcmNfaSk7XG4gICAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9ub25lIHNyYy5lbHRzIHNyY19pXG4gICAgZG9uZTtcbiAgICBkc3QubGVuZ3RoIDwtIGRzdC5sZW5ndGggKyBsZW47XG4gICAgc3JjLmZyb250IDwtIChzcmMuZnJvbnQgKyBsZW4pIGxhbmQgc3JjLm1hc2s7XG4gICAgc3JjLmxlbmd0aCA8LSBzcmMubGVuZ3RoIC0gbGVuKVxuOztcblxubGV0IGVucXVldWVfYWxsIHQgbCA9XG4gICgqIFRyYXZlcnNpbmcgdGhlIGxpc3QgdXAgZnJvbnQgdG8gY29tcHV0ZSBpdHMgbGVuZ3RoIGlzIHByb2JhYmx5IChidXQgbm90IGRlZmluaXRlbHkpXG4gICAgIGJldHRlciB0aGFuIGRvdWJsaW5nIHRoZSB1bmRlcmx5aW5nIGFycmF5IHNpemUgc2V2ZXJhbCB0aW1lcyBmb3IgbGFyZ2UgcXVldWVzLiAqKVxuICBzZXRfY2FwYWNpdHkgdCAoSW50Lm1heCAoY2FwYWNpdHkgdCkgKHQubGVuZ3RoICsgTGlzdC5sZW5ndGggbCkpO1xuICBMaXN0Lml0ZXIgbCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpXG47O1xuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgaWYgdC5sZW5ndGggPSAwXG4gIHRoZW4gaW5pdFxuICBlbHNlIChcbiAgICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICAgIGxldCByID0gcmVmIGluaXQgaW5cbiAgICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgICByIDo9IGYgIXIgKHVuc2FmZV9nZXQgdCBpKTtcbiAgICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnNcbiAgICBkb25lO1xuICAgICFyKVxuOztcblxubGV0IGZvbGRpIHQgfmluaXQgfmYgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGZvbGQgdCB+aW5pdCB+ZjooZnVuIGFjYyBhIC0+XG4gICAgbGV0IGFjYyA9IGYgIWkgYWNjIGEgaW5cbiAgICBpIDo9ICFpICsgMTtcbiAgICBhY2MpXG47O1xuXG5cbigqIFtpdGVyXSBpcyBpbXBsZW1lbnRlZCBkaXJlY3RseSBiZWNhdXNlIGltcGxlbWVudGluZyBpdCBpbiB0ZXJtcyBvZiBbZm9sZF0gaXNcbiAgIHNsb3dlci4gKilcbmxldCBpdGVyIHQgfmYgPVxuICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgZiAodW5zYWZlX2dldCB0IGkpO1xuICAgIGVuc3VyZV9ub19tdXRhdGlvbiB0IG51bV9tdXRhdGlvbnNcbiAgZG9uZVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBsZXQgbnVtX211dGF0aW9ucyA9IHQubnVtX211dGF0aW9ucyBpblxuICBmb3IgaSA9IDAgdG8gdC5sZW5ndGggLSAxIGRvXG4gICAgZiBpICh1bnNhZmVfZ2V0IHQgaSk7XG4gICAgZW5zdXJlX25vX211dGF0aW9uIHQgbnVtX211dGF0aW9uc1xuICBkb25lXG47O1xuXG5sZXQgdG9fbGlzdCB0ID1cbiAgbGV0IHJlc3VsdCA9IHJlZiBbXSBpblxuICBmb3IgaSA9IHQubGVuZ3RoIC0gMSBkb3dudG8gMCBkb1xuICAgIHJlc3VsdCA6PSB1bnNhZmVfZ2V0IHQgaSA6OiAhcmVzdWx0XG4gIGRvbmU7XG4gICFyZXN1bHRcbjs7XG5cbm1vZHVsZSBDID0gSW5kZXhlZF9jb250YWluZXIuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gICAgbGV0IGZvbGRpID0gYEN1c3RvbSBmb2xkaVxuICAgIGxldCBpdGVyaSA9IGBDdXN0b20gaXRlcmlcbiAgZW5kKVxuXG5sZXQgY291bnQgPSBDLmNvdW50XG5sZXQgZXhpc3RzID0gQy5leGlzdHNcbmxldCBmaW5kID0gQy5maW5kXG5sZXQgZmluZF9tYXAgPSBDLmZpbmRfbWFwXG5sZXQgZm9sZF9yZXN1bHQgPSBDLmZvbGRfcmVzdWx0XG5sZXQgZm9sZF91bnRpbCA9IEMuZm9sZF91bnRpbFxubGV0IGZvcl9hbGwgPSBDLmZvcl9hbGxcbmxldCBtYXhfZWx0ID0gQy5tYXhfZWx0XG5sZXQgbWVtID0gQy5tZW1cbmxldCBtaW5fZWx0ID0gQy5taW5fZWx0XG5sZXQgc3VtID0gQy5zdW1cbmxldCBjb3VudGkgPSBDLmNvdW50aVxubGV0IGV4aXN0c2kgPSBDLmV4aXN0c2lcbmxldCBmaW5kX21hcGkgPSBDLmZpbmRfbWFwaVxubGV0IGZpbmRpID0gQy5maW5kaVxubGV0IGZvcl9hbGxpID0gQy5mb3JfYWxsaVxuXG5cbigqIEZvciBbY29uY2F0X21hcF0sIFtmaWx0ZXJfbWFwXSwgYW5kIFtmaWx0ZXJdLCB3ZSBkb24ndCBjcmVhdGUgW3RfcmVzdWx0XSB3aXRoIFt0XSdzXG4gICBjYXBhY2l0eSBiZWNhdXNlIHdlIGhhdmUgbm8gaWRlYSBob3cgbWFueSBlbGVtZW50cyBbdF9yZXN1bHRdIHdpbGwgdWx0aW1hdGVseSBob2xkLiAqKVxubGV0IGNvbmNhdF9tYXAgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IExpc3QuaXRlciAoZiBhKSB+ZjooZnVuIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgY29uY2F0X21hcGkgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyaSB0IH5mOihmdW4gaSBhIC0+IExpc3QuaXRlciAoZiBpIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHRfcmVzdWx0IGIpKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwIHQgfmYgPVxuICBsZXQgdF9yZXN1bHQgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPlxuICAgIG1hdGNoIGYgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXJfbWFwaSB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT5cbiAgICBtYXRjaCBmIGkgYSB3aXRoXG4gICAgfCBOb25lIC0+ICgpXG4gICAgfCBTb21lIGIgLT4gZW5xdWV1ZSB0X3Jlc3VsdCBiKTtcbiAgdF9yZXN1bHRcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9XG4gIGxldCB0X3Jlc3VsdCA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+IGlmIGYgYSB0aGVuIGVucXVldWUgdF9yZXN1bHQgYSk7XG4gIHRfcmVzdWx0XG47O1xuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgbGV0IHRfcmVzdWx0ID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gaWYgZiBpIGEgdGhlbiBlbnF1ZXVlIHRfcmVzdWx0IGEpO1xuICB0X3Jlc3VsdFxuOztcblxubGV0IGZpbHRlcl9pbnBsYWNlIHQgfmYgPVxuICBsZXQgdDIgPSBmaWx0ZXIgdCB+ZiBpblxuICBjbGVhciB0O1xuICBibGl0X3RyYW5zZmVyIH5zcmM6dDIgfmRzdDp0ICgpXG47O1xuXG5sZXQgZmlsdGVyaV9pbnBsYWNlIHQgfmYgPVxuICBsZXQgdDIgPSBmaWx0ZXJpIHQgfmYgaW5cbiAgY2xlYXIgdDtcbiAgYmxpdF90cmFuc2ZlciB+c3JjOnQyIH5kc3Q6dCAoKVxuOztcblxubGV0IGNvcHkgc3JjID1cbiAgbGV0IGRzdCA9IGNyZWF0ZSB+Y2FwYWNpdHk6c3JjLmxlbmd0aCAoKSBpblxuICBibGl0X3RvX2FycmF5IH5zcmMgZHN0LmVsdHM7XG4gIGRzdC5sZW5ndGggPC0gc3JjLmxlbmd0aDtcbiAgZHN0XG47O1xuXG5sZXQgb2ZfbGlzdCBsID1cbiAgKCogVHJhdmVyc2luZyB0aGUgbGlzdCB1cCBmcm9udCB0byBjb21wdXRlIGl0cyBsZW5ndGggaXMgcHJvYmFibHkgKGJ1dCBub3QgZGVmaW5pdGVseSlcbiAgICAgYmV0dGVyIHRoYW4gZG91YmxpbmcgdGhlIHVuZGVybHlpbmcgYXJyYXkgc2l6ZSBzZXZlcmFsIHRpbWVzIGZvciBsYXJnZSBxdWV1ZXMuICopXG4gIGxldCB0ID0gY3JlYXRlIH5jYXBhY2l0eTooTGlzdC5sZW5ndGggbCkgKCkgaW5cbiAgTGlzdC5pdGVyIGwgfmY6KGZ1biB4IC0+IGVucXVldWUgdCB4KTtcbiAgdFxuOztcblxuKCogVGhlIHF1ZXVlIFt0XSByZXR1cm5lZCBieSBbY3JlYXRlXSB3aWxsIGhhdmUgW3QubGVuZ3RoID0gMF0sIFt0LmZyb250ID0gMF0sIGFuZFxuICAgW2NhcGFjaXR5IHQgPSBJbnQuY2VpbF9wb3cyIGxlbl0uICBTbywgd2Ugb25seSBoYXZlIHRvIHNldCBbdC5sZW5ndGhdIHRvIFtsZW5dIGFmdGVyXG4gICB0aGUgYmxpdCB0byBtYWludGFpbiBhbGwgdGhlIGludmFyaWFudHM6IFt0Lmxlbmd0aF0gaXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBlbGVtZW50c1xuICAgaW4gdGhlIHF1ZXVlLCBbdC5mcm9udF0gaXMgdGhlIGFycmF5IGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBxdWV1ZSwgYW5kXG4gICBbY2FwYWNpdHkgdCA9IE9wdGlvbl9hcnJheS5sZW5ndGggdC5lbHRzXS4gKilcbmxldCBpbml0IGxlbiB+ZiA9XG4gIGlmIGxlbiA8IDBcbiAgdGhlblxuICAgIEVycm9yLnJhaXNlX3NcbiAgICAgIChTZXhwLm1lc3NhZ2UgXCJRdWV1ZS5pbml0OiBuZWdhdGl2ZSBsZW5ndGhcIiBbIFwibGVuZ3RoXCIsIGxlbiB8PiBJbnQuc2V4cF9vZl90IF0pO1xuICBsZXQgdCA9IGNyZWF0ZSB+Y2FwYWNpdHk6bGVuICgpIGluXG4gIGFzc2VydCAoT3B0aW9uX2FycmF5Lmxlbmd0aCB0LmVsdHMgPj0gbGVuKTtcbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHQuZWx0cyBpIChmIGkpXG4gIGRvbmU7XG4gIHQubGVuZ3RoIDwtIGxlbjtcbiAgdFxuOztcblxubGV0IG9mX2FycmF5IGEgPSBpbml0IChBcnJheS5sZW5ndGggYSkgfmY6KEFycmF5LnVuc2FmZV9nZXQgYSlcbmxldCB0b19hcnJheSB0ID0gQXJyYXkuaW5pdCB0Lmxlbmd0aCB+ZjooZnVuIGkgLT4gdW5zYWZlX2dldCB0IGkpXG5cbmxldCBtYXAgdGEgfmYgPVxuICBsZXQgbnVtX211dGF0aW9ucyA9IHRhLm51bV9tdXRhdGlvbnMgaW5cbiAgbGV0IHRiID0gY3JlYXRlIH5jYXBhY2l0eTp0YS5sZW5ndGggKCkgaW5cbiAgdGIubGVuZ3RoIDwtIHRhLmxlbmd0aDtcbiAgZm9yIGkgPSAwIHRvIHRhLmxlbmd0aCAtIDEgZG9cbiAgICBsZXQgYiA9IGYgKHVuc2FmZV9nZXQgdGEgaSkgaW5cbiAgICBlbnN1cmVfbm9fbXV0YXRpb24gdGEgbnVtX211dGF0aW9ucztcbiAgICBPcHRpb25fYXJyYXkudW5zYWZlX3NldF9zb21lIHRiLmVsdHMgaSBiXG4gIGRvbmU7XG4gIHRiXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IGkgPSByZWYgMCBpblxuICBtYXAgdCB+ZjooZnVuIGEgLT5cbiAgICBsZXQgcmVzdWx0ID0gZiAhaSBhIGluXG4gICAgaSA6PSAhaSArIDE7XG4gICAgcmVzdWx0KVxuOztcblxubGV0IHNpbmdsZXRvbiB4ID1cbiAgbGV0IHQgPSBjcmVhdGUgKCkgaW5cbiAgZW5xdWV1ZSB0IHg7XG4gIHRcbjs7XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9hIHQgPSB0b19saXN0IHQgfD4gTGlzdC5zZXhwX29mX3Qgc2V4cF9vZl9hXG5sZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID0gTGlzdC50X29mX3NleHAgYV9vZl9zZXhwIHNleHAgfD4gb2ZfbGlzdFxuXG5sZXQgdF9zZXhwX2dyYW1tYXIgKHR5cGUgYSkgKGdyYW1tYXIgOiBhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICA6IGEgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICA9XG4gIFNleHBsaWIwLlNleHBfZ3JhbW1hci5jb2VyY2UgKExpc3QudF9zZXhwX2dyYW1tYXIgZ3JhbW1hcilcbjs7XG4iLCJvcGVuISBJbXBvcnRcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gfFxuXG4gIGxldCB1bnJlYWNoYWJsZV9jb2RlID0gZnVuY3Rpb25cbiAgICB8IChfIDogdCkgLT4gLlxuICA7O1xuXG4gIGxldCBhbGwgPSBbXVxuICBsZXQgaGFzaF9mb2xkX3QgXyB0ID0gdW5yZWFjaGFibGVfY29kZSB0XG4gIGxldCBoYXNoID0gdW5yZWFjaGFibGVfY29kZVxuICBsZXQgY29tcGFyZSBhIF8gPSB1bnJlYWNoYWJsZV9jb2RlIGFcbiAgbGV0IHNleHBfb2ZfdCA9IHVucmVhY2hhYmxlX2NvZGVcbiAgbGV0IHRfb2Zfc2V4cCBzZXhwID0gU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLmVtcHR5X3R5cGUgXCJCYXNlLk5vdGhpbmcudFwiIHNleHBcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0geyB1bnR5cGVkID0gVW5pb24gW10gfVxuICBsZXQgdG9fc3RyaW5nID0gdW5yZWFjaGFibGVfY29kZVxuICBsZXQgb2Zfc3RyaW5nIChfIDogc3RyaW5nKSA9IGZhaWx3aXRoIFwiQmFzZS5Ob3RoaW5nLm9mX3N0cmluZzogbm90IHN1cHBvcnRlZFwiXG5lbmRcblxuaW5jbHVkZSBUXG5cbmluY2x1ZGUgSWRlbnRpZmlhYmxlLk1ha2UgKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLk5vdGhpbmdcIlxuICBlbmQpXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIENhbWwuTmF0aXZlaW50XG5pbmNsdWRlIE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gbmF0aXZlaW50IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIGhhc2hfZm9sZF9uYXRpdmVpbnRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX25hdGl2ZWludCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAobmF0aXZlaW50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdClcbiAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX25hdGl2ZWludCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBuYXRpdmVpbnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlID0gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIG9wZW4gTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gICAgdHlwZSB0ID0gbmF0aXZlaW50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9uYXRpdmVpbnQgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX25hdGl2ZWludFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX25hdGl2ZWludCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gbmVnXG4gICAgbGV0ICggPCApID0gKCA8IClcbiAgICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiVueFwiIGlcbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBDYW1sLlNjYW5mLnNzY2FuZiBzIFwiJW54XCIgRm4uaWRcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuTmF0aXZlaW50LkhleFwiXG4gIGVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuTmF0aXZlaW50XCJcbiAgZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgbnVtX2JpdHMgPSBXb3JkX3NpemUubnVtX2JpdHMgV29yZF9zaXplLndvcmRfc2l6ZVxubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gbG9nbm90XG5sZXQgYml0X3hvciA9IGxvZ3hvclxubGV0IGJpdF9vciA9IGxvZ29yXG5sZXQgYml0X2FuZCA9IGxvZ2FuZFxubGV0IG1pbl92YWx1ZSA9IG1pbl9pbnRcbmxldCBtYXhfdmFsdWUgPSBtYXhfaW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1pbnVzX29uZSA9IG1pbnVzX29uZVxubGV0IG9uZSA9IG9uZVxubGV0IHplcm8gPSB6ZXJvXG5sZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCA9IG9mX2Zsb2F0XG5cbmxldCBvZl9mbG9hdCBmID1cbiAgaWYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBmIGZsb2F0X2xvd2VyX2JvdW5kXG4gICYmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oIDw9ICkgZiBmbG9hdF91cHBlcl9ib3VuZFxuICB0aGVuIG9mX2Zsb2F0IGZcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiTmF0aXZlaW50Lm9mX2Zsb2F0OiBhcmd1bWVudCAoJWYpIGlzIG91dCBvZiByYW5nZSBvciBOYU5cIlxuICAgICAgKEZsb2F0MC5ib3ggZilcbiAgICAgICgpXG47O1xuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcbiAgb3BlbiBOYXRpdmVpbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgbGV0IG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKSA9XG4gICAgUHJpbnRmLmludmFsaWRfYXJnZiBcImFyZ3VtZW50IG11c3QgYmUgc3RyaWN0bHkgcG9zaXRpdmVcIiAoKVxuICA7O1xuXG4gIGxldCAoIGxvciApID0gQ2FtbC5OYXRpdmVpbnQubG9nb3JcbiAgbGV0ICggbHNyICkgPSBDYW1sLk5hdGl2ZWludC5zaGlmdF9yaWdodF9sb2dpY2FsXG4gIGxldCAoIGxhbmQgKSA9IENhbWwuTmF0aXZlaW50LmxvZ2FuZFxuXG4gICgqKiBcImNlaWxpbmcgcG93ZXIgb2YgMlwiIC0gTGVhc3QgcG93ZXIgb2YgMiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGNlaWxfcG93MiAoeCA6IG5hdGl2ZWludCkgPVxuICAgIGlmIHggPD0gMG4gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSBDYW1sLk5hdGl2ZWludC5wcmVkIHggaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgICgqIFRoZSBuZXh0IGxpbmUgaXMgc3VwZXJmbHVvdXMgb24gMzItYml0IGFyY2hpdGVjdHVyZXMsIGJ1dCBpdCdzIGZhc3RlciB0byBkbyBpdFxuICAgICAgIGFueXdheSB0aGFuIHRvIGJyYW5jaCAqKVxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIENhbWwuTmF0aXZlaW50LnN1Y2MgeFxuICA7O1xuXG4gICgqKiBcImZsb29yIHBvd2VyIG9mIDJcIiAtIExhcmdlc3QgcG93ZXIgb2YgMiBsZXNzIHRoYW4gb3IgZXF1YWwgdG8geC4gKilcbiAgbGV0IGZsb29yX3BvdzIgeCA9XG4gICAgaWYgeCA8PSAwbiB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDMyKSBpblxuICAgIENhbWwuTmF0aXZlaW50LnN1YiB4ICh4IGxzciAxKVxuICA7O1xuXG4gIGxldCBpc19wb3cyIHggPVxuICAgIGlmIHggPD0gMG4gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kIENhbWwuTmF0aXZlaW50LnByZWQgeCA9IDBuXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgbmF0aXZlaW50IGNseiBhbmQgY3R6IHRvIHVzZSB0aGUgQ0xaL0JTUi9DVFovQlNGIGluc3RydWN0aW9uIHdoZXJlIHBvc3NpYmxlICopXG4gIGV4dGVybmFsIGNselxuICAgIDogIChuYXRpdmVpbnRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9uYXRpdmVpbnRfY2x6XCIgXCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jbHpfdW5ib3hlZFwiXG4gIFtAQG5vYWxsb2NdXG5cbiAgZXh0ZXJuYWwgY3R6XG4gICAgOiAgKG5hdGl2ZWludFtAdW5ib3hlZF0pXG4gICAgLT4gKGludFtAdW50YWdnZWRdKVxuICAgID0gXCJCYXNlX2ludF9tYXRoX25hdGl2ZWludF9jdHpcIiBcIkJhc2VfaW50X21hdGhfbmF0aXZlaW50X2N0el91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBmbG9vcl9sb2cyIGkgPVxuICAgIGlmIFBvbHkuKCA8PSApIGkgQ2FtbC5OYXRpdmVpbnQuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIltOYXRpdmVpbnQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIlxuICAgICAgICAgICBbIFwiXCIsIHNleHBfb2ZfbmF0aXZlaW50IGkgXSk7XG4gICAgbnVtX2JpdHMgLSAxIC0gY2x6IGlcbiAgOztcblxuICAoKiogSGFja2VyJ3MgRGVsaWdodCBTZWNvbmQgRWRpdGlvbiBwMTA2ICopXG4gIGxldCBjZWlsX2xvZzIgaSA9XG4gICAgaWYgUG9seS4oIDw9ICkgaSBDYW1sLk5hdGl2ZWludC56ZXJvXG4gICAgdGhlblxuICAgICAgcmFpc2Vfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiW05hdGl2ZWludC5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCJcbiAgICAgICAgICAgWyBcIlwiLCBzZXhwX29mX25hdGl2ZWludCBpIF0pO1xuICAgIGlmIENhbWwuTmF0aXZlaW50LmVxdWFsIGkgQ2FtbC5OYXRpdmVpbnQub25lXG4gICAgdGhlbiAwXG4gICAgZWxzZSBudW1fYml0cyAtIGNseiAoQ2FtbC5OYXRpdmVpbnQucHJlZCBpKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgUG93MlxuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCBpbmNyIHIgPSByIDo9ICFyICsgb25lXG5sZXQgZGVjciByID0gciA6PSAhciAtIG9uZVxubGV0IG9mX25hdGl2ZWludCB0ID0gdFxubGV0IG9mX25hdGl2ZWludF9leG4gPSBvZl9uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnQgdCA9IHRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gdG9fbmF0aXZlaW50XG5sZXQgcG9wY291bnQgPSBQb3Bjb3VudC5uYXRpdmVpbnRfcG9wY291bnRcbmxldCBvZl9pbnQgPSBDb252LmludF90b19uYXRpdmVpbnRcbmxldCBvZl9pbnRfZXhuID0gb2ZfaW50XG5sZXQgdG9faW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50XG5sZXQgdG9faW50X2V4biA9IENvbnYubmF0aXZlaW50X3RvX2ludF9leG5cbmxldCB0b19pbnRfdHJ1bmMgPSBDb252Lm5hdGl2ZWludF90b19pbnRfdHJ1bmNcbmxldCBvZl9pbnQzMiA9IENvbnYuaW50MzJfdG9fbmF0aXZlaW50XG5sZXQgb2ZfaW50MzJfZXhuID0gb2ZfaW50MzJcbmxldCB0b19pbnQzMiA9IENvbnYubmF0aXZlaW50X3RvX2ludDMyXG5sZXQgdG9faW50MzJfZXhuID0gQ29udi5uYXRpdmVpbnRfdG9faW50MzJfZXhuXG5sZXQgdG9faW50MzJfdHJ1bmMgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl90cnVuY1xubGV0IG9mX2ludDY0ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRcbmxldCBvZl9pbnQ2NF9leG4gPSBDb252LmludDY0X3RvX25hdGl2ZWludF9leG5cbmxldCBvZl9pbnQ2NF90cnVuYyA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50X3RydW5jXG5sZXQgdG9faW50NjQgPSBDb252Lm5hdGl2ZWludF90b19pbnQ2NFxubGV0IHBvdyBiIGUgPSBvZl9pbnRfZXhuIChJbnRfbWF0aC5Qcml2YXRlLmludF9wb3cgKHRvX2ludF9leG4gYikgKHRvX2ludF9leG4gZSkpXG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGxldCAoICsgKSA9ICggKyApXG4gIGxldCAoIC0gKSA9ICggLSApXG4gIGxldCAoICogKSA9ICggKiApXG4gIGxldCAoIC8gKSA9ICggLyApXG4gIGxldCAoIH4tICkgPSAoIH4tIClcbiAgbGV0ICggKiogKSA9ICggKiogKVxuXG4gIGluY2x1ZGUgKE5hdGl2ZWludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludF9leG4gPSBvZl9pbnRfZXhuXG5lbmRcblxubW9kdWxlIE8gPSBzdHJ1Y3RcbiAgaW5jbHVkZSBQcmVfT1xuXG4gIGluY2x1ZGUgSW50X21hdGguTWFrZSAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBpbmNsdWRlIFByZV9PXG5cbiAgICAgIGxldCByZW0gPSByZW1cbiAgICAgIGxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG4gICAgICBsZXQgb2ZfZmxvYXQgPSBvZl9mbG9hdFxuICAgICAgbGV0IG9mX3N0cmluZyA9IFQub2Zfc3RyaW5nXG4gICAgICBsZXQgdG9fc3RyaW5nID0gVC50b19zdHJpbmdcbiAgICBlbmQpXG5cbiAgbGV0ICggbGFuZCApID0gYml0X2FuZFxuICBsZXQgKCBsb3IgKSA9IGJpdF9vclxuICBsZXQgKCBseG9yICkgPSBiaXRfeG9yXG4gIGxldCBsbm90ID0gYml0X25vdFxuICBsZXQgKCBsc2wgKSA9IHNoaWZ0X2xlZnRcbiAgbGV0ICggYXNyICkgPSBzaGlmdF9yaWdodFxuICBsZXQgKCBsc3IgKSA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmVuZFxuXG5pbmNsdWRlIE9cblxuKCogW05hdGl2ZWludF0gYW5kIFtOYXRpdmVpbnQuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgTmF0aXZlaW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5leHRlcm5hbCBic3dhcCA6IHQgLT4gdCA9IFwiJWJzd2FwX25hdGl2ZVwiXG4iLCIoKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdGl2ZSBDYW1sICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICopXG4oKiAgZW4gQXV0b21hdGlxdWUuICBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBmaWxlIGlzIGRpc3RyaWJ1dGVkICAgICopXG4oKiAgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBBcGFjaGUgMi4wIGxpY2Vuc2UuIFNlZSAuLi9USElSRC1QQVJUWS50eHQgICopXG4oKiAgZm9yIGRldGFpbHMuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICopXG4oKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbm9wZW4hIEltcG9ydFxubW9kdWxlIExpc3QgPSBMaXN0MFxuaW5jbHVkZSBNYXBfaW50ZlxuXG5tb2R1bGUgRmluaXNoZWRfb3JfdW5maW5pc2hlZCA9IHN0cnVjdFxuICBpbmNsdWRlIE1hcF9pbnRmLkZpbmlzaGVkX29yX3VuZmluaXNoZWRcblxuICAoKiBUaGVzZSB0d28gZnVuY3Rpb25zIGFyZSB0ZXN0ZWQgaW4gW3Rlc3RfbWFwLm1sXSB0byBtYWtlIHN1cmUgb3VyIHVzZSBvZlxuICAgICBbQ2FtbC5PYmoubWFnaWNdIGlzIGNvcnJlY3QgYW5kIHNhZmUuICopXG4gIGxldCBvZl9jb250aW51ZV9vcl9zdG9wIDogQ29udGludWVfb3Jfc3RvcC50IC0+IHQgPSBDYW1sLk9iai5tYWdpY1xuICBsZXQgdG9fY29udGludWVfb3Jfc3RvcCA6IHQgLT4gQ29udGludWVfb3Jfc3RvcC50ID0gQ2FtbC5PYmoubWFnaWNcbmVuZFxuXG5tb2R1bGUgTWVyZ2VfZWxlbWVudCA9IHN0cnVjdFxuICBpbmNsdWRlIE1hcF9pbnRmLk1lcmdlX2VsZW1lbnRcblxuICBsZXQgbGVmdCA9IGZ1bmN0aW9uXG4gICAgfCBgUmlnaHQgXyAtPiBOb25lXG4gICAgfCBgTGVmdCBsZWZ0IHwgYEJvdGggKGxlZnQsIF8pIC0+IFNvbWUgbGVmdFxuICA7O1xuXG4gIGxldCByaWdodCA9IGZ1bmN0aW9uXG4gICAgfCBgTGVmdCBfIC0+IE5vbmVcbiAgICB8IGBSaWdodCByaWdodCB8IGBCb3RoIChfLCByaWdodCkgLT4gU29tZSByaWdodFxuICA7O1xuXG4gIGxldCBsZWZ0X3ZhbHVlIHQgfmRlZmF1bHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYFJpZ2h0IF8gLT4gZGVmYXVsdFxuICAgIHwgYExlZnQgbGVmdCB8IGBCb3RoIChsZWZ0LCBfKSAtPiBsZWZ0XG4gIDs7XG5cbiAgbGV0IHJpZ2h0X3ZhbHVlIHQgfmRlZmF1bHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYExlZnQgXyAtPiBkZWZhdWx0XG4gICAgfCBgUmlnaHQgcmlnaHQgfCBgQm90aCAoXywgcmlnaHQpIC0+IHJpZ2h0XG4gIDs7XG5cbiAgbGV0IHZhbHVlcyB0IH5sZWZ0X2RlZmF1bHQgfnJpZ2h0X2RlZmF1bHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgYExlZnQgbGVmdCAtPiBsZWZ0LCByaWdodF9kZWZhdWx0XG4gICAgfCBgUmlnaHQgcmlnaHQgLT4gbGVmdF9kZWZhdWx0LCByaWdodFxuICAgIHwgYEJvdGggKGxlZnQsIHJpZ2h0KSAtPiBsZWZ0LCByaWdodFxuICA7O1xuZW5kXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5cbmV4Y2VwdGlvbiBEdXBsaWNhdGUgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBdXG5cbmxldCAoKSA9XG4gIFNleHBsaWIwLlNleHBfY29udi5FeG5fY29udmVydGVyLmFkZCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBEdXBsaWNhdGVdIChmdW5jdGlvblxuICAgIHwgRHVwbGljYXRlIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIm1hcC5tbC5EdXBsaWNhdGVcIlxuICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UpXG47O1xuXG5bQEBAZW5kXVxuXG5tb2R1bGUgVHJlZTAgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssICd2KSB0ID1cbiAgICB8IEVtcHR5XG4gICAgfCBMZWFmIG9mICdrICogJ3ZcbiAgICB8IE5vZGUgb2YgKCdrLCAndikgdCAqICdrICogJ3YgKiAoJ2ssICd2KSB0ICogaW50XG5cbiAgdHlwZSAoJ2ssICd2KSB0cmVlID0gKCdrLCAndikgdFxuXG4gIGxldCBoZWlnaHQgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgLT4gMFxuICAgIHwgTGVhZiBfIC0+IDFcbiAgICB8IE5vZGUgKF8sIF8sIF8sIF8sIGgpIC0+IGhcbiAgOztcblxuICBsZXQgaW52YXJpYW50cyA9XG4gICAgbGV0IGluX3JhbmdlIGxvd2VyIHVwcGVyIGNvbXBhcmVfa2V5IGsgPVxuICAgICAgKG1hdGNoIGxvd2VyIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgIHwgU29tZSBsb3dlciAtPiBjb21wYXJlX2tleSBsb3dlciBrIDwgMClcbiAgICAgICYmXG4gICAgICBtYXRjaCB1cHBlciB3aXRoXG4gICAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgICAgfCBTb21lIHVwcGVyIC0+IGNvbXBhcmVfa2V5IGsgdXBwZXIgPCAwXG4gICAgaW5cbiAgICBsZXQgcmVjIGxvb3AgbG93ZXIgdXBwZXIgY29tcGFyZV9rZXkgdCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gdHJ1ZVxuICAgICAgfCBMZWFmIChrLCBfKSAtPiBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2tleSBrXG4gICAgICB8IE5vZGUgKGwsIGssIF8sIHIsIGgpIC0+XG4gICAgICAgIGxldCBobCA9IGhlaWdodCBsXG4gICAgICAgIGFuZCBociA9IGhlaWdodCByIGluXG4gICAgICAgIGFicyAoaGwgLSBocikgPD0gMlxuICAgICAgICAmJiBoID0gbWF4IGhsIGhyICsgMVxuICAgICAgICAmJiBpbl9yYW5nZSBsb3dlciB1cHBlciBjb21wYXJlX2tleSBrXG4gICAgICAgICYmIGxvb3AgbG93ZXIgKFNvbWUgaykgY29tcGFyZV9rZXkgbFxuICAgICAgICAmJiBsb29wIChTb21lIGspIHVwcGVyIGNvbXBhcmVfa2V5IHJcbiAgICBpblxuICAgIGZ1biB0IH5jb21wYXJlX2tleSAtPiBsb29wIE5vbmUgTm9uZSBjb21wYXJlX2tleSB0XG4gIDs7XG5cbiAgKCogcHJlY29uZGl0aW9uOiB8aGVpZ2h0KGwpIC0gaGVpZ2h0KHIpfCA8PSAyICopXG4gIGxldCBjcmVhdGUgbCB4IGQgciA9XG4gICAgbGV0IGhsID0gaGVpZ2h0IGxcbiAgICBhbmQgaHIgPSBoZWlnaHQgciBpblxuICAgIGlmIGhsID0gMCAmJiBociA9IDBcbiAgICB0aGVuIExlYWYgKHgsIGQpXG4gICAgZWxzZSBOb2RlIChsLCB4LCBkLCByLCBpZiBobCA+PSBociB0aGVuIGhsICsgMSBlbHNlIGhyICsgMSlcbiAgOztcblxuICBsZXQgc2luZ2xldG9uIGtleSBkYXRhID0gTGVhZiAoa2V5LCBkYXRhKVxuXG4gICgqIFdlIG11c3QgY2FsbCBbZl0gd2l0aCBpbmNyZWFzaW5nIGluZGV4ZXMsIGJlY2F1c2UgdGhlIGJpbl9wcm90IHJlYWRlciBpblxuICAgICBDb3JlLk1hcCBuZWVkcyBpdC4gKilcbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgPVxuICAgIGxldCByZWMgbG9vcCBuIH5mIGkgOiAoXywgXykgdCA9XG4gICAgICBtYXRjaCBuIHdpdGhcbiAgICAgIHwgMCAtPiBFbXB0eVxuICAgICAgfCAxIC0+XG4gICAgICAgIGxldCBrLCB2ID0gZiBpIGluXG4gICAgICAgIExlYWYgKGssIHYpXG4gICAgICB8IDIgLT5cbiAgICAgICAgbGV0IGtsLCB2bCA9IGYgaSBpblxuICAgICAgICBsZXQgaywgdiA9IGYgKGkgKyAxKSBpblxuICAgICAgICBOb2RlIChMZWFmIChrbCwgdmwpLCBrLCB2LCBFbXB0eSwgMilcbiAgICAgIHwgMyAtPlxuICAgICAgICBsZXQga2wsIHZsID0gZiBpIGluXG4gICAgICAgIGxldCBrLCB2ID0gZiAoaSArIDEpIGluXG4gICAgICAgIGxldCBrciwgdnIgPSBmIChpICsgMikgaW5cbiAgICAgICAgTm9kZSAoTGVhZiAoa2wsIHZsKSwgaywgdiwgTGVhZiAoa3IsIHZyKSwgMilcbiAgICAgIHwgbiAtPlxuICAgICAgICBsZXQgbGVmdF9sZW5ndGggPSBuIGxzciAxIGluXG4gICAgICAgIGxldCByaWdodF9sZW5ndGggPSBuIC0gbGVmdF9sZW5ndGggLSAxIGluXG4gICAgICAgIGxldCBsZWZ0ID0gbG9vcCBsZWZ0X2xlbmd0aCB+ZiBpIGluXG4gICAgICAgIGxldCBrLCB2ID0gZiAoaSArIGxlZnRfbGVuZ3RoKSBpblxuICAgICAgICBsZXQgcmlnaHQgPSBsb29wIHJpZ2h0X2xlbmd0aCB+ZiAoaSArIGxlZnRfbGVuZ3RoICsgMSkgaW5cbiAgICAgICAgY3JlYXRlIGxlZnQgayB2IHJpZ2h0XG4gICAgaW5cbiAgICBsb29wIGxlbiB+ZiAwXG4gIDs7XG5cbiAgbGV0IG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgYXJyYXlfbGVuZ3RoID0gQXJyYXkubGVuZ3RoIGFycmF5IGluXG4gICAgbGV0IG5leHQgPVxuICAgICAgaWYgYXJyYXlfbGVuZ3RoIDwgMlxuICAgICAgICAgfHxcbiAgICAgICAgIGxldCBrMCwgXyA9IGFycmF5LigwKSBpblxuICAgICAgICAgbGV0IGsxLCBfID0gYXJyYXkuKDEpIGluXG4gICAgICAgICBjb21wYXJlX2tleSBrMCBrMSA8IDBcbiAgICAgIHRoZW4gZnVuIGkgLT4gYXJyYXkuKGkpXG4gICAgICBlbHNlIGZ1biBpIC0+IGFycmF5LihhcnJheV9sZW5ndGggLSAxIC0gaSlcbiAgICBpblxuICAgIG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW46YXJyYXlfbGVuZ3RoIH5mOm5leHQsIGFycmF5X2xlbmd0aFxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCBhcnJheSB3aXRoXG4gICAgfCBbfHxdIHwgW3wgXyB8XSAtPiBSZXN1bHQuT2sgKG9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5KVxuICAgIHwgXyAtPlxuICAgICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICAgIGxldCBpbmNyZWFzaW5nID1cbiAgICAgICAgICBtYXRjaCBjb21wYXJlX2tleSAoZnN0IGFycmF5LigwKSkgKGZzdCBhcnJheS4oMSkpIHdpdGhcbiAgICAgICAgICB8IDAgLT4gci5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX3NvcnRlZF9hcnJheTogZHVwbGljYXRlZCBlbGVtZW50c1wiKVxuICAgICAgICAgIHwgaSAtPiBpIDwgMFxuICAgICAgICBpblxuICAgICAgICBmb3IgaSA9IDEgdG8gQXJyYXkubGVuZ3RoIGFycmF5IC0gMiBkb1xuICAgICAgICAgIG1hdGNoIGNvbXBhcmVfa2V5IChmc3QgYXJyYXkuKGkpKSAoZnN0IGFycmF5LihpICsgMSkpIHdpdGhcbiAgICAgICAgICB8IDAgLT4gci5yZXR1cm4gKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX3NvcnRlZF9hcnJheTogZHVwbGljYXRlZCBlbGVtZW50c1wiKVxuICAgICAgICAgIHwgaSAtPlxuICAgICAgICAgICAgaWYgUG9seS4oIDw+ICkgKGkgPCAwKSBpbmNyZWFzaW5nXG4gICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgIHIucmV0dXJuXG4gICAgICAgICAgICAgICAgKE9yX2Vycm9yLmVycm9yX3N0cmluZyBcIm9mX3NvcnRlZF9hcnJheTogZWxlbWVudHMgYXJlIG5vdCBvcmRlcmVkXCIpXG4gICAgICAgIGRvbmU7XG4gICAgICAgIFJlc3VsdC5PayAob2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhcnJheSB+Y29tcGFyZV9rZXkpKVxuICA7O1xuXG4gICgqIHByZWNvbmRpdGlvbjogfGhlaWdodChsKSAtIGhlaWdodChyKXwgPD0gMyAqKVxuICBsZXQgYmFsIGwgeCBkIHIgPVxuICAgIGxldCBobCA9IGhlaWdodCBsIGluXG4gICAgbGV0IGhyID0gaGVpZ2h0IHIgaW5cbiAgICBpZiBobCA+IGhyICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggbCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2UgKCogaGVpZ2h0KExlYWYpID0gMSAmJiAxIGlzIG5vdCBsYXJnZXIgdGhhbiBociArIDIgKilcbiAgICAgIHwgTm9kZSAobGwsIGx2LCBsZCwgbHIsIF8pIC0+XG4gICAgICAgIGlmIGhlaWdodCBsbCA+PSBoZWlnaHQgbHJcbiAgICAgICAgdGhlbiBjcmVhdGUgbGwgbHYgbGQgKGNyZWF0ZSBsciB4IGQgcilcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggbHIgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICB8IExlYWYgKGxydiwgbHJkKSAtPiBjcmVhdGUgKGNyZWF0ZSBsbCBsdiBsZCBFbXB0eSkgbHJ2IGxyZCAoY3JlYXRlIEVtcHR5IHggZCByKVxuICAgICAgICAgIHwgTm9kZSAobHJsLCBscnYsIGxyZCwgbHJyLCBfKSAtPlxuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbGwgbHYgbGQgbHJsKSBscnYgbHJkIChjcmVhdGUgbHJyIHggZCByKSkpXG4gICAgZWxzZSBpZiBociA+IGhsICsgMlxuICAgIHRoZW4gKFxuICAgICAgbWF0Y2ggciB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGludmFsaWRfYXJnIFwiTWFwLmJhbFwiXG4gICAgICB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2UgKCogaGVpZ2h0KExlYWYpID0gMSAmJiAxIGlzIG5vdCBsYXJnZXIgdGhhbiBobCArIDIgKilcbiAgICAgIHwgTm9kZSAocmwsIHJ2LCByZCwgcnIsIF8pIC0+XG4gICAgICAgIGlmIGhlaWdodCByciA+PSBoZWlnaHQgcmxcbiAgICAgICAgdGhlbiBjcmVhdGUgKGNyZWF0ZSBsIHggZCBybCkgcnYgcmQgcnJcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbWF0Y2ggcmwgd2l0aFxuICAgICAgICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAuYmFsXCJcbiAgICAgICAgICB8IExlYWYgKHJsdiwgcmxkKSAtPiBjcmVhdGUgKGNyZWF0ZSBsIHggZCBFbXB0eSkgcmx2IHJsZCAoY3JlYXRlIEVtcHR5IHJ2IHJkIHJyKVxuICAgICAgICAgIHwgTm9kZSAocmxsLCBybHYsIHJsZCwgcmxyLCBfKSAtPlxuICAgICAgICAgICAgY3JlYXRlIChjcmVhdGUgbCB4IGQgcmxsKSBybHYgcmxkIChjcmVhdGUgcmxyIHJ2IHJkIHJyKSkpXG4gICAgZWxzZSBjcmVhdGUgbCB4IGQgclxuICA7O1xuXG4gIGxldCBlbXB0eSA9IEVtcHR5XG5cbiAgbGV0IGlzX2VtcHR5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IHRydWVcbiAgICB8IF8gLT4gZmFsc2VcbiAgOztcblxuICBsZXQgcmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCB+a2V5IH5zZXhwX29mX2tleSA9XG4gICAgRXJyb3IucmFpc2Vfc1xuICAgICAgKFNleHAubWVzc2FnZSBcIltNYXAuYWRkX2V4bl0gZ290IGtleSBhbHJlYWR5IHByZXNlbnRcIiBbIFwia2V5XCIsIGtleSB8PiBzZXhwX29mX2tleSBdKVxuICA7O1xuXG4gIG1vZHVsZSBBZGRfb3Jfc2V0ID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgQWRkX2V4bl9pbnRlcm5hbFxuICAgICAgfCBBZGRfZXhuXG4gICAgICB8IFNldFxuICBlbmRcblxuXG4gIGxldCByZWMgZmluZF9hbmRfYWRkX29yX3NldFxuICAgICAgICAgICAgdFxuICAgICAgICAgICAgfmxlbmd0aFxuICAgICAgICAgICAgfmtleTp4XG4gICAgICAgICAgICB+ZGF0YVxuICAgICAgICAgICAgfmNvbXBhcmVfa2V5XG4gICAgICAgICAgICB+c2V4cF9vZl9rZXlcbiAgICAgICAgICAgIH4oYWRkX29yX3NldCA6IEFkZF9vcl9zZXQudClcbiAgICA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBMZWFmICh4LCBkYXRhKSwgbGVuZ3RoICsgMVxuICAgIHwgTGVhZiAodiwgZCkgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGFkZF9vcl9zZXQgd2l0aFxuICAgICAgICB8IEFkZF9leG5faW50ZXJuYWwgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIER1cGxpY2F0ZVxuICAgICAgICB8IEFkZF9leG4gLT4gcmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCB+a2V5OnggfnNleHBfb2Zfa2V5XG4gICAgICAgIHwgU2V0IC0+IExlYWYgKHgsIGRhdGEpLCBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIE5vZGUgKExlYWYgKHgsIGRhdGEpLCB2LCBkLCBFbXB0eSwgMiksIGxlbmd0aCArIDFcbiAgICAgIGVsc2UgTm9kZSAoRW1wdHksIHYsIGQsIExlYWYgKHgsIGRhdGEpLCAyKSwgbGVuZ3RoICsgMVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgaCkgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGFkZF9vcl9zZXQgd2l0aFxuICAgICAgICB8IEFkZF9leG5faW50ZXJuYWwgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIER1cGxpY2F0ZVxuICAgICAgICB8IEFkZF9leG4gLT4gcmFpc2Vfa2V5X2FscmVhZHlfcHJlc2VudCB+a2V5OnggfnNleHBfb2Zfa2V5XG4gICAgICAgIHwgU2V0IC0+IE5vZGUgKGwsIHgsIGRhdGEsIHIsIGgpLCBsZW5ndGgpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGwsIGxlbmd0aCA9XG4gICAgICAgICAgZmluZF9hbmRfYWRkX29yX3NldCB+bGVuZ3RoIH5rZXk6eCB+ZGF0YSBsIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgfmFkZF9vcl9zZXRcbiAgICAgICAgaW5cbiAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgciwgbGVuZ3RoID1cbiAgICAgICAgICBmaW5kX2FuZF9hZGRfb3Jfc2V0IH5sZW5ndGggfmtleTp4IH5kYXRhIHIgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSB+YWRkX29yX3NldFxuICAgICAgICBpblxuICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICA7O1xuXG4gIGxldCBhZGRfZXhuIHQgfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXkgPVxuICAgIGZpbmRfYW5kX2FkZF9vcl9zZXQgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSB+YWRkX29yX3NldDpBZGRfZXhuXG4gIDs7XG5cbiAgbGV0IGFkZF9leG5faW50ZXJuYWwgdCB+bGVuZ3RoIH5rZXkgfmRhdGEgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSA9XG4gICAgZmluZF9hbmRfYWRkX29yX3NldFxuICAgICAgdFxuICAgICAgfmxlbmd0aFxuICAgICAgfmtleVxuICAgICAgfmRhdGFcbiAgICAgIH5jb21wYXJlX2tleVxuICAgICAgfnNleHBfb2Zfa2V5XG4gICAgICB+YWRkX29yX3NldDpBZGRfZXhuX2ludGVybmFsXG4gIDs7XG5cbiAgbGV0IHNldCB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgPVxuICAgIGZpbmRfYW5kX2FkZF9vcl9zZXRcbiAgICAgIHRcbiAgICAgIH5sZW5ndGhcbiAgICAgIH5rZXlcbiAgICAgIH5kYXRhXG4gICAgICB+Y29tcGFyZV9rZXlcbiAgICAgIH5zZXhwX29mX2tleTooZnVuIF8gLT4gTGlzdCBbXSlcbiAgICAgIH5hZGRfb3Jfc2V0OlNldFxuICA7O1xuXG4gIGxldCBzZXQnIHQga2V5IGRhdGEgfmNvbXBhcmVfa2V5ID0gZnN0IChzZXQgdCB+bGVuZ3RoOjAgfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkpXG5cbiAgbW9kdWxlIEJ1aWxkX2luY3JlYXNpbmcgPSBzdHJ1Y3RcbiAgICBtb2R1bGUgRnJhZ21lbnQgPSBzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjICgnaywgJ3YpIHQgPVxuICAgICAgICB7IGxlZnRfc3VidHJlZSA6ICgnaywgJ3YpIHRcbiAgICAgICAgOyBrZXkgOiAna1xuICAgICAgICA7IGRhdGEgOiAndlxuICAgICAgICB9XG5cbiAgICAgIGxldCBzaW5nbGV0b25fdG9fdHJlZV9leG4gPSBmdW5jdGlvblxuICAgICAgICB8IHsgbGVmdF9zdWJ0cmVlID0gRW1wdHk7IGtleTsgZGF0YSB9IC0+IHNpbmdsZXRvbiBrZXkgZGF0YVxuICAgICAgICB8IF8gLT4gZmFpbHdpdGggXCJNYXAuc2luZ2xldG9uX3RvX3RyZWVfZXhuOiBub3QgYSBzaW5nbGV0b25cIlxuICAgICAgOztcblxuICAgICAgbGV0IHNpbmdsZXRvbiB+a2V5IH5kYXRhID0geyBsZWZ0X3N1YnRyZWUgPSBFbXB0eTsga2V5OyBkYXRhIH1cblxuICAgICAgKCogcHJlY29uZGl0aW9uOiB8aGVpZ2h0KGwubGVmdF9zdWJ0cmVlKSAtIGhlaWdodChyKXwgPD0gMixcbiAgICAgICAgIG1heF9rZXkobCkgPCBtaW5fa2V5KHIpXG4gICAgICAqKVxuICAgICAgbGV0IGNvbGxhcHNlIGwgciA9IGNyZWF0ZSBsLmxlZnRfc3VidHJlZSBsLmtleSBsLmRhdGEgclxuXG4gICAgICAoKiBwcmVjb25kaXRpb246IHxoZWlnaHQobC5sZWZ0X3N1YnRyZWUpIC0gaGVpZ2h0KHIubGVmdF9zdWJ0cmVlKXwgPD0gMixcbiAgICAgICAgIG1heF9rZXkobCkgPCBtaW5fa2V5KHIpXG4gICAgICAqKVxuICAgICAgbGV0IGpvaW4gbCByID0geyByIHdpdGggbGVmdF9zdWJ0cmVlID0gY29sbGFwc2UgbCByLmxlZnRfc3VidHJlZSB9XG4gICAgICBsZXQgbWF4X2tleSB0ID0gdC5rZXlcbiAgICBlbmRcblxuICAgICgqKiBCdWlsZCB0cmVlcyBmcm9tIHNpbmdsZXRvbnMgaW4gYSBiYWxhbmNlZCB3YXkgYnkgdXNpbmcgc2tldyBiaW5hcnkgZW5jb2RpbmcuXG4gICAgICAgIEVhY2ggbGV2ZWwgY29udGFpbnMgdHJlZXMgb2YgdGhlIHNhbWUgaGVpZ2h0LCBjb25zZWN1dGl2ZSBsZXZlbHMgaGF2ZSBjb25zZWN1dGl2ZVxuICAgICAgICBoZWlnaHRzLiBUaGVyZSBhcmUgbm8gZ2Fwcy4gVGhlIGZpcnN0IGxldmVsIGFyZSBzaW5nbGUga2V5cy5cbiAgICAqKVxuICAgIHR5cGUgKCdrLCAndikgdCA9XG4gICAgICB8IFplcm8gb2YgdW5pdFxuICAgICAgKCogW3VuaXRdIHRvIG1ha2UgcGF0dGVybiBtYXRjaGluZyBmYXN0ZXIgKilcbiAgICAgIHwgT25lIG9mICgnaywgJ3YpIHQgKiAoJ2ssICd2KSBGcmFnbWVudC50XG4gICAgICB8IFR3byBvZiAoJ2ssICd2KSB0ICogKCdrLCAndikgRnJhZ21lbnQudCAqICgnaywgJ3YpIEZyYWdtZW50LnRcblxuICAgIGxldCBlbXB0eSA9IFplcm8gKClcblxuICAgIGxldCBhZGRfdW5jaGVja2VkID1cbiAgICAgIGxldCByZWMgZ28gdCB4ID1cbiAgICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICAgIHwgWmVybyAoKSAtPiBPbmUgKHQsIHgpXG4gICAgICAgIHwgT25lICh0LCB5KSAtPiBUd28gKHQsIHksIHgpXG4gICAgICAgIHwgVHdvICh0LCB6LCB5KSAtPiBPbmUgKGdvIHQgKEZyYWdtZW50LmpvaW4geiB5KSwgeClcbiAgICAgIGluXG4gICAgICBmdW4gdCB+a2V5IH5kYXRhIC0+IGdvIHQgKEZyYWdtZW50LnNpbmdsZXRvbiB+a2V5IH5kYXRhKVxuICAgIDs7XG5cbiAgICBsZXQgdG9fdHJlZV91bmNoZWNrZWQgPVxuICAgICAgbGV0IHJlYyBnbyB0IHIgPVxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBaZXJvICgpIC0+IHJcbiAgICAgICAgfCBPbmUgKHQsIGwpIC0+IGdvIHQgKEZyYWdtZW50LmNvbGxhcHNlIGwgcilcbiAgICAgICAgfCBUd28gKHQsIGxsLCBsKSAtPiBnbyB0IChGcmFnbWVudC5jb2xsYXBzZSAoRnJhZ21lbnQuam9pbiBsbCBsKSByKVxuICAgICAgaW5cbiAgICAgIGZ1bmN0aW9uXG4gICAgICB8IFplcm8gKCkgLT4gRW1wdHlcbiAgICAgIHwgT25lICh0LCByKSAtPiBnbyB0IChGcmFnbWVudC5zaW5nbGV0b25fdG9fdHJlZV9leG4gcilcbiAgICAgIHwgVHdvICh0LCBsLCByKSAtPiBnbyAoT25lICh0LCBsKSkgKEZyYWdtZW50LnNpbmdsZXRvbl90b190cmVlX2V4biByKVxuICAgIDs7XG5cbiAgICBsZXQgbWF4X2tleSA9IGZ1bmN0aW9uXG4gICAgICB8IFplcm8gKCkgLT4gTm9uZVxuICAgICAgfCBPbmUgKF8sIHIpIHwgVHdvIChfLCBfLCByKSAtPiBTb21lIChGcmFnbWVudC5tYXhfa2V5IHIpXG4gICAgOztcbiAgZW5kXG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleSA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biB7IHJldHVybiB9IC0+XG4gICAgICBsZXQgYnVpbGRlciwgbGVuZ3RoID1cbiAgICAgICAgU2VxdWVuY2UuZm9sZFxuICAgICAgICAgIHNlcVxuICAgICAgICAgIH5pbml0OihCdWlsZF9pbmNyZWFzaW5nLmVtcHR5LCAwKVxuICAgICAgICAgIH5mOihmdW4gKGJ1aWxkZXIsIGxlbmd0aCkgKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgIG1hdGNoIEJ1aWxkX2luY3JlYXNpbmcubWF4X2tleSBidWlsZGVyIHdpdGhcbiAgICAgICAgICAgIHwgU29tZSBwcmV2X2tleSB3aGVuIGNvbXBhcmVfa2V5IHByZXZfa2V5IGtleSA+PSAwIC0+XG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIChPcl9lcnJvci5lcnJvcl9zdHJpbmcgXCJvZl9pbmNyZWFzaW5nX3NlcXVlbmNlOiBub24taW5jcmVhc2luZyBrZXlcIilcbiAgICAgICAgICAgIHwgXyAtPiBCdWlsZF9pbmNyZWFzaW5nLmFkZF91bmNoZWNrZWQgYnVpbGRlciB+a2V5IH5kYXRhLCBsZW5ndGggKyAxKVxuICAgICAgaW5cbiAgICAgIE9rIChCdWlsZF9pbmNyZWFzaW5nLnRvX3RyZWVfdW5jaGVja2VkIGJ1aWxkZXIsIGxlbmd0aCkpXG4gIDs7XG5cbiAgKCogTGlrZSBbYmFsXSBidXQgYWxsb3dzIGFueSBkaWZmZXJlbmNlIGluIGhlaWdodCBiZXR3ZWVuIFtsXSBhbmQgW3JdLlxuXG4gICAgIE8ofGhlaWdodCBsIC0gaGVpZ2h0IHJ8KSAqKVxuICBsZXQgcmVjIGpvaW4gbCBrIGQgciB+Y29tcGFyZV9rZXkgPVxuICAgIG1hdGNoIGwsIHIgd2l0aFxuICAgIHwgRW1wdHksIF8gLT4gc2V0JyByIGsgZCB+Y29tcGFyZV9rZXlcbiAgICB8IF8sIEVtcHR5IC0+IHNldCcgbCBrIGQgfmNvbXBhcmVfa2V5XG4gICAgfCBMZWFmIChsaywgbGQpLCBfIC0+IHNldCcgKHNldCcgciBrIGQgfmNvbXBhcmVfa2V5KSBsayBsZCB+Y29tcGFyZV9rZXlcbiAgICB8IF8sIExlYWYgKHJrLCByZCkgLT4gc2V0JyAoc2V0JyBsIGsgZCB+Y29tcGFyZV9rZXkpIHJrIHJkIH5jb21wYXJlX2tleVxuICAgIHwgTm9kZSAobGwsIGxrLCBsZCwgbHIsIGxoKSwgTm9kZSAocmwsIHJrLCByZCwgcnIsIHJoKSAtPlxuICAgICAgKCogW2JhbF0gcmVxdWlyZXMgaGVpZ2h0IGRpZmZlcmVuY2UgPD0gMy4gKilcbiAgICAgIGlmIGxoID4gcmggKyAzXG4gICAgICAoKiBbaGVpZ2h0IGxyID49IGhlaWdodCByXSxcbiAgICAgICAgIHRoZXJlZm9yZSBbaGVpZ2h0IChqb2luIGxyIGsgZCByIC4uLildIGlzIFtoZWlnaHQgcmwgKyAxXSBvciBbaGVpZ2h0IHJsXVxuICAgICAgICAgdGhlcmVmb3JlIHRoZSBoZWlnaHQgZGlmZmVyZW5jZSB3aXRoIFtsbF0gd2lsbCBiZSA8PSAzICopXG4gICAgICB0aGVuIGJhbCBsbCBsayBsZCAoam9pbiBsciBrIGQgciB+Y29tcGFyZV9rZXkpXG4gICAgICBlbHNlIGlmIHJoID4gbGggKyAzXG4gICAgICB0aGVuIGJhbCAoam9pbiBsIGsgZCBybCB+Y29tcGFyZV9rZXkpIHJrIHJkIHJyXG4gICAgICBlbHNlIGJhbCBsIGsgZCByXG4gIDs7XG5cbiAgbGV0IHJlYyBzcGxpdCB0IHggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5LCBOb25lLCBFbXB0eVxuICAgIHwgTGVhZiAoaywgZCkgLT5cbiAgICAgIGxldCBjbXAgPSBjb21wYXJlX2tleSB4IGsgaW5cbiAgICAgIGlmIGNtcCA9IDBcbiAgICAgIHRoZW4gRW1wdHksIFNvbWUgKGssIGQpLCBFbXB0eVxuICAgICAgZWxzZSBpZiBjbXAgPCAwXG4gICAgICB0aGVuIEVtcHR5LCBOb25lLCB0XG4gICAgICBlbHNlIHQsIE5vbmUsIEVtcHR5XG4gICAgfCBOb2RlIChsLCBrLCBkLCByLCBfKSAtPlxuICAgICAgbGV0IGNtcCA9IGNvbXBhcmVfa2V5IHggayBpblxuICAgICAgaWYgY21wID0gMFxuICAgICAgdGhlbiBsLCBTb21lIChrLCBkKSwgclxuICAgICAgZWxzZSBpZiBjbXAgPCAwXG4gICAgICB0aGVuIChcbiAgICAgICAgbGV0IGxsLCBtYXliZSwgbHIgPSBzcGxpdCBsIHggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGxsLCBtYXliZSwgam9pbiBsciBrIGQgciB+Y29tcGFyZV9rZXkpXG4gICAgICBlbHNlIChcbiAgICAgICAgbGV0IHJsLCBtYXliZSwgcnIgPSBzcGxpdCByIHggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgIGpvaW4gbCBrIGQgcmwgfmNvbXBhcmVfa2V5LCBtYXliZSwgcnIpXG4gIDs7XG5cbiAgbGV0IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB0IH5pbnRvIHggfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgbGVmdCwgYm91bmRhcnlfb3B0LCByaWdodCA9IHNwbGl0IHQgeCB+Y29tcGFyZV9rZXkgaW5cbiAgICBtYXRjaCBib3VuZGFyeV9vcHQgd2l0aFxuICAgIHwgTm9uZSAtPiBsZWZ0LCByaWdodFxuICAgIHwgU29tZSAoa2V5LCBkYXRhKSAtPlxuICAgICAgbGV0IGluc2VydF9pbnRvIHRyZWUgPSBmc3QgKHNldCB0cmVlIH5rZXkgfmRhdGEgfmxlbmd0aDowIH5jb21wYXJlX2tleSkgaW5cbiAgICAgIChtYXRjaCBpbnRvIHdpdGhcbiAgICAgICB8IGBMZWZ0IC0+IGluc2VydF9pbnRvIGxlZnQsIHJpZ2h0XG4gICAgICAgfCBgUmlnaHQgLT4gbGVmdCwgaW5zZXJ0X2ludG8gcmlnaHQpXG4gIDs7XG5cbiAgbGV0IHNwbGl0X3JhbmdlXG4gICAgICAgIHRcbiAgICAgICAgfihsb3dlcl9ib3VuZCA6ICdhIE1heWJlX2JvdW5kLnQpXG4gICAgICAgIH4odXBwZXJfYm91bmQgOiAnYSBNYXliZV9ib3VuZC50KVxuICAgICAgICB+Y29tcGFyZV9rZXlcbiAgICA9XG4gICAgaWYgTWF5YmVfYm91bmQuYm91bmRzX2Nyb3NzZWRcbiAgICAgICAgIH5jb21wYXJlOmNvbXBhcmVfa2V5XG4gICAgICAgICB+bG93ZXI6bG93ZXJfYm91bmRcbiAgICAgICAgIH51cHBlcjp1cHBlcl9ib3VuZFxuICAgIHRoZW4gZW1wdHksIGVtcHR5LCBlbXB0eVxuICAgIGVsc2UgKFxuICAgICAgbGV0IGxlZnQsIG1pZF9hbmRfcmlnaHQgPVxuICAgICAgICBtYXRjaCBsb3dlcl9ib3VuZCB3aXRoXG4gICAgICAgIHwgVW5ib3VuZGVkIC0+IGVtcHR5LCB0XG4gICAgICAgIHwgSW5jbCBsYiAtPiBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgfmludG86YFJpZ2h0IHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICAgIHwgRXhjbCBsYiAtPiBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgfmludG86YExlZnQgdCBsYiB+Y29tcGFyZV9rZXlcbiAgICAgIGluXG4gICAgICBsZXQgbWlkLCByaWdodCA9XG4gICAgICAgIG1hdGNoIHVwcGVyX2JvdW5kIHdpdGhcbiAgICAgICAgfCBVbmJvdW5kZWQgLT4gbWlkX2FuZF9yaWdodCwgZW1wdHlcbiAgICAgICAgfCBJbmNsIGxiIC0+IHNwbGl0X2FuZF9yZWluc2VydF9ib3VuZGFyeSB+aW50bzpgTGVmdCBtaWRfYW5kX3JpZ2h0IGxiIH5jb21wYXJlX2tleVxuICAgICAgICB8IEV4Y2wgbGIgLT5cbiAgICAgICAgICBzcGxpdF9hbmRfcmVpbnNlcnRfYm91bmRhcnkgfmludG86YFJpZ2h0IG1pZF9hbmRfcmlnaHQgbGIgfmNvbXBhcmVfa2V5XG4gICAgICBpblxuICAgICAgbGVmdCwgbWlkLCByaWdodClcbiAgOztcblxuICBsZXQgcmVjIGZpbmQgdCB4IH5jb21wYXJlX2tleSA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmICh2LCBkKSAtPiBpZiBjb21wYXJlX2tleSB4IHYgPSAwIHRoZW4gU29tZSBkIGVsc2UgTm9uZVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICBpZiBjID0gMCB0aGVuIFNvbWUgZCBlbHNlIGZpbmQgKGlmIGMgPCAwIHRoZW4gbCBlbHNlIHIpIHggfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbGV0IGFkZF9tdWx0aSB0IH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBkYXRhID0gZGF0YSA6OiBPcHRpb24udmFsdWUgKGZpbmQgdCBrZXkgfmNvbXBhcmVfa2V5KSB+ZGVmYXVsdDpbXSBpblxuICAgIHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgdCB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBsZXQgZmluZF9tdWx0aSB0IHggfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCBmaW5kIHQgeCB+Y29tcGFyZV9rZXkgd2l0aFxuICAgIHwgTm9uZSAtPiBbXVxuICAgIHwgU29tZSBsIC0+IGxcbiAgOztcblxuICBsZXQgZmluZF9leG4gPVxuICAgIGxldCBpZl9ub3RfZm91bmQga2V5IH5zZXhwX29mX2tleSA9XG4gICAgICByYWlzZSAoTm90X2ZvdW5kX3MgKExpc3QgWyBBdG9tIFwiTWFwLmZpbmRfZXhuOiBub3QgZm91bmRcIjsgc2V4cF9vZl9rZXkga2V5IF0pKVxuICAgIGluXG4gICAgbGV0IHJlYyBmaW5kX2V4biB0IHggfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaWZfbm90X2ZvdW5kIHggfnNleHBfb2Zfa2V5XG4gICAgICB8IExlYWYgKHYsIGQpIC0+IGlmIGNvbXBhcmVfa2V5IHggdiA9IDAgdGhlbiBkIGVsc2UgaWZfbm90X2ZvdW5kIHggfnNleHBfb2Zfa2V5XG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwIHRoZW4gZCBlbHNlIGZpbmRfZXhuIChpZiBjIDwgMCB0aGVuIGwgZWxzZSByKSB4IH5jb21wYXJlX2tleSB+c2V4cF9vZl9rZXlcbiAgICBpblxuICAgICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgICBmaW5kX2V4blxuICA7O1xuXG4gIGxldCBtZW0gdCB4IH5jb21wYXJlX2tleSA9IE9wdGlvbi5pc19zb21lIChmaW5kIHQgeCB+Y29tcGFyZV9rZXkpXG5cbiAgbGV0IHJlYyBtaW5fZWx0ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGssIGQpIC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIChFbXB0eSwgaywgZCwgXywgXykgLT4gU29tZSAoaywgZClcbiAgICB8IE5vZGUgKGwsIF8sIF8sIF8sIF8pIC0+IG1pbl9lbHQgbFxuICA7O1xuXG4gIGV4Y2VwdGlvbiBNYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwIFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBNYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwXVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgTWFwX21pbl9lbHRfZXhuX29mX2VtcHR5X21hcCAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuQXRvbSBcIm1hcC5tbC5UcmVlMC5NYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGV4Y2VwdGlvbiBNYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwIFtAQGRlcml2aW5nX2lubGluZSBzZXhwXVxuXG4gIGxldCAoKSA9XG4gICAgU2V4cGxpYjAuU2V4cF9jb252LkV4bl9jb252ZXJ0ZXIuYWRkXG4gICAgICBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBNYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwXVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcCAtPlxuICAgICAgICAgIFNleHBsaWIwLlNleHAuQXRvbSBcIm1hcC5tbC5UcmVlMC5NYXBfbWF4X2VsdF9leG5fb2ZfZW1wdHlfbWFwXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSlcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCBtaW5fZWx0X2V4biB0ID1cbiAgICBtYXRjaCBtaW5fZWx0IHQgd2l0aFxuICAgIHwgTm9uZSAtPiByYWlzZSBNYXBfbWluX2VsdF9leG5fb2ZfZW1wdHlfbWFwXG4gICAgfCBTb21lIHYgLT4gdlxuICA7O1xuXG4gIGxldCByZWMgbWF4X2VsdCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCBkKSAtPiBTb21lIChrLCBkKVxuICAgIHwgTm9kZSAoXywgaywgZCwgRW1wdHksIF8pIC0+IFNvbWUgKGssIGQpXG4gICAgfCBOb2RlIChfLCBfLCBfLCByLCBfKSAtPiBtYXhfZWx0IHJcbiAgOztcblxuICBsZXQgbWF4X2VsdF9leG4gdCA9XG4gICAgbWF0Y2ggbWF4X2VsdCB0IHdpdGhcbiAgICB8IE5vbmUgLT4gcmFpc2UgTWFwX21heF9lbHRfZXhuX29mX2VtcHR5X21hcFxuICAgIHwgU29tZSB2IC0+IHZcbiAgOztcblxuICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0IHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gaW52YWxpZF9hcmcgXCJNYXAucmVtb3ZlX21pbl9lbHRcIlxuICAgIHwgTGVhZiBfIC0+IEVtcHR5XG4gICAgfCBOb2RlIChFbXB0eSwgXywgXywgciwgXykgLT4gclxuICAgIHwgTm9kZSAobCwgeCwgZCwgciwgXykgLT4gYmFsIChyZW1vdmVfbWluX2VsdCBsKSB4IGQgclxuICA7O1xuXG4gIGxldCBhcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCBtYXhfZWx0IGxvd2VyX3BhcnQsIG1pbl9lbHQgdXBwZXJfcGFydCB3aXRoXG4gICAgfCBOb25lLCBfIC0+IGBPayB1cHBlcl9wYXJ0XG4gICAgfCBfLCBOb25lIC0+IGBPayBsb3dlcl9wYXJ0XG4gICAgfCBTb21lIChtYXhfbG93ZXIsIF8pLCBTb21lIChtaW5fdXBwZXIsIHYpIHdoZW4gY29tcGFyZV9rZXkgbWF4X2xvd2VyIG1pbl91cHBlciA8IDAgLT5cbiAgICAgIGxldCB1cHBlcl9wYXJ0X3dpdGhvdXRfbWluID0gcmVtb3ZlX21pbl9lbHQgdXBwZXJfcGFydCBpblxuICAgICAgYE9rIChqb2luIH5jb21wYXJlX2tleSBsb3dlcl9wYXJ0IG1pbl91cHBlciB2IHVwcGVyX3BhcnRfd2l0aG91dF9taW4pXG4gICAgfCBfIC0+IGBPdmVybGFwcGluZ19rZXlfcmFuZ2VzXG4gIDs7XG5cbiAgbGV0IGZvbGRfcmFuZ2VfaW5jbHVzaXZlID1cbiAgICAoKiBUaGlzIGFzc3VtZXMgdGhhdCBtaW4gPD0gbWF4LCB3aGljaCBpcyBjaGVja2VkIGJ5IHRoZSBvdXRlciBmdW5jdGlvbi4gKilcbiAgICBsZXQgcmVjIGdvIHQgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gaW5pdFxuICAgICAgfCBMZWFmIChrLCBkKSAtPlxuICAgICAgICBpZiBjb21wYXJlX2tleSBrIG1pbiA8IDAgfHwgY29tcGFyZV9rZXkgayBtYXggPiAwXG4gICAgICAgIHRoZW4gKCogayA8IG1pbiB8fCBrID4gbWF4ICopXG4gICAgICAgICAgaW5pdFxuICAgICAgICBlbHNlIGYgfmtleTprIH5kYXRhOmQgaW5pdFxuICAgICAgfCBOb2RlIChsLCBrLCBkLCByLCBfKSAtPlxuICAgICAgICBsZXQgY19taW4gPSBjb21wYXJlX2tleSBrIG1pbiBpblxuICAgICAgICBpZiBjX21pbiA8IDBcbiAgICAgICAgdGhlblxuICAgICAgICAgICgqIGlmIGsgPCBtaW4sIHRoZW4gdGhpcyBub2RlIGFuZCBpdHMgbGVmdCBicmFuY2ggYXJlIG91dHNpZGUgb3VyIHJhbmdlICopXG4gICAgICAgICAgZ28gciB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5XG4gICAgICAgIGVsc2UgaWYgY19taW4gPSAwXG4gICAgICAgIHRoZW5cbiAgICAgICAgICAoKiBpZiBrID0gbWluLCB0aGVuIHRoaXMgbm9kZSdzIGxlZnQgYnJhbmNoIGlzIG91dHNpZGUgb3VyIHJhbmdlICopXG4gICAgICAgICAgZ28gciB+bWluIH5tYXggfmluaXQ6KGYgfmtleTprIH5kYXRhOmQgaW5pdCkgfmYgfmNvbXBhcmVfa2V5XG4gICAgICAgIGVsc2UgKFxuICAgICAgICAgICgqIGsgPiBtaW4gKilcbiAgICAgICAgICBsZXQgeiA9IGdvIGwgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSBpblxuICAgICAgICAgIGxldCBjX21heCA9IGNvbXBhcmVfa2V5IGsgbWF4IGluXG4gICAgICAgICAgKCogaWYgayA+IG1heCwgd2UncmUgZG9uZSAqKVxuICAgICAgICAgIGlmIGNfbWF4ID4gMFxuICAgICAgICAgIHRoZW4gelxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IHogPSBmIH5rZXk6ayB+ZGF0YTpkIHogaW5cbiAgICAgICAgICAgICgqIGlmIGsgPSBtYXgsIHRoZW4gd2UgZm9sZCBpbiB0aGlzIG9uZSBsYXN0IHZhbHVlIGFuZCB3ZSdyZSBkb25lICopXG4gICAgICAgICAgICBpZiBjX21heCA9IDAgdGhlbiB6IGVsc2UgZ28gciB+bWluIH5tYXggfmluaXQ6eiB+ZiB+Y29tcGFyZV9rZXkpKVxuICAgIGluXG4gICAgZnVuIHQgfm1pbiB+bWF4IH5pbml0IH5mIH5jb21wYXJlX2tleSAtPlxuICAgICAgaWYgY29tcGFyZV9rZXkgbWluIG1heCA8PSAwIHRoZW4gZ28gdCB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5IGVsc2UgaW5pdFxuICA7O1xuXG4gIGxldCByYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCB+Y29tcGFyZV9rZXkgPVxuICAgIExpc3QucmV2XG4gICAgICAoZm9sZF9yYW5nZV9pbmNsdXNpdmVcbiAgICAgICAgIHRcbiAgICAgICAgIH5taW5cbiAgICAgICAgIH5tYXhcbiAgICAgICAgIH5pbml0OltdXG4gICAgICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgbCAtPiAoa2V5LCBkYXRhKSA6OiBsKVxuICAgICAgICAgfmNvbXBhcmVfa2V5KVxuICA7O1xuXG4gIGxldCBjb25jYXRfdW5jaGVja2VkIHQxIHQyID1cbiAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgIHwgRW1wdHksIHQgLT4gdFxuICAgIHwgdCwgRW1wdHkgLT4gdFxuICAgIHwgXywgXyAtPlxuICAgICAgbGV0IHgsIGQgPSBtaW5fZWx0X2V4biB0MiBpblxuICAgICAgYmFsIHQxIHggZCAocmVtb3ZlX21pbl9lbHQgdDIpXG4gIDs7XG5cbiAgZXhjZXB0aW9uIFJlbW92ZV9ub19vcFxuXG4gIGxldCByZW1vdmUgdCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgcmVjIHJlbW92ZV9sb29wIHQgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gRXhuLnJhaXNlX3dpdGhvdXRfYmFja3RyYWNlIFJlbW92ZV9ub19vcFxuICAgICAgfCBMZWFmICh2LCBfKSAtPlxuICAgICAgICBpZiBjb21wYXJlX2tleSB4IHYgPSAwXG4gICAgICAgIHRoZW4gRW1wdHksIGxlbmd0aCAtIDFcbiAgICAgICAgZWxzZSBFeG4ucmFpc2Vfd2l0aG91dF9iYWNrdHJhY2UgUmVtb3ZlX25vX29wXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgeCB2IGluXG4gICAgICAgIGlmIGMgPSAwXG4gICAgICAgIHRoZW4gY29uY2F0X3VuY2hlY2tlZCBsIHIsIGxlbmd0aCAtIDFcbiAgICAgICAgZWxzZSBpZiBjIDwgMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgbCwgbGVuZ3RoID0gcmVtb3ZlX2xvb3AgbCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgYmFsIGwgdiBkIHIsIGxlbmd0aClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgbGV0IHIsIGxlbmd0aCA9IHJlbW92ZV9sb29wIHIgeCB+bGVuZ3RoIH5jb21wYXJlX2tleSBpblxuICAgICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgaW5cbiAgICB0cnkgcmVtb3ZlX2xvb3AgdCB4IH5sZW5ndGggfmNvbXBhcmVfa2V5IHdpdGhcbiAgICB8IFJlbW92ZV9ub19vcCAtPiB0LCBsZW5ndGhcbiAgOztcblxuICAoKiBVc2UgZXhjZXB0aW9uIHRvIGF2b2lkIHRyZWUtcmVidWlsZCBpbiBuby1vcCBjYXNlICopXG4gIGV4Y2VwdGlvbiBDaGFuZ2Vfbm9fb3BcblxuICBsZXQgY2hhbmdlIHQga2V5IH5mIH5sZW5ndGggfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgcmVjIGNoYW5nZV9jb3JlIHQga2V5IGYgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+XG4gICAgICAgIChtYXRjaCBmIE5vbmUgd2l0aFxuICAgICAgICAgfCBOb25lIC0+IHJhaXNlIENoYW5nZV9ub19vcCAoKiBlcXVpdmFsZW50IHRvIHJldHVybmluZzogRW1wdHkgKilcbiAgICAgICAgIHwgU29tZSBkYXRhIC0+IExlYWYgKGtleSwgZGF0YSksIGxlbmd0aCArIDEpXG4gICAgICB8IExlYWYgKHYsIGQpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkga2V5IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbWF0Y2ggZiAoU29tZSBkKSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IEVtcHR5LCBsZW5ndGggLSAxXG4gICAgICAgICAgfCBTb21lIGQnIC0+IExlYWYgKHYsIGQnKSwgbGVuZ3RoKVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsLCBsZW5ndGggPSBjaGFuZ2VfY29yZSBFbXB0eSBrZXkgZiBpblxuICAgICAgICAgIGJhbCBsIHYgZCBFbXB0eSwgbGVuZ3RoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgciwgbGVuZ3RoID0gY2hhbmdlX2NvcmUgRW1wdHkga2V5IGYgaW5cbiAgICAgICAgICBiYWwgRW1wdHkgdiBkIHIsIGxlbmd0aClcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgaCkgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBtYXRjaCBmIChTb21lIGQpIHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gY29uY2F0X3VuY2hlY2tlZCBsIHIsIGxlbmd0aCAtIDFcbiAgICAgICAgICB8IFNvbWUgZGF0YSAtPiBOb2RlIChsLCBrZXksIGRhdGEsIHIsIGgpLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGwsIGxlbmd0aCA9IGNoYW5nZV9jb3JlIGwga2V5IGYgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgciwgbGVuZ3RoID0gY2hhbmdlX2NvcmUgciBrZXkgZiBpblxuICAgICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgaW5cbiAgICB0cnkgY2hhbmdlX2NvcmUgdCBrZXkgZiB3aXRoXG4gICAgfCBDaGFuZ2Vfbm9fb3AgLT4gdCwgbGVuZ3RoXG4gIDs7XG5cbiAgbGV0IHVwZGF0ZSB0IGtleSB+ZiB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgbGV0IHJlYyB1cGRhdGVfY29yZSB0IGtleSBmID1cbiAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgfCBFbXB0eSAtPlxuICAgICAgICBsZXQgZGF0YSA9IGYgTm9uZSBpblxuICAgICAgICBMZWFmIChrZXksIGRhdGEpLCBsZW5ndGggKyAxXG4gICAgICB8IExlYWYgKHYsIGQpIC0+XG4gICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkga2V5IHYgaW5cbiAgICAgICAgaWYgYyA9IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGQnID0gZiAoU29tZSBkKSBpblxuICAgICAgICAgIExlYWYgKHYsIGQnKSwgbGVuZ3RoKVxuICAgICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICAgIHRoZW4gKFxuICAgICAgICAgIGxldCBsLCBsZW5ndGggPSB1cGRhdGVfY29yZSBFbXB0eSBrZXkgZiBpblxuICAgICAgICAgIGJhbCBsIHYgZCBFbXB0eSwgbGVuZ3RoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgciwgbGVuZ3RoID0gdXBkYXRlX2NvcmUgRW1wdHkga2V5IGYgaW5cbiAgICAgICAgICBiYWwgRW1wdHkgdiBkIHIsIGxlbmd0aClcbiAgICAgIHwgTm9kZSAobCwgdiwgZCwgciwgaCkgLT5cbiAgICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrZXkgdiBpblxuICAgICAgICBpZiBjID0gMFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICBsZXQgZGF0YSA9IGYgKFNvbWUgZCkgaW5cbiAgICAgICAgICBOb2RlIChsLCBrZXksIGRhdGEsIHIsIGgpLCBsZW5ndGgpXG4gICAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IGwsIGxlbmd0aCA9IHVwZGF0ZV9jb3JlIGwga2V5IGYgaW5cbiAgICAgICAgICBiYWwgbCB2IGQgciwgbGVuZ3RoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBsZXQgciwgbGVuZ3RoID0gdXBkYXRlX2NvcmUgciBrZXkgZiBpblxuICAgICAgICAgIGJhbCBsIHYgZCByLCBsZW5ndGgpXG4gICAgaW5cbiAgICB1cGRhdGVfY29yZSB0IGtleSBmXG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9tdWx0aSB0IGtleSB+bGVuZ3RoIH5jb21wYXJlX2tleSA9XG4gICAgY2hhbmdlIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5IH5mOihmdW5jdGlvblxuICAgICAgfCBOb25lIHwgU29tZSAoW10gfCBbIF8gXSkgLT4gTm9uZVxuICAgICAgfCBTb21lIChfIDo6IChfIDo6IF8gYXMgbm9uX2VtcHR5X3RhaWwpKSAtPiBTb21lIG5vbl9lbXB0eV90YWlsKVxuICA7O1xuXG4gIGxldCByZWMgaXRlcl9rZXlzIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gKClcbiAgICB8IExlYWYgKHYsIF8pIC0+IGYgdlxuICAgIHwgTm9kZSAobCwgdiwgXywgciwgXykgLT5cbiAgICAgIGl0ZXJfa2V5cyB+ZiBsO1xuICAgICAgZiB2O1xuICAgICAgaXRlcl9rZXlzIH5mIHJcbiAgOztcblxuICBsZXQgcmVjIGl0ZXIgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiAoXywgZCkgLT4gZiBkXG4gICAgfCBOb2RlIChsLCBfLCBkLCByLCBfKSAtPlxuICAgICAgaXRlciB+ZiBsO1xuICAgICAgZiBkO1xuICAgICAgaXRlciB+ZiByXG4gIDs7XG5cbiAgbGV0IHJlYyBpdGVyaSB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgaXRlcmkgfmYgbDtcbiAgICAgIGYgfmtleTp2IH5kYXRhOmQ7XG4gICAgICBpdGVyaSB+ZiByXG4gIDs7XG5cbiAgbGV0IGl0ZXJpX3VudGlsID1cbiAgICBsZXQgcmVjIGl0ZXJpX3VudGlsX2xvb3AgdCB+ZiA6IENvbnRpbnVlX29yX3N0b3AudCA9XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgRW1wdHkgLT4gQ29udGludWVcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gZiB+a2V5OnYgfmRhdGE6ZFxuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICAobWF0Y2ggaXRlcmlfdW50aWxfbG9vcCB+ZiBsIHdpdGhcbiAgICAgICAgIHwgU3RvcCAtPiBTdG9wXG4gICAgICAgICB8IENvbnRpbnVlIC0+XG4gICAgICAgICAgIChtYXRjaCBmIH5rZXk6diB+ZGF0YTpkIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCAtPiBTdG9wXG4gICAgICAgICAgICB8IENvbnRpbnVlIC0+IGl0ZXJpX3VudGlsX2xvb3AgfmYgcikpXG4gICAgaW5cbiAgICBmdW4gdCB+ZiAtPiBGaW5pc2hlZF9vcl91bmZpbmlzaGVkLm9mX2NvbnRpbnVlX29yX3N0b3AgKGl0ZXJpX3VudGlsX2xvb3AgdCB+ZilcbiAgOztcblxuICBsZXQgcmVjIG1hcCB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IEVtcHR5XG4gICAgfCBMZWFmICh2LCBkKSAtPiBMZWFmICh2LCBmIGQpXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgbGV0IGwnID0gbWFwIH5mIGwgaW5cbiAgICAgIGxldCBkJyA9IGYgZCBpblxuICAgICAgbGV0IHInID0gbWFwIH5mIHIgaW5cbiAgICAgIE5vZGUgKGwnLCB2LCBkJywgcicsIGgpXG4gIDs7XG5cbiAgbGV0IHJlYyBtYXBpIHQgfmYgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgKHYsIGQpIC0+IExlYWYgKHYsIGYgfmtleTp2IH5kYXRhOmQpXG4gICAgfCBOb2RlIChsLCB2LCBkLCByLCBoKSAtPlxuICAgICAgbGV0IGwnID0gbWFwaSB+ZiBsIGluXG4gICAgICBsZXQgZCcgPSBmIH5rZXk6diB+ZGF0YTpkIGluXG4gICAgICBsZXQgcicgPSBtYXBpIH5mIHIgaW5cbiAgICAgIE5vZGUgKGwnLCB2LCBkJywgcicsIGgpXG4gIDs7XG5cbiAgbGV0IHJlYyBmb2xkIHQgfmluaXQ6YWNjdSB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBhY2N1XG4gICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkIGFjY3VcbiAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGZvbGQgfmYgciB+aW5pdDooZiB+a2V5OnYgfmRhdGE6ZCAoZm9sZCB+ZiBsIH5pbml0OmFjY3UpKVxuICA7O1xuXG4gIGxldCBmb2xkX3VudGlsIHQgfmluaXQgfmYgfmZpbmlzaCA9XG4gICAgbGV0IHJlYyBmb2xkX3VudGlsX2xvb3AgdCB+YWNjIH5mIDogKF8sIF8pIENvbnRhaW5lci5Db250aW51ZV9vcl9zdG9wLnQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IENvbnRpbnVlIGFjY1xuICAgICAgfCBMZWFmICh2LCBkKSAtPiBmIH5rZXk6diB+ZGF0YTpkIGFjY1xuICAgICAgfCBOb2RlIChsLCB2LCBkLCByLCBfKSAtPlxuICAgICAgICAobWF0Y2ggZm9sZF91bnRpbF9sb29wIGwgfmFjYyB+ZiB3aXRoXG4gICAgICAgICB8IFN0b3AgZmluYWwgLT4gU3RvcCBmaW5hbFxuICAgICAgICAgfCBDb250aW51ZSBhY2MgLT5cbiAgICAgICAgICAgKG1hdGNoIGYgfmtleTp2IH5kYXRhOmQgYWNjIHdpdGhcbiAgICAgICAgICAgIHwgU3RvcCBmaW5hbCAtPiBTdG9wIGZpbmFsXG4gICAgICAgICAgICB8IENvbnRpbnVlIGFjYyAtPiBmb2xkX3VudGlsX2xvb3AgciB+YWNjIH5mKSlcbiAgICBpblxuICAgIG1hdGNoIGZvbGRfdW50aWxfbG9vcCB0IH5hY2M6aW5pdCB+ZiB3aXRoXG4gICAgfCBDb250aW51ZSBhY2MgLT4gZmluaXNoIGFjY1xuICAgIHwgU3RvcCBzdG9wIC0+IHN0b3BcbiAgOztcblxuICBsZXQgcmVjIGZvbGRfcmlnaHQgdCB+aW5pdDphY2N1IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IGFjY3VcbiAgICB8IExlYWYgKHYsIGQpIC0+IGYgfmtleTp2IH5kYXRhOmQgYWNjdVxuICAgIHwgTm9kZSAobCwgdiwgZCwgciwgXykgLT5cbiAgICAgIGZvbGRfcmlnaHQgfmYgbCB+aW5pdDooZiB+a2V5OnYgfmRhdGE6ZCAoZm9sZF9yaWdodCB+ZiByIH5pbml0OmFjY3UpKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfa2V5cyB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgZm9sZCB+aW5pdDooRW1wdHksIDApIHQgfmY6KGZ1biB+a2V5IH5kYXRhIChhY2N1LCBsZW5ndGgpIC0+XG4gICAgICBpZiBmIGtleSB0aGVuIHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgYWNjdSB+Y29tcGFyZV9rZXkgZWxzZSBhY2N1LCBsZW5ndGgpXG4gIDs7XG5cblxuICBsZXQgZmlsdGVyIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBmb2xkIH5pbml0OihFbXB0eSwgMCkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgKGFjY3UsIGxlbmd0aCkgLT5cbiAgICAgIGlmIGYgZGF0YSB0aGVuIHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgYWNjdSB+Y29tcGFyZV9rZXkgZWxzZSBhY2N1LCBsZW5ndGgpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcmkgdCB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGZvbGQgfmluaXQ6KEVtcHR5LCAwKSB0IH5mOihmdW4gfmtleSB+ZGF0YSAoYWNjdSwgbGVuZ3RoKSAtPlxuICAgICAgaWYgZiB+a2V5IH5kYXRhIHRoZW4gc2V0IH5sZW5ndGggfmtleSB+ZGF0YSBhY2N1IH5jb21wYXJlX2tleSBlbHNlIGFjY3UsIGxlbmd0aClcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgZm9sZCB+aW5pdDooRW1wdHksIDApIHQgfmY6KGZ1biB+a2V5IH5kYXRhIChhY2N1LCBsZW5ndGgpIC0+XG4gICAgICBtYXRjaCBmIGRhdGEgd2l0aFxuICAgICAgfCBOb25lIC0+IGFjY3UsIGxlbmd0aFxuICAgICAgfCBTb21lIGIgLT4gc2V0IH5sZW5ndGggfmtleSB+ZGF0YTpiIGFjY3UgfmNvbXBhcmVfa2V5KVxuICA7O1xuXG4gIGxldCBmaWx0ZXJfbWFwaSB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgZm9sZCB+aW5pdDooRW1wdHksIDApIHQgfmY6KGZ1biB+a2V5IH5kYXRhIChhY2N1LCBsZW5ndGgpIC0+XG4gICAgICBtYXRjaCBmIH5rZXkgfmRhdGEgd2l0aFxuICAgICAgfCBOb25lIC0+IGFjY3UsIGxlbmd0aFxuICAgICAgfCBTb21lIGIgLT4gc2V0IH5sZW5ndGggfmtleSB+ZGF0YTpiIGFjY3UgfmNvbXBhcmVfa2V5KVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwaSB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgZm9sZFxuICAgICAgdFxuICAgICAgfmluaXQ6KChFbXB0eSwgMCksIChFbXB0eSwgMCkpXG4gICAgICB+ZjooZnVuIH5rZXkgfmRhdGEgKHBhaXIxLCBwYWlyMikgLT5cbiAgICAgICAgbWF0Y2ggKGYgfmtleSB+ZGF0YSA6IF8gRWl0aGVyLnQpIHdpdGhcbiAgICAgICAgfCBGaXJzdCB4IC0+XG4gICAgICAgICAgbGV0IHQsIGxlbmd0aCA9IHBhaXIxIGluXG4gICAgICAgICAgc2V0IHQgfmtleSB+ZGF0YTp4IH5jb21wYXJlX2tleSB+bGVuZ3RoLCBwYWlyMlxuICAgICAgICB8IFNlY29uZCB5IC0+XG4gICAgICAgICAgbGV0IHQsIGxlbmd0aCA9IHBhaXIyIGluXG4gICAgICAgICAgcGFpcjEsIHNldCB0IH5rZXkgfmRhdGE6eSB+Y29tcGFyZV9rZXkgfmxlbmd0aClcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcCB0IH5mIH5jb21wYXJlX2tleSA9XG4gICAgcGFydGl0aW9uX21hcGkgdCB+Y29tcGFyZV9rZXkgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25pX3RmIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBwYXJ0aXRpb25fbWFwaSB0IH5jb21wYXJlX2tleSB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgIGlmIGYgfmtleSB+ZGF0YSB0aGVuIEZpcnN0IGRhdGEgZWxzZSBTZWNvbmQgZGF0YSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIHQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBwYXJ0aXRpb25fbWFwaSB0IH5jb21wYXJlX2tleSB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPlxuICAgICAgaWYgZiBkYXRhIHRoZW4gRmlyc3QgZGF0YSBlbHNlIFNlY29uZCBkYXRhKVxuICA7O1xuXG4gIG1vZHVsZSBFbnVtID0gc3RydWN0XG4gICAgdHlwZSBpbmNyZWFzaW5nXG4gICAgdHlwZSBkZWNyZWFzaW5nXG5cbiAgICB0eXBlICgnaywgJ3YsICdkaXJlY3Rpb24pIHQgPVxuICAgICAgfCBFbmRcbiAgICAgIHwgTW9yZSBvZiAnayAqICd2ICogKCdrLCAndikgdHJlZSAqICgnaywgJ3YsICdkaXJlY3Rpb24pIHRcblxuICAgIGxldCByZWMgY29ucyB0IChlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQpIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gTW9yZSAodiwgZCwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGNvbnMgbCAoTW9yZSAodiwgZCwgciwgZSkpXG4gICAgOztcblxuICAgIGxldCByZWMgY29uc19yaWdodCB0IChlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQpIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbWF0Y2ggdCB3aXRoXG4gICAgICB8IEVtcHR5IC0+IGVcbiAgICAgIHwgTGVhZiAodiwgZCkgLT4gTW9yZSAodiwgZCwgRW1wdHksIGUpXG4gICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGNvbnNfcmlnaHQgciAoTW9yZSAodiwgZCwgbCwgZSkpXG4gICAgOztcblxuICAgIGxldCBvZl90cmVlIHRyZWUgOiAoXywgXywgaW5jcmVhc2luZykgdCA9IGNvbnMgdHJlZSBFbmRcbiAgICBsZXQgb2ZfdHJlZV9yaWdodCB0cmVlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPSBjb25zX3JpZ2h0IHRyZWUgRW5kXG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfaW5jcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIF8sIGluY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmICh2LCBkKSAtPiBsb29wIChOb2RlIChFbXB0eSwgdiwgZCwgRW1wdHksIDEpKSBlXG4gICAgICAgIHwgTm9kZSAoXywgdiwgXywgciwgXykgd2hlbiBjb21wYXJlIHYga2V5IDwgMCAtPiBsb29wIHIgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGxvb3AgbCAoTW9yZSAodiwgZCwgciwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJlIDogKF8sIF8sIGRlY3JlYXNpbmcpIHQgPVxuICAgICAgbGV0IHJlYyBsb29wIHQgZSA9XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IGVcbiAgICAgICAgfCBMZWFmICh2LCBkKSAtPiBsb29wIChOb2RlIChFbXB0eSwgdiwgZCwgRW1wdHksIDEpKSBlXG4gICAgICAgIHwgTm9kZSAobCwgdiwgXywgXywgXykgd2hlbiBjb21wYXJlIHYga2V5ID4gMCAtPiBsb29wIGwgZVxuICAgICAgICB8IE5vZGUgKGwsIHYsIGQsIHIsIF8pIC0+IGxvb3AgciAoTW9yZSAodiwgZCwgbCwgZSkpXG4gICAgICBpblxuICAgICAgbG9vcCB0IEVuZFxuICAgIDs7XG5cbiAgICBsZXQgY29tcGFyZSBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgICAgbGV0IHJlYyBsb29wIHQxIHQyID1cbiAgICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiAwXG4gICAgICAgIHwgRW5kLCBfIC0+IC0xXG4gICAgICAgIHwgXywgRW5kIC0+IDFcbiAgICAgICAgfCBNb3JlICh2MSwgZDEsIHIxLCBlMSksIE1vcmUgKHYyLCBkMiwgcjIsIGUyKSAtPlxuICAgICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgdjEgdjIgaW5cbiAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICB0aGVuIGNcbiAgICAgICAgICBlbHNlIChcbiAgICAgICAgICAgIGxldCBjID0gY29tcGFyZV9kYXRhIGQxIGQyIGluXG4gICAgICAgICAgICBpZiBjIDw+IDBcbiAgICAgICAgICAgIHRoZW4gY1xuICAgICAgICAgICAgZWxzZSBpZiBwaHlzX2VxdWFsIHIxIHIyXG4gICAgICAgICAgICB0aGVuIGxvb3AgZTEgZTJcbiAgICAgICAgICAgIGVsc2UgbG9vcCAoY29ucyByMSBlMSkgKGNvbnMgcjIgZTIpKVxuICAgICAgaW5cbiAgICAgIGxvb3AgdDEgdDJcbiAgICA7O1xuXG4gICAgbGV0IGVxdWFsIGNvbXBhcmVfa2V5IGRhdGFfZXF1YWwgdDEgdDIgPVxuICAgICAgbGV0IHJlYyBsb29wIHQxIHQyID1cbiAgICAgICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiB0cnVlXG4gICAgICAgIHwgRW5kLCBfIHwgXywgRW5kIC0+IGZhbHNlXG4gICAgICAgIHwgTW9yZSAodjEsIGQxLCByMSwgZTEpLCBNb3JlICh2MiwgZDIsIHIyLCBlMikgLT5cbiAgICAgICAgICBjb21wYXJlX2tleSB2MSB2MiA9IDBcbiAgICAgICAgICAmJiBkYXRhX2VxdWFsIGQxIGQyXG4gICAgICAgICAgJiYgaWYgcGh5c19lcXVhbCByMSByMiB0aGVuIGxvb3AgZTEgZTIgZWxzZSBsb29wIChjb25zIHIxIGUxKSAoY29ucyByMiBlMilcbiAgICAgIGluXG4gICAgICBsb29wIHQxIHQyXG4gICAgOztcblxuICAgIGxldCByZWMgZm9sZCB+aW5pdCB+ZiA9IGZ1bmN0aW9uXG4gICAgICB8IEVuZCAtPiBpbml0XG4gICAgICB8IE1vcmUgKGtleSwgZGF0YSwgdHJlZSwgZW51bSkgLT5cbiAgICAgICAgbGV0IG5leHQgPSBmIH5rZXkgfmRhdGEgaW5pdCBpblxuICAgICAgICBmb2xkIChjb25zIHRyZWUgZW51bSkgfmluaXQ6bmV4dCB+ZlxuICAgIDs7XG5cbiAgICBsZXQgZm9sZDIgY29tcGFyZV9rZXkgdDEgdDIgfmluaXQgfmYgPVxuICAgICAgbGV0IHJlYyBsb29wIHQxIHQyIGN1cnIgPVxuICAgICAgICBtYXRjaCB0MSwgdDIgd2l0aFxuICAgICAgICB8IEVuZCwgRW5kIC0+IGN1cnJcbiAgICAgICAgfCBFbmQsIF8gLT5cbiAgICAgICAgICBmb2xkIHQyIH5pbml0OmN1cnIgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBmIH5rZXkgfmRhdGE6KGBSaWdodCBkYXRhKSBhY2MpXG4gICAgICAgIHwgXywgRW5kIC0+XG4gICAgICAgICAgZm9sZCB0MSB+aW5pdDpjdXJyIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gZiB+a2V5IH5kYXRhOihgTGVmdCBkYXRhKSBhY2MpXG4gICAgICAgIHwgTW9yZSAoazEsIHYxLCB0cmVlMSwgZW51bTEpLCBNb3JlIChrMiwgdjIsIHRyZWUyLCBlbnVtMikgLT5cbiAgICAgICAgICBsZXQgY29tcGFyZV9yZXN1bHQgPSBjb21wYXJlX2tleSBrMSBrMiBpblxuICAgICAgICAgIGlmIGNvbXBhcmVfcmVzdWx0ID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5leHQgPSBmIH5rZXk6azEgfmRhdGE6KGBCb3RoICh2MSwgdjIpKSBjdXJyIGluXG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSAoY29ucyB0cmVlMiBlbnVtMikgbmV4dClcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgbGV0IG5leHQgPSBmIH5rZXk6azEgfmRhdGE6KGBMZWZ0IHYxKSBjdXJyIGluXG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSB0MiBuZXh0KVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgbGV0IG5leHQgPSBmIH5rZXk6azIgfmRhdGE6KGBSaWdodCB2MikgY3VyciBpblxuICAgICAgICAgICAgbG9vcCB0MSAoY29ucyB0cmVlMiBlbnVtMikgbmV4dClcbiAgICAgIGluXG4gICAgICBsb29wIHQxIHQyIGluaXRcbiAgICA7O1xuXG4gICAgbGV0IHN5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCA9XG4gICAgICBsZXQgc3RlcCBzdGF0ZSA9XG4gICAgICAgIG1hdGNoIHN0YXRlIHdpdGhcbiAgICAgICAgfCBFbmQsIEVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgICAgfCBFbmQsIE1vcmUgKGtleSwgZGF0YSwgdHJlZSwgZW51bSkgLT5cbiAgICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkICgoa2V5LCBgUmlnaHQgZGF0YSksIChFbmQsIGNvbnMgdHJlZSBlbnVtKSlcbiAgICAgICAgfCBNb3JlIChrZXksIGRhdGEsIHRyZWUsIGVudW0pLCBFbmQgLT5cbiAgICAgICAgICBTZXF1ZW5jZS5TdGVwLllpZWxkICgoa2V5LCBgTGVmdCBkYXRhKSwgKGNvbnMgdHJlZSBlbnVtLCBFbmQpKVxuICAgICAgICB8IChNb3JlIChrMSwgdjEsIHRyZWUxLCBlbnVtMSkgYXMgbGVmdCksIChNb3JlIChrMiwgdjIsIHRyZWUyLCBlbnVtMikgYXMgcmlnaHQpIC0+XG4gICAgICAgICAgbGV0IGNvbXBhcmVfcmVzdWx0ID0gY29tcGFyZV9rZXkgazEgazIgaW5cbiAgICAgICAgICBpZiBjb21wYXJlX3Jlc3VsdCA9IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBuZXh0X3N0YXRlID1cbiAgICAgICAgICAgICAgaWYgcGh5c19lcXVhbCB0cmVlMSB0cmVlMlxuICAgICAgICAgICAgICB0aGVuIGVudW0xLCBlbnVtMlxuICAgICAgICAgICAgICBlbHNlIGNvbnMgdHJlZTEgZW51bTEsIGNvbnMgdHJlZTIgZW51bTJcbiAgICAgICAgICAgIGluXG4gICAgICAgICAgICBpZiBkYXRhX2VxdWFsIHYxIHYyXG4gICAgICAgICAgICB0aGVuIFNlcXVlbmNlLlN0ZXAuU2tpcCBuZXh0X3N0YXRlXG4gICAgICAgICAgICBlbHNlIFNlcXVlbmNlLlN0ZXAuWWllbGQgKChrMSwgYFVuZXF1YWwgKHYxLCB2MikpLCBuZXh0X3N0YXRlKSlcbiAgICAgICAgICBlbHNlIGlmIGNvbXBhcmVfcmVzdWx0IDwgMFxuICAgICAgICAgIHRoZW4gU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGsxLCBgTGVmdCB2MSksIChjb25zIHRyZWUxIGVudW0xLCByaWdodCkpXG4gICAgICAgICAgZWxzZSBTZXF1ZW5jZS5TdGVwLllpZWxkICgoazIsIGBSaWdodCB2MiksIChsZWZ0LCBjb25zIHRyZWUyIGVudW0yKSlcbiAgICAgIGluXG4gICAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdDoob2ZfdHJlZSB0MSwgb2ZfdHJlZSB0MikgfmY6c3RlcFxuICAgIDs7XG5cbiAgICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXkgfmRhdGFfZXF1YWwgfmluaXQgfmYgPVxuICAgICAgbGV0IGFkZCBhY2MgayB2ID0gZiBhY2MgKGssIGBSaWdodCB2KSBpblxuICAgICAgbGV0IHJlbW92ZSBhY2MgayB2ID0gZiBhY2MgKGssIGBMZWZ0IHYpIGluXG4gICAgICBsZXQgcmVjIGxvb3AgbGVmdCByaWdodCBhY2MgPVxuICAgICAgICBtYXRjaCBsZWZ0LCByaWdodCB3aXRoXG4gICAgICAgIHwgRW5kLCBlbnVtIC0+IGZvbGQgZW51bSB+aW5pdDphY2MgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBhZGQgYWNjIGtleSBkYXRhKVxuICAgICAgICB8IGVudW0sIEVuZCAtPiBmb2xkIGVudW0gfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gcmVtb3ZlIGFjYyBrZXkgZGF0YSlcbiAgICAgICAgfCAoTW9yZSAoazEsIHYxLCB0cmVlMSwgZW51bTEpIGFzIGxlZnQpLCAoTW9yZSAoazIsIHYyLCB0cmVlMiwgZW51bTIpIGFzIHJpZ2h0KSAtPlxuICAgICAgICAgIGxldCBjb21wYXJlX3Jlc3VsdCA9IGNvbXBhcmVfa2V5IGsxIGsyIGluXG4gICAgICAgICAgaWYgY29tcGFyZV9yZXN1bHQgPSAwXG4gICAgICAgICAgdGhlbiAoXG4gICAgICAgICAgICBsZXQgYWNjID0gaWYgZGF0YV9lcXVhbCB2MSB2MiB0aGVuIGFjYyBlbHNlIGYgYWNjIChrMSwgYFVuZXF1YWwgKHYxLCB2MikpIGluXG4gICAgICAgICAgICBpZiBwaHlzX2VxdWFsIHRyZWUxIHRyZWUyXG4gICAgICAgICAgICB0aGVuIGxvb3AgZW51bTEgZW51bTIgYWNjXG4gICAgICAgICAgICBlbHNlIGxvb3AgKGNvbnMgdHJlZTEgZW51bTEpIChjb25zIHRyZWUyIGVudW0yKSBhY2MpXG4gICAgICAgICAgZWxzZSBpZiBjb21wYXJlX3Jlc3VsdCA8IDBcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCBhY2MgPSByZW1vdmUgYWNjIGsxIHYxIGluXG4gICAgICAgICAgICBsb29wIChjb25zIHRyZWUxIGVudW0xKSByaWdodCBhY2MpXG4gICAgICAgICAgZWxzZSAoXG4gICAgICAgICAgICBsZXQgYWNjID0gYWRkIGFjYyBrMiB2MiBpblxuICAgICAgICAgICAgbG9vcCBsZWZ0IChjb25zIHRyZWUyIGVudW0yKSBhY2MpXG4gICAgICBpblxuICAgICAgbG9vcCAob2ZfdHJlZSB0MSkgKG9mX3RyZWUgdDIpIGluaXRcbiAgICA7O1xuICBlbmRcblxuICBsZXQgdG9fc2VxdWVuY2VfaW5jcmVhc2luZyBjb21wYXJhdG9yIH5mcm9tX2tleSB0ID1cbiAgICBsZXQgbmV4dCBlbnVtID1cbiAgICAgIG1hdGNoIGVudW0gd2l0aFxuICAgICAgfCBFbnVtLkVuZCAtPiBTZXF1ZW5jZS5TdGVwLkRvbmVcbiAgICAgIHwgRW51bS5Nb3JlIChrLCB2LCB0LCBlKSAtPiBTZXF1ZW5jZS5TdGVwLllpZWxkICgoaywgdiksIEVudW0uY29ucyB0IGUpXG4gICAgaW5cbiAgICBsZXQgaW5pdCA9XG4gICAgICBtYXRjaCBmcm9tX2tleSB3aXRoXG4gICAgICB8IE5vbmUgLT4gRW51bS5vZl90cmVlIHRcbiAgICAgIHwgU29tZSBrZXkgLT4gRW51bS5zdGFydGluZ19hdF9pbmNyZWFzaW5nIHQga2V5IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBTZXF1ZW5jZS51bmZvbGRfc3RlcCB+aW5pdCB+ZjpuZXh0XG4gIDs7XG5cbiAgbGV0IHRvX3NlcXVlbmNlX2RlY3JlYXNpbmcgY29tcGFyYXRvciB+ZnJvbV9rZXkgdCA9XG4gICAgbGV0IG5leHQgZW51bSA9XG4gICAgICBtYXRjaCBlbnVtIHdpdGhcbiAgICAgIHwgRW51bS5FbmQgLT4gU2VxdWVuY2UuU3RlcC5Eb25lXG4gICAgICB8IEVudW0uTW9yZSAoaywgdiwgdCwgZSkgLT4gU2VxdWVuY2UuU3RlcC5ZaWVsZCAoKGssIHYpLCBFbnVtLmNvbnNfcmlnaHQgdCBlKVxuICAgIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbWF0Y2ggZnJvbV9rZXkgd2l0aFxuICAgICAgfCBOb25lIC0+IEVudW0ub2ZfdHJlZV9yaWdodCB0XG4gICAgICB8IFNvbWUga2V5IC0+IEVudW0uc3RhcnRpbmdfYXRfZGVjcmVhc2luZyB0IGtleSBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgU2VxdWVuY2UudW5mb2xkX3N0ZXAgfmluaXQgfmY6bmV4dFxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZVxuICAgICAgICBjb21wYXJhdG9yXG4gICAgICAgID8ob3JkZXIgPSBgSW5jcmVhc2luZ19rZXkpXG4gICAgICAgID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG9cbiAgICAgICAgP2tleXNfbGVzc19vcl9lcXVhbF90b1xuICAgICAgICB0XG4gICAgPVxuICAgIGxldCBpbmNsdXNpdmVfYm91bmQgc2lkZSB0IGJvdW5kID1cbiAgICAgIGxldCBjb21wYXJlX2tleSA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGluXG4gICAgICBsZXQgbCwgbWF5YmUsIHIgPSBzcGxpdCB0IGJvdW5kIH5jb21wYXJlX2tleSBpblxuICAgICAgbGV0IHQgPSBzaWRlIChsLCByKSBpblxuICAgICAgbWF0Y2ggbWF5YmUgd2l0aFxuICAgICAgfCBOb25lIC0+IHRcbiAgICAgIHwgU29tZSAoa2V5LCBkYXRhKSAtPiBzZXQnIHQga2V5IGRhdGEgfmNvbXBhcmVfa2V5XG4gICAgaW5cbiAgICBtYXRjaCBvcmRlciB3aXRoXG4gICAgfCBgSW5jcmVhc2luZ19rZXkgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQga2V5c19sZXNzX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBmc3QpIGluXG4gICAgICB0b19zZXF1ZW5jZV9pbmNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5OmtleXNfZ3JlYXRlcl9vcl9lcXVhbF90byB0XG4gICAgfCBgRGVjcmVhc2luZ19rZXkgLT5cbiAgICAgIGxldCB0ID0gT3B0aW9uLmZvbGQga2V5c19ncmVhdGVyX29yX2VxdWFsX3RvIH5pbml0OnQgfmY6KGluY2x1c2l2ZV9ib3VuZCBzbmQpIGluXG4gICAgICB0b19zZXF1ZW5jZV9kZWNyZWFzaW5nIGNvbXBhcmF0b3IgfmZyb21fa2V5OmtleXNfbGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cbiAgbGV0IGNvbXBhcmUgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBFbnVtLmNvbXBhcmUgY29tcGFyZV9rZXkgY29tcGFyZV9kYXRhIChFbnVtLm9mX3RyZWUgdDEpIChFbnVtLm9mX3RyZWUgdDIpXG4gIDs7XG5cbiAgbGV0IGVxdWFsIGNvbXBhcmVfa2V5IGNvbXBhcmVfZGF0YSB0MSB0MiA9XG4gICAgRW51bS5lcXVhbCBjb21wYXJlX2tleSBjb21wYXJlX2RhdGEgKEVudW0ub2ZfdHJlZSB0MSkgKEVudW0ub2ZfdHJlZSB0MilcbiAgOztcblxuICBsZXQgaXRlcjIgdDEgdDIgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBFbnVtLmZvbGQyXG4gICAgICBjb21wYXJlX2tleVxuICAgICAgKEVudW0ub2ZfdHJlZSB0MSlcbiAgICAgIChFbnVtLm9mX3RyZWUgdDIpXG4gICAgICB+aW5pdDooKVxuICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhICgpIC0+IGYgfmtleSB+ZGF0YSlcbiAgOztcblxuICBsZXQgZm9sZDIgdDEgdDIgfmluaXQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICBFbnVtLmZvbGQyIGNvbXBhcmVfa2V5IChFbnVtLm9mX3RyZWUgdDEpIChFbnVtLm9mX3RyZWUgdDIpIH5mIH5pbml0XG4gIDs7XG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmID0gRW51bS5zeW1tZXRyaWNfZGlmZlxuXG4gIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIHQxIHQyIH5jb21wYXJlX2tleSB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgKCogW0VudW0uZm9sZF9kaWZmc10gaXMgYSBjb3JyZWN0IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24sIGJ1dCBpcyBjb25zaWRlcmFibHlcbiAgICAgICBzbG93ZXIsIGFzIHdlIGhhdmUgdG8gYWxsb2NhdGUgcXVpdGUgYSBsb3Qgb2Ygc3RhdGUgdG8gdHJhY2sgZW51bWVyYXRpb24gb2YgYSB0cmVlLlxuICAgICAgIEF2b2lkIGlmIHdlIGNhbi5cbiAgICAqKVxuICAgIGxldCBzbG93IHggeSB+aW5pdCA9IEVudW0uZm9sZF9zeW1tZXRyaWNfZGlmZiB4IHkgfmNvbXBhcmVfa2V5IH5kYXRhX2VxdWFsIH5mIH5pbml0IGluXG4gICAgbGV0IGFkZCBhY2MgayB2ID0gZiBhY2MgKGssIGBSaWdodCB2KSBpblxuICAgIGxldCByZW1vdmUgYWNjIGsgdiA9IGYgYWNjIChrLCBgTGVmdCB2KSBpblxuICAgIGxldCBkZWx0YSBhY2MgayB2IHYnID0gaWYgZGF0YV9lcXVhbCB2IHYnIHRoZW4gYWNjIGVsc2UgZiBhY2MgKGssIGBVbmVxdWFsICh2LCB2JykpIGluXG4gICAgKCogSWYgdHdvIHRyZWVzIGhhdmUgdGhlIHNhbWUgc3RydWN0dXJlIGF0IHRoZSByb290IChhbmQgdGhlIHNhbWUga2V5LCBpZiB0aGV5J3JlXG4gICAgICAgW05vZGVdcykgd2UgY2FuIHRyaXZpYWxseSBkaWZmIGVhY2ggc3VicGFydCBpbiBvYnZpb3VzIHdheXMuICopXG4gICAgbGV0IHJlYyBsb29wIHQgdCcgYWNjID1cbiAgICAgIGlmIHBoeXNfZXF1YWwgdCB0J1xuICAgICAgdGhlbiBhY2NcbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCB0LCB0JyB3aXRoXG4gICAgICAgIHwgRW1wdHksIG5ld192YWxzIC0+XG4gICAgICAgICAgZm9sZCBuZXdfdmFscyB+aW5pdDphY2MgfmY6KGZ1biB+a2V5IH5kYXRhIGFjYyAtPiBhZGQgYWNjIGtleSBkYXRhKVxuICAgICAgICB8IG9sZF92YWxzLCBFbXB0eSAtPlxuICAgICAgICAgIGZvbGQgb2xkX3ZhbHMgfmluaXQ6YWNjIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gcmVtb3ZlIGFjYyBrZXkgZGF0YSlcbiAgICAgICAgfCBMZWFmIChrLCB2KSwgTGVhZiAoaycsIHYnKSAtPlxuICAgICAgICAgIChtYXRjaCBjb21wYXJlX2tleSBrIGsnIHdpdGhcbiAgICAgICAgICAgfCB4IHdoZW4geCA9IDAgLT4gZGVsdGEgYWNjIGsgdiB2J1xuICAgICAgICAgICB8IHggd2hlbiB4IDwgMCAtPlxuICAgICAgICAgICAgIGxldCBhY2MgPSByZW1vdmUgYWNjIGsgdiBpblxuICAgICAgICAgICAgIGFkZCBhY2MgaycgdidcbiAgICAgICAgICAgfCBfICgqIHdoZW4geCA+IDAgKikgLT5cbiAgICAgICAgICAgICBsZXQgYWNjID0gYWRkIGFjYyBrJyB2JyBpblxuICAgICAgICAgICAgIHJlbW92ZSBhY2MgayB2KVxuICAgICAgICB8IE5vZGUgKGwsIGssIHYsIHIsIF8pLCBOb2RlIChsJywgaycsIHYnLCByJywgXykgd2hlbiBjb21wYXJlX2tleSBrIGsnID0gMCAtPlxuICAgICAgICAgIGxldCBhY2MgPSBsb29wIGwgbCcgYWNjIGluXG4gICAgICAgICAgbGV0IGFjYyA9IGRlbHRhIGFjYyBrIHYgdicgaW5cbiAgICAgICAgICBsb29wIHIgcicgYWNjXG4gICAgICAgICgqIE91ciByb290cyBhcmVuJ3QgdGhlIHNhbWUga2V5LiBGYWxsYmFjayB0byB0aGUgc2xvdyBtb2RlLiBUcmVlcyB3aXRoIHNtYWxsXG4gICAgICAgICAgIGRpZmZzIHdpbGwgb25seSBkbyB0aGlzIG9uIHZlcnkgc21hbGwgcGFydHMgb2YgdGhlIHRyZWUgKGhvcGVmdWxseSAtIGlmIHRoZVxuICAgICAgICAgICBvdmVyYWxsIHJvb3QgaXMgcmViYWxhbmNlZCwgd2UnbGwgZWF0IHRoZSB3aG9sZSBjb3N0LCB1bmZvcnR1bmF0ZWx5LikgKilcbiAgICAgICAgfCBOb2RlIF8sIE5vZGUgXyB8IE5vZGUgXywgTGVhZiBfIHwgTGVhZiBfLCBOb2RlIF8gLT4gc2xvdyB0IHQnIH5pbml0OmFjYylcbiAgICBpblxuICAgIGxvb3AgdDEgdDIgaW5pdFxuICA7O1xuXG4gIGxldCByZWMgbGVuZ3RoID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+IDBcbiAgICB8IExlYWYgXyAtPiAxXG4gICAgfCBOb2RlIChsLCBfLCBfLCByLCBfKSAtPiBsZW5ndGggbCArIGxlbmd0aCByICsgMVxuICA7O1xuXG4gIGxldCBoYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0ID1cbiAgICBmb2xkXG4gICAgICB0XG4gICAgICB+aW5pdDooaGFzaF9mb2xkX2ludCBzdGF0ZSAobGVuZ3RoIHQpKVxuICAgICAgfmY6KGZ1biB+a2V5IH5kYXRhIHN0YXRlIC0+IGhhc2hfZm9sZF9kYXRhIChoYXNoX2ZvbGRfa2V5IHN0YXRlIGtleSkgZGF0YSlcbiAgOztcblxuICBsZXQga2V5cyB0ID0gZm9sZF9yaWdodCB+ZjooZnVuIH5rZXkgfmRhdGE6XyBsaXN0IC0+IGtleSA6OiBsaXN0KSB0IH5pbml0OltdXG4gIGxldCBkYXRhIHQgPSBmb2xkX3JpZ2h0IH5mOihmdW4gfmtleTpfIH5kYXRhIGxpc3QgLT4gZGF0YSA6OiBsaXN0KSB0IH5pbml0OltdXG5cbiAgbW9kdWxlIHR5cGUgRm9sZGFibGUgPSBzaWdcbiAgICB2YWwgbmFtZSA6IHN0cmluZ1xuXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgZm9sZCA6ICdhIHQgLT4gaW5pdDonYiAtPiBmOignYiAtPiAnYSAtPiAnYikgLT4gJ2JcbiAgZW5kXG5cbiAgbW9kdWxlIE9mX2ZvbGRhYmxlIChNIDogRm9sZGFibGUpID0gc3RydWN0XG4gICAgbGV0IG9mX2ZvbGRhYmxlX2ZvbGQgZm9sZGFibGUgfmluaXQgfmYgfmNvbXBhcmVfa2V5ID1cbiAgICAgIE0uZm9sZCBmb2xkYWJsZSB+aW5pdDooZW1wdHksIDApIH5mOihmdW4gKGFjY3VtLCBsZW5ndGgpIChrZXksIGRhdGEpIC0+XG4gICAgICAgIGxldCBwcmV2X2RhdGEgPVxuICAgICAgICAgIG1hdGNoIGZpbmQgYWNjdW0ga2V5IH5jb21wYXJlX2tleSB3aXRoXG4gICAgICAgICAgfCBOb25lIC0+IGluaXRcbiAgICAgICAgICB8IFNvbWUgcHJldiAtPiBwcmV2XG4gICAgICAgIGluXG4gICAgICAgIGxldCBkYXRhID0gZiBwcmV2X2RhdGEgZGF0YSBpblxuICAgICAgICBzZXQgYWNjdW0gfmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleSlcbiAgICA7O1xuXG4gICAgbGV0IG9mX2ZvbGRhYmxlX3JlZHVjZSBmb2xkYWJsZSB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgICAgTS5mb2xkIGZvbGRhYmxlIH5pbml0OihlbXB0eSwgMCkgfmY6KGZ1biAoYWNjdW0sIGxlbmd0aCkgKGtleSwgZGF0YSkgLT5cbiAgICAgICAgbGV0IG5ld19kYXRhID1cbiAgICAgICAgICBtYXRjaCBmaW5kIGFjY3VtIGtleSB+Y29tcGFyZV9rZXkgd2l0aFxuICAgICAgICAgIHwgTm9uZSAtPiBkYXRhXG4gICAgICAgICAgfCBTb21lIHByZXYgLT4gZiBwcmV2IGRhdGFcbiAgICAgICAgaW5cbiAgICAgICAgc2V0IGFjY3VtIH5sZW5ndGggfmtleSB+ZGF0YTpuZXdfZGF0YSB+Y29tcGFyZV9rZXkpXG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZSBmb2xkYWJsZSB+Y29tcGFyZV9rZXkgPVxuICAgICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICAgIGxldCBtYXAgPVxuICAgICAgICAgIE0uZm9sZCBmb2xkYWJsZSB+aW5pdDooZW1wdHksIDApIH5mOihmdW4gKHQsIGxlbmd0aCkgKGtleSwgZGF0YSkgLT5cbiAgICAgICAgICAgIGxldCAoKF8sIGxlbmd0aCcpIGFzIGFjYykgPSBzZXQgfmxlbmd0aCB+a2V5IH5kYXRhIHQgfmNvbXBhcmVfa2V5IGluXG4gICAgICAgICAgICBpZiBsZW5ndGggPSBsZW5ndGgnIHRoZW4gci5yZXR1cm4gKGBEdXBsaWNhdGVfa2V5IGtleSkgZWxzZSBhY2MpXG4gICAgICAgIGluXG4gICAgICAgIGBPayBtYXApXG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZV9vcl9lcnJvciBmb2xkYWJsZSB+Y29tcGFyYXRvciA9XG4gICAgICBtYXRjaCBvZl9mb2xkYWJsZSBmb2xkYWJsZSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgICAgfCBgT2sgeCAtPiBSZXN1bHQuT2sgeFxuICAgICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgICAgT3JfZXJyb3IuZXJyb3JcbiAgICAgICAgICAoXCJNYXAub2ZfXCIgXiBNLm5hbWUgXiBcIl9vcl9lcnJvcjogZHVwbGljYXRlIGtleVwiKVxuICAgICAgICAgIGtleVxuICAgICAgICAgIGNvbXBhcmF0b3Iuc2V4cF9vZl90XG4gICAgOztcblxuICAgIGxldCBvZl9mb2xkYWJsZV9leG4gZm9sZGFibGUgfmNvbXBhcmF0b3IgPVxuICAgICAgbWF0Y2ggb2ZfZm9sZGFibGUgZm9sZGFibGUgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICAgIHwgYE9rIHggLT4geFxuICAgICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgICAgRXJyb3IuY3JlYXRlIChcIk1hcC5vZl9cIiBeIE0ubmFtZSBeIFwiX2V4bjogZHVwbGljYXRlIGtleVwiKSBrZXkgY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICAgICAgfD4gRXJyb3IucmFpc2VcbiAgICA7O1xuICBlbmRcblxuICBtb2R1bGUgT2ZfYWxpc3QgPSBPZl9mb2xkYWJsZSAoc3RydWN0XG4gICAgICBsZXQgbmFtZSA9IFwiYWxpc3RcIlxuXG4gICAgICB0eXBlICdhIHQgPSAnYSBsaXN0XG5cbiAgICAgIGxldCBmb2xkID0gTGlzdC5mb2xkXG4gICAgZW5kKVxuXG4gIGxldCBvZl9hbGlzdF9mb2xkID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfZm9sZFxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlID0gT2ZfYWxpc3Qub2ZfZm9sZGFibGVfcmVkdWNlXG4gIGxldCBvZl9hbGlzdCA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciA9IE9mX2FsaXN0Lm9mX2ZvbGRhYmxlX29yX2Vycm9yXG4gIGxldCBvZl9hbGlzdF9leG4gPSBPZl9hbGlzdC5vZl9mb2xkYWJsZV9leG5cblxuICAoKiBSZXZlcnNlIHRoZSBpbnB1dCwgdGhlbiBmb2xkIGZyb20gbGVmdCB0byByaWdodC4gVGhlIHJlc3VsdGluZyBtYXAgdXNlcyB0aGUgZmlyc3RcbiAgICAgaW5zdGFuY2Ugb2YgZWFjaCBrZXkgZnJvbSB0aGUgaW5wdXQgbGlzdC4gVGhlIHJlbGF0aXZlIG9yZGVyaW5nIG9mIGVsZW1lbnRzIGluIGVhY2hcbiAgICAgb3V0cHV0IGxpc3QgaXMgdGhlIHNhbWUgYXMgaW4gdGhlIGlucHV0IGxpc3QuICopXG4gIGxldCBvZl9mb2xkYWJsZV9tdWx0aSBmb2xkYWJsZSB+Zm9sZCB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBhbGlzdCA9IGZvbGQgZm9sZGFibGUgfmluaXQ6W10gfmY6KGZ1biBsIHggLT4geCA6OiBsKSBpblxuICAgIG9mX2FsaXN0X2ZvbGQgYWxpc3QgfmluaXQ6W10gfmY6KGZ1biBsIHggLT4geCA6OiBsKSB+Y29tcGFyZV9rZXlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgYWxpc3QgfmNvbXBhcmVfa2V5ID1cbiAgICBvZl9mb2xkYWJsZV9tdWx0aSBhbGlzdCB+Zm9sZDpMaXN0LmZvbGQgfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbW9kdWxlIE9mX3NlcXVlbmNlID0gT2ZfZm9sZGFibGUgKHN0cnVjdFxuICAgICAgbGV0IG5hbWUgPSBcInNlcXVlbmNlXCJcblxuICAgICAgdHlwZSAnYSB0ID0gJ2EgU2VxdWVuY2UudFxuXG4gICAgICBsZXQgZm9sZCA9IFNlcXVlbmNlLmZvbGRcbiAgICBlbmQpXG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9mb2xkXG4gIGxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgPSBPZl9zZXF1ZW5jZS5vZl9mb2xkYWJsZV9yZWR1Y2VcbiAgbGV0IG9mX3NlcXVlbmNlID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVcbiAgbGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yID0gT2Zfc2VxdWVuY2Uub2ZfZm9sZGFibGVfb3JfZXJyb3JcbiAgbGV0IG9mX3NlcXVlbmNlX2V4biA9IE9mX3NlcXVlbmNlLm9mX2ZvbGRhYmxlX2V4blxuXG4gIGxldCBvZl9zZXF1ZW5jZV9tdWx0aSBzZXF1ZW5jZSB+Y29tcGFyZV9rZXkgPVxuICAgIG9mX2ZvbGRhYmxlX211bHRpIHNlcXVlbmNlIH5mb2xkOlNlcXVlbmNlLmZvbGQgfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbGV0IGZvcl9hbGwgdCB+ZiA9XG4gICAgd2l0aF9yZXR1cm4gKGZ1biByIC0+XG4gICAgICBpdGVyIHQgfmY6KGZ1biBkYXRhIC0+IGlmIG5vdCAoZiBkYXRhKSB0aGVuIHIucmV0dXJuIGZhbHNlKTtcbiAgICAgIHRydWUpXG4gIDs7XG5cbiAgbGV0IGZvcl9hbGxpIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgbm90IChmIH5rZXkgfmRhdGEpIHRoZW4gci5yZXR1cm4gZmFsc2UpO1xuICAgICAgdHJ1ZSlcbiAgOztcblxuICBsZXQgZXhpc3RzIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlciB0IH5mOihmdW4gZGF0YSAtPiBpZiBmIGRhdGEgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICAgIGZhbHNlKVxuICA7O1xuXG4gIGxldCBleGlzdHNpIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gci5yZXR1cm4gdHJ1ZSk7XG4gICAgICBmYWxzZSlcbiAgOztcblxuICBsZXQgY291bnQgdCB+ZiA9XG4gICAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgYWNjIC0+IGlmIGYgZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpXG4gIDs7XG5cbiAgbGV0IGNvdW50aSB0IH5mID1cbiAgICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXkgfmRhdGEgYWNjIC0+IGlmIGYgfmtleSB+ZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpXG4gIDs7XG5cbiAgbGV0IHRvX2FsaXN0ID8oa2V5X29yZGVyID0gYEluY3JlYXNpbmcpIHQgPVxuICAgIG1hdGNoIGtleV9vcmRlciB3aXRoXG4gICAgfCBgSW5jcmVhc2luZyAtPiBmb2xkX3JpZ2h0IHQgfmluaXQ6W10gfmY6KGZ1biB+a2V5IH5kYXRhIHggLT4gKGtleSwgZGF0YSkgOjogeClcbiAgICB8IGBEZWNyZWFzaW5nIC0+IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgeCAtPiAoa2V5LCBkYXRhKSA6OiB4KVxuICA7O1xuXG4gIGxldCBtZXJnZSB0MSB0MiB+ZiB+Y29tcGFyZV9rZXkgPVxuICAgIGxldCBlbHRzID0gVW5pZm9ybV9hcnJheS51bnNhZmVfY3JlYXRlX3VuaW5pdGlhbGl6ZWQgfmxlbjoobGVuZ3RoIHQxICsgbGVuZ3RoIHQyKSBpblxuICAgIGxldCBpID0gcmVmIDAgaW5cbiAgICBpdGVyMiB0MSB0MiB+Y29tcGFyZV9rZXkgfmY6KGZ1biB+a2V5IH5kYXRhOnZhbHVlcyAtPlxuICAgICAgbWF0Y2ggZiB+a2V5IHZhbHVlcyB3aXRoXG4gICAgICB8IFNvbWUgdmFsdWUgLT5cbiAgICAgICAgVW5pZm9ybV9hcnJheS5zZXQgZWx0cyAhaSAoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGluY3IgaVxuICAgICAgfCBOb25lIC0+ICgpKTtcbiAgICBsZXQgbGVuID0gIWkgaW5cbiAgICBsZXQgZ2V0IGkgPSBVbmlmb3JtX2FycmF5LmdldCBlbHRzIGkgaW5cbiAgICBsZXQgdHJlZSA9IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmY6Z2V0IGluXG4gICAgdHJlZSwgbGVuXG4gIDs7XG5cbiAgbGV0IG1lcmdlX3NrZXdlZCA9XG4gICAgbGV0IG1lcmdlX2xhcmdlX2ZpcnN0IGxlbmd0aF9sYXJnZSB0X2xhcmdlIHRfc21hbGwgfmNhbGwgfmNvbWJpbmUgfmNvbXBhcmVfa2V5ID1cbiAgICAgIGZvbGQgdF9zbWFsbCB+aW5pdDoodF9sYXJnZSwgbGVuZ3RoX2xhcmdlKSB+ZjooZnVuIH5rZXkgfmRhdGE6ZGF0YScgKHQsIGxlbmd0aCkgLT5cbiAgICAgICAgdXBkYXRlIHQga2V5IH5sZW5ndGggfmNvbXBhcmVfa2V5IH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgTm9uZSAtPiBkYXRhJ1xuICAgICAgICAgIHwgU29tZSBkYXRhIC0+IGNhbGwgY29tYmluZSB+a2V5IGRhdGEgZGF0YScpKVxuICAgIGluXG4gICAgbGV0IGNhbGwgZiB+a2V5IHggeSA9IGYgfmtleSB4IHkgaW5cbiAgICBsZXQgc3dhcCBmIH5rZXkgeCB5ID0gZiB+a2V5IHkgeCBpblxuICAgIGZ1biB0MSB0MiB+bGVuZ3RoMSB+bGVuZ3RoMiB+Y29tYmluZSB+Y29tcGFyZV9rZXkgLT5cbiAgICAgIGlmIGxlbmd0aDIgPD0gbGVuZ3RoMVxuICAgICAgdGhlbiBtZXJnZV9sYXJnZV9maXJzdCBsZW5ndGgxIHQxIHQyIH5jYWxsIH5jb21iaW5lIH5jb21wYXJlX2tleVxuICAgICAgZWxzZSBtZXJnZV9sYXJnZV9maXJzdCBsZW5ndGgyIHQyIHQxIH5jYWxsOnN3YXAgfmNvbWJpbmUgfmNvbXBhcmVfa2V5XG4gIDs7XG5cbiAgbW9kdWxlIENsb3Nlc3Rfa2V5X2ltcGwgPSBzdHJ1Y3RcbiAgICAoKiBbbWFya2VyXSBhbmQgW3JlcGFja2FnZV0gYWxsb3cgdXMgdG8gY3JlYXRlIFwibG9naWNhbFwiIG9wdGlvbnMgd2l0aG91dCBhY3R1YWxseVxuICAgICAgIGFsbG9jYXRpbmcgYW55IG9wdGlvbnMuIFBhc3NpbmcgW0ZvdW5kIGtleSB2YWx1ZV0gdG8gYSBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgcGFzc2luZyBbU29tZSAoa2V5LCB2YWx1ZSldOyBwYXNzaW5nIFtNaXNzaW5nICgpICgpXSBpcyBlcXVpdmFsZW50IHRvIHBhc3NpbmdcbiAgICAgICBbTm9uZV0uICopXG4gICAgdHlwZSAoJ2ssICd2LCAna19vcHQsICd2X29wdCkgbWFya2VyID1cbiAgICAgIHwgTWlzc2luZyA6ICgnaywgJ3YsIHVuaXQsIHVuaXQpIG1hcmtlclxuICAgICAgfCBGb3VuZCA6ICgnaywgJ3YsICdrLCAndikgbWFya2VyXG5cbiAgICBsZXQgcmVwYWNrYWdlXG4gICAgICAgICAgKHR5cGUgayB2IGtfb3B0IHZfb3B0KVxuICAgICAgICAgIChtYXJrZXIgOiAoaywgdiwga19vcHQsIHZfb3B0KSBtYXJrZXIpXG4gICAgICAgICAgKGsgOiBrX29wdClcbiAgICAgICAgICAodiA6IHZfb3B0KVxuICAgICAgOiAoayAqIHYpIG9wdGlvblxuICAgICAgPVxuICAgICAgbWF0Y2ggbWFya2VyIHdpdGhcbiAgICAgIHwgTWlzc2luZyAtPiBOb25lXG4gICAgICB8IEZvdW5kIC0+IFNvbWUgKGssIHYpXG4gICAgOztcblxuICAgICgqIFRoZSB0eXBlIHNpZ25hdHVyZSBpcyBleHBsaWNpdCBoZXJlIHRvIGFsbG93IHBvbHltb3JwaGljIHJlY3Vyc2lvbi4gKilcbiAgICBsZXQgcmVjIGxvb3AgOlxuICAgICAgJ2sgJ3YgJ2tfb3B0ICd2X29wdC5cbiAgICAgICgnaywgJ3YpIHRyZWVcbiAgICAgIC0+IFsgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIHwgYExlc3Nfb3JfZXF1YWxfdG8gfCBgTGVzc190aGFuIF1cbiAgICAgIC0+ICdrXG4gICAgICAtPiBjb21wYXJlX2tleTooJ2sgLT4gJ2sgLT4gaW50KVxuICAgICAgLT4gKCdrLCAndiwgJ2tfb3B0LCAndl9vcHQpIG1hcmtlclxuICAgICAgLT4gJ2tfb3B0XG4gICAgICAtPiAndl9vcHRcbiAgICAgIC0+ICgnayAqICd2KSBvcHRpb25cbiAgICAgID1cbiAgICAgIGZ1biB0IGRpciBrIH5jb21wYXJlX2tleSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlIC0+XG4gICAgICAgIG1hdGNoIHQgd2l0aFxuICAgICAgICB8IEVtcHR5IC0+IHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlXG4gICAgICAgIHwgTGVhZiAoaycsIHYnKSAtPlxuICAgICAgICAgIGxldCBjID0gY29tcGFyZV9rZXkgaycgayBpblxuICAgICAgICAgIGlmIG1hdGNoIGRpciB3aXRoXG4gICAgICAgICAgICB8IGBHcmVhdGVyX29yX2VxdWFsX3RvIC0+IGMgPj0gMFxuICAgICAgICAgICAgfCBgR3JlYXRlcl90aGFuIC0+IGMgPiAwXG4gICAgICAgICAgICB8IGBMZXNzX29yX2VxdWFsX3RvIC0+IGMgPD0gMFxuICAgICAgICAgICAgfCBgTGVzc190aGFuIC0+IGMgPCAwXG4gICAgICAgICAgdGhlbiBTb21lIChrJywgdicpXG4gICAgICAgICAgZWxzZSByZXBhY2thZ2UgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZVxuICAgICAgICB8IE5vZGUgKGwsIGsnLCB2JywgciwgXykgLT5cbiAgICAgICAgICBsZXQgYyA9IGNvbXBhcmVfa2V5IGsnIGsgaW5cbiAgICAgICAgICBpZiBjID0gMFxuICAgICAgICAgIHRoZW4gKFxuICAgICAgICAgICAgKCogVGhpcyBpcyBhIGJhc2UgY2FzZSAobm8gcmVjdXJzaXZlIGNhbGwpLiAqKVxuICAgICAgICAgICAgbWF0Y2ggZGlyIHdpdGhcbiAgICAgICAgICAgIHwgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgTGVzc19vcl9lcXVhbF90byAtPiBTb21lIChrJywgdicpXG4gICAgICAgICAgICB8IGBHcmVhdGVyX3RoYW4gLT5cbiAgICAgICAgICAgICAgaWYgaXNfZW1wdHkgciB0aGVuIHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlIGVsc2UgbWluX2VsdCByXG4gICAgICAgICAgICB8IGBMZXNzX3RoYW4gLT5cbiAgICAgICAgICAgICAgaWYgaXNfZW1wdHkgbCB0aGVuIHJlcGFja2FnZSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlIGVsc2UgbWF4X2VsdCBsKVxuICAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICAgKCogV2UgYXJlIGd1YXJhbnRlZWQgaGVyZSB0aGF0IGsnIDw+IGsuICopXG4gICAgICAgICAgICAoKiBUaGlzIGlzIHRoZSBvbmx5IHJlY3Vyc2l2ZSBjYXNlLiAqKVxuICAgICAgICAgICAgbWF0Y2ggZGlyIHdpdGhcbiAgICAgICAgICAgIHwgYEdyZWF0ZXJfb3JfZXF1YWxfdG8gfCBgR3JlYXRlcl90aGFuIC0+XG4gICAgICAgICAgICAgIGlmIGMgPiAwXG4gICAgICAgICAgICAgIHRoZW4gbG9vcCBsIGRpciBrIH5jb21wYXJlX2tleSBGb3VuZCBrJyB2J1xuICAgICAgICAgICAgICBlbHNlIGxvb3AgciBkaXIgayB+Y29tcGFyZV9rZXkgZm91bmRfbWFya2VyIGZvdW5kX2tleSBmb3VuZF92YWx1ZVxuICAgICAgICAgICAgfCBgTGVzc19vcl9lcXVhbF90byB8IGBMZXNzX3RoYW4gLT5cbiAgICAgICAgICAgICAgaWYgYyA8IDBcbiAgICAgICAgICAgICAgdGhlbiBsb29wIHIgZGlyIGsgfmNvbXBhcmVfa2V5IEZvdW5kIGsnIHYnXG4gICAgICAgICAgICAgIGVsc2UgbG9vcCBsIGRpciBrIH5jb21wYXJlX2tleSBmb3VuZF9tYXJrZXIgZm91bmRfa2V5IGZvdW5kX3ZhbHVlKVxuICAgIDs7XG5cbiAgICBsZXQgY2xvc2VzdF9rZXkgdCBkaXIgayB+Y29tcGFyZV9rZXkgPSBsb29wIHQgZGlyIGsgfmNvbXBhcmVfa2V5IE1pc3NpbmcgKCkgKClcbiAgZW5kXG5cbiAgbGV0IGNsb3Nlc3Rfa2V5ID0gQ2xvc2VzdF9rZXlfaW1wbC5jbG9zZXN0X2tleVxuXG4gIGxldCByZWMgcmFuayB0IGsgfmNvbXBhcmVfa2V5ID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGsnLCBfKSAtPiBpZiBjb21wYXJlX2tleSBrJyBrID0gMCB0aGVuIFNvbWUgMCBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIGsnLCBfLCByLCBfKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlX2tleSBrJyBrIGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiBTb21lIChsZW5ndGggbClcbiAgICAgIGVsc2UgaWYgYyA+IDBcbiAgICAgIHRoZW4gcmFuayBsIGsgfmNvbXBhcmVfa2V5XG4gICAgICBlbHNlIE9wdGlvbi5tYXAgKHJhbmsgciBrIH5jb21wYXJlX2tleSkgfmY6KGZ1biByYW5rIC0+IHJhbmsgKyAxICsgbGVuZ3RoIGwpXG4gIDs7XG5cbiAgKCogdGhpcyBjb3VsZCBiZSBpbXBsZW1lbnRlZCB1c2luZyBbU2VxdWVuY2VdIGludGVyZmFjZSBidXQgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvblxuICAgICBhbGxvY2F0ZXMgb25seSAyIHdvcmRzIGFuZCBkb2Vzbid0IHJlcXVpcmUgd3JpdGUtYmFycmllciAqKVxuICBsZXQgcmVjIG50aCcgbnVtX3RvX3NlYXJjaCA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCB2KSAtPlxuICAgICAgaWYgIW51bV90b19zZWFyY2ggPSAwXG4gICAgICB0aGVuIFNvbWUgKGssIHYpXG4gICAgICBlbHNlIChcbiAgICAgICAgZGVjciBudW1fdG9fc2VhcmNoO1xuICAgICAgICBOb25lKVxuICAgIHwgTm9kZSAobCwgaywgdiwgciwgXykgLT5cbiAgICAgIChtYXRjaCBudGgnIG51bV90b19zZWFyY2ggbCB3aXRoXG4gICAgICAgfCBTb21lIF8gYXMgc29tZSAtPiBzb21lXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBpZiAhbnVtX3RvX3NlYXJjaCA9IDBcbiAgICAgICAgIHRoZW4gU29tZSAoaywgdilcbiAgICAgICAgIGVsc2UgKFxuICAgICAgICAgICBkZWNyIG51bV90b19zZWFyY2g7XG4gICAgICAgICAgIG50aCcgbnVtX3RvX3NlYXJjaCByKSlcbiAgOztcblxuICBsZXQgbnRoIHQgbiA9IG50aCcgKHJlZiBuKSB0XG5cblxuICBsZXQgcmVjIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mID1cbiAgICBtYXRjaCB0IHdpdGhcbiAgICB8IEVtcHR5IC0+IE5vbmVcbiAgICB8IExlYWYgKGssIHYpIC0+IGlmIGYgfmtleTprIH5kYXRhOnYgdGhlbiBTb21lIChrLCB2KSBlbHNlIE5vbmVcbiAgICB8IE5vZGUgKGwsIGssIHYsIHIsIF8pIC0+XG4gICAgICBpZiBmIH5rZXk6ayB+ZGF0YTp2XG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIGwgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSAoaywgdilcbiAgICAgICAgfCBTb21lIF8gYXMgeCAtPiB4KVxuICAgICAgZWxzZSBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgciB+ZlxuICA7O1xuXG4gIGxldCByZWMgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPiBOb25lXG4gICAgfCBMZWFmIChrLCB2KSAtPiBpZiBmIH5rZXk6ayB+ZGF0YTp2IHRoZW4gU29tZSAoaywgdikgZWxzZSBOb25lXG4gICAgfCBOb2RlIChsLCBrLCB2LCByLCBfKSAtPlxuICAgICAgaWYgZiB+a2V5OmsgfmRhdGE6dlxuICAgICAgdGhlbiAoXG4gICAgICAgIG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHIgfmYgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gU29tZSAoaywgdilcbiAgICAgICAgfCBTb21lIF8gYXMgeCAtPiB4KVxuICAgICAgZWxzZSBmaW5kX2xhc3Rfc2F0aXNmeWluZyBsIH5mXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9XG4gICAgbWF0Y2ggaG93IHdpdGhcbiAgICB8IGBMYXN0X3N0cmljdGx5X2xlc3NfdGhhbiAtPlxuICAgICAgZmluZF9sYXN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPCAwKVxuICAgIHwgYExhc3RfbGVzc190aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgICBmaW5kX2xhc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA8PSAwKVxuICAgIHwgYEZpcnN0X2VxdWFsX3RvIC0+XG4gICAgICAobWF0Y2ggZmluZF9maXJzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2ID49IDApIHdpdGhcbiAgICAgICB8IFNvbWUgKGtleSwgZGF0YSkgYXMgcGFpciB3aGVuIGNvbXBhcmUgfmtleSB+ZGF0YSB2ID0gMCAtPiBwYWlyXG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgTGFzdF9lcXVhbF90byAtPlxuICAgICAgKG1hdGNoIGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+IGNvbXBhcmUgfmtleSB+ZGF0YSB2IDw9IDApIHdpdGhcbiAgICAgICB8IFNvbWUgKGtleSwgZGF0YSkgYXMgcGFpciB3aGVuIGNvbXBhcmUgfmtleSB+ZGF0YSB2ID0gMCAtPiBwYWlyXG4gICAgICAgfCBOb25lIHwgU29tZSBfIC0+IE5vbmUpXG4gICAgfCBgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvIC0+XG4gICAgICBmaW5kX2ZpcnN0X3NhdGlzZnlpbmcgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gY29tcGFyZSB+a2V5IH5kYXRhIHYgPj0gMClcbiAgICB8IGBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW4gLT5cbiAgICAgIGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBjb21wYXJlIH5rZXkgfmRhdGEgdiA+IDApXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBsZXQgaXNfbGVmdCB+a2V5IH5kYXRhID1cbiAgICAgIG1hdGNoIHNlZ21lbnRfb2YgfmtleSB+ZGF0YSB3aXRoXG4gICAgICB8IGBMZWZ0IC0+IHRydWVcbiAgICAgIHwgYFJpZ2h0IC0+IGZhbHNlXG4gICAgaW5cbiAgICBsZXQgaXNfcmlnaHQgfmtleSB+ZGF0YSA9IG5vdCAoaXNfbGVmdCB+a2V5IH5kYXRhKSBpblxuICAgIG1hdGNoIGhvdyB3aXRoXG4gICAgfCBgTGFzdF9vbl9sZWZ0IC0+IGZpbmRfbGFzdF9zYXRpc2Z5aW5nIHQgfmY6aXNfbGVmdFxuICAgIHwgYEZpcnN0X29uX3JpZ2h0IC0+IGZpbmRfZmlyc3Rfc2F0aXNmeWluZyB0IH5mOmlzX3JpZ2h0XG4gIDs7XG5cbiAgKCogW2JpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kXSBmaW5kcyB0aGUga2V5IGluIFt0XSB3aGljaCBzYXRpc2ZpZXMgW21heWJlX2JvdW5kXVxuICAgICBhbmQgdGhlIHJlbGV2YW50IG9uZSBvZiBbaWZfZXhjbHVzaXZlXSBvciBbaWZfaW5jbHVzaXZlXSwgYXMganVkZ2VkIGJ5IFtjb21wYXJlXS4gKilcbiAgbGV0IGJpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kIHQgbWF5YmVfYm91bmQgfmNvbXBhcmUgfmlmX2V4Y2x1c2l2ZSB+aWZfaW5jbHVzaXZlID1cbiAgICBsZXQgZmluZF9ib3VuZCB0IGhvdyBib3VuZCB+Y29tcGFyZSA6IF8gTWF5YmVfYm91bmQudCBvcHRpb24gPVxuICAgICAgbWF0Y2ggYmluYXJ5X3NlYXJjaCB0IGhvdyBib3VuZCB+Y29tcGFyZSB3aXRoXG4gICAgICB8IFNvbWUgKGJvdW5kLCBfKSAtPiBTb21lIChJbmNsIGJvdW5kKVxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICBpblxuICAgIG1hdGNoIChtYXliZV9ib3VuZCA6IF8gTWF5YmVfYm91bmQudCkgd2l0aFxuICAgIHwgRXhjbCBib3VuZCAtPiBmaW5kX2JvdW5kIHQgaWZfZXhjbHVzaXZlIGJvdW5kIH5jb21wYXJlXG4gICAgfCBJbmNsIGJvdW5kIC0+IGZpbmRfYm91bmQgdCBpZl9pbmNsdXNpdmUgYm91bmQgfmNvbXBhcmVcbiAgICB8IFVuYm91bmRlZCAtPiBTb21lIFVuYm91bmRlZFxuICA7O1xuXG4gICgqIFtiaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHNdIGZpbmRzIHRoZSAobm90IG5lY2Vzc2FyaWx5IGRpc3RpbmN0KSBrZXlzIGluIFt0XVxuICAgICB3aGljaCBtb3N0IGNsb3NlbHkgYXBwcm9hY2ggKGJ1dCBkbyBub3QgY3Jvc3MpIFtsb3dlcl9ib3VuZF0gYW5kIFt1cHBlcl9ib3VuZF0sIGFzXG4gICAgIGp1ZGdlZCBieSBbY29tcGFyZV0uIEl0IHJldHVybnMgW05vbmVdIGlmIG5vIGtleXMgaW4gW3RdIGFyZSB3aXRoaW4gdGhhdCByYW5nZS4gKilcbiAgbGV0IGJpbmFyeV9zZWFyY2hfdHdvX3NpZGVkX2JvdW5kcyB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIGxldCBmaW5kX2xvd2VyX2JvdW5kIHQgbWF5YmVfYm91bmQgfmNvbXBhcmUgPVxuICAgICAgYmluYXJ5X3NlYXJjaF9vbmVfc2lkZWRfYm91bmRcbiAgICAgICAgdFxuICAgICAgICBtYXliZV9ib3VuZFxuICAgICAgICB+Y29tcGFyZVxuICAgICAgICB+aWZfZXhjbHVzaXZlOmBGaXJzdF9zdHJpY3RseV9ncmVhdGVyX3RoYW5cbiAgICAgICAgfmlmX2luY2x1c2l2ZTpgRmlyc3RfZ3JlYXRlcl90aGFuX29yX2VxdWFsX3RvXG4gICAgaW5cbiAgICBsZXQgZmluZF91cHBlcl9ib3VuZCB0IG1heWJlX2JvdW5kIH5jb21wYXJlID1cbiAgICAgIGJpbmFyeV9zZWFyY2hfb25lX3NpZGVkX2JvdW5kXG4gICAgICAgIHRcbiAgICAgICAgbWF5YmVfYm91bmRcbiAgICAgICAgfmNvbXBhcmVcbiAgICAgICAgfmlmX2V4Y2x1c2l2ZTpgTGFzdF9zdHJpY3RseV9sZXNzX3RoYW5cbiAgICAgICAgfmlmX2luY2x1c2l2ZTpgTGFzdF9sZXNzX3RoYW5fb3JfZXF1YWxfdG9cbiAgICBpblxuICAgIG1hdGNoIGZpbmRfbG93ZXJfYm91bmQgdCBsb3dlcl9ib3VuZCB+Y29tcGFyZSB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgbG93ZXJfYm91bmQgLT5cbiAgICAgIChtYXRjaCBmaW5kX3VwcGVyX2JvdW5kIHQgdXBwZXJfYm91bmQgfmNvbXBhcmUgd2l0aFxuICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICAgfCBTb21lIHVwcGVyX2JvdW5kIC0+IFNvbWUgKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkpXG4gIDs7XG5cbiAgdHlwZSAoJ2ssICd2KSBhY2MgPVxuICAgIHsgbXV0YWJsZSBiYWRfa2V5IDogJ2sgb3B0aW9uXG4gICAgOyBtdXRhYmxlIG1hcF9sZW5ndGggOiAoJ2ssICd2KSB0ICogaW50XG4gICAgfVxuXG4gIGxldCBvZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmVfa2V5ID1cbiAgICBsZXQgYWNjID0geyBiYWRfa2V5ID0gTm9uZTsgbWFwX2xlbmd0aCA9IGVtcHR5LCAwIH0gaW5cbiAgICBpdGVyaSB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgIGxldCBtYXAsIGxlbmd0aCA9IGFjYy5tYXBfbGVuZ3RoIGluXG4gICAgICBsZXQgKChfLCBsZW5ndGgnKSBhcyBwYWlyKSA9IHNldCB+bGVuZ3RoIH5rZXkgfmRhdGEgbWFwIH5jb21wYXJlX2tleSBpblxuICAgICAgaWYgbGVuZ3RoID0gbGVuZ3RoJyAmJiBPcHRpb24uaXNfbm9uZSBhY2MuYmFkX2tleVxuICAgICAgdGhlbiBhY2MuYmFkX2tleSA8LSBTb21lIGtleVxuICAgICAgZWxzZSBhY2MubWFwX2xlbmd0aCA8LSBwYWlyKTtcbiAgICBtYXRjaCBhY2MuYmFkX2tleSB3aXRoXG4gICAgfCBOb25lIC0+IGBPayBhY2MubWFwX2xlbmd0aFxuICAgIHwgU29tZSBrZXkgLT4gYER1cGxpY2F0ZV9rZXkga2V5XG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpX2V4biB+aXRlcmkgfihjb21wYXJhdG9yIDogXyBDb21wYXJhdG9yLnQpID1cbiAgICBtYXRjaCBvZl9pdGVyaSB+aXRlcmkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuY29tcGFyZSB3aXRoXG4gICAgfCBgT2sgdiAtPiB2XG4gICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgIEVycm9yLmNyZWF0ZSBcIk1hcC5vZl9pdGVyaV9leG46IGR1cGxpY2F0ZSBrZXlcIiBrZXkgY29tcGFyYXRvci5zZXhwX29mX3RcbiAgICAgIHw+IEVycm9yLnJhaXNlXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3Qga2V5X29mX3NleHAgdmFsdWVfb2Zfc2V4cCBzZXhwIH4oY29tcGFyYXRvciA6IF8gQ29tcGFyYXRvci50KSA9XG4gICAgbGV0IGFsaXN0ID0gbGlzdF9vZl9zZXhwIChwYWlyX29mX3NleHAga2V5X29mX3NleHAgdmFsdWVfb2Zfc2V4cCkgc2V4cCBpblxuICAgIGxldCBjb21wYXJlX2tleSA9IGNvbXBhcmF0b3IuY29tcGFyZSBpblxuICAgIG1hdGNoIG9mX2FsaXN0IGFsaXN0IH5jb21wYXJlX2tleSB3aXRoXG4gICAgfCBgT2sgdiAtPiB2XG4gICAgfCBgRHVwbGljYXRlX2tleSBrIC0+XG4gICAgICAoKiBmaW5kIHRoZSBzZXhwIG9mIGEgZHVwbGljYXRlIGtleSwgc28gdGhlIGVycm9yIGlzIG5hcnJvd2VkIHRvIGEga2V5IGFuZCBub3RcbiAgICAgICAgIHRoZSB3aG9sZSBtYXAgKilcbiAgICAgIGxldCBhbGlzdF9zZXhwcyA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIEZuLmlkIEZuLmlkKSBzZXhwIGluXG4gICAgICBsZXQgZm91bmRfZmlyc3RfayA9IHJlZiBmYWxzZSBpblxuICAgICAgTGlzdC5pdGVyMl9vayBhbGlzdCBhbGlzdF9zZXhwcyB+ZjooZnVuIChrMiwgXykgKGsyX3NleHAsIF8pIC0+XG4gICAgICAgIGlmIGNvbXBhcmVfa2V5IGsgazIgPSAwXG4gICAgICAgIHRoZW5cbiAgICAgICAgICBpZiAhZm91bmRfZmlyc3Rfa1xuICAgICAgICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcIk1hcC50X29mX3NleHBfZGlyZWN0OiBkdXBsaWNhdGUga2V5XCIgazJfc2V4cFxuICAgICAgICAgIGVsc2UgZm91bmRfZmlyc3RfayA6PSB0cnVlKTtcbiAgICAgIGFzc2VydCBmYWxzZVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9rZXkgc2V4cF9vZl92YWx1ZSB0ID1cbiAgICBsZXQgZiB+a2V5IH5kYXRhIGFjYyA9IFNleHAuTGlzdCBbIHNleHBfb2Zfa2V5IGtleTsgc2V4cF9vZl92YWx1ZSBkYXRhIF0gOjogYWNjIGluXG4gICAgU2V4cC5MaXN0IChmb2xkX3JpZ2h0IH5mIHQgfmluaXQ6W10pXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmVfZXJyb3JzIHQgfmNvbXBhcmVfa2V5IH5zZXhwX29mX2tleSA9XG4gICAgbGV0IG9rcywgKGVycm9yX3RyZWUsIF8pID0gcGFydGl0aW9uX21hcCB0IH5jb21wYXJlX2tleSB+ZjpSZXN1bHQudG9fZWl0aGVyIGluXG4gICAgaWYgaXNfZW1wdHkgZXJyb3JfdHJlZVxuICAgIHRoZW4gT2sgb2tzXG4gICAgZWxzZSBPcl9lcnJvci5lcnJvcl9zIChzZXhwX29mX3Qgc2V4cF9vZl9rZXkgRXJyb3Iuc2V4cF9vZl90IGVycm9yX3RyZWUpXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzXG4gICAgICAgIHQxXG4gICAgICAgIH5mXG4gICAgICAgIH5jb21wYXJhdG9yOih7IGNvbXBhcmUgPSBjb21wYXJlX2tleTsgc2V4cF9vZl90ID0gc2V4cF9vZl9rZXkgfSA6IF8gQ29tcGFyYXRvci50KVxuICAgID1cbiAgICB3aXRoX3JldHVybiAoZnVuIHsgcmV0dXJuIH0gLT5cbiAgICAgIGBPa1xuICAgICAgICAoZm9sZCB0MSB+aW5pdDooZW1wdHksIDApIH5mOihmdW4gfmtleSB+ZGF0YSAodDIsIGxlbmd0aCkgLT5cbiAgICAgICAgICAgbGV0IGtleSA9IGYga2V5IGluXG4gICAgICAgICAgIHRyeSBhZGRfZXhuX2ludGVybmFsIHQyIH5sZW5ndGggfmtleSB+ZGF0YSB+Y29tcGFyZV9rZXkgfnNleHBfb2Zfa2V5IHdpdGhcbiAgICAgICAgICAgfCBEdXBsaWNhdGUgLT4gcmV0dXJuIChgRHVwbGljYXRlX2tleSBrZXkpKSkpXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzX2V4biB0IH5mIH5jb21wYXJhdG9yID1cbiAgICBtYXRjaCBtYXBfa2V5cyB0IH5mIH5jb21wYXJhdG9yIHdpdGhcbiAgICB8IGBPayByZXN1bHQgLT4gcmVzdWx0XG4gICAgfCBgRHVwbGljYXRlX2tleSBrZXkgLT5cbiAgICAgIGxldCBzZXhwX29mX2tleSA9IGNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3QgaW5cbiAgICAgIEVycm9yLnJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZSBcIk1hcC5tYXBfa2V5c19leG46IGR1cGxpY2F0ZSBrZXlcIiBbIFwia2V5XCIsIGtleSB8PiBzZXhwX29mX2tleSBdKVxuICA7O1xuZW5kXG5cbnR5cGUgKCdrLCAndiwgJ2NvbXBhcmF0b3IpIHQgPVxuICB7ICgqIFtjb21wYXJhdG9yXSBpcyB0aGUgZmlyc3QgZmllbGQgc28gdGhhdCBwb2x5bW9ycGhpYyBlcXVhbGl0eSBmYWlscyBvbiBhIG1hcCBkdWVcbiAgICAgICB0byB0aGUgZnVuY3Rpb25hbCB2YWx1ZSBpbiB0aGUgY29tcGFyYXRvci5cbiAgICAgICBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgcG9seW1vcnBoaWMgW2NvbXBhcmVdOiB0aGF0IHN0aWxsIHByb2R1Y2VzXG4gICAgICAgbm9uc2Vuc2UuICopXG4gICAgY29tcGFyYXRvciA6ICgnaywgJ2NvbXBhcmF0b3IpIENvbXBhcmF0b3IudFxuICA7IHRyZWUgOiAoJ2ssICd2KSBUcmVlMC50XG4gIDsgbGVuZ3RoIDogaW50XG4gIH1cblxudHlwZSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdHJlZSA9ICgnaywgJ3YpIFRyZWUwLnRcblxubGV0IGNvbXBhcmVfa2V5IHQgPSB0LmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cblxubGV0IGxpa2UgeyB0cmVlID0gXzsgbGVuZ3RoID0gXzsgY29tcGFyYXRvciB9ICh0cmVlLCBsZW5ndGgpID1cbiAgeyB0cmVlOyBsZW5ndGg7IGNvbXBhcmF0b3IgfVxuOztcblxubGV0IGxpa2UyIHggKHksIHopID0gbGlrZSB4IHksIGxpa2UgeCB6XG5cbmxldCBsaWtlX21heWJlX25vX29wICh7IHRyZWUgPSBvbGRfdHJlZTsgbGVuZ3RoID0gXzsgY29tcGFyYXRvciB9IGFzIG9sZF90KSAodHJlZSwgbGVuZ3RoKVxuICA9XG4gIGlmIHBoeXNfZXF1YWwgb2xkX3RyZWUgdHJlZSB0aGVuIG9sZF90IGVsc2UgeyB0cmVlOyBsZW5ndGg7IGNvbXBhcmF0b3IgfVxuOztcblxubGV0IHdpdGhfc2FtZV9sZW5ndGggeyB0cmVlID0gXzsgY29tcGFyYXRvcjsgbGVuZ3RoIH0gdHJlZSA9IHsgdHJlZTsgY29tcGFyYXRvcjsgbGVuZ3RoIH1cbmxldCBvZl90cmVlIH5jb21wYXJhdG9yIHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCA9IFRyZWUwLmxlbmd0aCB0cmVlIH1cblxuKCogRXhwb3NpbmcgdGhpcyBmdW5jdGlvbiB3b3VsZCBtYWtlIGl0IHZlcnkgZWFzeSBmb3IgdGhlIGludmFyaWFudHNcbiAgIG9mIHRoaXMgbW9kdWxlIHRvIGJlIGJyb2tlbi4gKilcbmxldCBvZl90cmVlX3Vuc2FmZSB+Y29tcGFyYXRvciB+bGVuZ3RoIHRyZWUgPSB7IHRyZWU7IGNvbXBhcmF0b3I7IGxlbmd0aCB9XG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGNvbXBhcmF0b3IgdCA9IHQuY29tcGFyYXRvclxuICBsZXQgdG9fdHJlZSB0ID0gdC50cmVlXG5cbiAgbGV0IGludmFyaWFudHMgdCA9XG4gICAgVHJlZTAuaW52YXJpYW50cyB0LnRyZWUgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSAmJiBUcmVlMC5sZW5ndGggdC50cmVlID0gdC5sZW5ndGhcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgdCA9IFRyZWUwLmlzX2VtcHR5IHQudHJlZVxuICBsZXQgbGVuZ3RoIHQgPSB0Lmxlbmd0aFxuXG4gIGxldCBzZXQgdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlIHQgKFRyZWUwLnNldCB0LnRyZWUgfmxlbmd0aDp0Lmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IGFkZF9leG4gdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuYWRkX2V4blxuICAgICAgICAgdC50cmVlXG4gICAgICAgICB+bGVuZ3RoOnQubGVuZ3RoXG4gICAgICAgICB+a2V5XG4gICAgICAgICB+ZGF0YVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgICAgICAgfnNleHBfb2Zfa2V5OnQuY29tcGFyYXRvci5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGFkZF9leG5faW50ZXJuYWwgdCB+a2V5IH5kYXRhID1cbiAgICBsaWtlXG4gICAgICB0XG4gICAgICAoVHJlZTAuYWRkX2V4bl9pbnRlcm5hbFxuICAgICAgICAgdC50cmVlXG4gICAgICAgICB+bGVuZ3RoOnQubGVuZ3RoXG4gICAgICAgICB+a2V5XG4gICAgICAgICB+ZGF0YVxuICAgICAgICAgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICAgICAgICAgfnNleHBfb2Zfa2V5OnQuY29tcGFyYXRvci5zZXhwX29mX3QpXG4gIDs7XG5cbiAgbGV0IGFkZCB0IH5rZXkgfmRhdGEgPVxuICAgIG1hdGNoIGFkZF9leG5faW50ZXJuYWwgdCB+a2V5IH5kYXRhIHdpdGhcbiAgICB8IHJlc3VsdCAtPiBgT2sgcmVzdWx0XG4gICAgfCBleGNlcHRpb24gRHVwbGljYXRlIC0+IGBEdXBsaWNhdGVcbiAgOztcblxuICBsZXQgYWRkX211bHRpIHQgfmtleSB+ZGF0YSA9XG4gICAgbGlrZVxuICAgICAgdFxuICAgICAgKFRyZWUwLmFkZF9tdWx0aSB0LnRyZWUgfmxlbmd0aDp0Lmxlbmd0aCB+a2V5IH5kYXRhIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IHJlbW92ZV9tdWx0aSB0IGtleSA9XG4gICAgbGlrZSB0IChUcmVlMC5yZW1vdmVfbXVsdGkgdC50cmVlIH5sZW5ndGg6dC5sZW5ndGgga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IGZpbmRfbXVsdGkgdCBrZXkgPSBUcmVlMC5maW5kX211bHRpIHQudHJlZSBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuXG4gIGxldCBjaGFuZ2UgdCBrZXkgfmYgPVxuICAgIGxpa2UgdCAoVHJlZTAuY2hhbmdlIHQudHJlZSBrZXkgfmYgfmxlbmd0aDp0Lmxlbmd0aCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCB1cGRhdGUgdCBrZXkgfmYgPVxuICAgIGxpa2UgdCAoVHJlZTAudXBkYXRlIHQudHJlZSBrZXkgfmYgfmxlbmd0aDp0Lmxlbmd0aCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBmaW5kX2V4biB0IGtleSA9XG4gICAgVHJlZTAuZmluZF9leG5cbiAgICAgIHQudHJlZVxuICAgICAga2V5XG4gICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgICB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCBmaW5kIHQga2V5ID0gVHJlZTAuZmluZCB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcblxuICBsZXQgcmVtb3ZlIHQga2V5ID1cbiAgICBsaWtlX21heWJlX25vX29wXG4gICAgICB0XG4gICAgICAoVHJlZTAucmVtb3ZlIHQudHJlZSBrZXkgfmxlbmd0aDp0Lmxlbmd0aCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBtZW0gdCBrZXkgPSBUcmVlMC5tZW0gdC50cmVlIGtleSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIGxldCBpdGVyX2tleXMgdCB+ZiA9IFRyZWUwLml0ZXJfa2V5cyB0LnRyZWUgfmZcbiAgbGV0IGl0ZXIgdCB+ZiA9IFRyZWUwLml0ZXIgdC50cmVlIH5mXG4gIGxldCBpdGVyaSB0IH5mID0gVHJlZTAuaXRlcmkgdC50cmVlIH5mXG4gIGxldCBpdGVyaV91bnRpbCB0IH5mID0gVHJlZTAuaXRlcmlfdW50aWwgdC50cmVlIH5mXG4gIGxldCBpdGVyMiB0MSB0MiB+ZiA9IFRyZWUwLml0ZXIyIHQxLnRyZWUgdDIudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKVxuICBsZXQgbWFwIHQgfmYgPSB3aXRoX3NhbWVfbGVuZ3RoIHQgKFRyZWUwLm1hcCB0LnRyZWUgfmYpXG4gIGxldCBtYXBpIHQgfmYgPSB3aXRoX3NhbWVfbGVuZ3RoIHQgKFRyZWUwLm1hcGkgdC50cmVlIH5mKVxuICBsZXQgZm9sZCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZCB0LnRyZWUgfmYgfmluaXRcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGRfdW50aWwgdC50cmVlIH5mIH5pbml0XG4gIGxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBUcmVlMC5mb2xkX3JpZ2h0IHQudHJlZSB+ZiB+aW5pdFxuXG4gIGxldCBmb2xkMiB0MSB0MiB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZDIgdDEudHJlZSB0Mi50cmVlIH5pbml0IH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9rZXlzIHQgfmYgPSBsaWtlIHQgKFRyZWUwLmZpbHRlcl9rZXlzIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICBsZXQgZmlsdGVyIHQgfmYgPSBsaWtlIHQgKFRyZWUwLmZpbHRlciB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgbGV0IGZpbHRlcmkgdCB+ZiA9IGxpa2UgdCAoVHJlZTAuZmlsdGVyaSB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgbGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGxpa2UgdCAoVHJlZTAuZmlsdGVyX21hcCB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgbGV0IGZpbHRlcl9tYXBpIHQgfmYgPSBsaWtlIHQgKFRyZWUwLmZpbHRlcl9tYXBpIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuXG4gIGxldCBwYXJ0aXRpb25fbWFwaSB0IH5mID1cbiAgICBsaWtlMiB0IChUcmVlMC5wYXJ0aXRpb25fbWFwaSB0LnRyZWUgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KSlcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX21hcCB0IH5mID1cbiAgICBsaWtlMiB0IChUcmVlMC5wYXJ0aXRpb25fbWFwIHQudHJlZSB+ZiB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpKVxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICAgIGxpa2UyIHQgKFRyZWUwLnBhcnRpdGlvbmlfdGYgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl90ZiB0IH5mID1cbiAgICBsaWtlMiB0IChUcmVlMC5wYXJ0aXRpb25fdGYgdC50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdCkpXG4gIDs7XG5cbiAgbGV0IGNvbWJpbmVfZXJyb3JzIHQgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6KGxpa2UgdClcbiAgICAgIChUcmVlMC5jb21iaW5lX2Vycm9yc1xuICAgICAgICAgdC50cmVlXG4gICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgICAgICB+c2V4cF9vZl9rZXk6dC5jb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgY29tcGFyZV9kaXJlY3QgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBUcmVlMC5jb21wYXJlIChjb21wYXJlX2tleSB0MSkgY29tcGFyZV9kYXRhIHQxLnRyZWUgdDIudHJlZVxuICA7O1xuXG4gIGxldCBlcXVhbCBjb21wYXJlX2RhdGEgdDEgdDIgPSBUcmVlMC5lcXVhbCAoY29tcGFyZV9rZXkgdDEpIGNvbXBhcmVfZGF0YSB0MS50cmVlIHQyLnRyZWVcbiAgbGV0IGtleXMgdCA9IFRyZWUwLmtleXMgdC50cmVlXG4gIGxldCBkYXRhIHQgPSBUcmVlMC5kYXRhIHQudHJlZVxuICBsZXQgdG9fYWxpc3QgP2tleV9vcmRlciB0ID0gVHJlZTAudG9fYWxpc3QgP2tleV9vcmRlciB0LnRyZWVcblxuICBsZXQgc3ltbWV0cmljX2RpZmYgdDEgdDIgfmRhdGFfZXF1YWwgPVxuICAgIFRyZWUwLnN5bW1ldHJpY19kaWZmIHQxLnRyZWUgdDIudHJlZSB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKSB+ZGF0YV9lcXVhbFxuICA7O1xuXG4gIGxldCBmb2xkX3N5bW1ldHJpY19kaWZmIHQxIHQyIH5kYXRhX2VxdWFsIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkX3N5bW1ldHJpY19kaWZmXG4gICAgICB0MS50cmVlXG4gICAgICB0Mi50cmVlXG4gICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQxKVxuICAgICAgfmRhdGFfZXF1YWxcbiAgICAgIH5pbml0XG4gICAgICB+ZlxuICA7O1xuXG4gIGxldCBtZXJnZSB0MSB0MiB+ZiA9XG4gICAgbGlrZSB0MSAoVHJlZTAubWVyZ2UgdDEudHJlZSB0Mi50cmVlIH5mIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpKVxuICA7O1xuXG4gIGxldCBtZXJnZV9za2V3ZWQgdDEgdDIgfmNvbWJpbmUgPVxuICAgICgqIFRoaXMgaXMgb25seSBhIG5vLW9wIGluIHRoZSBjYXNlIHdoZXJlIGF0IGxlYXN0IG9uZSBvZiB0aGUgbWFwcyBpcyBlbXB0eS4gKilcbiAgICBsaWtlX21heWJlX25vX29wXG4gICAgICAoaWYgdDIubGVuZ3RoIDw9IHQxLmxlbmd0aCB0aGVuIHQxIGVsc2UgdDIpXG4gICAgICAoVHJlZTAubWVyZ2Vfc2tld2VkXG4gICAgICAgICB0MS50cmVlXG4gICAgICAgICB0Mi50cmVlXG4gICAgICAgICB+bGVuZ3RoMTp0MS5sZW5ndGhcbiAgICAgICAgIH5sZW5ndGgyOnQyLmxlbmd0aFxuICAgICAgICAgfmNvbWJpbmVcbiAgICAgICAgIH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdDEpKVxuICA7O1xuXG4gIGxldCBtaW5fZWx0IHQgPSBUcmVlMC5taW5fZWx0IHQudHJlZVxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHQudHJlZVxuICBsZXQgbWF4X2VsdCB0ID0gVHJlZTAubWF4X2VsdCB0LnRyZWVcbiAgbGV0IG1heF9lbHRfZXhuIHQgPSBUcmVlMC5tYXhfZWx0X2V4biB0LnRyZWVcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdC50cmVlIH5mXG4gIGxldCBmb3JfYWxsaSB0IH5mID0gVHJlZTAuZm9yX2FsbGkgdC50cmVlIH5mXG4gIGxldCBleGlzdHMgdCB+ZiA9IFRyZWUwLmV4aXN0cyB0LnRyZWUgfmZcbiAgbGV0IGV4aXN0c2kgdCB+ZiA9IFRyZWUwLmV4aXN0c2kgdC50cmVlIH5mXG4gIGxldCBjb3VudCB0IH5mID0gVHJlZTAuY291bnQgdC50cmVlIH5mXG4gIGxldCBjb3VudGkgdCB+ZiA9IFRyZWUwLmNvdW50aSB0LnRyZWUgfmZcblxuICBsZXQgc3BsaXQgdCBrID1cbiAgICBsZXQgbCwgbWF5YmUsIHIgPSBUcmVlMC5zcGxpdCB0LnRyZWUgayB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpIGluXG4gICAgbGV0IGNvbXBhcmF0b3IgPSBjb21wYXJhdG9yIHQgaW5cbiAgICAoKiBUcnkgdG8gdHJhdmVyc2UgdGhlIGxlYXN0IGFtb3VudCBwb3NzaWJsZSB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCxcbiAgICAgICB1c2luZyBoZWlnaHQgYXMgYSBoZXVyaXN0aWMuICopXG4gICAgbGV0IGJvdGhfbGVuID0gaWYgT3B0aW9uLmlzX3NvbWUgbWF5YmUgdGhlbiB0Lmxlbmd0aCAtIDEgZWxzZSB0Lmxlbmd0aCBpblxuICAgIGlmIFRyZWUwLmhlaWdodCBsIDwgVHJlZTAuaGVpZ2h0IHJcbiAgICB0aGVuIChcbiAgICAgIGxldCBsID0gb2ZfdHJlZSBsIH5jb21wYXJhdG9yIGluXG4gICAgICBsLCBtYXliZSwgb2ZfdHJlZV91bnNhZmUgciB+Y29tcGFyYXRvciB+bGVuZ3RoOihib3RoX2xlbiAtIGxlbmd0aCBsKSlcbiAgICBlbHNlIChcbiAgICAgIGxldCByID0gb2ZfdHJlZSByIH5jb21wYXJhdG9yIGluXG4gICAgICBvZl90cmVlX3Vuc2FmZSBsIH5jb21wYXJhdG9yIH5sZW5ndGg6KGJvdGhfbGVuIC0gbGVuZ3RoIHIpLCBtYXliZSwgcilcbiAgOztcblxuICBsZXQgc3VicmFuZ2UgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBsZXQgbGVmdCwgbWlkLCByaWdodCA9XG4gICAgICBUcmVlMC5zcGxpdF9yYW5nZSB0LnRyZWUgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gICAgaW5cbiAgICAoKiBUcnkgdG8gdHJhdmVyc2UgdGhlIGxlYXN0IGFtb3VudCBwb3NzaWJsZSB0byBjYWxjdWxhdGUgdGhlIGxlbmd0aCxcbiAgICAgICB1c2luZyBoZWlnaHQgYXMgYSBoZXVyaXN0aWMuICopXG4gICAgbGV0IG91dGVyX2pvaW5lZF9oZWlnaHQgPVxuICAgICAgbGV0IGhfbCA9IFRyZWUwLmhlaWdodCBsZWZ0XG4gICAgICBhbmQgaF9yID0gVHJlZTAuaGVpZ2h0IHJpZ2h0IGluXG4gICAgICBpZiBoX2wgPSBoX3IgdGhlbiBoX2wgKyAxIGVsc2UgbWF4IGhfbCBoX3JcbiAgICBpblxuICAgIGlmIG91dGVyX2pvaW5lZF9oZWlnaHQgPCBUcmVlMC5oZWlnaHQgbWlkXG4gICAgdGhlbiAoXG4gICAgICBsZXQgbWlkX2xlbmd0aCA9IHQubGVuZ3RoIC0gKFRyZWUwLmxlbmd0aCBsZWZ0ICsgVHJlZTAubGVuZ3RoIHJpZ2h0KSBpblxuICAgICAgb2ZfdHJlZV91bnNhZmUgbWlkIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIHQpIH5sZW5ndGg6bWlkX2xlbmd0aClcbiAgICBlbHNlIG9mX3RyZWUgbWlkIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIHQpXG4gIDs7XG5cbiAgbGV0IGFwcGVuZCB+bG93ZXJfcGFydCB+dXBwZXJfcGFydCA9XG4gICAgbWF0Y2hcbiAgICAgIFRyZWUwLmFwcGVuZFxuICAgICAgICB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IGxvd2VyX3BhcnQpXG4gICAgICAgIH5sb3dlcl9wYXJ0Omxvd2VyX3BhcnQudHJlZVxuICAgICAgICB+dXBwZXJfcGFydDp1cHBlcl9wYXJ0LnRyZWVcbiAgICB3aXRoXG4gICAgfCBgT2sgdHJlZSAtPlxuICAgICAgYE9rXG4gICAgICAgIChvZl90cmVlX3Vuc2FmZVxuICAgICAgICAgICB0cmVlXG4gICAgICAgICAgIH5jb21wYXJhdG9yOihjb21wYXJhdG9yIGxvd2VyX3BhcnQpXG4gICAgICAgICAgIH5sZW5ndGg6KGxvd2VyX3BhcnQubGVuZ3RoICsgdXBwZXJfcGFydC5sZW5ndGgpKVxuICAgIHwgYE92ZXJsYXBwaW5nX2tleV9yYW5nZXMgLT4gYE92ZXJsYXBwaW5nX2tleV9yYW5nZXNcbiAgOztcblxuICBsZXQgZm9sZF9yYW5nZV9pbmNsdXNpdmUgdCB+bWluIH5tYXggfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGRfcmFuZ2VfaW5jbHVzaXZlIHQudHJlZSB+bWluIH5tYXggfmluaXQgfmYgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCByYW5nZV90b19hbGlzdCB0IH5taW4gfm1heCA9XG4gICAgVHJlZTAucmFuZ2VfdG9fYWxpc3QgdC50cmVlIH5taW4gfm1heCB+Y29tcGFyZV9rZXk6KGNvbXBhcmVfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IGNsb3Nlc3Rfa2V5IHQgZGlyIGtleSA9XG4gICAgVHJlZTAuY2xvc2VzdF9rZXkgdC50cmVlIGRpciBrZXkgfmNvbXBhcmVfa2V5Oihjb21wYXJlX2tleSB0KVxuICA7O1xuXG4gIGxldCBudGggdCBuID0gVHJlZTAubnRoIHQudHJlZSBuXG4gIGxldCBudGhfZXhuIHQgbiA9IE9wdGlvbi52YWx1ZV9leG4gKG50aCB0IG4pXG4gIGxldCByYW5rIHQga2V5ID0gVHJlZTAucmFuayB0LnRyZWUga2V5IH5jb21wYXJlX2tleTooY29tcGFyZV9rZXkgdClcbiAgbGV0IHNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IF8gdCA9IFRyZWUwLnNleHBfb2ZfdCBzZXhwX29mX2sgc2V4cF9vZl92IHQudHJlZVxuXG4gIGxldCB0b19zZXF1ZW5jZSA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlXG4gICAgICB0LmNvbXBhcmF0b3JcbiAgICAgID9vcmRlclxuICAgICAgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90b1xuICAgICAgP2tleXNfbGVzc19vcl9lcXVhbF90b1xuICAgICAgdC50cmVlXG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggdCB+Y29tcGFyZSBob3cgdiA9IFRyZWUwLmJpbmFyeV9zZWFyY2ggdC50cmVlIH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93ID1cbiAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3NlZ21lbnRlZCB0LnRyZWUgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9kaXJlY3QgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0ID1cbiAgICBUcmVlMC5oYXNoX2ZvbGRfdF9pZ25vcmluZ19zdHJ1Y3R1cmUgaGFzaF9mb2xkX2tleSBoYXNoX2ZvbGRfZGF0YSBzdGF0ZSB0LnRyZWVcbiAgOztcblxuICBsZXQgYmluYXJ5X3NlYXJjaF9zdWJyYW5nZSB0IH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmQgPVxuICAgIG1hdGNoXG4gICAgICBUcmVlMC5iaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdC50cmVlIH5jb21wYXJlIH5sb3dlcl9ib3VuZCB+dXBwZXJfYm91bmRcbiAgICB3aXRoXG4gICAgfCBTb21lIChsb3dlcl9ib3VuZCwgdXBwZXJfYm91bmQpIC0+IHN1YnJhbmdlIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZFxuICAgIHwgTm9uZSAtPiBsaWtlX21heWJlX25vX29wIHQgKEVtcHR5LCAwKVxuICA7O1xuZW5kXG5cbigqIFswXSBpcyB1c2VkIGFzIHRoZSBbbGVuZ3RoXSBhcmd1bWVudCBldmVyeXdoZXJlIGluIHRoaXMgbW9kdWxlLCBzaW5jZSB0cmVlcyBkbyBub3RcbiAgIGhhdmUgdGhlaXIgbGVuZ3RocyBzdG9yZWQgYXQgdGhlIHJvb3QsIHVubGlrZSBtYXBzLiBUaGUgdmFsdWVzIGFyZSBkaXNjYXJkZWQgYWx3YXlzLiAqKVxubW9kdWxlIFRyZWUgPSBzdHJ1Y3RcbiAgdHlwZSAoJ2ssICd2LCAnY29tcGFyYXRvcikgdCA9ICgnaywgJ3YsICdjb21wYXJhdG9yKSB0cmVlXG5cbiAgbGV0IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gPSBUcmVlMC5lbXB0eVxuICBsZXQgZW1wdHkgfmNvbXBhcmF0b3I6XyA9IGVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb25cbiAgbGV0IG9mX3RyZWUgfmNvbXBhcmF0b3I6XyB0cmVlID0gdHJlZVxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yOl8gayB2ID0gVHJlZTAuc2luZ2xldG9uIGsgdlxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBmc3QgKFRyZWUwLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgfmNvbXBhcmF0b3IgYXJyYXkgPVxuICAgIFRyZWUwLm9mX3NvcnRlZF9hcnJheSBhcnJheSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB8PiBPcl9lcnJvci5tYXAgfmY6ZnN0XG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0IH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBtYXRjaCBUcmVlMC5vZl9hbGlzdCBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkIC0+IGRcbiAgICB8IGBPayAodHJlZSwgX3NpemUpIC0+IGBPayB0cmVlXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X29yX2Vycm9yIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBUcmVlMC5vZl9hbGlzdF9vcl9lcnJvciBhbGlzdCB+Y29tcGFyYXRvciB8PiBPcl9lcnJvci5tYXAgfmY6ZnN0XG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biB+Y29tcGFyYXRvciBhbGlzdCA9IGZzdCAoVHJlZTAub2ZfYWxpc3RfZXhuIGFsaXN0IH5jb21wYXJhdG9yKVxuXG4gIGxldCBvZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgZnN0IChUcmVlMC5vZl9hbGlzdF9tdWx0aSBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2ZvbGQgfmNvbXBhcmF0b3IgYWxpc3QgfmluaXQgfmYgPVxuICAgIGZzdCAoVHJlZTAub2ZfYWxpc3RfZm9sZCBhbGlzdCB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X3JlZHVjZSB+Y29tcGFyYXRvciBhbGlzdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5vZl9hbGlzdF9yZWR1Y2UgYWxpc3QgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9pdGVyaSB+Y29tcGFyYXRvciB+aXRlcmkgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2l0ZXJpIH5pdGVyaSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rICh0cmVlLCBfc2l6ZSkgLT4gYE9rIHRyZWVcbiAgICB8IGBEdXBsaWNhdGVfa2V5IF8gYXMgZCAtPiBkXG4gIDs7XG5cbiAgbGV0IG9mX2l0ZXJpX2V4biB+Y29tcGFyYXRvciB+aXRlcmkgPSBmc3QgKFRyZWUwLm9mX2l0ZXJpX2V4biB+aXRlcmkgfmNvbXBhcmF0b3IpXG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5jb21wYXJhdG9yOl9yZXF1aXJlZF9ieV9pbnRmIH5sZW4gfmYgPVxuICAgIFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmZcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6ZnN0XG4gICAgICAoVHJlZTAub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIG1hdGNoIFRyZWUwLm9mX3NlcXVlbmNlIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkIC0+IGRcbiAgICB8IGBPayAodHJlZSwgX3NpemUpIC0+IGBPayB0cmVlXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgVHJlZTAub2Zfc2VxdWVuY2Vfb3JfZXJyb3Igc2VxIH5jb21wYXJhdG9yIHw+IE9yX2Vycm9yLm1hcCB+Zjpmc3RcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfZXhuIH5jb21wYXJhdG9yIHNlcSA9IGZzdCAoVHJlZTAub2Zfc2VxdWVuY2VfZXhuIHNlcSB+Y29tcGFyYXRvcilcblxuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBmc3QgKFRyZWUwLm9mX3NlcXVlbmNlX211bHRpIHNlcSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX2ZvbGQgfmNvbXBhcmF0b3Igc2VxIH5pbml0IH5mID1cbiAgICBmc3QgKFRyZWUwLm9mX3NlcXVlbmNlX2ZvbGQgc2VxIH5pbml0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfcmVkdWNlIH5jb21wYXJhdG9yIHNlcSB+ZiA9XG4gICAgZnN0IChUcmVlMC5vZl9zZXF1ZW5jZV9yZWR1Y2Ugc2VxIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgdG9fdHJlZSB0ID0gdFxuXG4gIGxldCBpbnZhcmlhbnRzIH5jb21wYXJhdG9yIHQgPVxuICAgIFRyZWUwLmludmFyaWFudHMgdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgaXNfZW1wdHkgdCA9IFRyZWUwLmlzX2VtcHR5IHRcbiAgbGV0IGxlbmd0aCB0ID0gVHJlZTAubGVuZ3RoIHRcblxuICBsZXQgc2V0IH5jb21wYXJhdG9yIHQgfmtleSB+ZGF0YSA9XG4gICAgZnN0IChUcmVlMC5zZXQgdCB+a2V5IH5kYXRhIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGFkZF9leG4gfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICBmc3RcbiAgICAgIChUcmVlMC5hZGRfZXhuXG4gICAgICAgICB0XG4gICAgICAgICB+a2V5XG4gICAgICAgICB+ZGF0YVxuICAgICAgICAgfmxlbmd0aDowXG4gICAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgICAgIH5zZXhwX29mX2tleTpjb21wYXJhdG9yLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgYWRkIH5jb21wYXJhdG9yIHQgfmtleSB+ZGF0YSA9XG4gICAgdHJ5IGBPayAoYWRkX2V4biB0IH5jb21wYXJhdG9yIH5rZXkgfmRhdGEpIHdpdGhcbiAgICB8IF8gLT4gYER1cGxpY2F0ZVxuICA7O1xuXG4gIGxldCBhZGRfbXVsdGkgfmNvbXBhcmF0b3IgdCB+a2V5IH5kYXRhID1cbiAgICBUcmVlMC5hZGRfbXVsdGkgdCB+a2V5IH5kYXRhIH5sZW5ndGg6MCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICB8PiBmc3RcbiAgOztcblxuICBsZXQgcmVtb3ZlX211bHRpIH5jb21wYXJhdG9yIHQga2V5ID1cbiAgICBUcmVlMC5yZW1vdmVfbXVsdGkgdCBrZXkgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB8PiBmc3RcbiAgOztcblxuICBsZXQgZmluZF9tdWx0aSB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgVHJlZTAuZmluZF9tdWx0aSB0IGtleSB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgY2hhbmdlIH5jb21wYXJhdG9yIHQga2V5IH5mID1cbiAgICBmc3QgKFRyZWUwLmNoYW5nZSB0IGtleSB+ZiB+bGVuZ3RoOjAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCB1cGRhdGUgfmNvbXBhcmF0b3IgdCBrZXkgfmYgPVxuICAgIGNoYW5nZSB+Y29tcGFyYXRvciB0IGtleSB+ZjooZnVuIGRhdGEgLT4gU29tZSAoZiBkYXRhKSlcbiAgOztcblxuICBsZXQgZmluZF9leG4gfmNvbXBhcmF0b3IgdCBrZXkgPVxuICAgIFRyZWUwLmZpbmRfZXhuXG4gICAgICB0XG4gICAgICBrZXlcbiAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgICAgfnNleHBfb2Zfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5zZXhwX29mX3RcbiAgOztcblxuICBsZXQgZmluZCB+Y29tcGFyYXRvciB0IGtleSA9IFRyZWUwLmZpbmQgdCBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG5cbiAgbGV0IHJlbW92ZSB+Y29tcGFyYXRvciB0IGtleSA9XG4gICAgZnN0IChUcmVlMC5yZW1vdmUgdCBrZXkgfmxlbmd0aDowIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgbWVtIH5jb21wYXJhdG9yIHQga2V5ID0gVHJlZTAubWVtIHQga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICBsZXQgaXRlcl9rZXlzIHQgfmYgPSBUcmVlMC5pdGVyX2tleXMgdCB+ZlxuICBsZXQgaXRlciB0IH5mID0gVHJlZTAuaXRlciB0IH5mXG4gIGxldCBpdGVyaSB0IH5mID0gVHJlZTAuaXRlcmkgdCB+ZlxuICBsZXQgaXRlcmlfdW50aWwgdCB+ZiA9IFRyZWUwLml0ZXJpX3VudGlsIHQgfmZcblxuICBsZXQgaXRlcjIgfmNvbXBhcmF0b3IgdDEgdDIgfmYgPVxuICAgIFRyZWUwLml0ZXIyIHQxIHQyIH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBtYXAgdCB+ZiA9IFRyZWUwLm1hcCB0IH5mXG4gIGxldCBtYXBpIHQgfmYgPSBUcmVlMC5tYXBpIHQgfmZcbiAgbGV0IGZvbGQgdCB+aW5pdCB+ZiA9IFRyZWUwLmZvbGQgdCB+ZiB+aW5pdFxuICBsZXQgZm9sZF91bnRpbCB0IH5pbml0IH5mIH5maW5pc2ggPSBUcmVlMC5mb2xkX3VudGlsIHQgfmYgfmluaXQgfmZpbmlzaFxuICBsZXQgZm9sZF9yaWdodCB0IH5pbml0IH5mID0gVHJlZTAuZm9sZF9yaWdodCB0IH5mIH5pbml0XG5cbiAgbGV0IGZvbGQyIH5jb21wYXJhdG9yIHQxIHQyIH5pbml0IH5mID1cbiAgICBUcmVlMC5mb2xkMiB0MSB0MiB+aW5pdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgOztcblxuICBsZXQgZmlsdGVyX2tleXMgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgZnN0IChUcmVlMC5maWx0ZXJfa2V5cyB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgZmlsdGVyIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGZzdCAoVHJlZTAuZmlsdGVyIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBmaWx0ZXJpIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGZzdCAoVHJlZTAuZmlsdGVyaSB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgZmlsdGVyX21hcCB+Y29tcGFyYXRvciB0IH5mID1cbiAgICBmc3QgKFRyZWUwLmZpbHRlcl9tYXAgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9tYXBpIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGZzdCAoVHJlZTAuZmlsdGVyX21hcGkgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbl9tYXBpIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGxldCAoYSwgXyksIChiLCBfKSA9XG4gICAgICBUcmVlMC5wYXJ0aXRpb25fbWFwaSB0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICAgIGluXG4gICAgYSwgYlxuICA7O1xuXG4gIGxldCBwYXJ0aXRpb25fbWFwIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGxldCAoYSwgXyksIChiLCBfKSA9XG4gICAgICBUcmVlMC5wYXJ0aXRpb25fbWFwIHQgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICBhLCBiXG4gIDs7XG5cbiAgbGV0IHBhcnRpdGlvbmlfdGYgfmNvbXBhcmF0b3IgdCB+ZiA9XG4gICAgbGV0IChhLCBfKSwgKGIsIF8pID1cbiAgICAgIFRyZWUwLnBhcnRpdGlvbmlfdGYgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIGEsIGJcbiAgOztcblxuICBsZXQgcGFydGl0aW9uX3RmIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIGxldCAoYSwgXyksIChiLCBfKSA9XG4gICAgICBUcmVlMC5wYXJ0aXRpb25fdGYgdCB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICBpblxuICAgIGEsIGJcbiAgOztcblxuICBsZXQgY29tYmluZV9lcnJvcnMgfmNvbXBhcmF0b3IgdCA9XG4gICAgT3JfZXJyb3IubWFwXG4gICAgICB+Zjpmc3RcbiAgICAgIChUcmVlMC5jb21iaW5lX2Vycm9yc1xuICAgICAgICAgdFxuICAgICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgICAgICB+c2V4cF9vZl9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLnNleHBfb2ZfdClcbiAgOztcblxuICBsZXQgY29tcGFyZV9kaXJlY3QgfmNvbXBhcmF0b3IgY29tcGFyZV9kYXRhIHQxIHQyID1cbiAgICBUcmVlMC5jb21wYXJlIGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGNvbXBhcmVfZGF0YSB0MSB0MlxuICA7O1xuXG4gIGxldCBlcXVhbCB+Y29tcGFyYXRvciBjb21wYXJlX2RhdGEgdDEgdDIgPVxuICAgIFRyZWUwLmVxdWFsIGNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIGNvbXBhcmVfZGF0YSB0MSB0MlxuICA7O1xuXG4gIGxldCBrZXlzIHQgPSBUcmVlMC5rZXlzIHRcbiAgbGV0IGRhdGEgdCA9IFRyZWUwLmRhdGEgdFxuICBsZXQgdG9fYWxpc3QgP2tleV9vcmRlciB0ID0gVHJlZTAudG9fYWxpc3QgP2tleV9vcmRlciB0XG5cbiAgbGV0IHN5bW1ldHJpY19kaWZmIH5jb21wYXJhdG9yIHQxIHQyIH5kYXRhX2VxdWFsID1cbiAgICBUcmVlMC5zeW1tZXRyaWNfZGlmZiB0MSB0MiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgfmRhdGFfZXF1YWxcbiAgOztcblxuICBsZXQgZm9sZF9zeW1tZXRyaWNfZGlmZiB+Y29tcGFyYXRvciB0MSB0MiB+ZGF0YV9lcXVhbCB+aW5pdCB+ZiA9XG4gICAgVHJlZTAuZm9sZF9zeW1tZXRyaWNfZGlmZlxuICAgICAgdDFcbiAgICAgIHQyXG4gICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcbiAgICAgIH5kYXRhX2VxdWFsXG4gICAgICB+aW5pdFxuICAgICAgfmZcbiAgOztcblxuICBsZXQgbWVyZ2UgfmNvbXBhcmF0b3IgdDEgdDIgfmYgPVxuICAgIGZzdCAoVHJlZTAubWVyZ2UgdDEgdDIgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBtZXJnZV9za2V3ZWQgfmNvbXBhcmF0b3IgdDEgdDIgfmNvbWJpbmUgPVxuICAgICgqIExlbmd0aCBjb21wdXRhdGlvbiBtYWtlcyB0aGlzIHNpZ25pZmljYW50bHkgc2xvd2VyIHRoYW4gW21lcmdlX3NrZXdlZF0gb24gYSBtYXBcbiAgICAgICB3aXRoIGEgW2xlbmd0aF0gZmllbGQsIGJ1dCBkb2VzIHByZXNlcnZlIGFtb3VudCBvZiBhbGxvY2F0aW9uLiAqKVxuICAgIGZzdFxuICAgICAgKFRyZWUwLm1lcmdlX3NrZXdlZFxuICAgICAgICAgdDFcbiAgICAgICAgIHQyXG4gICAgICAgICB+bGVuZ3RoMToobGVuZ3RoIHQxKVxuICAgICAgICAgfmxlbmd0aDI6KGxlbmd0aCB0MilcbiAgICAgICAgIH5jb21iaW5lXG4gICAgICAgICB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IG1pbl9lbHQgdCA9IFRyZWUwLm1pbl9lbHQgdFxuICBsZXQgbWluX2VsdF9leG4gdCA9IFRyZWUwLm1pbl9lbHRfZXhuIHRcbiAgbGV0IG1heF9lbHQgdCA9IFRyZWUwLm1heF9lbHQgdFxuICBsZXQgbWF4X2VsdF9leG4gdCA9IFRyZWUwLm1heF9lbHRfZXhuIHRcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IFRyZWUwLmZvcl9hbGwgdCB+ZlxuICBsZXQgZm9yX2FsbGkgdCB+ZiA9IFRyZWUwLmZvcl9hbGxpIHQgfmZcbiAgbGV0IGV4aXN0cyB0IH5mID0gVHJlZTAuZXhpc3RzIHQgfmZcbiAgbGV0IGV4aXN0c2kgdCB+ZiA9IFRyZWUwLmV4aXN0c2kgdCB+ZlxuICBsZXQgY291bnQgdCB+ZiA9IFRyZWUwLmNvdW50IHQgfmZcbiAgbGV0IGNvdW50aSB0IH5mID0gVHJlZTAuY291bnRpIHQgfmZcbiAgbGV0IHNwbGl0IH5jb21wYXJhdG9yIHQgayA9IFRyZWUwLnNwbGl0IHQgayB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmVcblxuICBsZXQgYXBwZW5kIH5jb21wYXJhdG9yIH5sb3dlcl9wYXJ0IH51cHBlcl9wYXJ0ID1cbiAgICBUcmVlMC5hcHBlbmQgfmxvd2VyX3BhcnQgfnVwcGVyX3BhcnQgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IHN1YnJhbmdlIH5jb21wYXJhdG9yIHQgfmxvd2VyX2JvdW5kIH51cHBlcl9ib3VuZCA9XG4gICAgbGV0IF8sIHJldCwgXyA9XG4gICAgICBUcmVlMC5zcGxpdF9yYW5nZVxuICAgICAgICB0XG4gICAgICAgIH5sb3dlcl9ib3VuZFxuICAgICAgICB+dXBwZXJfYm91bmRcbiAgICAgICAgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gICAgaW5cbiAgICByZXRcbiAgOztcblxuICBsZXQgZm9sZF9yYW5nZV9pbmNsdXNpdmUgfmNvbXBhcmF0b3IgdCB+bWluIH5tYXggfmluaXQgfmYgPVxuICAgIFRyZWUwLmZvbGRfcmFuZ2VfaW5jbHVzaXZlXG4gICAgICB0XG4gICAgICB+bWluXG4gICAgICB+bWF4XG4gICAgICB+aW5pdFxuICAgICAgfmZcbiAgICAgIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCByYW5nZV90b19hbGlzdCB+Y29tcGFyYXRvciB0IH5taW4gfm1heCA9XG4gICAgVHJlZTAucmFuZ2VfdG9fYWxpc3QgdCB+bWluIH5tYXggfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIDs7XG5cbiAgbGV0IGNsb3Nlc3Rfa2V5IH5jb21wYXJhdG9yIHQgZGlyIGtleSA9XG4gICAgVHJlZTAuY2xvc2VzdF9rZXkgdCBkaXIga2V5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZVxuICA7O1xuXG4gIGxldCBudGggdCBuID0gVHJlZTAubnRoIHQgblxuICBsZXQgbnRoX2V4biB0IG4gPSBPcHRpb24udmFsdWVfZXhuIChudGggdCBuKVxuICBsZXQgcmFuayB+Y29tcGFyYXRvciB0IGtleSA9IFRyZWUwLnJhbmsgdCBrZXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlXG4gIGxldCBzZXhwX29mX3Qgc2V4cF9vZl9rIHNleHBfb2ZfdiBfIHQgPSBUcmVlMC5zZXhwX29mX3Qgc2V4cF9vZl9rIHNleHBfb2ZfdiB0XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3Iga19vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwID1cbiAgICBmc3QgKFRyZWUwLnRfb2Zfc2V4cF9kaXJlY3Qga19vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCB0b19zZXF1ZW5jZSB+Y29tcGFyYXRvciA/b3JkZXIgP2tleXNfZ3JlYXRlcl9vcl9lcXVhbF90byA/a2V5c19sZXNzX29yX2VxdWFsX3RvIHQgPVxuICAgIFRyZWUwLnRvX3NlcXVlbmNlIGNvbXBhcmF0b3IgP29yZGVyID9rZXlzX2dyZWF0ZXJfb3JfZXF1YWxfdG8gP2tleXNfbGVzc19vcl9lcXVhbF90byB0XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2ggfmNvbXBhcmF0b3I6XyB0IH5jb21wYXJlIGhvdyB2ID0gVHJlZTAuYmluYXJ5X3NlYXJjaCB0IH5jb21wYXJlIGhvdyB2XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIH5jb21wYXJhdG9yOl8gdCB+c2VnbWVudF9vZiBob3cgPVxuICAgIFRyZWUwLmJpbmFyeV9zZWFyY2hfc2VnbWVudGVkIHQgfnNlZ21lbnRfb2YgaG93XG4gIDs7XG5cbiAgbGV0IGJpbmFyeV9zZWFyY2hfc3VicmFuZ2UgfmNvbXBhcmF0b3IgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kID1cbiAgICBtYXRjaCBUcmVlMC5iaW5hcnlfc2VhcmNoX3R3b19zaWRlZF9ib3VuZHMgdCB+Y29tcGFyZSB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kIHdpdGhcbiAgICB8IFNvbWUgKGxvd2VyX2JvdW5kLCB1cHBlcl9ib3VuZCkgLT4gc3VicmFuZ2UgfmNvbXBhcmF0b3IgdCB+bG93ZXJfYm91bmQgfnVwcGVyX2JvdW5kXG4gICAgfCBOb25lIC0+IEVtcHR5XG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIG1hdGNoIFRyZWUwLm1hcF9rZXlzIH5jb21wYXJhdG9yIHQgfmYgd2l0aFxuICAgIHwgYE9rICh0LCBfKSAtPiBgT2sgdFxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyBkdXAgLT4gZHVwXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzX2V4biB+Y29tcGFyYXRvciB0IH5mID0gZnN0IChUcmVlMC5tYXBfa2V5c19leG4gfmNvbXBhcmF0b3IgdCB+ZilcblxuICBtb2R1bGUgQnVpbGRfaW5jcmVhc2luZyA9IHN0cnVjdFxuICAgIHR5cGUgKCdrLCAndiwgJ3cpIHQgPSAoJ2ssICd2KSBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLnRcblxuICAgIGxldCBlbXB0eSA9IFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcuZW1wdHlcblxuICAgIGxldCBhZGRfZXhuIHQgfmNvbXBhcmF0b3IgfmtleSB+ZGF0YSA9XG4gICAgICBtYXRjaCBUcmVlMC5CdWlsZF9pbmNyZWFzaW5nLm1heF9rZXkgdCB3aXRoXG4gICAgICB8IFNvbWUgcHJldl9rZXkgd2hlbiBjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSBwcmV2X2tleSBrZXkgPj0gMCAtPlxuICAgICAgICBFcnJvci5yYWlzZV9zIChTZXhwLkF0b20gXCJNYXAuQnVpbGRfaW5jcmVhc2luZy5hZGQ6IG5vbi1pbmNyZWFzaW5nIGtleVwiKVxuICAgICAgfCBfIC0+IFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcuYWRkX3VuY2hlY2tlZCB0IH5rZXkgfmRhdGFcbiAgICA7O1xuXG4gICAgbGV0IHRvX3RyZWUgdCA9IFRyZWUwLkJ1aWxkX2luY3JlYXNpbmcudG9fdHJlZV91bmNoZWNrZWQgdFxuICBlbmRcbmVuZFxuXG5tb2R1bGUgVXNpbmdfY29tcGFyYXRvciA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyAoJ2ssICd2LCAnY21wKSB0ID0gKCdrLCAndiwgJ2NtcCkgdFxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IGVtcHR5IH5jb21wYXJhdG9yID0geyB0cmVlID0gVHJlZTAuZW1wdHk7IGNvbXBhcmF0b3I7IGxlbmd0aCA9IDAgfVxuICBsZXQgc2luZ2xldG9uIH5jb21wYXJhdG9yIGsgdiA9IHsgY29tcGFyYXRvcjsgdHJlZSA9IFRyZWUwLnNpbmdsZXRvbiBrIHY7IGxlbmd0aCA9IDEgfVxuICBsZXQgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKHRyZWUsIGxlbmd0aCkgPSB7IGNvbXBhcmF0b3I7IHRyZWU7IGxlbmd0aCB9XG4gIGxldCBvZl90cmVlIH5jb21wYXJhdG9yIHRyZWUgPSBvZl90cmVlMCB+Y29tcGFyYXRvciAodHJlZSwgVHJlZTAubGVuZ3RoIHRyZWUpXG4gIGxldCB0b190cmVlID0gdG9fdHJlZVxuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIGFycmF5IH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFycmF5ID1cbiAgICBPcl9lcnJvci5tYXBcbiAgICAgIChUcmVlMC5vZl9zb3J0ZWRfYXJyYXkgYXJyYXkgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICAgICAgfmY6KGZ1biB0cmVlIC0+IG9mX3RyZWUwIH5jb21wYXJhdG9yIHRyZWUpXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0IH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBtYXRjaCBUcmVlMC5vZl9hbGlzdCBhbGlzdCB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUgd2l0aFxuICAgIHwgYE9rICh0cmVlLCBsZW5ndGgpIC0+IGBPayB7IGNvbXBhcmF0b3I7IHRyZWU7IGxlbmd0aCB9XG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIHogLT4gelxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgUmVzdWx0Lm1hcCAoVHJlZTAub2ZfYWxpc3Rfb3JfZXJyb3IgYWxpc3QgfmNvbXBhcmF0b3IpIH5mOihmdW4gdHJlZSAtPlxuICAgICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgdHJlZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yIGFsaXN0ID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAub2ZfYWxpc3RfZXhuIGFsaXN0IH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvciBhbGlzdCA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2ZfYWxpc3RfbXVsdGkgYWxpc3QgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9mb2xkIH5jb21wYXJhdG9yIGFsaXN0IH5pbml0IH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9hbGlzdF9mb2xkIGFsaXN0IH5pbml0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2ZfYWxpc3RfcmVkdWNlIH5jb21wYXJhdG9yIGFsaXN0IH5mID1cbiAgICBvZl90cmVlMFxuICAgICAgfmNvbXBhcmF0b3JcbiAgICAgIChUcmVlMC5vZl9hbGlzdF9yZWR1Y2UgYWxpc3QgfmYgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlKVxuICA7O1xuXG4gIGxldCBvZl9pdGVyaSB+Y29tcGFyYXRvciB+aXRlcmkgPVxuICAgIG1hdGNoIFRyZWUwLm9mX2l0ZXJpIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSB+aXRlcmkgd2l0aFxuICAgIHwgYE9rIHRyZWVfbGVuZ3RoIC0+IGBPayAob2ZfdHJlZTAgfmNvbXBhcmF0b3IgdHJlZV9sZW5ndGgpXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIHogLT4gelxuICA7O1xuXG4gIGxldCBvZl9pdGVyaV9leG4gfmNvbXBhcmF0b3Igfml0ZXJpID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAub2ZfaXRlcmlfZXhuIH5jb21wYXJhdG9yIH5pdGVyaSlcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmNvbXBhcmF0b3IgfmxlbiB+ZiA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYsIGxlbilcbiAgOztcblxuICBsZXQgb2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXEgPVxuICAgIE9yX2Vycm9yLm1hcFxuICAgICAgfmY6KG9mX3RyZWUwIH5jb21wYXJhdG9yKVxuICAgICAgKFRyZWUwLm9mX2luY3JlYXNpbmdfc2VxdWVuY2Ugc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBtYXRjaCBUcmVlMC5vZl9zZXF1ZW5jZSBzZXEgfmNvbXBhcmVfa2V5OmNvbXBhcmF0b3IuQ29tcGFyYXRvci5jb21wYXJlIHdpdGhcbiAgICB8IGBPayAodHJlZSwgbGVuZ3RoKSAtPiBgT2sgeyBjb21wYXJhdG9yOyB0cmVlOyBsZW5ndGggfVxuICAgIHwgYER1cGxpY2F0ZV9rZXkgXyBhcyB6IC0+IHpcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgfmNvbXBhcmF0b3Igc2VxID1cbiAgICBSZXN1bHQubWFwIChUcmVlMC5vZl9zZXF1ZW5jZV9vcl9lcnJvciBzZXEgfmNvbXBhcmF0b3IpIH5mOihmdW4gdHJlZSAtPlxuICAgICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgdHJlZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfZXhuIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgb2ZfdHJlZTAgfmNvbXBhcmF0b3IgKFRyZWUwLm9mX3NlcXVlbmNlX2V4biBzZXEgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX211bHRpIH5jb21wYXJhdG9yIHNlcSA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2Zfc2VxdWVuY2VfbXVsdGkgc2VxIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfZm9sZCB+Y29tcGFyYXRvciBzZXEgfmluaXQgfmYgPVxuICAgIG9mX3RyZWUwXG4gICAgICB+Y29tcGFyYXRvclxuICAgICAgKFRyZWUwLm9mX3NlcXVlbmNlX2ZvbGQgc2VxIH5pbml0IH5mIH5jb21wYXJlX2tleTpjb21wYXJhdG9yLkNvbXBhcmF0b3IuY29tcGFyZSlcbiAgOztcblxuICBsZXQgb2Zfc2VxdWVuY2VfcmVkdWNlIH5jb21wYXJhdG9yIHNlcSB+ZiA9XG4gICAgb2ZfdHJlZTBcbiAgICAgIH5jb21wYXJhdG9yXG4gICAgICAoVHJlZTAub2Zfc2VxdWVuY2VfcmVkdWNlIHNlcSB+ZiB+Y29tcGFyZV9rZXk6Y29tcGFyYXRvci5Db21wYXJhdG9yLmNvbXBhcmUpXG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3Iga19vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwID1cbiAgICBvZl90cmVlMCB+Y29tcGFyYXRvciAoVHJlZTAudF9vZl9zZXhwX2RpcmVjdCBrX29mX3NleHAgdl9vZl9zZXhwIHNleHAgfmNvbXBhcmF0b3IpXG4gIDs7XG5cbiAgbGV0IG1hcF9rZXlzIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIG1hdGNoIFRyZWUwLm1hcF9rZXlzIHQudHJlZSB+ZiB+Y29tcGFyYXRvciB3aXRoXG4gICAgfCBgT2sgcGFpciAtPiBgT2sgKG9mX3RyZWUwIH5jb21wYXJhdG9yIHBhaXIpXG4gICAgfCBgRHVwbGljYXRlX2tleSBfIGFzIGR1cCAtPiBkdXBcbiAgOztcblxuICBsZXQgbWFwX2tleXNfZXhuIH5jb21wYXJhdG9yIHQgfmYgPVxuICAgIG9mX3RyZWUwIH5jb21wYXJhdG9yIChUcmVlMC5tYXBfa2V5c19leG4gdC50cmVlIH5mIH5jb21wYXJhdG9yKVxuICA7O1xuXG4gIG1vZHVsZSBFbXB0eV93aXRob3V0X3ZhbHVlX3Jlc3RyaWN0aW9uIChLIDogQ29tcGFyYXRvci5TMSkgPSBzdHJ1Y3RcbiAgICBsZXQgZW1wdHkgPSB7IHRyZWUgPSBUcmVlMC5lbXB0eTsgY29tcGFyYXRvciA9IEsuY29tcGFyYXRvcjsgbGVuZ3RoID0gMCB9XG4gIGVuZFxuXG4gIG1vZHVsZSBUcmVlID0gVHJlZVxuZW5kXG5cbmluY2x1ZGUgQWNjZXNzb3JzXG5cbnR5cGUgKCdrLCAnY21wKSBjb21wYXJhdG9yID1cbiAgKG1vZHVsZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgPSAnayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSAnY21wKVxuXG5sZXQgY29tcGFyYXRvcl9zICh0eXBlIGsgY21wKSB0IDogKGssIGNtcCkgY29tcGFyYXRvciA9XG4gIChtb2R1bGUgc3RydWN0XG4gICAgdHlwZSB0ID0ga1xuICAgIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gY21wXG5cbiAgICBsZXQgY29tcGFyYXRvciA9IHQuY29tcGFyYXRvclxuICBlbmQpXG47O1xuXG5sZXQgdG9fY29tcGFyYXRvciAodHlwZSBrIGNtcCkgKChtb2R1bGUgTSkgOiAoaywgY21wKSBjb21wYXJhdG9yKSA9IE0uY29tcGFyYXRvclxuXG5sZXQgb2ZfdHJlZSAodHlwZSBrIGNtcCkgKChtb2R1bGUgTSkgOiAoaywgY21wKSBjb21wYXJhdG9yKSB0cmVlID1cbiAgb2ZfdHJlZSB+Y29tcGFyYXRvcjpNLmNvbXBhcmF0b3IgdHJlZVxuOztcblxubGV0IGVtcHR5IG0gPSBVc2luZ19jb21wYXJhdG9yLmVtcHR5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG5sZXQgc2luZ2xldG9uIG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iuc2luZ2xldG9uIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9hbGlzdCBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcblxubGV0IG9mX2FsaXN0X29yX2Vycm9yIG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3Rfb3JfZXJyb3IgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgYVxuOztcblxubGV0IG9mX2FsaXN0X2V4biBtIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X2V4biB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5sZXQgb2ZfYWxpc3RfbXVsdGkgbSBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9tdWx0aSB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG5cbmxldCBvZl9hbGlzdF9mb2xkIG0gYSB+aW5pdCB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhIH5pbml0IH5mXG47O1xuXG5sZXQgb2ZfYWxpc3RfcmVkdWNlIG0gYSB+ZiA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfcmVkdWNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGEgfmZcbjs7XG5cbmxldCBvZl9zb3J0ZWRfYXJyYXlfdW5jaGVja2VkIG0gYSA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBhXG47O1xuXG5sZXQgb2Zfc29ydGVkX2FycmF5IG0gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIGFcbmxldCBvZl9pdGVyaSBtIH5pdGVyaSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pXG5cbmxldCBvZl9pdGVyaV9leG4gbSB+aXRlcmkgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2l0ZXJpX2V4biB+aXRlcmkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcbjs7XG5cbmxldCBvZl9pbmNyZWFzaW5nX2l0ZXJhdG9yX3VuY2hlY2tlZCBtIH5sZW4gfmYgPVxuICBVc2luZ19jb21wYXJhdG9yLm9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSlcbjs7XG5cbmxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIG0gc2VxID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9pbmNyZWFzaW5nX3NlcXVlbmNlIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNlcVxuOztcblxubGV0IG9mX3NlcXVlbmNlIG0gcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuXG5sZXQgb2Zfc2VxdWVuY2Vfb3JfZXJyb3IgbSBzID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9vcl9lcnJvciB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSBzXG47O1xuXG5sZXQgb2Zfc2VxdWVuY2VfZXhuIG0gcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfZXhuIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHNcblxubGV0IG9mX3NlcXVlbmNlX211bHRpIG0gcyA9XG4gIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgc1xuOztcblxubGV0IG9mX3NlcXVlbmNlX2ZvbGQgbSBzIH5pbml0IH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9mb2xkIH5jb21wYXJhdG9yOih0b19jb21wYXJhdG9yIG0pIHMgfmluaXQgfmZcbjs7XG5cbmxldCBvZl9zZXF1ZW5jZV9yZWR1Y2UgbSBzIH5mID1cbiAgVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgcyB+ZlxuOztcblxubGV0IG1hcF9rZXlzIG0gdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXMgfmNvbXBhcmF0b3I6KHRvX2NvbXBhcmF0b3IgbSkgdCB+ZlxubGV0IG1hcF9rZXlzX2V4biBtIHQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcF9rZXlzX2V4biB+Y29tcGFyYXRvcjoodG9fY29tcGFyYXRvciBtKSB0IH5mXG5cbm1vZHVsZSBNIChLIDogc2lnXG4gICAgdHlwZSB0XG4gICAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3NcbiAgZW5kKSA9XG5zdHJ1Y3RcbiAgdHlwZSBub25yZWMgJ3YgdCA9IChLLnQsICd2LCBLLmNvbXBhcmF0b3Jfd2l0bmVzcykgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBDb21wYXJhdG9yLlMgd2l0aCB0eXBlIHQgOj0gdFxuZW5kXG5cbm1vZHVsZSB0eXBlIE1fc2V4cF9ncmFtbWFyID0gc2lnXG4gIHR5cGUgdCBbQEBkZXJpdmluZ19pbmxpbmUgc2V4cF9ncmFtbWFyXVxuXG4gIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICBbQEBAZW5kXVxuZW5kXG5cbm1vZHVsZSB0eXBlIENvbXBhcmVfbSA9IHNpZyBlbmRcbm1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG5tb2R1bGUgdHlwZSBIYXNoX2ZvbGRfbSA9IEhhc2hlci5TXG5cbmxldCBzZXhwX29mX21fX3QgKHR5cGUgaykgKG1vZHVsZSBLIDogU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gaykgc2V4cF9vZl92IHQgPVxuICBzZXhwX29mX3QgSy5zZXhwX29mX3Qgc2V4cF9vZl92IChmdW4gXyAtPiBTZXhwLkF0b20gXCJfXCIpIHRcbjs7XG5cbmxldCBtX190X29mX3NleHBcbiAgICAgICh0eXBlIGsgY21wKVxuICAgICAgKG1vZHVsZSBLIDogTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gayBhbmQgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBjbXApXG4gICAgICB2X29mX3NleHBcbiAgICAgIHNleHBcbiAgPVxuICBVc2luZ19jb21wYXJhdG9yLnRfb2Zfc2V4cF9kaXJlY3QgfmNvbXBhcmF0b3I6Sy5jb21wYXJhdG9yIEsudF9vZl9zZXhwIHZfb2Zfc2V4cCBzZXhwXG47O1xuXG5sZXQgbV9fdF9zZXhwX2dyYW1tYXJcbiAgICAgICh0eXBlIGspXG4gICAgICAobW9kdWxlIEsgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGspXG4gICAgICAodl9ncmFtbWFyIDogXyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBfIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gID1cbiAgeyB1bnR5cGVkID1cbiAgICAgIExpc3RcbiAgICAgICAgKE1hbnkgKExpc3QgKENvbnMgKEsudF9zZXhwX2dyYW1tYXIudW50eXBlZCwgQ29ucyAodl9ncmFtbWFyLnVudHlwZWQsIEVtcHR5KSkpKSlcbiAgfVxuOztcblxubGV0IGNvbXBhcmVfbV9fdCAobW9kdWxlIF8gOiBDb21wYXJlX20pIGNvbXBhcmVfdiB0MSB0MiA9IGNvbXBhcmVfZGlyZWN0IGNvbXBhcmVfdiB0MSB0MlxubGV0IGVxdWFsX21fX3QgKG1vZHVsZSBfIDogRXF1YWxfbSkgZXF1YWxfdiB0MSB0MiA9IGVxdWFsIGVxdWFsX3YgdDEgdDJcblxubGV0IGhhc2hfZm9sZF9tX190ICh0eXBlIGspIChtb2R1bGUgSyA6IEhhc2hfZm9sZF9tIHdpdGggdHlwZSB0ID0gaykgaGFzaF9mb2xkX3Ygc3RhdGUgPVxuICBoYXNoX2ZvbGRfZGlyZWN0IEsuaGFzaF9mb2xkX3QgaGFzaF9mb2xkX3Ygc3RhdGVcbjs7XG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICgnaywgJ3YpIHQgPSAoJ2ssICd2LCBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvcl93aXRuZXNzKSB0XG4gIHR5cGUgbm9ucmVjICgnaywgJ3YpIHRyZWUgPSAoJ2ssICd2KSBUcmVlMC50XG4gIHR5cGUgY29tcGFyYXRvcl93aXRuZXNzID0gQ29tcGFyYXRvci5Qb2x5LmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IGNvbXBhcmF0b3IgPSBDb21wYXJhdG9yLlBvbHkuY29tcGFyYXRvclxuICBsZXQgb2ZfdHJlZSB0cmVlID0geyB0cmVlOyBjb21wYXJhdG9yOyBsZW5ndGggPSBUcmVlMC5sZW5ndGggdHJlZSB9XG5cbiAgaW5jbHVkZSBVc2luZ19jb21wYXJhdG9yLkVtcHR5X3dpdGhvdXRfdmFsdWVfcmVzdHJpY3Rpb24gKENvbXBhcmF0b3IuUG9seSlcblxuICBsZXQgc2luZ2xldG9uIGEgPSBVc2luZ19jb21wYXJhdG9yLnNpbmdsZXRvbiB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdCBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdCB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciBhID0gVXNpbmdfY29tcGFyYXRvci5vZl9hbGlzdF9vcl9lcnJvciB+Y29tcGFyYXRvciBhXG4gIGxldCBvZl9hbGlzdF9leG4gYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfZXhuIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0X211bHRpIGEgPSBVc2luZ19jb21wYXJhdG9yLm9mX2FsaXN0X211bHRpIH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2FsaXN0X2ZvbGQgYSB+aW5pdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfZm9sZCB+Y29tcGFyYXRvciBhIH5pbml0IH5mXG4gIGxldCBvZl9hbGlzdF9yZWR1Y2UgYSB+ZiA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfYWxpc3RfcmVkdWNlIH5jb21wYXJhdG9yIGEgfmZcblxuICBsZXQgb2Zfc29ydGVkX2FycmF5X3VuY2hlY2tlZCBhID1cbiAgICBVc2luZ19jb21wYXJhdG9yLm9mX3NvcnRlZF9hcnJheV91bmNoZWNrZWQgfmNvbXBhcmF0b3IgYVxuICA7O1xuXG4gIGxldCBvZl9zb3J0ZWRfYXJyYXkgYSA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc29ydGVkX2FycmF5IH5jb21wYXJhdG9yIGFcbiAgbGV0IG9mX2l0ZXJpIH5pdGVyaSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfaXRlcmkgfml0ZXJpIH5jb21wYXJhdG9yXG4gIGxldCBvZl9pdGVyaV9leG4gfml0ZXJpID0gVXNpbmdfY29tcGFyYXRvci5vZl9pdGVyaV9leG4gfml0ZXJpIH5jb21wYXJhdG9yXG5cbiAgbGV0IG9mX2luY3JlYXNpbmdfaXRlcmF0b3JfdW5jaGVja2VkIH5sZW4gfmYgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19pdGVyYXRvcl91bmNoZWNrZWQgfmxlbiB+ZiB+Y29tcGFyYXRvclxuICA7O1xuXG4gIGxldCBvZl9pbmNyZWFzaW5nX3NlcXVlbmNlIHNlcSA9IFVzaW5nX2NvbXBhcmF0b3Iub2ZfaW5jcmVhc2luZ19zZXF1ZW5jZSB+Y29tcGFyYXRvciBzZXFcbiAgbGV0IG9mX3NlcXVlbmNlIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlIH5jb21wYXJhdG9yIHNcbiAgbGV0IG9mX3NlcXVlbmNlX29yX2Vycm9yIHMgPSBVc2luZ19jb21wYXJhdG9yLm9mX3NlcXVlbmNlX29yX2Vycm9yIH5jb21wYXJhdG9yIHNcbiAgbGV0IG9mX3NlcXVlbmNlX2V4biBzID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9leG4gfmNvbXBhcmF0b3Igc1xuICBsZXQgb2Zfc2VxdWVuY2VfbXVsdGkgcyA9IFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfbXVsdGkgfmNvbXBhcmF0b3Igc1xuXG4gIGxldCBvZl9zZXF1ZW5jZV9mb2xkIHMgfmluaXQgfmYgPVxuICAgIFVzaW5nX2NvbXBhcmF0b3Iub2Zfc2VxdWVuY2VfZm9sZCB+Y29tcGFyYXRvciBzIH5pbml0IH5mXG4gIDs7XG5cbiAgbGV0IG9mX3NlcXVlbmNlX3JlZHVjZSBzIH5mID0gVXNpbmdfY29tcGFyYXRvci5vZl9zZXF1ZW5jZV9yZWR1Y2UgfmNvbXBhcmF0b3IgcyB+ZlxuICBsZXQgbWFwX2tleXMgdCB+ZiA9IFVzaW5nX2NvbXBhcmF0b3IubWFwX2tleXMgfmNvbXBhcmF0b3IgdCB+ZlxuICBsZXQgbWFwX2tleXNfZXhuIHQgfmYgPSBVc2luZ19jb21wYXJhdG9yLm1hcF9rZXlzX2V4biB+Y29tcGFyYXRvciB0IH5mXG5lbmRcbiIsIm9wZW4hIEltcG9ydDBcblxudHlwZSAnYSB0ID0gJ2EgQ2FtbC5RdWV1ZS50XG5cbmxldCBjcmVhdGUgPSBDYW1sLlF1ZXVlLmNyZWF0ZVxubGV0IGNsZWFyID0gQ2FtbC5RdWV1ZS5jbGVhclxubGV0IGNvcHkgPSBDYW1sLlF1ZXVlLmNvcHlcbmxldCBpc19lbXB0eSA9IENhbWwuUXVldWUuaXNfZW1wdHlcbmxldCBsZW5ndGggPSBDYW1sLlF1ZXVlLmxlbmd0aFxubGV0IHBlZWsgPSBDYW1sLlF1ZXVlLnBlZWtcbmxldCBwb3AgPSBDYW1sLlF1ZXVlLnBvcFxubGV0IHB1c2ggPSBDYW1sLlF1ZXVlLnB1c2hcbmxldCB0cmFuc2ZlciA9IENhbWwuUXVldWUudHJhbnNmZXJcbmxldCBpdGVyIHQgfmYgPSBDYW1sLlF1ZXVlLml0ZXIgZiB0XG5sZXQgZm9sZCB0IH5pbml0IH5mID0gQ2FtbC5RdWV1ZS5mb2xkIGYgaW5pdCB0XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgTGlua2VkX3F1ZXVlMFxuXG5sZXQgZW5xdWV1ZSB0IHggPSBMaW5rZWRfcXVldWUwLnB1c2ggeCB0XG5sZXQgZGVxdWV1ZSB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChMaW5rZWRfcXVldWUwLnBvcCB0KVxubGV0IGRlcXVldWVfZXhuID0gTGlua2VkX3F1ZXVlMC5wb3BcbmxldCBwZWVrIHQgPSBpZiBpc19lbXB0eSB0IHRoZW4gTm9uZSBlbHNlIFNvbWUgKExpbmtlZF9xdWV1ZTAucGVlayB0KVxubGV0IHBlZWtfZXhuID0gTGlua2VkX3F1ZXVlMC5wZWVrXG5cbm1vZHVsZSBDID0gSW5kZXhlZF9jb250YWluZXIuTWFrZSAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgJ2EgdCA9ICdhIHRcblxuICAgIGxldCBmb2xkID0gZm9sZFxuICAgIGxldCBpdGVyID0gYEN1c3RvbSBpdGVyXG4gICAgbGV0IGxlbmd0aCA9IGBDdXN0b20gbGVuZ3RoXG4gICAgbGV0IGZvbGRpID0gYERlZmluZV91c2luZ19mb2xkXG4gICAgbGV0IGl0ZXJpID0gYERlZmluZV91c2luZ19mb2xkXG4gIGVuZClcblxubGV0IGNvdW50ID0gQy5jb3VudFxubGV0IGV4aXN0cyA9IEMuZXhpc3RzXG5sZXQgZmluZCA9IEMuZmluZFxubGV0IGZpbmRfbWFwID0gQy5maW5kX21hcFxubGV0IGZvbGRfcmVzdWx0ID0gQy5mb2xkX3Jlc3VsdFxubGV0IGZvbGRfdW50aWwgPSBDLmZvbGRfdW50aWxcbmxldCBmb3JfYWxsID0gQy5mb3JfYWxsXG5sZXQgbWF4X2VsdCA9IEMubWF4X2VsdFxubGV0IG1lbSA9IEMubWVtXG5sZXQgbWluX2VsdCA9IEMubWluX2VsdFxubGV0IHN1bSA9IEMuc3VtXG5sZXQgdG9fbGlzdCA9IEMudG9fbGlzdFxubGV0IGNvdW50aSA9IEMuY291bnRpXG5sZXQgZXhpc3RzaSA9IEMuZXhpc3RzaVxubGV0IGZpbmRfbWFwaSA9IEMuZmluZF9tYXBpXG5sZXQgZmluZGkgPSBDLmZpbmRpXG5sZXQgZm9sZGkgPSBDLmZvbGRpXG5sZXQgZm9yX2FsbGkgPSBDLmZvcl9hbGxpXG5sZXQgaXRlcmkgPSBDLml0ZXJpXG5sZXQgdHJhbnNmZXIgfnNyYyB+ZHN0ID0gTGlua2VkX3F1ZXVlMC50cmFuc2ZlciBzcmMgZHN0XG5cbmxldCBjb25jYXRfbWFwIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gTGlzdC5pdGVyIChmIGEpIH5mOihmdW4gYiAtPiBlbnF1ZXVlIHJlcyBiKSk7XG4gIHJlc1xuOztcblxubGV0IGNvbmNhdF9tYXBpIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biBpIGEgLT4gTGlzdC5pdGVyIChmIGkgYSkgfmY6KGZ1biBiIC0+IGVucXVldWUgcmVzIGIpKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyX21hcCB0IH5mID1cbiAgbGV0IHJlcyA9IGNyZWF0ZSAoKSBpblxuICBpdGVyIHQgfmY6KGZ1biBhIC0+XG4gICAgbWF0Y2ggZiBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHJlcyBiKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPlxuICAgIG1hdGNoIGYgaSBhIHdpdGhcbiAgICB8IE5vbmUgLT4gKClcbiAgICB8IFNvbWUgYiAtPiBlbnF1ZXVlIHJlcyBiKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyIHQgfmYgPVxuICBsZXQgcmVzID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gZW5xdWV1ZSByZXMgYSk7XG4gIHJlc1xuOztcblxubGV0IGZpbHRlcmkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBpZiBmIGkgYSB0aGVuIGVucXVldWUgcmVzIGEpO1xuICByZXNcbjs7XG5cbmxldCBtYXAgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlciB0IH5mOihmdW4gYSAtPiBlbnF1ZXVlIHJlcyAoZiBhKSk7XG4gIHJlc1xuOztcblxubGV0IG1hcGkgdCB+ZiA9XG4gIGxldCByZXMgPSBjcmVhdGUgKCkgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIGkgYSAtPiBlbnF1ZXVlIHJlcyAoZiBpIGEpKTtcbiAgcmVzXG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgcSB+ZiA9XG4gIGxldCBxJyA9IGZpbHRlciBxIH5mIGluXG4gIGNsZWFyIHE7XG4gIHRyYW5zZmVyIH5zcmM6cScgfmRzdDpxXG47O1xuXG5sZXQgZmlsdGVyaV9pbnBsYWNlIHEgfmYgPVxuICBsZXQgcScgPSBmaWx0ZXJpIHEgfmYgaW5cbiAgY2xlYXIgcTtcbiAgdHJhbnNmZXIgfnNyYzpxJyB+ZHN0OnFcbjs7XG5cbmxldCBlbnF1ZXVlX2FsbCB0IGxpc3QgPSBMaXN0Lml0ZXIgbGlzdCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpXG5cbmxldCBvZl9saXN0IGxpc3QgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBMaXN0Lml0ZXIgbGlzdCB+ZjooZnVuIHggLT4gZW5xdWV1ZSB0IHgpO1xuICB0XG47O1xuXG5sZXQgb2ZfYXJyYXkgYXJyYXkgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBBcnJheS5pdGVyIGFycmF5IH5mOihmdW4geCAtPiBlbnF1ZXVlIHQgeCk7XG4gIHRcbjs7XG5cbmxldCBpbml0IGxlbiB+ZiA9XG4gIGxldCB0ID0gY3JlYXRlICgpIGluXG4gIGZvciBpID0gMCB0byBsZW4gLSAxIGRvXG4gICAgZW5xdWV1ZSB0IChmIGkpXG4gIGRvbmU7XG4gIHRcbjs7XG5cbmxldCB0b19hcnJheSB0ID1cbiAgbWF0Y2ggbGVuZ3RoIHQgd2l0aFxuICB8IDAgLT4gW3x8XVxuICB8IGxlbiAtPlxuICAgIGxldCBhcnIgPSBBcnJheS5jcmVhdGUgfmxlbiAocGVla19leG4gdCkgaW5cbiAgICBsZXQgaSA9IHJlZiAwIGluXG4gICAgaXRlciB0IH5mOihmdW4gdiAtPlxuICAgICAgYXJyLighaSkgPC0gdjtcbiAgICAgIGluY3IgaSk7XG4gICAgYXJyXG47O1xuXG5sZXQgdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwID0gb2ZfbGlzdCAobGlzdF9vZl9zZXhwIGFfb2Zfc2V4cCBzZXhwKVxubGV0IHNleHBfb2ZfdCBzZXhwX29mX2EgdCA9IHNleHBfb2ZfbGlzdCBzZXhwX29mX2EgKHRvX2xpc3QgdClcblxubGV0IHRfc2V4cF9ncmFtbWFyICh0eXBlIGEpIChncmFtbWFyIDogYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgOiBhIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG47O1xuXG5sZXQgc2luZ2xldG9uIGEgPVxuICBsZXQgdCA9IGNyZWF0ZSAoKSBpblxuICBlbnF1ZXVlIHQgYTtcbiAgdFxuOztcbiIsIm9wZW4hIEltcG9ydFxub3BlbiEgQ2FtbC5JbnQ2NFxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQ2NCBbQEBkZXJpdmluZ19pbmxpbmUgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICBoYXNoX2ZvbGRfaW50NjRcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2ludDY0IGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHRfb2Zfc2V4cCA9IChpbnQ2NF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoc2V4cF9vZl9pbnQ2NCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBpbnQ2NF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIGxldCBoYXNoYWJsZSA6IHQgSGFzaGFibGUudCA9IHsgaGFzaDsgY29tcGFyZTsgc2V4cF9vZl90IH1cblxuICBsZXQgY29tcGFyZSA9IEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5jb21wYXJlXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmxldCBudW1fYml0cyA9IDY0XG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF9vZl9iaXRzID0gZmxvYXRfb2ZfYml0c1xubGV0IGJpdHNfb2ZfZmxvYXQgPSBiaXRzX29mX2Zsb2F0XG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gbG9nbm90XG5sZXQgYml0X3hvciA9IGxvZ3hvclxubGV0IGJpdF9vciA9IGxvZ29yXG5sZXQgYml0X2FuZCA9IGxvZ2FuZFxubGV0IG1pbl92YWx1ZSA9IG1pbl9pbnRcbmxldCBtYXhfdmFsdWUgPSBtYXhfaW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHBvdyA9IEludF9tYXRoLlByaXZhdGUuaW50NjRfcG93XG5sZXQgcmVtID0gcmVtXG5sZXQgbmVnID0gbmVnXG5sZXQgbWludXNfb25lID0gbWludXNfb25lXG5sZXQgb25lID0gb25lXG5sZXQgemVybyA9IHplcm9cbmxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gQ2FtbC5JbnQ2NC5vZl9mbG9hdFxuXG5sZXQgb2ZfZmxvYXQgZiA9XG4gIGlmIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID49ICkgZiBmbG9hdF9sb3dlcl9ib3VuZFxuICAmJiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIGYgZmxvYXRfdXBwZXJfYm91bmRcbiAgdGhlbiBDYW1sLkludDY0Lm9mX2Zsb2F0IGZcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiSW50NjQub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCBmKVxuICAgICAgKClcbjs7XG5cbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxuXG5leHRlcm5hbCBic3dhcDY0IDogdCAtPiB0ID0gXCIlYnN3YXBfaW50NjRcIlxuXG5sZXRbQGlubGluZSBhbHdheXNdIGJzd2FwMTYgeCA9IENhbWwuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXA2NCB4KSA0OFxuXG5sZXRbQGlubGluZSBhbHdheXNdIGJzd2FwMzIgeCA9XG4gICgqIFRoaXMgaXMgc3RyaWN0bHkgYmV0dGVyIHRoYW4gY29lcmNpbmcgdG8gYW4gaW50MzIgdG8gcGVyZm9ybSBieXRlc3dhcC4gQ29lcmNpbmdcbiAgICAgZnJvbSBhbiBpbnQzMiB3aWxsIGFkZCB1bm5lY2Vzc2FyeSBzaGlmdCBvcGVyYXRpb25zIHRvIHNpZ24gZXh0ZW5kIHRoZSBudW1iZXJcbiAgICAgYXBwcm9wcmlhdGVseS5cbiAgKilcbiAgQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodF9sb2dpY2FsIChic3dhcDY0IHgpIDMyXG47O1xuXG5sZXRbQGlubGluZSBhbHdheXNdIGJzd2FwNDggeCA9IENhbWwuSW50NjQuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXA2NCB4KSAxNlxuXG5pbmNsdWRlIENvbXBhcmFibGUuV2l0aF96ZXJvIChzdHJ1Y3RcbiAgICBpbmNsdWRlIFRcblxuICAgIGxldCB6ZXJvID0gemVyb1xuICBlbmQpXG5cbigqIE9wZW4gcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGFmdGVyIGluY2x1ZGluZyBmdW5jdG9yIGluc3RhbnRpYXRpb25zIHNvIHRoZXkgZG8gbm90XG4gICBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb25cbiAgIGZ1bmN0aW9ucyBhcmUgYXZhaWxhYmxlIHdpdGhpbiB0aGlzIG1vZHVsZS4gKilcbm9wZW4gSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG5cbmxldCBpbnZhcmlhbnQgKF8gOiB0KSA9ICgpXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgaW5jciByID0gciA6PSBhZGQgIXIgb25lXG5sZXQgZGVjciByID0gciA6PSBzdWIgIXIgb25lXG5cbmV4dGVybmFsIG9mX2ludDY0IDogdCAtPiB0ID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgb2ZfaW50NjRfZXhuID0gb2ZfaW50NjRcbmxldCB0b19pbnQ2NCB0ID0gdFxubGV0IHBvcGNvdW50ID0gUG9wY291bnQuaW50NjRfcG9wY291bnRcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcblxuZXh0ZXJuYWwgdG9faW50X3RydW5jIDogdCAtPiBpbnQgPSBcIiVpbnQ2NF90b19pbnRcIlxuZXh0ZXJuYWwgdG9faW50MzJfdHJ1bmMgOiBpbnQ2NCAtPiBpbnQzMiA9IFwiJWludDY0X3RvX2ludDMyXCJcbmV4dGVybmFsIHRvX25hdGl2ZWludF90cnVuYyA6IGludDY0IC0+IG5hdGl2ZWludCA9IFwiJWludDY0X3RvX25hdGl2ZWludFwiXG5leHRlcm5hbCBvZl9pbnQgOiBpbnQgLT4gaW50NjQgPSBcIiVpbnQ2NF9vZl9pbnRcIlxuZXh0ZXJuYWwgb2ZfaW50MzIgOiBpbnQzMiAtPiBpbnQ2NCA9IFwiJWludDY0X29mX2ludDMyXCJcblxubGV0IG9mX2ludF9leG4gPSBvZl9pbnRcbmxldCB0b19pbnQgPSBDb252LmludDY0X3RvX2ludFxubGV0IHRvX2ludF9leG4gPSBDb252LmludDY0X3RvX2ludF9leG5cbmxldCBvZl9pbnQzMl9leG4gPSBvZl9pbnQzMlxubGV0IHRvX2ludDMyID0gQ29udi5pbnQ2NF90b19pbnQzMlxubGV0IHRvX2ludDMyX2V4biA9IENvbnYuaW50NjRfdG9faW50MzJfZXhuXG5sZXQgb2ZfbmF0aXZlaW50ID0gQ29udi5uYXRpdmVpbnRfdG9faW50NjRcbmxldCBvZl9uYXRpdmVpbnRfZXhuID0gb2ZfbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRcbmxldCB0b19uYXRpdmVpbnRfZXhuID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfZXhuXG5cbm1vZHVsZSBQb3cyID0gc3RydWN0XG4gIG9wZW4hIEltcG9ydFxuICBvcGVuIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCByYWlzZV9zID0gRXJyb3IucmFpc2Vfc1xuXG4gIGxldCBub25fcG9zaXRpdmVfYXJndW1lbnQgKCkgPVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2YgXCJhcmd1bWVudCBtdXN0IGJlIHN0cmljdGx5IHBvc2l0aXZlXCIgKClcbiAgOztcblxuICBsZXQgKCBsb3IgKSA9IENhbWwuSW50NjQubG9nb3JcbiAgbGV0ICggbHNyICkgPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbiAgbGV0ICggbGFuZCApID0gQ2FtbC5JbnQ2NC5sb2dhbmRcblxuICAoKiogXCJjZWlsaW5nIHBvd2VyIG9mIDJcIiAtIExlYXN0IHBvd2VyIG9mIDIgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBjZWlsX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBDYW1sLkludDY0Lnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgbGV0IHggPSBDYW1sLkludDY0LnByZWQgeCBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgQ2FtbC5JbnQ2NC5zdWNjIHhcbiAgOztcblxuICAoKiogXCJmbG9vciBwb3dlciBvZiAyXCIgLSBMYXJnZXN0IHBvd2VyIG9mIDIgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHguICopXG4gIGxldCBmbG9vcl9wb3cyIHggPVxuICAgIGlmIHggPD0gQ2FtbC5JbnQ2NC56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDEpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMikgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA0KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDgpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMTYpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgMzIpIGluXG4gICAgQ2FtbC5JbnQ2NC5zdWIgeCAoeCBsc3IgMSlcbiAgOztcblxuICBsZXQgaXNfcG93MiB4ID1cbiAgICBpZiB4IDw9IENhbWwuSW50NjQuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICB4IGxhbmQgQ2FtbC5JbnQ2NC5wcmVkIHggPSBDYW1sLkludDY0Lnplcm9cbiAgOztcblxuICAoKiBDIHN0dWJzIGZvciBpbnQgY2x6IGFuZCBjdHogdG8gdXNlIHRoZSBDTFovQlNSL0NUWi9CU0YgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbiAgZXh0ZXJuYWwgY2x6XG4gICAgOiAgKGludDY0W0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50NjRfY2x6XCIgXCJCYXNlX2ludF9tYXRoX2ludDY0X2Nsel91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAoaW50NjRbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQ2NF9jdHpcIiBcIkJhc2VfaW50X21hdGhfaW50NjRfY3R6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgaSA8PSBDYW1sLkludDY0Lnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJbSW50NjQuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50NjQgaSBdKTtcbiAgICBudW1fYml0cyAtIDEgLSBjbHogaVxuICA7O1xuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBQb2x5LiggPD0gKSBpIENhbWwuSW50NjQuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQ2NC5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDY0IGkgXSk7XG4gICAgaWYgQ2FtbC5JbnQ2NC5lcXVhbCBpIENhbWwuSW50NjQub25lIHRoZW4gMCBlbHNlIG51bV9iaXRzIC0gY2x6IChDYW1sLkludDY0LnByZWQgaSlcbiAgOztcbmVuZFxuXG5pbmNsdWRlIFBvdzJcbmluY2x1ZGUgQ29udi5NYWtlIChUKVxuXG5pbmNsdWRlIENvbnYuTWFrZV9oZXggKHN0cnVjdFxuICAgIHR5cGUgdCA9IGludDY0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoXVxuXG4gICAgbGV0IGNvbXBhcmUgPSAoY29tcGFyZV9pbnQ2NCA6IHQgLT4gdCAtPiBpbnQpXG5cbiAgICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgICBoYXNoX2ZvbGRfaW50NjRcblxuICAgIGFuZCAoaGFzaCA6IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICAgIGxldCBmdW5jID0gaGFzaF9pbnQ2NCBpblxuICAgICAgZnVuIHggLT4gZnVuYyB4XG4gICAgOztcblxuICAgIFtAQEBlbmRdXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgICBsZXQgbmVnID0gbmVnXG4gICAgbGV0ICggPCApID0gKCA8IClcbiAgICBsZXQgdG9fc3RyaW5nIGkgPSBQcmludGYuc3ByaW50ZiBcIiVMeFwiIGlcbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBDYW1sLlNjYW5mLnNzY2FuZiBzIFwiJUx4XCIgRm4uaWRcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50NjQuSGV4XCJcbiAgZW5kKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5JbnQ2NFwiXG4gIGVuZClcblxubW9kdWxlIFByZV9PID0gc3RydWN0XG4gIGV4dGVybmFsICggKyApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF9hZGRcIlxuICBleHRlcm5hbCAoIC0gKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfc3ViXCJcbiAgZXh0ZXJuYWwgKCAqICkgOiB0IC0+IHQgLT4gdCA9IFwiJWludDY0X211bFwiXG4gIGV4dGVybmFsICggLyApIDogdCAtPiB0IC0+IHQgPSBcIiVpbnQ2NF9kaXZcIlxuICBleHRlcm5hbCAoIH4tICkgOiB0IC0+IHQgPSBcIiVpbnQ2NF9uZWdcIlxuXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gIGxldCBhYnMgPSBhYnNcblxuICBleHRlcm5hbCBuZWcgOiB0IC0+IHQgPSBcIiVpbnQ2NF9uZWdcIlxuXG4gIGxldCB6ZXJvID0gemVyb1xuICBsZXQgb2ZfaW50X2V4biA9IG9mX2ludF9leG5cbmVuZFxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBpbmNsdWRlIFByZV9PXG5cbiAgaW5jbHVkZSBJbnRfbWF0aC5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgbm9ucmVjIHQgPSB0XG5cbiAgICAgIGluY2x1ZGUgUHJlX09cblxuICAgICAgbGV0IHJlbSA9IHJlbVxuICAgICAgbGV0IHRvX2Zsb2F0ID0gdG9fZmxvYXRcbiAgICAgIGxldCBvZl9mbG9hdCA9IG9mX2Zsb2F0XG4gICAgICBsZXQgb2Zfc3RyaW5nID0gVC5vZl9zdHJpbmdcbiAgICAgIGxldCB0b19zdHJpbmcgPSBULnRvX3N0cmluZ1xuICAgIGVuZClcblxuICBleHRlcm5hbCAoIGxhbmQgKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfYW5kXCJcbiAgZXh0ZXJuYWwgKCBsb3IgKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfb3JcIlxuICBleHRlcm5hbCAoIGx4b3IgKSA6IHQgLT4gdCAtPiB0ID0gXCIlaW50NjRfeG9yXCJcblxuICBsZXQgbG5vdCA9IGJpdF9ub3RcblxuICBleHRlcm5hbCAoIGxzbCApIDogdCAtPiBpbnQgLT4gdCA9IFwiJWludDY0X2xzbFwiXG4gIGV4dGVybmFsICggYXNyICkgOiB0IC0+IGludCAtPiB0ID0gXCIlaW50NjRfYXNyXCJcbiAgZXh0ZXJuYWwgKCBsc3IgKSA6IHQgLT4gaW50IC0+IHQgPSBcIiVpbnQ2NF9sc3JcIlxuZW5kXG5cbmluY2x1ZGUgT1xuXG4oKiBbSW50NjRdIGFuZCBbSW50NjQuT10gYWdyZWUgdmFsdWUtd2lzZSAqKVxuXG4oKiBJbmNsdWRlIHR5cGUtc3BlY2lmaWMgW1JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZV0gYXQgdGhlIGVuZCwgYWZ0ZXJcbiAgIGluY2x1ZGluZyBmdW5jdG9yIGFwcGxpY2F0aW9uIHRoYXQgY291bGQgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpc1xuICAgaGVyZSBzbyB0aGF0IGVmZmljaWVudCB2ZXJzaW9ucyBvZiB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkIGJ5XG4gICB0aGlzIG1vZHVsZS4gKilcbmluY2x1ZGUgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCIoKiBBIDYzYml0IGludGVnZXIgaXMgYSA2NGJpdCBpbnRlZ2VyIHdpdGggaXRzIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdFxuICAgYW5kIGl0cyBsb3dlc3QgYml0IHNldCB0byAwLlxuICAgVGhpcyBpcyB0aGUgc2FtZSBraW5kIG9mIGVuY29kaW5nIGFzIE9DYW1sIGludCBvbiA2NGJpdCBhcmNoaXRlY3R1cmUuXG4gICBUaGUgb25seSBkaWZmZXJlbmNlIGJlaW5nIHRoZSBsb3dlc3QgYml0IChpbW1lZGlhdGUgYml0KSBzZXQgdG8gMS4gKilcblxub3BlbiEgSW1wb3J0XG5pbmNsdWRlIEludDY0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5cbm1vZHVsZSBUMCA9IHN0cnVjdFxuICBtb2R1bGUgVCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IGludDY0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2ludDY0IDogdCAtPiB0IC0+IGludClcblxuICAgIGxldCAoaGFzaF9mb2xkX3QgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpID1cbiAgICAgIGhhc2hfZm9sZF9pbnQ2NFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBoYXNoX2ludDY0IGluXG4gICAgICBmdW4geCAtPiBmdW5jIHhcbiAgICA7O1xuXG4gICAgbGV0IHRfb2Zfc2V4cCA9IChpbnQ2NF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gICAgbGV0IHNleHBfb2ZfdCA9IChzZXhwX29mX2ludDY0IDogdCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gICAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50NjRfc2V4cF9ncmFtbWFyXG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuICBlbmRcblxuICBpbmNsdWRlIFRcbiAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5lbmRcblxubW9kdWxlIENvbnYgPSBJbnRfY29udmVyc2lvbnNcblxubW9kdWxlIFcgOiBzaWdcblxuICBpbmNsdWRlIG1vZHVsZSB0eXBlIG9mIHN0cnVjdFxuICAgIGluY2x1ZGUgVDBcbiAgZW5kXG5cbiAgdHlwZSB0ID0gaW50NjRcblxuICB2YWwgd3JhcF9leG4gOiBDYW1sLkludDY0LnQgLT4gdFxuICB2YWwgd3JhcF9tb2R1bG8gOiBDYW1sLkludDY0LnQgLT4gdFxuICB2YWwgdW53cmFwIDogdCAtPiBDYW1sLkludDY0LnRcblxuICAoKiogUmV0dXJucyBhIG5vbi1uZWdhdGl2ZSBpbnQ2NCB0aGF0IGlzIGVxdWFsIHRvIHRoZSBpbnB1dCBpbnQ2MyBtb2R1bG8gMl42My4gKilcbiAgdmFsIHVud3JhcF91bnNpZ25lZCA6IHQgLT4gQ2FtbC5JbnQ2NC50XG5cbiAgdmFsIGludmFyaWFudCA6IHQgLT4gdW5pdFxuICB2YWwgYWRkIDogdCAtPiB0IC0+IHRcbiAgdmFsIHN1YiA6IHQgLT4gdCAtPiB0XG4gIHZhbCBuZWcgOiB0IC0+IHRcbiAgdmFsIGFicyA6IHQgLT4gdFxuICB2YWwgc3VjYyA6IHQgLT4gdFxuICB2YWwgcHJlZCA6IHQgLT4gdFxuICB2YWwgbXVsIDogdCAtPiB0IC0+IHRcbiAgdmFsIHBvdyA6IHQgLT4gdCAtPiB0XG4gIHZhbCBkaXYgOiB0IC0+IHQgLT4gdFxuICB2YWwgcmVtIDogdCAtPiB0IC0+IHRcbiAgdmFsIHBvcGNvdW50IDogdCAtPiBpbnRcbiAgdmFsIGJpdF9ub3QgOiB0IC0+IHRcbiAgdmFsIGJpdF94b3IgOiB0IC0+IHQgLT4gdFxuICB2YWwgYml0X29yIDogdCAtPiB0IC0+IHRcbiAgdmFsIGJpdF9hbmQgOiB0IC0+IHQgLT4gdFxuICB2YWwgc2hpZnRfbGVmdCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIHNoaWZ0X3JpZ2h0IDogdCAtPiBpbnQgLT4gdFxuICB2YWwgc2hpZnRfcmlnaHRfbG9naWNhbCA6IHQgLT4gaW50IC0+IHRcbiAgdmFsIG1pbl92YWx1ZSA6IHRcbiAgdmFsIG1heF92YWx1ZSA6IHRcbiAgdmFsIHRvX2ludDY0IDogdCAtPiBDYW1sLkludDY0LnRcbiAgdmFsIG9mX2ludDY0IDogQ2FtbC5JbnQ2NC50IC0+IHQgb3B0aW9uXG4gIHZhbCBvZl9pbnQ2NF9leG4gOiBDYW1sLkludDY0LnQgLT4gdFxuICB2YWwgb2ZfaW50NjRfdHJ1bmMgOiBDYW1sLkludDY0LnQgLT4gdFxuICB2YWwgY29tcGFyZSA6IHQgLT4gdCAtPiBpbnRcbiAgdmFsIGNlaWxfcG93MiA6IHQgLT4gdFxuICB2YWwgZmxvb3JfcG93MiA6IHQgLT4gdFxuICB2YWwgY2VpbF9sb2cyIDogdCAtPiBpbnRcbiAgdmFsIGZsb29yX2xvZzIgOiB0IC0+IGludFxuICB2YWwgaXNfcG93MiA6IHQgLT4gYm9vbFxuICB2YWwgY2x6IDogdCAtPiBpbnRcbiAgdmFsIGN0eiA6IHQgLT4gaW50XG5lbmQgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBUMFxuXG4gIHR5cGUgdCA9IGludDY0XG5cbiAgbGV0IHdyYXBfZXhuIHggPVxuICAgICgqIFJhaXNlcyBpZiB0aGUgaW50NjQgdmFsdWUgZG9lcyBub3QgZml0IG9uIGludDYzLiAqKVxuICAgIENvbnYuaW50NjRfZml0X29uX2ludDYzX2V4biB4O1xuICAgIENhbWwuSW50NjQubXVsIHggMkxcbiAgOztcblxuICBsZXQgd3JhcCB4ID1cbiAgICBpZiBDb252LmludDY0X2lzX3JlcHJlc2VudGFibGVfYXNfaW50NjMgeCB0aGVuIFNvbWUgKENhbWwuSW50NjQubXVsIHggMkwpIGVsc2UgTm9uZVxuICA7O1xuXG4gIGxldCB3cmFwX21vZHVsbyB4ID0gQ2FtbC5JbnQ2NC5tdWwgeCAyTFxuICBsZXQgdW53cmFwIHggPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IHggMVxuICBsZXQgdW53cmFwX3Vuc2lnbmVkIHggPSBDYW1sLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCAxXG5cbiAgKCogVGhpcyBkb2VzIG5vdCB1c2Ugd3JhcCBvciB1bndyYXAgdG8gYXZvaWQgZ2VuZXJhdGluZyBleGNlcHRpb25zIGluIHRoZSBjYXNlIG9mXG4gICAgIG92ZXJmbG93cy4gVGhpcyBpcyB0byBwcmVzZXJ2ZSB0aGUgc2VtYW50aWNzIG9mIGludCB0eXBlIG9uIDY0IGJpdCBhcmNoaXRlY3R1cmUuICopXG4gIGxldCBmMiBmIGEgYiA9XG4gICAgQ2FtbC5JbnQ2NC5tdWwgKGYgKENhbWwuSW50NjQuc2hpZnRfcmlnaHQgYSAxKSAoQ2FtbC5JbnQ2NC5zaGlmdF9yaWdodCBiIDEpKSAyTFxuICA7O1xuXG4gIGxldCBtYXNrID0gMHhmZmZmX2ZmZmZfZmZmZl9mZmZlTFxuICBsZXQgbSB4ID0gQ2FtbC5JbnQ2NC5sb2dhbmQgeCBtYXNrXG4gIGxldCBpbnZhcmlhbnQgdCA9IGFzc2VydCAobSB0ID0gdClcbiAgbGV0IGFkZCB4IHkgPSBDYW1sLkludDY0LmFkZCB4IHlcbiAgbGV0IHN1YiB4IHkgPSBDYW1sLkludDY0LnN1YiB4IHlcbiAgbGV0IG5lZyB4ID0gQ2FtbC5JbnQ2NC5uZWcgeFxuICBsZXQgYWJzIHggPSBDYW1sLkludDY0LmFicyB4XG4gIGxldCBvbmUgPSB3cmFwX2V4biAxTFxuICBsZXQgc3VjYyBhID0gYWRkIGEgb25lXG4gIGxldCBwcmVkIGEgPSBzdWIgYSBvbmVcbiAgbGV0IG1pbl92YWx1ZSA9IG0gQ2FtbC5JbnQ2NC5taW5faW50XG4gIGxldCBtYXhfdmFsdWUgPSBtIENhbWwuSW50NjQubWF4X2ludFxuICBsZXQgYml0X25vdCB4ID0gbSAoQ2FtbC5JbnQ2NC5sb2dub3QgeClcbiAgbGV0IGJpdF9hbmQgPSBDYW1sLkludDY0LmxvZ2FuZFxuICBsZXQgYml0X3hvciA9IENhbWwuSW50NjQubG9neG9yXG4gIGxldCBiaXRfb3IgPSBDYW1sLkludDY0LmxvZ29yXG4gIGxldCBzaGlmdF9sZWZ0IHggaSA9IENhbWwuSW50NjQuc2hpZnRfbGVmdCB4IGlcbiAgbGV0IHNoaWZ0X3JpZ2h0IHggaSA9IG0gKENhbWwuSW50NjQuc2hpZnRfcmlnaHQgeCBpKVxuICBsZXQgc2hpZnRfcmlnaHRfbG9naWNhbCB4IGkgPSBtIChDYW1sLkludDY0LnNoaWZ0X3JpZ2h0X2xvZ2ljYWwgeCBpKVxuICBsZXQgcG93ID0gZjIgSW50X21hdGguUHJpdmF0ZS5pbnQ2M19wb3dfb25faW50NjRcbiAgbGV0IG11bCBhIGIgPSBDYW1sLkludDY0Lm11bCBhIChDYW1sLkludDY0LnNoaWZ0X3JpZ2h0IGIgMSlcbiAgbGV0IGRpdiBhIGIgPSB3cmFwX21vZHVsbyAoQ2FtbC5JbnQ2NC5kaXYgYSBiKVxuICBsZXQgcmVtIGEgYiA9IENhbWwuSW50NjQucmVtIGEgYlxuICBsZXQgcG9wY291bnQgeCA9IFBvcGNvdW50LmludDY0X3BvcGNvdW50IHhcbiAgbGV0IHRvX2ludDY0IHQgPSB1bndyYXAgdFxuICBsZXQgb2ZfaW50NjQgdCA9IHdyYXAgdFxuICBsZXQgb2ZfaW50NjRfZXhuIHQgPSB3cmFwX2V4biB0XG4gIGxldCBvZl9pbnQ2NF90cnVuYyB0ID0gd3JhcF9tb2R1bG8gdFxuICBsZXQgdF9vZl9zZXhwIHggPSB3cmFwX2V4biAoaW50NjRfb2Zfc2V4cCB4KVxuICBsZXQgc2V4cF9vZl90IHggPSBzZXhwX29mX2ludDY0ICh1bndyYXAgeClcbiAgbGV0IGNvbXBhcmUgKHggOiB0KSB5ID0gY29tcGFyZSB4IHlcbiAgbGV0IGlzX3BvdzIgeCA9IEludDY0LmlzX3BvdzIgKHVud3JhcCB4KVxuXG4gIGxldCBjbHogeCA9XG4gICAgKCogV2UgcnVuIEludDY0LmNseiBkaXJlY3RseSBvbiB0aGUgd3JhcHBlZCBpbnQ2MyB2YWx1ZS4gVGhpcyBpcyBjb3JyZWN0IGJlY2F1c2UgdGhlXG4gICAgICAgYml0cyBvZiB0aGUgaW50NjNfZW11bCBhcmUgbGVmdC1hbGlnbmVkIGluIHRoZSBJbnQ2NC4gKilcbiAgICBJbnQ2NC5jbHogeFxuICA7O1xuXG4gIGxldCBjdHogeCA9IEludDY0LmN0eiAodW53cmFwIHgpXG4gIGxldCBmbG9vcl9wb3cyIHggPSBJbnQ2NC5mbG9vcl9wb3cyICh1bndyYXAgeCkgfD4gd3JhcF9leG5cbiAgbGV0IGNlaWxfcG93MiB4ID0gSW50NjQuZmxvb3JfcG93MiAodW53cmFwIHgpIHw+IHdyYXBfZXhuXG4gIGxldCBmbG9vcl9sb2cyIHggPSBJbnQ2NC5mbG9vcl9sb2cyICh1bndyYXAgeClcbiAgbGV0IGNlaWxfbG9nMiB4ID0gSW50NjQuY2VpbF9sb2cyICh1bndyYXAgeClcbmVuZFxuXG5vcGVuIFdcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gVy50IFtAQGRlcml2aW5nX2lubGluZSBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIFcuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBXLmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKFcudF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHQpXG4gIGxldCBzZXhwX29mX3QgPSAoVy5zZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gVy50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSBjb21wYXJhdG9yX3dpdG5lc3MgPSBXLmNvbXBhcmF0b3Jfd2l0bmVzc1xuXG4gIGxldCBjb21wYXJhdG9yID0gVy5jb21wYXJhdG9yXG4gIGxldCBjb21wYXJlID0gVy5jb21wYXJlXG4gIGxldCBpbnZhcmlhbnQgPSBXLmludmFyaWFudFxuXG4gICgqIFdlIGRvbid0IGV4cGVjdCBbaGFzaF0gdG8gZm9sbG93IHRoZSBiZWhhdmlvciBvZiBpbnQgaW4gNjRiaXQgYXJjaGl0ZWN0dXJlICopXG4gIGxldCBfID0gaGFzaFxuICBsZXQgaGFzaCAoeCA6IHQpID0gQ2FtbC5IYXNodGJsLmhhc2ggeFxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBpbnZhbGlkX3N0ciB4ID0gUHJpbnRmLmZhaWx3aXRoZiBcIkludDYzLm9mX3N0cmluZzogaW52YWxpZCBpbnB1dCAlU1wiIHggKClcblxuICAoKlxuICAgICBcInNpZ25cIiByZWZlcnMgdG8gd2hldGhlciB0aGUgbnVtYmVyIHN0YXJ0cyB3aXRoIGEgJy0nXG4gICAgIFwic2lnbmVkbmVzcyA9IGZhbHNlXCIgbWVhbnMgdGhlIHJlc3Qgb2YgdGhlIG51bWJlciBpcyBwYXJzZWQgYXMgdW5zaWduZWQgYW5kIHRoZW4gY2FzdFxuICAgICB0byBzaWduZWQgd2l0aCB3cmFwLWFyb3VuZCBtb2R1bG8gMl5pXG4gICAgIFwic2lnbmVkbmVzcyA9IHRydWVcIiBtZWFucyBubyBzdWNoIGNyYXppbmVzcyBoYXBwZW5zXG5cbiAgICAgVGhlIHRlcm1pbm9sb2d5IGFuZCB0aGUgbG9naWMgaXMgZHVlIHRvIHRoZSBjb2RlIGluIGJ5dGVydW4vaW50cy5jIGluIG9jYW1sIDQuMDNcbiAgICAgKFtwYXJzZV9zaWduX2FuZF9iYXNlXSBmdW5jdGlvbikuXG5cbiAgICAgU2lnbmVkbmVzcyBlcXVhbHMgdHJ1ZSBmb3IgcGxhaW4gZGVjaW1hbCBudW1iZXIgKGUuZy4gMTIzNSwgLTY3ODkpXG5cbiAgICAgU2lnbmVkbmVzcyBlcXVhbHMgZmFsc2UgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgLSBbMHhmZmZmXSwgWy0weGZmZmZdIChoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbilcbiAgICAgLSBbMGIwMTAxXSwgWy0wYjAxMDFdIChiaW5hcnkgcmVwcmVzZW50YXRpb24pXG4gICAgIC0gWzBvMTIzN10sIFstMG8xMjM3XSAob2N0YWwgcmVwcmVzZW50YXRpb24pXG4gICAgIC0gWzB1OTgxMl0sIFstMHU5ODEyXSAodW5zaWduZWQgZGVjaW1hbCByZXByZXNlbnRhdGlvbiAtIGF2YWlsYWJsZSBmcm9tIE9DYW1sIDQuMDMpICopXG4gIGxldCBzaWduX2FuZF9zaWduZWRuZXNzIHggPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHggaW5cbiAgICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgbGV0IHBvcywgc2lnbiA9XG4gICAgICBpZiAwIDwgbGVuXG4gICAgICB0aGVuIChcbiAgICAgICAgbWF0Y2ggeC5bMF0gd2l0aFxuICAgICAgICB8ICctJyAtPiAxLCBgTmVnXG4gICAgICAgIHwgJysnIC0+IDEsIGBQb3NcbiAgICAgICAgfCBfIC0+IDAsIGBQb3MpXG4gICAgICBlbHNlIDAsIGBQb3NcbiAgICBpblxuICAgIGlmIHBvcyArIDIgPCBsZW5cbiAgICB0aGVuIChcbiAgICAgIGxldCBjMSA9IHguW3Bvc10gaW5cbiAgICAgIGxldCBjMiA9IHguW3BvcyArIDFdIGluXG4gICAgICBtYXRjaCBjMSwgYzIgd2l0aFxuICAgICAgfCAnMCcsICcwJyAuLiAnOScgLT4gc2lnbiwgdHJ1ZVxuICAgICAgfCAnMCcsIF8gLT4gc2lnbiwgZmFsc2VcbiAgICAgIHwgXyAtPiBzaWduLCB0cnVlKVxuICAgIGVsc2Ugc2lnbiwgdHJ1ZVxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgeCA9IENhbWwuSW50NjQudG9fc3RyaW5nICh1bndyYXAgeClcblxuICBsZXQgb2Zfc3RyaW5nIHN0ciA9XG4gICAgdHJ5XG4gICAgICBsZXQgc2lnbiwgc2lnbmVkbmVzcyA9IHNpZ25fYW5kX3NpZ25lZG5lc3Mgc3RyIGluXG4gICAgICBpZiBzaWduZWRuZXNzXG4gICAgICB0aGVuIG9mX2ludDY0X2V4biAoQ2FtbC5JbnQ2NC5vZl9zdHJpbmcgc3RyKVxuICAgICAgZWxzZSAoXG4gICAgICAgIGxldCBwb3Nfc3RyID1cbiAgICAgICAgICBtYXRjaCBzaWduIHdpdGhcbiAgICAgICAgICB8IGBOZWcgLT4gU3RyaW5nLnN1YiBzdHIgfnBvczoxIH5sZW46KFN0cmluZy5sZW5ndGggc3RyIC0gMSlcbiAgICAgICAgICB8IGBQb3MgLT4gc3RyXG4gICAgICAgIGluXG4gICAgICAgIGxldCBpbnQ2NCA9IENhbWwuSW50NjQub2Zfc3RyaW5nIHBvc19zdHIgaW5cbiAgICAgICAgKCogdW5zaWduZWQgNjMtYml0IGludCBtdXN0IHBhcnNlIGFzIGEgcG9zaXRpdmUgc2lnbmVkIDY0LWJpdCBpbnQgKilcbiAgICAgICAgaWYgSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIGludDY0IDBMIHRoZW4gaW52YWxpZF9zdHIgc3RyO1xuICAgICAgICBsZXQgaW50NjMgPSB3cmFwX21vZHVsbyBpbnQ2NCBpblxuICAgICAgICBtYXRjaCBzaWduIHdpdGhcbiAgICAgICAgfCBgTmVnIC0+IG5lZyBpbnQ2M1xuICAgICAgICB8IGBQb3MgLT4gaW50NjMpXG4gICAgd2l0aFxuICAgIHwgXyAtPiBpbnZhbGlkX3N0ciBzdHJcbiAgOztcblxuICBsZXQgYnN3YXAxNiB0ID0gd3JhcF9tb2R1bG8gKEludDY0LmJzd2FwMTYgKHVud3JhcCB0KSlcbiAgbGV0IGJzd2FwMzIgdCA9IHdyYXBfbW9kdWxvIChJbnQ2NC5ic3dhcDMyICh1bndyYXAgdCkpXG4gIGxldCBic3dhcDQ4IHQgPSB3cmFwX21vZHVsbyAoSW50NjQuYnN3YXA0OCAodW53cmFwIHQpKVxuZW5kXG5cbmluY2x1ZGUgVFxuXG5sZXQgbnVtX2JpdHMgPSA2M1xubGV0IGZsb2F0X2xvd2VyX2JvdW5kID0gRmxvYXQwLmxvd2VyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF91cHBlcl9ib3VuZCA9IEZsb2F0MC51cHBlcl9ib3VuZF9mb3JfaW50IG51bV9iaXRzXG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gYml0X25vdFxubGV0IGJpdF94b3IgPSBiaXRfeG9yXG5sZXQgYml0X29yID0gYml0X29yXG5sZXQgYml0X2FuZCA9IGJpdF9hbmRcbmxldCBwb3Bjb3VudCA9IHBvcGNvdW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHBvdyA9IHBvd1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1heF92YWx1ZSA9IG1heF92YWx1ZVxubGV0IG1pbl92YWx1ZSA9IG1pbl92YWx1ZVxubGV0IG1pbnVzX29uZSA9IHdyYXBfZXhuIENhbWwuSW50NjQubWludXNfb25lXG5sZXQgb25lID0gd3JhcF9leG4gQ2FtbC5JbnQ2NC5vbmVcbmxldCB6ZXJvID0gd3JhcF9leG4gQ2FtbC5JbnQ2NC56ZXJvXG5sZXQgaXNfcG93MiA9IGlzX3BvdzJcbmxldCBmbG9vcl9wb3cyID0gZmxvb3JfcG93MlxubGV0IGNlaWxfcG93MiA9IGNlaWxfcG93MlxubGV0IGZsb29yX2xvZzIgPSBmbG9vcl9sb2cyXG5sZXQgY2VpbF9sb2cyID0gY2VpbF9sb2cyXG5sZXQgY2x6ID0gY2x6XG5sZXQgY3R6ID0gY3R6XG5sZXQgdG9fZmxvYXQgeCA9IENhbWwuSW50NjQudG9fZmxvYXQgKHVud3JhcCB4KVxubGV0IG9mX2Zsb2F0X3VuY2hlY2tlZCB4ID0gd3JhcF9tb2R1bG8gKENhbWwuSW50NjQub2ZfZmxvYXQgeClcblxubGV0IG9mX2Zsb2F0IHQgPVxuICBsZXQgb3BlbiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgaWYgdCA+PSBmbG9hdF9sb3dlcl9ib3VuZCAmJiB0IDw9IGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gd3JhcF9tb2R1bG8gKENhbWwuSW50NjQub2ZfZmxvYXQgdClcbiAgZWxzZVxuICAgIFByaW50Zi5pbnZhbGlkX2FyZ2ZcbiAgICAgIFwiSW50NjMub2ZfZmxvYXQ6IGFyZ3VtZW50ICglZikgaXMgb3V0IG9mIHJhbmdlIG9yIE5hTlwiXG4gICAgICAoRmxvYXQwLmJveCB0KVxuICAgICAgKClcbjs7XG5cbmxldCBvZl9pbnQ2NCA9IG9mX2ludDY0XG5sZXQgb2ZfaW50NjRfZXhuID0gb2ZfaW50NjRfZXhuXG5sZXQgb2ZfaW50NjRfdHJ1bmMgPSBvZl9pbnQ2NF90cnVuY1xubGV0IHRvX2ludDY0ID0gdG9faW50NjRcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG5sZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbmxldCBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXggPSBpZiB0IDwgbWluIHRoZW4gbWluIGVsc2UgaWYgdCA8PSBtYXggdGhlbiB0IGVsc2UgbWF4XG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICBjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXhcbjs7XG5cbmxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gIGlmIG1pbiA+IG1heFxuICB0aGVuXG4gICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgXCJjbGFtcCByZXF1aXJlcyBbbWluIDw9IG1heF1cIlxuICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICBlbHNlIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG47O1xuXG5sZXQgKCAvICkgPSBkaXZcbmxldCAoICogKSA9IG11bFxubGV0ICggLSApID0gc3ViXG5sZXQgKCArICkgPSBhZGRcbmxldCAoIH4tICkgPSBuZWdcbmxldCAoICoqICkgYiBlID0gcG93IGIgZVxubGV0IGluY3IgciA9IHIgOj0gIXIgKyBvbmVcbmxldCBkZWNyIHIgPSByIDo9ICFyIC0gb25lXG5cbigqIFdlIGNhbiByZXVzZSBjb252ZXJzaW9uIGZ1bmN0aW9uIGZyb20vdG8gaW50NjQgaGVyZS4gKilcbmxldCBvZl9pbnQgeCA9IHdyYXBfZXhuIChDb252LmludF90b19pbnQ2NCB4KVxubGV0IG9mX2ludF9leG4geCA9IG9mX2ludCB4XG5sZXQgdG9faW50IHggPSBDb252LmludDY0X3RvX2ludCAodW53cmFwIHgpXG5sZXQgdG9faW50X2V4biB4ID0gQ29udi5pbnQ2NF90b19pbnRfZXhuICh1bndyYXAgeClcbmxldCB0b19pbnRfdHJ1bmMgeCA9IENvbnYuaW50NjRfdG9faW50X3RydW5jICh1bndyYXAgeClcbmxldCBvZl9pbnQzMiB4ID0gd3JhcF9leG4gKENvbnYuaW50MzJfdG9faW50NjQgeClcbmxldCBvZl9pbnQzMl9leG4geCA9IG9mX2ludDMyIHhcbmxldCB0b19pbnQzMiB4ID0gQ29udi5pbnQ2NF90b19pbnQzMiAodW53cmFwIHgpXG5sZXQgdG9faW50MzJfZXhuIHggPSBDb252LmludDY0X3RvX2ludDMyX2V4biAodW53cmFwIHgpXG5sZXQgdG9faW50MzJfdHJ1bmMgeCA9IENvbnYuaW50NjRfdG9faW50MzJfdHJ1bmMgKHVud3JhcCB4KVxubGV0IG9mX25hdGl2ZWludCB4ID0gb2ZfaW50NjQgKENvbnYubmF0aXZlaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfbmF0aXZlaW50X2V4biB4ID0gd3JhcF9leG4gKENvbnYubmF0aXZlaW50X3RvX2ludDY0IHgpXG5sZXQgb2ZfbmF0aXZlaW50X3RydW5jIHggPSBvZl9pbnQ2NF90cnVuYyAoQ29udi5uYXRpdmVpbnRfdG9faW50NjQgeClcbmxldCB0b19uYXRpdmVpbnQgeCA9IENvbnYuaW50NjRfdG9fbmF0aXZlaW50ICh1bndyYXAgeClcbmxldCB0b19uYXRpdmVpbnRfZXhuIHggPSBDb252LmludDY0X3RvX25hdGl2ZWludF9leG4gKHVud3JhcCB4KVxubGV0IHRvX25hdGl2ZWludF90cnVuYyB4ID0gQ29udi5pbnQ2NF90b19uYXRpdmVpbnRfdHJ1bmMgKHVud3JhcCB4KVxuXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBULnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGhhc2hdXG5cbiAgICBsZXQgY29tcGFyZSA9IChULmNvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgVC5oYXNoX2ZvbGRfdFxuXG4gICAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgICAgbGV0IGZ1bmMgPSBULmhhc2ggaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9ICggfi0gKVxuICAgIGxldCAoIDwgKSA9ICggPCApXG5cbiAgICBsZXQgdG9fc3RyaW5nIGkgPVxuICAgICAgKCogdGhlIHVzZSBvZiBbdW53cmFwX3Vuc2lnbmVkXSBoZXJlIGlzIGltcG9ydGFudCBmb3IgdGhlIGNhc2Ugb2YgW21pbl92YWx1ZV0gKilcbiAgICAgIFByaW50Zi5zcHJpbnRmIFwiJUx4XCIgKHVud3JhcF91bnNpZ25lZCBpKVxuICAgIDs7XG5cbiAgICBsZXQgb2Zfc3RyaW5nIHMgPSBvZl9zdHJpbmcgKFwiMHhcIiBeIHMpXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDYzLkhleFwiXG4gIGVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgeCA9IHRvX3N0cmluZyB4XG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDYzXCJcbiAgZW5kKVxuXG5tb2R1bGUgUHJlX08gPSBzdHJ1Y3RcbiAgbGV0ICggKyApID0gKCArIClcbiAgbGV0ICggLSApID0gKCAtIClcbiAgbGV0ICggKiApID0gKCAqIClcbiAgbGV0ICggLyApID0gKCAvIClcbiAgbGV0ICggfi0gKSA9ICggfi0gKVxuICBsZXQgKCAqKiApID0gKCAqKiApXG5cbiAgaW5jbHVkZSAoSW50NjRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgICBsZXQgcmVtID0gcmVtXG4gICAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gICAgZW5kKVxuXG4gIGxldCAoIGxhbmQgKSA9IGJpdF9hbmRcbiAgbGV0ICggbG9yICkgPSBiaXRfb3JcbiAgbGV0ICggbHhvciApID0gYml0X3hvclxuICBsZXQgbG5vdCA9IGJpdF9ub3RcbiAgbGV0ICggbHNsICkgPSBzaGlmdF9sZWZ0XG4gIGxldCAoIGFzciApID0gc2hpZnRfcmlnaHRcbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnQ2M10gYW5kIFtJbnQ2My5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG5cbm1vZHVsZSBSZXByID0gc3RydWN0XG4gIHR5cGUgZW11bGF0ZWQgPSB0XG5cbiAgdHlwZSAoJ3VuZGVybHlpbmdfdHlwZSwgJ2ludGVybWVkaWF0ZV90eXBlKSB0ID1cbiAgICB8IEludCA6IChpbnQsIGludCkgdFxuICAgIHwgSW50NjQgOiAoaW50NjQsIGVtdWxhdGVkKSB0XG5lbmRcblxubGV0IHJlcHIgPSBSZXByLkludDY0XG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBJbnQ2NF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcbiIsIm9wZW4hIEltcG9ydFxuXG5sZXQgaW52YWxpZF9hcmdmID0gUHJpbnRmLmludmFsaWRfYXJnZlxuXG5tb2R1bGUgVCA9IHN0cnVjdFxuICB0eXBlIHQgPSBib29sIFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlbnVtZXJhdGUsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZSA9IChjb21wYXJlX2Jvb2wgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgZmFsc2U7IHRydWUgXSA6IHQgbGlzdClcblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2Jvb2xcblxuICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgbGV0IGZ1bmMgPSBoYXNoX2Jvb2wgaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwID0gKGJvb2xfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfYm9vbCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBib29sX3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgbGV0IGhhc2hhYmxlIDogdCBIYXNoYWJsZS50ID0geyBoYXNoOyBjb21wYXJlOyBzZXhwX29mX3QgfVxuXG4gIGxldCBvZl9zdHJpbmcgPSBmdW5jdGlvblxuICAgIHwgXCJ0cnVlXCIgLT4gdHJ1ZVxuICAgIHwgXCJmYWxzZVwiIC0+IGZhbHNlXG4gICAgfCBzIC0+IGludmFsaWRfYXJnZiBcIkJvb2wub2Zfc3RyaW5nOiBleHBlY3RlZCB0cnVlIG9yIGZhbHNlIGJ1dCBnb3QgJXNcIiBzICgpXG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyA9IENhbWwuc3RyaW5nX29mX2Jvb2xcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG5pbmNsdWRlIFByZXR0eV9wcmludGVyLlJlZ2lzdGVyIChzdHJ1Y3RcbiAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgbGV0IHRvX3N0cmluZyA9IHRvX3N0cmluZ1xuICAgIGxldCBtb2R1bGVfbmFtZSA9IFwiQmFzZS5Cb29sXCJcbiAgZW5kKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuISBCb29sX3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5sZXQgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4ID0gaWYgdCA8IG1pbiB0aGVuIG1pbiBlbHNlIGlmIHQgPD0gbWF4IHRoZW4gdCBlbHNlIG1heFxuXG5sZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgYXNzZXJ0IChtaW4gPD0gbWF4KTtcbiAgY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4XG47O1xuXG5sZXQgY2xhbXAgdCB+bWluIH5tYXggPVxuICBpZiBtaW4gPiBtYXhcbiAgdGhlblxuICAgIE9yX2Vycm9yLmVycm9yX3NcbiAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgIFsgXCJtaW5cIiwgVC5zZXhwX29mX3QgbWluOyBcIm1heFwiLCBULnNleHBfb2ZfdCBtYXggXSlcbiAgZWxzZSBPayAoY2xhbXBfdW5jaGVja2VkIHQgfm1pbiB+bWF4KVxuOztcblxubGV0IHRvX2ludCB4ID0gYm9vbF90b19pbnQgeFxuXG5tb2R1bGUgTm9uX3Nob3J0X2NpcmN1aXRpbmcgPSBzdHJ1Y3RcbiAgKCogV2UgZG9uJ3QgZXhwb3NlIHRoaXMsIHNpbmNlIHdlIGRvbid0IHdhbnQgdG8gYnJlYWsgdGhlIGludmFyaWFudCBtZW50aW9uZWQgYmVsb3cgb2ZcbiAgICAgKHRvX2ludCB0cnVlID0gMSkgYW5kICh0b19pbnQgZmFsc2UgPSAwKS4gKilcbiAgbGV0IHVuc2FmZV9vZl9pbnQgKHggOiBpbnQpIDogYm9vbCA9IENhbWwuT2JqLm1hZ2ljIHhcbiAgbGV0ICggfHwgKSBhIGIgPSB1bnNhZmVfb2ZfaW50ICh0b19pbnQgYSBsb3IgdG9faW50IGIpXG4gIGxldCAoICYmICkgYSBiID0gdW5zYWZlX29mX2ludCAodG9faW50IGEgbGFuZCB0b19pbnQgYilcbmVuZFxuXG4oKiBXZSBkbyB0aGlzIGFzIGEgZGlyZWN0IGFzc2VydCBvbiB0aGUgdGhlb3J5IHRoYXQgaXQncyBhIGNoZWFwIHRoaW5nIHRvIHRlc3QgYW5kIGFcbiAgIHJlYWxseSBjb3JlIGludmFyaWFudCB0aGF0IHdlIG5ldmVyIGV4cGVjdCB0byBicmVhaywgYW5kIHdlIHNob3VsZCBiZSBoYXBweSBmb3IgYVxuICAgcHJvZ3JhbSB0byBmYWlsIGltbWVkaWF0ZWx5IGlmIHRoaXMgaXMgdmlvbGF0ZWQuICopXG5sZXQgKCkgPSBhc3NlcnQgKFBvbHkuKCA9ICkgKHRvX2ludCB0cnVlKSAxICYmIFBvbHkuKCA9ICkgKHRvX2ludCBmYWxzZSkgMClcblxuKCogSW5jbHVkZSB0eXBlLXNwZWNpZmljIFtSZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVdIGF0IHRoZSBlbmQsIGFmdGVyXG4gICBpbmNsdWRpbmcgZnVuY3RvciBhcHBsaWNhdGlvbiB0aGF0IGNvdWxkIHNoYWRvdyBpdHMgZGVmaW5pdGlvbnMuIFRoaXMgaXNcbiAgIGhlcmUgc28gdGhhdCBlZmZpY2llbnQgdmVyc2lvbnMgb2YgdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25zIGFyZSBleHBvcnRlZCBieVxuICAgdGhpcyBtb2R1bGUuICopXG5pbmNsdWRlIEJvb2xfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIENhbWwuSW50MzJcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gaW50MzIgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2ludDMyXG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9pbnQzMiBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoaW50MzJfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfaW50MzIgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gaW50MzJfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlICh4IDogdCkgeSA9IGNvbXBhcmUgeCB5XG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgbGV0IG9mX3N0cmluZyA9IG9mX3N0cmluZ1xuZW5kXG5cbmluY2x1ZGUgVFxuaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG5cbmxldCBudW1fYml0cyA9IDMyXG5sZXQgZmxvYXRfbG93ZXJfYm91bmQgPSBGbG9hdDAubG93ZXJfYm91bmRfZm9yX2ludCBudW1fYml0c1xubGV0IGZsb2F0X3VwcGVyX2JvdW5kID0gRmxvYXQwLnVwcGVyX2JvdW5kX2Zvcl9pbnQgbnVtX2JpdHNcbmxldCBmbG9hdF9vZl9iaXRzID0gZmxvYXRfb2ZfYml0c1xubGV0IGJpdHNfb2ZfZmxvYXQgPSBiaXRzX29mX2Zsb2F0XG5sZXQgc2hpZnRfcmlnaHRfbG9naWNhbCA9IHNoaWZ0X3JpZ2h0X2xvZ2ljYWxcbmxldCBzaGlmdF9yaWdodCA9IHNoaWZ0X3JpZ2h0XG5sZXQgc2hpZnRfbGVmdCA9IHNoaWZ0X2xlZnRcbmxldCBiaXRfbm90ID0gbG9nbm90XG5sZXQgYml0X3hvciA9IGxvZ3hvclxubGV0IGJpdF9vciA9IGxvZ29yXG5sZXQgYml0X2FuZCA9IGxvZ2FuZFxubGV0IG1pbl92YWx1ZSA9IG1pbl9pbnRcbmxldCBtYXhfdmFsdWUgPSBtYXhfaW50XG5sZXQgYWJzID0gYWJzXG5sZXQgcHJlZCA9IHByZWRcbmxldCBzdWNjID0gc3VjY1xubGV0IHJlbSA9IHJlbVxubGV0IG5lZyA9IG5lZ1xubGV0IG1pbnVzX29uZSA9IG1pbnVzX29uZVxubGV0IG9uZSA9IG9uZVxubGV0IHplcm8gPSB6ZXJvXG5sZXQgY29tcGFyZSA9IGNvbXBhcmVcbmxldCB0b19mbG9hdCA9IHRvX2Zsb2F0XG5sZXQgb2ZfZmxvYXRfdW5jaGVja2VkID0gb2ZfZmxvYXRcblxubGV0IG9mX2Zsb2F0IGYgPVxuICBpZiBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA+PSApIGYgZmxvYXRfbG93ZXJfYm91bmRcbiAgJiYgRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPD0gKSBmIGZsb2F0X3VwcGVyX2JvdW5kXG4gIHRoZW4gb2ZfZmxvYXQgZlxuICBlbHNlXG4gICAgUHJpbnRmLmludmFsaWRfYXJnZlxuICAgICAgXCJJbnQzMi5vZl9mbG9hdDogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IGYpXG4gICAgICAoKVxuOztcblxuaW5jbHVkZSBDb21wYXJhYmxlLldpdGhfemVybyAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgemVybyA9IHplcm9cbiAgZW5kKVxuXG5tb2R1bGUgSW5maXhfY29tcGFyZSA9IHN0cnVjdFxuICBvcGVuIFBvbHlcblxuICBsZXQgKCA+PSApICh4IDogdCkgeSA9IHggPj0geVxuICBsZXQgKCA8PSApICh4IDogdCkgeSA9IHggPD0geVxuICBsZXQgKCA9ICkgKHggOiB0KSB5ID0geCA9IHlcbiAgbGV0ICggPiApICh4IDogdCkgeSA9IHggPiB5XG4gIGxldCAoIDwgKSAoeCA6IHQpIHkgPSB4IDwgeVxuICBsZXQgKCA8PiApICh4IDogdCkgeSA9IHggPD4geVxuZW5kXG5cbm1vZHVsZSBDb21wYXJlID0gc3RydWN0XG4gIGluY2x1ZGUgSW5maXhfY29tcGFyZVxuXG4gIGxldCBjb21wYXJlID0gY29tcGFyZVxuICBsZXQgYXNjZW5kaW5nID0gY29tcGFyZVxuICBsZXQgZGVzY2VuZGluZyB4IHkgPSBjb21wYXJlIHkgeFxuICBsZXQgbWluICh4IDogdCkgeSA9IGlmIHggPCB5IHRoZW4geCBlbHNlIHlcbiAgbGV0IG1heCAoeCA6IHQpIHkgPSBpZiB4ID4geSB0aGVuIHggZWxzZSB5XG4gIGxldCBlcXVhbCAoeCA6IHQpIHkgPSB4ID0geVxuICBsZXQgYmV0d2VlbiB0IH5sb3cgfmhpZ2ggPSBsb3cgPD0gdCAmJiB0IDw9IGhpZ2hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heCA9IGlmIHQgPCBtaW4gdGhlbiBtaW4gZWxzZSBpZiB0IDw9IG1heCB0aGVuIHQgZWxzZSBtYXhcblxuICBsZXQgY2xhbXBfZXhuIHQgfm1pbiB+bWF4ID1cbiAgICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAgIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuICA7O1xuXG4gIGxldCBjbGFtcCB0IH5taW4gfm1heCA9XG4gICAgaWYgbWluID4gbWF4XG4gICAgdGhlblxuICAgICAgT3JfZXJyb3IuZXJyb3Jfc1xuICAgICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICAgIFwiY2xhbXAgcmVxdWlyZXMgW21pbiA8PSBtYXhdXCJcbiAgICAgICAgICAgWyBcIm1pblwiLCBULnNleHBfb2ZfdCBtaW47IFwibWF4XCIsIFQuc2V4cF9vZl90IG1heCBdKVxuICAgIGVsc2UgT2sgKGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heClcbiAgOztcbmVuZFxuXG5pbmNsdWRlIENvbXBhcmVcblxubGV0IGludmFyaWFudCAoXyA6IHQpID0gKClcbmxldCAoIC8gKSA9IGRpdlxubGV0ICggKiApID0gbXVsXG5sZXQgKCAtICkgPSBzdWJcbmxldCAoICsgKSA9IGFkZFxubGV0ICggfi0gKSA9IG5lZ1xubGV0IGluY3IgciA9IHIgOj0gIXIgKyBvbmVcbmxldCBkZWNyIHIgPSByIDo9ICFyIC0gb25lXG5sZXQgb2ZfaW50MzIgdCA9IHRcbmxldCBvZl9pbnQzMl9leG4gPSBvZl9pbnQzMlxubGV0IHRvX2ludDMyIHQgPSB0XG5sZXQgdG9faW50MzJfZXhuID0gdG9faW50MzJcbmxldCBwb3Bjb3VudCA9IFBvcGNvdW50LmludDMyX3BvcGNvdW50XG5cbm1vZHVsZSBDb252ID0gSW50X2NvbnZlcnNpb25zXG5cbmxldCBvZl9pbnQgPSBDb252LmludF90b19pbnQzMlxubGV0IG9mX2ludF9leG4gPSBDb252LmludF90b19pbnQzMl9leG5cbmxldCBvZl9pbnRfdHJ1bmMgPSBDb252LmludF90b19pbnQzMl90cnVuY1xubGV0IHRvX2ludCA9IENvbnYuaW50MzJfdG9faW50XG5sZXQgdG9faW50X2V4biA9IENvbnYuaW50MzJfdG9faW50X2V4blxubGV0IHRvX2ludF90cnVuYyA9IENvbnYuaW50MzJfdG9faW50X3RydW5jXG5sZXQgb2ZfaW50NjQgPSBDb252LmludDY0X3RvX2ludDMyXG5sZXQgb2ZfaW50NjRfZXhuID0gQ29udi5pbnQ2NF90b19pbnQzMl9leG5cbmxldCBvZl9pbnQ2NF90cnVuYyA9IENvbnYuaW50NjRfdG9faW50MzJfdHJ1bmNcbmxldCB0b19pbnQ2NCA9IENvbnYuaW50MzJfdG9faW50NjRcbmxldCBvZl9uYXRpdmVpbnQgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMlxubGV0IG9mX25hdGl2ZWludF9leG4gPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl9leG5cbmxldCBvZl9uYXRpdmVpbnRfdHJ1bmMgPSBDb252Lm5hdGl2ZWludF90b19pbnQzMl90cnVuY1xubGV0IHRvX25hdGl2ZWludCA9IENvbnYuaW50MzJfdG9fbmF0aXZlaW50XG5sZXQgdG9fbmF0aXZlaW50X2V4biA9IHRvX25hdGl2ZWludFxubGV0IHBvdyBiIGUgPSBvZl9pbnRfZXhuIChJbnRfbWF0aC5Qcml2YXRlLmludF9wb3cgKHRvX2ludF9leG4gYikgKHRvX2ludF9leG4gZSkpXG5sZXQgKCAqKiApIGIgZSA9IHBvdyBiIGVcblxuZXh0ZXJuYWwgYnN3YXAzMiA6IHQgLT4gdCA9IFwiJWJzd2FwX2ludDMyXCJcblxubGV0IGJzd2FwMTYgeCA9IENhbWwuSW50MzIuc2hpZnRfcmlnaHRfbG9naWNhbCAoYnN3YXAzMiB4KSAxNlxuXG5tb2R1bGUgUG93MiA9IHN0cnVjdFxuICBvcGVuISBJbXBvcnRcbiAgb3BlbiBJbnQzMl9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuICBsZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxuICBsZXQgbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpID1cbiAgICBQcmludGYuaW52YWxpZF9hcmdmIFwiYXJndW1lbnQgbXVzdCBiZSBzdHJpY3RseSBwb3NpdGl2ZVwiICgpXG4gIDs7XG5cbiAgbGV0ICggbG9yICkgPSBDYW1sLkludDMyLmxvZ29yXG4gIGxldCAoIGxzciApID0gQ2FtbC5JbnQzMi5zaGlmdF9yaWdodF9sb2dpY2FsXG4gIGxldCAoIGxhbmQgKSA9IENhbWwuSW50MzIubG9nYW5kXG5cbiAgKCoqIFwiY2VpbGluZyBwb3dlciBvZiAyXCIgLSBMZWFzdCBwb3dlciBvZiAyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgY2VpbF9wb3cyIHggPVxuICAgIGlmIHggPD0gQ2FtbC5JbnQzMi56ZXJvIHRoZW4gbm9uX3Bvc2l0aXZlX2FyZ3VtZW50ICgpO1xuICAgIGxldCB4ID0gQ2FtbC5JbnQzMi5wcmVkIHggaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIENhbWwuSW50MzIuc3VjYyB4XG4gIDs7XG5cbiAgKCoqIFwiZmxvb3IgcG93ZXIgb2YgMlwiIC0gTGFyZ2VzdCBwb3dlciBvZiAyIGxlc3MgdGhhbiBvciBlcXVhbCB0byB4LiAqKVxuICBsZXQgZmxvb3JfcG93MiB4ID1cbiAgICBpZiB4IDw9IENhbWwuSW50MzIuemVybyB0aGVuIG5vbl9wb3NpdGl2ZV9hcmd1bWVudCAoKTtcbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciAxKSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDIpIGluXG4gICAgbGV0IHggPSB4IGxvciAoeCBsc3IgNCkgaW5cbiAgICBsZXQgeCA9IHggbG9yICh4IGxzciA4KSBpblxuICAgIGxldCB4ID0geCBsb3IgKHggbHNyIDE2KSBpblxuICAgIENhbWwuSW50MzIuc3ViIHggKHggbHNyIDEpXG4gIDs7XG5cbiAgbGV0IGlzX3BvdzIgeCA9XG4gICAgaWYgeCA8PSBDYW1sLkludDMyLnplcm8gdGhlbiBub25fcG9zaXRpdmVfYXJndW1lbnQgKCk7XG4gICAgeCBsYW5kIENhbWwuSW50MzIucHJlZCB4ID0gQ2FtbC5JbnQzMi56ZXJvXG4gIDs7XG5cbiAgKCogQyBzdHVicyBmb3IgaW50MzIgY2x6IGFuZCBjdHogdG8gdXNlIHRoZSBDTFovQlNSL0NUWi9CU0YgaW5zdHJ1Y3Rpb24gd2hlcmUgcG9zc2libGUgKilcbiAgZXh0ZXJuYWwgY2x6XG4gICAgOiAgKGludDMyW0B1bmJveGVkXSlcbiAgICAtPiAoaW50W0B1bnRhZ2dlZF0pXG4gICAgPSBcIkJhc2VfaW50X21hdGhfaW50MzJfY2x6XCIgXCJCYXNlX2ludF9tYXRoX2ludDMyX2Nsel91bmJveGVkXCJcbiAgW0BAbm9hbGxvY11cblxuICBleHRlcm5hbCBjdHpcbiAgICA6ICAoaW50MzJbQHVuYm94ZWRdKVxuICAgIC0+IChpbnRbQHVudGFnZ2VkXSlcbiAgICA9IFwiQmFzZV9pbnRfbWF0aF9pbnQzMl9jdHpcIiBcIkJhc2VfaW50X21hdGhfaW50MzJfY3R6X3VuYm94ZWRcIlxuICBbQEBub2FsbG9jXVxuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGZsb29yX2xvZzIgaSA9XG4gICAgaWYgaSA8PSBDYW1sLkludDMyLnplcm9cbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2UgXCJbSW50MzIuZmxvb3JfbG9nMl0gZ290IGludmFsaWQgaW5wdXRcIiBbIFwiXCIsIHNleHBfb2ZfaW50MzIgaSBdKTtcbiAgICBudW1fYml0cyAtIDEgLSBjbHogaVxuICA7O1xuXG4gICgqKiBIYWNrZXIncyBEZWxpZ2h0IFNlY29uZCBFZGl0aW9uIHAxMDYgKilcbiAgbGV0IGNlaWxfbG9nMiBpID1cbiAgICBpZiBpIDw9IENhbWwuSW50MzIuemVyb1xuICAgIHRoZW5cbiAgICAgIHJhaXNlX3MgKFNleHAubWVzc2FnZSBcIltJbnQzMi5jZWlsX2xvZzJdIGdvdCBpbnZhbGlkIGlucHV0XCIgWyBcIlwiLCBzZXhwX29mX2ludDMyIGkgXSk7XG4gICAgKCogVGhlIFtpID0gMV0gY2hlY2sgaXMgbmVlZGVkIGJlY2F1c2UgY2x6KDApIGlzIHVuZGVmaW5lZCAqKVxuICAgIGlmIENhbWwuSW50MzIuZXF1YWwgaSBDYW1sLkludDMyLm9uZSB0aGVuIDAgZWxzZSBudW1fYml0cyAtIGNseiAoQ2FtbC5JbnQzMi5wcmVkIGkpXG4gIDs7XG5lbmRcblxuaW5jbHVkZSBQb3cyXG5pbmNsdWRlIENvbnYuTWFrZSAoVClcblxuaW5jbHVkZSBDb252Lk1ha2VfaGV4IChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQzMiBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgaGFzaF1cblxuICAgIGxldCBjb21wYXJlID0gKGNvbXBhcmVfaW50MzIgOiB0IC0+IHQgLT4gaW50KVxuXG4gICAgbGV0IChoYXNoX2ZvbGRfdCA6IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgICAgaGFzaF9mb2xkX2ludDMyXG5cbiAgICBhbmQgKGhhc2ggOiB0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5oYXNoX3ZhbHVlKSA9XG4gICAgICBsZXQgZnVuYyA9IGhhc2hfaW50MzIgaW5cbiAgICAgIGZ1biB4IC0+IGZ1bmMgeFxuICAgIDs7XG5cbiAgICBbQEBAZW5kXVxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gICAgbGV0IG5lZyA9ICggfi0gKVxuICAgIGxldCAoIDwgKSA9ICggPCApXG4gICAgbGV0IHRvX3N0cmluZyBpID0gUHJpbnRmLnNwcmludGYgXCIlbHhcIiBpXG4gICAgbGV0IG9mX3N0cmluZyBzID0gQ2FtbC5TY2FuZi5zc2NhbmYgcyBcIiVseFwiIEZuLmlkXG4gICAgbGV0IG1vZHVsZV9uYW1lID0gXCJCYXNlLkludDMyLkhleFwiXG4gIGVuZClcblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuSW50MzJcIlxuICBlbmQpXG5cbm1vZHVsZSBQcmVfTyA9IHN0cnVjdFxuICBsZXQgKCArICkgPSAoICsgKVxuICBsZXQgKCAtICkgPSAoIC0gKVxuICBsZXQgKCAqICkgPSAoICogKVxuICBsZXQgKCAvICkgPSAoIC8gKVxuICBsZXQgKCB+LSApID0gKCB+LSApXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIChDb21wYXJlIDogQ29tcGFyaXNvbnMuSW5maXggd2l0aCB0eXBlIHQgOj0gdClcblxuICBsZXQgYWJzID0gYWJzXG4gIGxldCBuZWcgPSBuZWdcbiAgbGV0IHplcm8gPSB6ZXJvXG4gIGxldCBvZl9pbnRfZXhuID0gb2ZfaW50X2V4blxuZW5kXG5cbm1vZHVsZSBPID0gc3RydWN0XG4gIGluY2x1ZGUgUHJlX09cblxuICBpbmNsdWRlIEludF9tYXRoLk1ha2UgKHN0cnVjdFxuICAgICAgdHlwZSBub25yZWMgdCA9IHRcblxuICAgICAgaW5jbHVkZSBQcmVfT1xuXG4gICAgICBsZXQgcmVtID0gcmVtXG4gICAgICBsZXQgdG9fZmxvYXQgPSB0b19mbG9hdFxuICAgICAgbGV0IG9mX2Zsb2F0ID0gb2ZfZmxvYXRcbiAgICAgIGxldCBvZl9zdHJpbmcgPSBULm9mX3N0cmluZ1xuICAgICAgbGV0IHRvX3N0cmluZyA9IFQudG9fc3RyaW5nXG4gICAgZW5kKVxuXG4gIGxldCAoIGxhbmQgKSA9IGJpdF9hbmRcbiAgbGV0ICggbG9yICkgPSBiaXRfb3JcbiAgbGV0ICggbHhvciApID0gYml0X3hvclxuICBsZXQgbG5vdCA9IGJpdF9ub3RcbiAgbGV0ICggbHNsICkgPSBzaGlmdF9sZWZ0XG4gIGxldCAoIGFzciApID0gc2hpZnRfcmlnaHRcbiAgbGV0ICggbHNyICkgPSBzaGlmdF9yaWdodF9sb2dpY2FsXG5lbmRcblxuaW5jbHVkZSBPXG5cbigqIFtJbnQzMl0gYW5kIFtJbnQzMi5PXSBhZ3JlZSB2YWx1ZS13aXNlICopXG4iLCJvcGVuISBJbXBvcnRcblxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbm1vZHVsZSBSZXByID0gSW50NjNfZW11bC5SZXByXG5cbigqIEluIGEgd29ybGQgd2hlcmUgdGhlIGNvbXBpbGVyIHdvdWxkIHVuZGVyc3RhbmQgW0BAaW1tZWRpYXRlNjRdIGF0dHJpYnV0ZXMgb24gdHlwZVxuICAgZGVjbGFyYXRpb25zLCB0aGlzIG1vZHVsZSBpcyBob3cgb25lIHdvdWxkIHByb2R1Y2UgYSBbdHlwZSB0XSB3aXRoIHRoaXMgYXR0cmlidXRlLiAqKVxubW9kdWxlIEltbWVkaWF0ZTY0IDogc2lnXG4gIG1vZHVsZSB0eXBlIE5vbl9pbW1lZGlhdGUgPSBzaWdcbiAgICB0eXBlIHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgSW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0IFtAQGltbWVkaWF0ZV1cbiAgZW5kXG5cbiAgbW9kdWxlIE1ha2UgKEltbWVkaWF0ZSA6IEltbWVkaWF0ZSkgKE5vbl9pbW1lZGlhdGUgOiBOb25faW1tZWRpYXRlKSA6IHNpZ1xuICAgIHR5cGUgdCBbQEBpbW1lZGlhdGU2NF1cblxuICAgIHR5cGUgJ2EgcmVwciA9XG4gICAgICB8IEltbWVkaWF0ZSA6IEltbWVkaWF0ZS50IHJlcHJcbiAgICAgIHwgTm9uX2ltbWVkaWF0ZSA6IE5vbl9pbW1lZGlhdGUudCByZXByXG5cbiAgICB2YWwgcmVwciA6IHQgcmVwclxuICBlbmRcbmVuZCA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBOb25faW1tZWRpYXRlID0gc2lnXG4gICAgdHlwZSB0XG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEltbWVkaWF0ZSA9IHNpZ1xuICAgIHR5cGUgdCBbQEBpbW1lZGlhdGVdXG4gIGVuZFxuXG4gIG1vZHVsZSBNYWtlIChJbW1lZGlhdGUgOiBJbW1lZGlhdGUpIChOb25faW1tZWRpYXRlIDogTm9uX2ltbWVkaWF0ZSkgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgW0BAaW1tZWRpYXRlNjRdXG5cbiAgICB0eXBlICdhIHJlcHIgPVxuICAgICAgfCBJbW1lZGlhdGUgOiBJbW1lZGlhdGUudCByZXByXG4gICAgICB8IE5vbl9pbW1lZGlhdGUgOiBOb25faW1tZWRpYXRlLnQgcmVwclxuXG4gICAgbGV0IHJlcHIgPVxuICAgICAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gICAgICB8IFc2NCAtPiAoQ2FtbC5PYmoubWFnaWMgSW1tZWRpYXRlIDogdCByZXByKVxuICAgICAgfCBXMzIgLT4gKENhbWwuT2JqLm1hZ2ljIE5vbl9pbW1lZGlhdGUgOiB0IHJlcHIpXG4gICAgOztcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSBJbW1lZGlhdGU2NC5NYWtlIChJbnQpIChJbnQ2M19lbXVsKVxuXG5tb2R1bGUgQmFja2VuZCA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0XG5cbiAgICBpbmNsdWRlIEludF9pbnRmLlMgd2l0aCB0eXBlIHQgOj0gdFxuXG4gICAgdmFsIG9mX2ludCA6IGludCAtPiB0XG4gICAgdmFsIHRvX2ludCA6IHQgLT4gaW50IG9wdGlvblxuICAgIHZhbCB0b19pbnRfdHJ1bmMgOiB0IC0+IGludFxuICAgIHZhbCBvZl9pbnQzMiA6IGludDMyIC0+IHRcbiAgICB2YWwgdG9faW50MzIgOiB0IC0+IEludDMyLnQgb3B0aW9uXG4gICAgdmFsIHRvX2ludDMyX3RydW5jIDogdCAtPiBJbnQzMi50XG4gICAgdmFsIG9mX2ludDY0IDogSW50NjQudCAtPiB0IG9wdGlvblxuICAgIHZhbCBvZl9pbnQ2NF90cnVuYyA6IEludDY0LnQgLT4gdFxuICAgIHZhbCBvZl9uYXRpdmVpbnQgOiBuYXRpdmVpbnQgLT4gdCBvcHRpb25cbiAgICB2YWwgdG9fbmF0aXZlaW50IDogdCAtPiBuYXRpdmVpbnQgb3B0aW9uXG4gICAgdmFsIG9mX25hdGl2ZWludF90cnVuYyA6IG5hdGl2ZWludCAtPiB0XG4gICAgdmFsIHRvX25hdGl2ZWludF90cnVuYyA6IHQgLT4gbmF0aXZlaW50XG4gICAgdmFsIG9mX2Zsb2F0X3VuY2hlY2tlZCA6IGZsb2F0IC0+IHRcbiAgICB2YWwgcmVwciA6ICh0LCB0KSBJbnQ2M19lbXVsLlJlcHIudFxuICAgIHZhbCBic3dhcDE2IDogdCAtPiB0XG4gICAgdmFsIGJzd2FwMzIgOiB0IC0+IHRcbiAgICB2YWwgYnN3YXA0OCA6IHQgLT4gdFxuICBlbmRcbiAgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIG1vZHVsZSBOYXRpdmUgPSBzdHJ1Y3RcbiAgICBpbmNsdWRlIEludFxuXG4gICAgbGV0IHRvX2ludCB4ID0gU29tZSB4XG4gICAgbGV0IHRvX2ludF90cnVuYyB4ID0geFxuXG4gICAgKCogW29mX2ludDMyX2V4bl0gaXMgYSBzYWZlIG9wZXJhdGlvbiBvbiBwbGF0Zm9ybXMgd2l0aCA2NC1iaXQgd29yZCBzaXplcy4gKilcbiAgICBsZXQgb2ZfaW50MzIgPSBvZl9pbnQzMl9leG5cbiAgICBsZXQgdG9fbmF0aXZlaW50X3RydW5jIHggPSB0b19uYXRpdmVpbnQgeFxuICAgIGxldCB0b19uYXRpdmVpbnQgeCA9IFNvbWUgKHRvX25hdGl2ZWludCB4KVxuICAgIGxldCByZXByID0gSW50NjNfZW11bC5SZXByLkludFxuICAgIGxldCBic3dhcDMyIHQgPSBJbnQ2NC50b19pbnRfdHJ1bmMgKEludDY0LmJzd2FwMzIgKEludDY0Lm9mX2ludCB0KSlcbiAgICBsZXQgYnN3YXA0OCB0ID0gSW50NjQudG9faW50X3RydW5jIChJbnQ2NC5ic3dhcDQ4IChJbnQ2NC5vZl9pbnQgdCkpXG4gIGVuZFxuXG4gIGxldCBpbXBsIDogKG1vZHVsZSBTKSA9XG4gICAgbWF0Y2ggcmVwciB3aXRoXG4gICAgfCBJbW1lZGlhdGUgLT4gKG1vZHVsZSBOYXRpdmUgOiBTKVxuICAgIHwgTm9uX2ltbWVkaWF0ZSAtPiAobW9kdWxlIEludDYzX2VtdWwgOiBTKVxuICA7O1xuZW5kXG5cbmluY2x1ZGUgKHZhbCBCYWNrZW5kLmltcGwgOiBCYWNrZW5kLlMpXG5cbm1vZHVsZSBPdmVyZmxvd19leG4gPSBzdHJ1Y3RcbiAgbGV0ICggKyApIHQgdSA9XG4gICAgbGV0IHN1bSA9IHQgKyB1IGluXG4gICAgaWYgYml0X29yIChiaXRfeG9yIHQgdSkgKGJpdF94b3IgdCAoYml0X25vdCBzdW0pKSA8IHplcm9cbiAgICB0aGVuIHN1bVxuICAgIGVsc2VcbiAgICAgIHJhaXNlX3NcbiAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICBcIiggKyApIG92ZXJmbG93XCJcbiAgICAgICAgICAgWyBcInRcIiwgc2V4cF9vZl90IHQ7IFwidVwiLCBzZXhwX29mX3QgdTsgXCJzdW1cIiwgc2V4cF9vZl90IHN1bSBdKVxuICA7O1xuXG4gIGxldCAoIC0gKSB0IHUgPVxuICAgIGxldCBkaWZmID0gdCAtIHUgaW5cbiAgICBsZXQgcG9zX2RpZmYgPSB0ID4gdSBpblxuICAgIGlmIHQgPD4gdSAmJiBCb29sLiggPD4gKSBwb3NfZGlmZiAoaXNfcG9zaXRpdmUgZGlmZilcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCIoIC0gKSBvdmVyZmxvd1wiXG4gICAgICAgICAgIFsgXCJ0XCIsIHNleHBfb2ZfdCB0OyBcInVcIiwgc2V4cF9vZl90IHU7IFwiZGlmZlwiLCBzZXhwX29mX3QgZGlmZiBdKVxuICAgIGVsc2UgZGlmZlxuICA7O1xuXG4gIGxldCBuZWdhdGl2ZV9vbmUgPSBvZl9pbnQgKC0xKVxuICBsZXQgZGl2X3dvdWxkX292ZXJmbG93IHQgdSA9IHQgPSBtaW5fdmFsdWUgJiYgdSA9IG5lZ2F0aXZlX29uZVxuXG4gIGxldCAoICogKSB0IHUgPVxuICAgIGxldCBwcm9kdWN0ID0gdCAqIHUgaW5cbiAgICBpZiB1IDw+IHplcm8gJiYgKGRpdl93b3VsZF9vdmVyZmxvdyBwcm9kdWN0IHUgfHwgcHJvZHVjdCAvIHUgPD4gdClcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCIoICogKSBvdmVyZmxvd1wiXG4gICAgICAgICAgIFsgXCJ0XCIsIHNleHBfb2ZfdCB0OyBcInVcIiwgc2V4cF9vZl90IHU7IFwicHJvZHVjdFwiLCBzZXhwX29mX3QgcHJvZHVjdCBdKVxuICAgIGVsc2UgcHJvZHVjdFxuICA7O1xuXG4gIGxldCAoIC8gKSB0IHUgPVxuICAgIGlmIGRpdl93b3VsZF9vdmVyZmxvdyB0IHVcbiAgICB0aGVuXG4gICAgICByYWlzZV9zXG4gICAgICAgIChTZXhwLm1lc3NhZ2VcbiAgICAgICAgICAgXCIoIC8gKSBvdmVyZmxvd1wiXG4gICAgICAgICAgIFsgXCJ0XCIsIHNleHBfb2ZfdCB0OyBcInVcIiwgc2V4cF9vZl90IHU7IFwicHJvZHVjdFwiLCBzZXhwX29mX3QgKHQgLyB1KSBdKVxuICAgIGVsc2UgdCAvIHVcbiAgOztcblxuICBsZXQgYWJzIHQgPSBpZiB0ID0gbWluX3ZhbHVlIHRoZW4gZmFpbHdpdGggXCJhYnMgb3ZlcmZsb3dcIiBlbHNlIGFicyB0XG4gIGxldCBuZWcgdCA9IGlmIHQgPSBtaW5fdmFsdWUgdGhlbiBmYWlsd2l0aCBcIm5lZyBvdmVyZmxvd1wiIGVsc2UgbmVnIHRcbmVuZFxuXG5sZXQgKCkgPSBhc3NlcnQgKEludC4oID0gKSBudW1fYml0cyA2MylcblxubGV0IHJhbmRvbV9vZl9pbnQgPyhzdGF0ZSA9IFJhbmRvbS5TdGF0ZS5kZWZhdWx0KSBib3VuZCA9XG4gIG9mX2ludCAoUmFuZG9tLlN0YXRlLmludCBzdGF0ZSAodG9faW50X2V4biBib3VuZCkpXG47O1xuXG5sZXQgcmFuZG9tX29mX2ludDY0ID8oc3RhdGUgPSBSYW5kb20uU3RhdGUuZGVmYXVsdCkgYm91bmQgPVxuICBvZl9pbnQ2NF9leG4gKFJhbmRvbS5TdGF0ZS5pbnQ2NCBzdGF0ZSAodG9faW50NjQgYm91bmQpKVxuOztcblxubGV0IHJhbmRvbSA9XG4gIG1hdGNoIFdvcmRfc2l6ZS53b3JkX3NpemUgd2l0aFxuICB8IFc2NCAtPiByYW5kb21fb2ZfaW50XG4gIHwgVzMyIC0+IHJhbmRvbV9vZl9pbnQ2NFxuOztcblxubGV0IHJhbmRvbV9pbmNsX29mX2ludCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGxvIGhpID1cbiAgb2ZfaW50IChSYW5kb20uU3RhdGUuaW50X2luY2wgc3RhdGUgKHRvX2ludF9leG4gbG8pICh0b19pbnRfZXhuIGhpKSlcbjs7XG5cbmxldCByYW5kb21faW5jbF9vZl9pbnQ2NCA/KHN0YXRlID0gUmFuZG9tLlN0YXRlLmRlZmF1bHQpIGxvIGhpID1cbiAgb2ZfaW50NjRfZXhuIChSYW5kb20uU3RhdGUuaW50NjRfaW5jbCBzdGF0ZSAodG9faW50NjQgbG8pICh0b19pbnQ2NCBoaSkpXG47O1xuXG5sZXQgcmFuZG9tX2luY2wgPVxuICBtYXRjaCBXb3JkX3NpemUud29yZF9zaXplIHdpdGhcbiAgfCBXNjQgLT4gcmFuZG9tX2luY2xfb2ZfaW50XG4gIHwgVzMyIC0+IHJhbmRvbV9pbmNsX29mX2ludDY0XG47O1xuXG5sZXQgZmxvb3JfbG9nMiB0ID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IHQgfD4gdG9faW50X2V4biB8PiBJbnQuZmxvb3JfbG9nMlxuICB8IFczMiAtPlxuICAgIGlmIHQgPD0gemVyb1xuICAgIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0ludC5mbG9vcl9sb2cyXSBnb3QgaW52YWxpZCBpbnB1dFwiIFsgXCJcIiwgc2V4cF9vZl90IHQgXSk7XG4gICAgbGV0IGZsb29yX2xvZzIgPSByZWYgKEludC4oIC0gKSBudW1fYml0cyAyKSBpblxuICAgIHdoaWxlIGVxdWFsIHplcm8gKGJpdF9hbmQgdCAoc2hpZnRfbGVmdCBvbmUgIWZsb29yX2xvZzIpKSBkb1xuICAgICAgZmxvb3JfbG9nMiA6PSBJbnQuKCAtICkgIWZsb29yX2xvZzIgMVxuICAgIGRvbmU7XG4gICAgIWZsb29yX2xvZzJcbjs7XG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSBSZXByID0gUmVwclxuXG4gIGxldCByZXByID0gcmVwclxuXG4gIG1vZHVsZSBFbXVsID0gSW50NjNfZW11bFxuZW5kXG4iLCJvcGVuISBJbXBvcnRcblxuKCoqIEBjYW5vbmljYWwgQmFzZS5IYXNodGJsLktleSAqKVxubW9kdWxlIEtleSA9IHN0cnVjdFxuICBtb2R1bGUgdHlwZSBTID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBzZXhwX29mXVxuXG4gICAgaW5jbHVkZSBQcHhfY29tcGFyZV9saWIuQ29tcGFyYWJsZS5TIHdpdGggdHlwZSB0IDo9IHRcblxuICAgIHZhbCBzZXhwX29mX3QgOiB0IC0+IFNleHBsaWIwLlNleHAudFxuXG4gICAgW0BAQGVuZF1cblxuICAgICgqKiBUd28gW3RdcyB0aGF0IFtjb21wYXJlXSBlcXVhbCBtdXN0IGhhdmUgZXF1YWwgaGFzaGVzIGZvciB0aGUgaGFzaHRhYmxlXG4gICAgICAgIHRvIGJlaGF2ZSBwcm9wZXJseS4gKilcbiAgICB2YWwgaGFzaCA6IHQgLT4gaW50XG4gIGVuZFxuXG4gIHR5cGUgJ2EgdCA9IChtb2R1bGUgUyB3aXRoIHR5cGUgdCA9ICdhKVxuZW5kXG5cbigqKiBAY2Fub25pY2FsIEJhc2UuSGFzaHRibC5NZXJnZV9pbnRvX2FjdGlvbiAqKVxubW9kdWxlIE1lcmdlX2ludG9fYWN0aW9uID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBSZW1vdmVcbiAgICB8IFNldF90byBvZiAnYVxuZW5kXG5cbm1vZHVsZSB0eXBlIEFjY2Vzc29ycyA9IHNpZ1xuICAoKiogezIgQWNjZXNzb3JzfSAqKVxuXG4gIHR5cGUgKCdhLCAnYikgdFxuICB0eXBlICdhIGtleVxuXG4gIHZhbCBzZXhwX29mX2tleSA6ICgnYSwgXykgdCAtPiAnYSBrZXkgLT4gU2V4cC50XG4gIHZhbCBjbGVhciA6IChfLCBfKSB0IC0+IHVuaXRcbiAgdmFsIGNvcHkgOiAoJ2EsICdiKSB0IC0+ICgnYSwgJ2IpIHRcblxuICAoKiogQXR0ZW1wdGluZyB0byBtb2RpZnkgKFtzZXRdLCBbcmVtb3ZlXSwgZXRjLikgdGhlIGhhc2h0YWJsZSBkdXJpbmcgaXRlcmF0aW9uIChbZm9sZF0sXG4gICAgICBbaXRlcl0sIFtpdGVyX2tleXNdLCBbaXRlcmldKSB3aWxsIHJhaXNlIGFuIGV4Y2VwdGlvbi4gKilcbiAgdmFsIGZvbGQgOiAoJ2EsICdiKSB0IC0+IGluaXQ6J2MgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdjIC0+ICdjKSAtPiAnY1xuXG4gIHZhbCBpdGVyX2tleXMgOiAoJ2EsIF8pIHQgLT4gZjooJ2Ega2V5IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGl0ZXIgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqKiBJdGVyYXRlcyBvdmVyIGJvdGgga2V5cyBhbmQgdmFsdWVzLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgbGV0IGggPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA0KTsgKDUsIDYpXSBpblxuICAgICAgSGFzaHRibC5pdGVyaSBoIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgICAgICBwcmludF9lbmRsaW5lIChQcmludGYuc3ByaW50ZiBcIiVkLSVkXCIga2V5IGRhdGEpKTs7XG4gICAgICAxLTRcbiAgICAgIDUtNlxuICAgICAgLSA6IHVuaXQgPSAoKVxuICAgICAgdn0gKilcbiAgdmFsIGl0ZXJpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gdW5pdCkgLT4gdW5pdFxuXG4gIHZhbCBleGlzdHNpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZXhpc3RzIDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGJvb2xcbiAgdmFsIGZvcl9hbGxpIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gYm9vbFxuICB2YWwgZm9yX2FsbCA6IChfLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiBib29sXG4gIHZhbCBjb3VudGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKSAtPiBpbnRcbiAgdmFsIGNvdW50IDogKF8sICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+IGludFxuICB2YWwgbGVuZ3RoIDogKF8sIF8pIHQgLT4gaW50XG4gIHZhbCBpc19lbXB0eSA6IChfLCBfKSB0IC0+IGJvb2xcbiAgdmFsIG1lbSA6ICgnYSwgXykgdCAtPiAnYSBrZXkgLT4gYm9vbFxuICB2YWwgcmVtb3ZlIDogKCdhLCBfKSB0IC0+ICdhIGtleSAtPiB1bml0XG4gIHZhbCBjaG9vc2UgOiAoJ2EsICdiKSB0IC0+ICgnYSBrZXkgKiAnYikgb3B0aW9uXG4gIHZhbCBjaG9vc2VfZXhuIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgKiAnYlxuXG4gICgqKiBTZXRzIHRoZSBnaXZlbiBba2V5XSB0byBbZGF0YV0uICopXG4gIHZhbCBzZXQgOiAoJ2EsICdiKSB0IC0+IGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiB1bml0XG5cbiAgKCoqIFthZGRdIGFuZCBbYWRkX2V4bl0gbGVhdmUgdGhlIHRhYmxlIHVuY2hhbmdlZCBpZiB0aGUga2V5IHdhcyBhbHJlYWR5IHByZXNlbnQuICopXG4gIHZhbCBhZGQgOiAoJ2EsICdiKSB0IC0+IGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBbIGBPayB8IGBEdXBsaWNhdGUgXVxuXG4gIHZhbCBhZGRfZXhuIDogKCdhLCAnYikgdCAtPiBrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gdW5pdFxuXG4gICgqKiBbY2hhbmdlIHQga2V5IH5mXSBjaGFuZ2VzIFt0XSdzIHZhbHVlIGZvciBba2V5XSB0byBiZSBbZiAoZmluZCB0IGtleSldLiAqKVxuICB2YWwgY2hhbmdlIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gZjooJ2Igb3B0aW9uIC0+ICdiIG9wdGlvbikgLT4gdW5pdFxuXG4gICgqKiBbdXBkYXRlIHQga2V5IH5mXSBpcyBbY2hhbmdlIHQga2V5IH5mOihmdW4gbyAtPiBTb21lIChmIG8pKV0uICopXG4gIHZhbCB1cGRhdGUgOiAoJ2EsICdiKSB0IC0+ICdhIGtleSAtPiBmOignYiBvcHRpb24gLT4gJ2IpIC0+IHVuaXRcblxuICAoKiogW3VwZGF0ZV9hbmRfcmV0dXJuIHQga2V5IH5mXSBpcyBbdXBkYXRlXSwgYnV0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBbZiBvXS4gKilcbiAgdmFsIHVwZGF0ZV9hbmRfcmV0dXJuIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gZjooJ2Igb3B0aW9uIC0+ICdiKSAtPiAnYlxuXG4gICgqKiBbbWFwIHQgZl0gcmV0dXJucyBhIG5ldyB0YWJsZSB3aXRoIHZhbHVlcyByZXBsYWNlZCBieSB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIFtmXVxuICAgICAgdG8gdGhlIGN1cnJlbnQgdmFsdWVzLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgbGV0IGggPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA0KTsgKDUsIDYpXSBpblxuICAgICAgbGV0IGgnID0gSGFzaHRibC5tYXAgaCB+ZjooZnVuIHggLT4geCAqIDIpIGluXG4gICAgICBIYXNodGJsLnRvX2FsaXN0IGgnOztcbiAgICAgIC0gOiAoaW50ICogaW50KSBsaXN0ID0gWyg1LCAxMik7ICgxLCA4KV1cbiAgICAgIHZ9ICopXG4gIHZhbCBtYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICdjKSAtPiAoJ2EsICdjKSB0XG5cbiAgKCoqIExpa2UgW21hcF0sIGJ1dCB0aGUgZnVuY3Rpb24gW2ZdIHRha2VzIGJvdGgga2V5IGFuZCBkYXRhIGFzIGFyZ3VtZW50cy4gKilcbiAgdmFsIG1hcGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYykgLT4gKCdhLCAnYykgdFxuXG4gICgqKiBSZXR1cm5zIGEgbmV3IHRhYmxlIGJ5IGZpbHRlcmluZyB0aGUgZ2l2ZW4gdGFibGUncyB2YWx1ZXMgYnkgW2ZdOiB0aGUga2V5cyBmb3Igd2hpY2hcbiAgICAgIFtmXSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHZhbHVlIHJldHVybnMgW1NvbWVdIGFyZSBrZXB0LCBhbmQgdGhvc2UgZm9yIHdoaWNoIGl0XG4gICAgICByZXR1cm5zIFtOb25lXSBhcmUgZGlzY2FyZGVkLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgbGV0IGggPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA0KTsgKDUsIDYpXSBpblxuICAgICAgSGFzaHRibC5maWx0ZXJfbWFwIGggfmY6KGZ1biB4IC0+IGlmIHggPiA1IHRoZW4gU29tZSB4IGVsc2UgTm9uZSlcbiAgICAgIHw+IEhhc2h0YmwudG9fYWxpc3Q7O1xuICAgICAgLSA6IChpbnQgKiBpbnQpIGxpc3QgPSBbKDUsIDYpXVxuICAgICAgdn0gKilcbiAgdmFsIGZpbHRlcl9tYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICdjIG9wdGlvbikgLT4gKCdhLCAnYykgdFxuXG4gICgqKiBMaWtlIFtmaWx0ZXJfbWFwXSwgYnV0IHRoZSBmdW5jdGlvbiBbZl0gdGFrZXMgYm90aCBrZXkgYW5kIGRhdGEgYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgZmlsdGVyX21hcGkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnYyBvcHRpb24pIC0+ICgnYSwgJ2MpIHRcblxuICB2YWwgZmlsdGVyX2tleXMgOiAoJ2EsICdiKSB0IC0+IGY6KCdhIGtleSAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG4gIHZhbCBmaWx0ZXIgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+IGJvb2wpIC0+ICgnYSwgJ2IpIHRcbiAgdmFsIGZpbHRlcmkgOiAoJ2EsICdiKSB0IC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0XG5cbiAgKCoqIFJldHVybnMgbmV3IHRhYmxlcyB3aXRoIGJvdW5kIHZhbHVlcyBwYXJ0aXRpb25lZCBieSBbZl0gYXBwbGllZCB0byB0aGUgYm91bmRcbiAgICAgIHZhbHVlcy4gKilcbiAgdmFsIHBhcnRpdGlvbl9tYXAgOiAoJ2EsICdiKSB0IC0+IGY6KCdiIC0+ICgnYywgJ2QpIEVpdGhlci50KSAtPiAoJ2EsICdjKSB0ICogKCdhLCAnZCkgdFxuXG4gICgqKiBMaWtlIFtwYXJ0aXRpb25fbWFwXSwgYnV0IHRoZSBmdW5jdGlvbiBbZl0gdGFrZXMgYm90aCBrZXkgYW5kIGRhdGEgYXMgYXJndW1lbnRzLiAqKVxuICB2YWwgcGFydGl0aW9uX21hcGlcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICgnYywgJ2QpIEVpdGhlci50KVxuICAgIC0+ICgnYSwgJ2MpIHQgKiAoJ2EsICdkKSB0XG5cbiAgKCoqIFJldHVybnMgYSBwYWlyIG9mIHRhYmxlcyBbKHQxLCB0MildLCB3aGVyZSBbdDFdIGNvbnRhaW5zIGFsbCB0aGUgZWxlbWVudHMgb2YgdGhlXG4gICAgICBpbml0aWFsIHRhYmxlIHdoaWNoIHNhdGlzZnkgdGhlIHByZWRpY2F0ZSBbZl0sIGFuZCBbdDJdIGNvbnRhaW5zIHRoZSByZXN0LiAqKVxuICB2YWwgcGFydGl0aW9uX3RmIDogKCdhLCAnYikgdCAtPiBmOignYiAtPiBib29sKSAtPiAoJ2EsICdiKSB0ICogKCdhLCAnYikgdFxuXG4gICgqKiBMaWtlIFtwYXJ0aXRpb25fdGZdLCBidXQgdGhlIGZ1bmN0aW9uIFtmXSB0YWtlcyBib3RoIGtleSBhbmQgZGF0YSBhcyBhcmd1bWVudHMuICopXG4gIHZhbCBwYXJ0aXRpb25pX3RmXG4gICAgOiAgKCdhLCAnYikgdFxuICAgIC0+IGY6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiBib29sKVxuICAgIC0+ICgnYSwgJ2IpIHQgKiAoJ2EsICdiKSB0XG5cbiAgKCoqIFtmaW5kX29yX2FkZCB0IGsgfmRlZmF1bHRdIHJldHVybnMgdGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGtleSBba10gaWYgaXQgaXMgaW4gdGhlXG4gICAgICB0YWJsZSBbdF0sIGFuZCBvdGhlcndpc2UgYXNzaWducyBba10gdGhlIHZhbHVlIHJldHVybmVkIGJ5IFtkZWZhdWx0ICgpXS4gKilcbiAgdmFsIGZpbmRfb3JfYWRkIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gZGVmYXVsdDoodW5pdCAtPiAnYikgLT4gJ2JcblxuICAoKiogTGlrZSBbZmluZF9vcl9hZGRdIGJ1dCBbZGVmYXVsdF0gdGFrZXMgdGhlIGtleSBhcyBhbiBhcmd1bWVudC4gKilcbiAgdmFsIGZpbmRpX29yX2FkZCA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+IGRlZmF1bHQ6KCdhIGtleSAtPiAnYikgLT4gJ2JcblxuICAoKiogW2ZpbmQgdCBrXSByZXR1cm5zIFtTb21lXSAodGhlIGN1cnJlbnQgYmluZGluZykgb2YgW2tdIGluIFt0XSwgb3IgW05vbmVdIGlmIG5vIHN1Y2hcbiAgICAgIGJpbmRpbmcgZXhpc3RzLiAqKVxuICB2YWwgZmluZCA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+ICdiIG9wdGlvblxuXG4gICgqKiBbZmluZF9leG4gdCBrXSByZXR1cm5zIHRoZSBjdXJyZW50IGJpbmRpbmcgb2YgW2tdIGluIFt0XSwgb3IgcmFpc2VzIFtDYW1sLk5vdF9mb3VuZF1cbiAgICAgIG9yIFtOb3RfZm91bmRfc10gaWYgbm8gc3VjaCBiaW5kaW5nIGV4aXN0cy4gKilcbiAgdmFsIGZpbmRfZXhuIDogKCdhLCAnYikgdCAtPiAnYSBrZXkgLT4gJ2JcblxuICAoKiogW2ZpbmRfYW5kX2NhbGwgdCBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXVxuXG4gICAgICBpcyBlcXVpdmFsZW50IHRvOlxuXG4gICAgICBbbWF0Y2ggZmluZCB0IGsgd2l0aCBTb21lIHYgLT4gaWZfZm91bmQgdiB8IE5vbmUgLT4gaWZfbm90X2ZvdW5kIGtdXG5cbiAgICAgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYWxsb2NhdGUgdGhlIG9wdGlvbi4gKilcbiAgdmFsIGZpbmRfYW5kX2NhbGxcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gJ2Ega2V5XG4gICAgLT4gaWZfZm91bmQ6KCdiIC0+ICdjKVxuICAgIC0+IGlmX25vdF9mb3VuZDooJ2Ega2V5IC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgKCoqIEp1c3QgbGlrZSBbZmluZF9hbmRfY2FsbF0sIGJ1dCB0YWtlcyBhbiBleHRyYSBhcmd1bWVudCB3aGljaCBpcyBwYXNzZWQgdG8gW2lmX2ZvdW5kXVxuICAgICAgYW5kIFtpZl9ub3RfZm91bmRdLCBzbyB0aGF0IHRoZSBjbGllbnQgY29kZSBjYW4gYXZvaWQgYWxsb2NhdGluZyBjbG9zdXJlcyBvciB1c2luZ1xuICAgICAgcmVmcyB0byBwYXNzIHRoaXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi4gIFRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VmdWwgaW4gY29kZVxuICAgICAgd2hpY2ggdHJpZXMgdG8gbWluaW1pemUgaGVhcCBhbGxvY2F0aW9uLiAqKVxuICB2YWwgZmluZF9hbmRfY2FsbDFcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gJ2Ega2V5XG4gICAgLT4gYTonZFxuICAgIC0+IGlmX2ZvdW5kOignYiAtPiAnZCAtPiAnYylcbiAgICAtPiBpZl9ub3RfZm91bmQ6KCdhIGtleSAtPiAnZCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBmaW5kX2FuZF9jYWxsMlxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXlcbiAgICAtPiBhOidkXG4gICAgLT4gYjonZVxuICAgIC0+IGlmX2ZvdW5kOignYiAtPiAnZCAtPiAnZSAtPiAnYylcbiAgICAtPiBpZl9ub3RfZm91bmQ6KCdhIGtleSAtPiAnZCAtPiAnZSAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBmaW5kaV9hbmRfY2FsbFxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXlcbiAgICAtPiBpZl9mb3VuZDooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdjKVxuICAgIC0+IGlmX25vdF9mb3VuZDooJ2Ega2V5IC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgdmFsIGZpbmRpX2FuZF9jYWxsMVxuICAgIDogICgnYSwgJ2IpIHRcbiAgICAtPiAnYSBrZXlcbiAgICAtPiBhOidkXG4gICAgLT4gaWZfZm91bmQ6KGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiAnZCAtPiAnYylcbiAgICAtPiBpZl9ub3RfZm91bmQ6KCdhIGtleSAtPiAnZCAtPiAnYylcbiAgICAtPiAnY1xuXG4gIHZhbCBmaW5kaV9hbmRfY2FsbDJcbiAgICA6ICAoJ2EsICdiKSB0XG4gICAgLT4gJ2Ega2V5XG4gICAgLT4gYTonZFxuICAgIC0+IGI6J2VcbiAgICAtPiBpZl9mb3VuZDooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdkIC0+ICdlIC0+ICdjKVxuICAgIC0+IGlmX25vdF9mb3VuZDooJ2Ega2V5IC0+ICdkIC0+ICdlIC0+ICdjKVxuICAgIC0+ICdjXG5cbiAgKCoqIFtmaW5kX2FuZF9yZW1vdmUgdCBrXSByZXR1cm5zIFNvbWUgKHRoZSBjdXJyZW50IGJpbmRpbmcpIG9mIGsgaW4gdCBhbmQgcmVtb3ZlcyBpdCxcbiAgICAgIG9yIE5vbmUgaXMgbm8gc3VjaCBiaW5kaW5nIGV4aXN0cy4gKilcbiAgdmFsIGZpbmRfYW5kX3JlbW92ZSA6ICgnYSwgJ2IpIHQgLT4gJ2Ega2V5IC0+ICdiIG9wdGlvblxuXG4gICgqKiBNZXJnZXMgdHdvIGhhc2h0YWJsZXMuXG5cbiAgICAgIFRoZSByZXN1bHQgb2YgW21lcmdlIGYgaDEgaDJdIGhhcyBhcyBrZXlzIHRoZSBzZXQgb2YgYWxsIFtrXSBpbiB0aGUgdW5pb24gb2YgdGhlXG4gICAgICBzZXRzIG9mIGtleXMgb2YgW2gxXSBhbmQgW2gyXSBmb3Igd2hpY2ggW2QoayldIGlzIG5vdCBOb25lLCB3aGVyZTpcblxuICAgICAgZChrKSA9XG4gICAgICAtIFtmIH5rZXk6ayAoYExlZnQgZDEpXVxuICAgICAgICBpZiBba10gaW4gW2gxXSBtYXBzIHRvIGQxLCBhbmQgW2gyXSBkb2VzIG5vdCBoYXZlIGRhdGEgZm9yIFtrXTtcblxuICAgICAgLSBbZiB+a2V5OmsgKGBSaWdodCBkMildXG4gICAgICAgIGlmIFtrXSBpbiBbaDJdIG1hcHMgdG8gZDIsIGFuZCBbaDFdIGRvZXMgbm90IGhhdmUgZGF0YSBmb3IgW2tdO1xuXG4gICAgICAtIFtmIH5rZXk6ayAoYEJvdGggKGQxLCBkMikpXVxuICAgICAgICBvdGhlcndpc2UsIHdoZXJlIFtrXSBpbiBbaDFdIG1hcHMgdG8gW2QxXSBhbmQgW2tdIGluIFtoMl0gbWFwcyB0byBbZDJdLlxuXG4gICAgICBFYWNoIGtleSBba10gaXMgbWFwcGVkIHRvIGEgc2luZ2xlIHBpZWNlIG9mIGRhdGEgW3hdLCB3aGVyZSBbZChrKSA9IFNvbWUgeF0uXG5cbiAgICAgIEV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaDEgPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA1KTsgKDIsIDMyMzIpXSBpblxuICAgICAgbGV0IGgyID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgMyldIGluXG4gICAgICBIYXNodGJsLm1lcmdlIGgxIGgyIH5mOihmdW4gfmtleTpfIC0+IGZ1bmN0aW9uXG4gICAgICAgIHwgYExlZnQgeCAtPiBTb21lIChgTGVmdCB4KVxuICAgICAgICB8IGBSaWdodCB4IC0+IFNvbWUgKGBSaWdodCB4KVxuICAgICAgICB8IGBCb3RoICh4LCB5KSAtPiBpZiB4PXkgdGhlbiBOb25lIGVsc2UgU29tZSAoYEJvdGggKHgseSkpXG4gICAgICApIHw+IEhhc2h0YmwudG9fYWxpc3Q7O1xuICAgICAgLSA6IChpbnQgKiBbPiBgQm90aCBvZiBpbnQgKiBpbnQgfCBgTGVmdCBvZiBpbnQgfCBgUmlnaHQgb2YgaW50IF0pIGxpc3QgPVxuICAgICAgWygyLCBgTGVmdCAzMjMyKTsgKDEsIGBCb3RoICg1LCAzKSldXG4gICAgICB2fSAqKVxuICB2YWwgbWVyZ2VcbiAgICA6ICAoJ2ssICdhKSB0XG4gICAgLT4gKCdrLCAnYikgdFxuICAgIC0+IGY6KGtleTonayBrZXkgLT4gWyBgTGVmdCBvZiAnYSB8IGBSaWdodCBvZiAnYiB8IGBCb3RoIG9mICdhICogJ2IgXSAtPiAnYyBvcHRpb24pXG4gICAgLT4gKCdrLCAnYykgdFxuXG5cbiAgKCoqIEV2ZXJ5IFtrZXldIGluIFtzcmNdIHdpbGwgYmUgcmVtb3ZlZCBvciBzZXQgaW4gW2RzdF0gYWNjb3JkaW5nIHRvIHRoZSByZXR1cm4gdmFsdWVcbiAgICAgIG9mIFtmXS4gKilcbiAgdmFsIG1lcmdlX2ludG9cbiAgICA6ICBzcmM6KCdrLCAnYSkgdFxuICAgIC0+IGRzdDooJ2ssICdiKSB0XG4gICAgLT4gZjooa2V5OidrIGtleSAtPiAnYSAtPiAnYiBvcHRpb24gLT4gJ2IgTWVyZ2VfaW50b19hY3Rpb24udClcbiAgICAtPiB1bml0XG5cbiAgKCoqIFJldHVybnMgdGhlIGxpc3Qgb2YgYWxsIGtleXMgZm9yIGdpdmVuIGhhc2h0YWJsZS4gKilcbiAgdmFsIGtleXMgOiAoJ2EsIF8pIHQgLT4gJ2Ega2V5IGxpc3RcblxuICAoKiogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgZGF0YSBmb3IgZ2l2ZW4gaGFzaHRhYmxlLiAqKVxuICB2YWwgZGF0YSA6IChfLCAnYikgdCAtPiAnYiBsaXN0XG5cbiAgKCoqIFtmaWx0ZXJfaW5wbGFjZSB0IH5mXSByZW1vdmVzIGFsbCB0aGUgZWxlbWVudHMgZnJvbSBbdF0gdGhhdCBkb24ndCBzYXRpc2Z5IFtmXS4gKilcbiAgdmFsIGZpbHRlcl9rZXlzX2lucGxhY2UgOiAoJ2EsIF8pIHQgLT4gZjooJ2Ega2V5IC0+IGJvb2wpIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyX2lucGxhY2UgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gYm9vbCkgLT4gdW5pdFxuICB2YWwgZmlsdGVyaV9pbnBsYWNlIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gYm9vbCkgLT4gdW5pdFxuXG4gICgqKiBbbWFwX2lucGxhY2UgdCB+Zl0gYXBwbGllcyBbZl0gdG8gYWxsIGVsZW1lbnRzIGluIFt0XSwgdHJhbnNmb3JtaW5nIHRoZW0gaW5cbiAgICAgIHBsYWNlLiAqKVxuICB2YWwgbWFwX2lucGxhY2UgOiAoXywgJ2IpIHQgLT4gZjooJ2IgLT4gJ2IpIC0+IHVuaXRcblxuICB2YWwgbWFwaV9pbnBsYWNlIDogKCdhLCAnYikgdCAtPiBmOihrZXk6J2Ega2V5IC0+IGRhdGE6J2IgLT4gJ2IpIC0+IHVuaXRcblxuICAoKiogW2ZpbHRlcl9tYXBfaW5wbGFjZV0gY29tYmluZXMgdGhlIGVmZmVjdHMgb2YgW21hcF9pbnBsYWNlXSBhbmQgW2ZpbHRlcl9pbnBsYWNlXS4gKilcbiAgdmFsIGZpbHRlcl9tYXBfaW5wbGFjZSA6IChfLCAnYikgdCAtPiBmOignYiAtPiAnYiBvcHRpb24pIC0+IHVuaXRcblxuICB2YWwgZmlsdGVyX21hcGlfaW5wbGFjZSA6ICgnYSwgJ2IpIHQgLT4gZjooa2V5OidhIGtleSAtPiBkYXRhOidiIC0+ICdiIG9wdGlvbikgLT4gdW5pdFxuXG4gICgqKiBbZXF1YWwgZiB0MSB0Ml0gYW5kIFtzaW1pbGFyIGYgdDEgdDJdIGJvdGggcmV0dXJuIHRydWUgaWZmIFt0MV0gYW5kIFt0Ml0gaGF2ZSB0aGVcbiAgICAgIHNhbWUga2V5cyBhbmQgZm9yIGFsbCBrZXlzIFtrXSwgW2YgKGZpbmRfZXhuIHQxIGspIChmaW5kX2V4biB0MiBrKV0uICBbZXF1YWxdIGFuZFxuICAgICAgW3NpbWlsYXJdIG9ubHkgZGlmZmVyIGluIHRoZWlyIHR5cGVzLiAqKVxuICB2YWwgZXF1YWwgOiAoJ2IgLT4gJ2IgLT4gYm9vbCkgLT4gKCdhLCAnYikgdCAtPiAoJ2EsICdiKSB0IC0+IGJvb2xcblxuICB2YWwgc2ltaWxhciA6ICgnYjEgLT4gJ2IyIC0+IGJvb2wpIC0+ICgnYSwgJ2IxKSB0IC0+ICgnYSwgJ2IyKSB0IC0+IGJvb2xcblxuICAoKiogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgKGtleSwgZGF0YSkgcGFpcnMgZm9yIGdpdmVuIGhhc2h0YWJsZS4gKilcbiAgdmFsIHRvX2FsaXN0IDogKCdhLCAnYikgdCAtPiAoJ2Ega2V5ICogJ2IpIGxpc3RcblxuXG4gICgqKiBbcmVtb3ZlX2lmX3plcm9dJ3MgZGVmYXVsdCBpcyBbZmFsc2VdLiAqKVxuICB2YWwgaW5jciA6ID9ieTppbnQgLT4gP3JlbW92ZV9pZl96ZXJvOmJvb2wgLT4gKCdhLCBpbnQpIHQgLT4gJ2Ega2V5IC0+IHVuaXRcblxuICB2YWwgZGVjciA6ID9ieTppbnQgLT4gP3JlbW92ZV9pZl96ZXJvOmJvb2wgLT4gKCdhLCBpbnQpIHQgLT4gJ2Ega2V5IC0+IHVuaXRcbmVuZFxuXG5tb2R1bGUgdHlwZSBNdWx0aSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRcbiAgdHlwZSAnYSBrZXlcblxuICAoKiogW2FkZF9tdWx0aSB0IH5rZXkgfmRhdGFdIGlmIFtrZXldIGlzIHByZXNlbnQgaW4gdGhlIHRhYmxlIHRoZW4gY29uc1xuICAgICAgW2RhdGFdIG9uIHRoZSBsaXN0LCBvdGhlcndpc2UgYWRkIFtrZXldIHdpdGggYSBzaW5nbGUgZWxlbWVudCBsaXN0LiAqKVxuICB2YWwgYWRkX211bHRpIDogKCdhLCAnYiBsaXN0KSB0IC0+IGtleTonYSBrZXkgLT4gZGF0YTonYiAtPiB1bml0XG5cbiAgKCoqIFtyZW1vdmVfbXVsdGkgdCBrZXldIHVwZGF0ZXMgdGhlIHRhYmxlLCByZW1vdmluZyB0aGUgaGVhZCBvZiB0aGUgbGlzdCBib3VuZCB0b1xuICAgICAgW2tleV0uIElmIHRoZSBsaXN0IGhhcyBvbmx5IG9uZSBlbGVtZW50IChvciBpcyBlbXB0eSkgdGhlbiB0aGUgYmluZGluZyBpc1xuICAgICAgcmVtb3ZlZC4gKilcbiAgdmFsIHJlbW92ZV9tdWx0aSA6ICgnYSwgXyBsaXN0KSB0IC0+ICdhIGtleSAtPiB1bml0XG5cbiAgKCoqIFtmaW5kX211bHRpIHQga2V5XSByZXR1cm5zIHRoZSBlbXB0eSBsaXN0IGlmIFtrZXldIGlzIG5vdCBwcmVzZW50IGluIHRoZSB0YWJsZSxcbiAgICAgIHJldHVybnMgW3RdJ3MgdmFsdWVzIGZvciBba2V5XSBvdGhlcndpc2UuICopXG4gIHZhbCBmaW5kX211bHRpIDogKCdhLCAnYiBsaXN0KSB0IC0+ICdhIGtleSAtPiAnYiBsaXN0XG5lbmRcblxudHlwZSAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9ucyA9XG4gID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gIC0+ICdrZXkgS2V5LnRcbiAgLT4gJ3pcblxudHlwZSAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZSA9XG4gID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gIC0+ICd6XG5cbm1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG4gIHR5cGUgJ2Ega2V5XG4gIHR5cGUgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgY3JlYXRlIDogKCdhIGtleSwgJ2IsIHVuaXQgLT4gKCdhLCAnYikgdCkgY3JlYXRlX29wdGlvbnNcblxuXG4gIHZhbCBvZl9hbGlzdFxuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ2JcbiAgICAgICwgKCdhIGtleSAqICdiKSBsaXN0IC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBrZXkgXSApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwc1xuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ2JcbiAgICAgICwgKCdhIGtleSAqICdiKSBsaXN0IC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2Ega2V5IGxpc3QgXSApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5cbiAgdmFsIG9mX2FsaXN0X29yX2Vycm9yXG4gICAgOiAoJ2Ega2V5LCAnYiwgKCdhIGtleSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IpIHQgT3JfZXJyb3IudCkgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgb2ZfYWxpc3RfZXhuIDogKCdhIGtleSwgJ2IsICgnYSBrZXkgKiAnYikgbGlzdCAtPiAoJ2EsICdiKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogKCdhIGtleSwgJ2IgbGlzdCwgKCdhIGtleSAqICdiKSBsaXN0IC0+ICgnYSwgJ2IgbGlzdCkgdCkgY3JlYXRlX29wdGlvbnNcblxuXG4gICgqKiB7WyBjcmVhdGVfbWFwcGVkIGdldF9rZXkgZ2V0X2RhdGEgW3gxLC4uLix4bl1cbiAgICAgICAgID0gb2ZfYWxpc3QgW2dldF9rZXkgeDEsIGdldF9kYXRhIHgxOyAuLi47IGdldF9rZXkgeG4sIGdldF9kYXRhIHhuXSBdfSAqKVxuICB2YWwgY3JlYXRlX21hcHBlZFxuICAgIDogKCAnYSBrZXlcbiAgICAgICwgJ2JcbiAgICAgICwgZ2V0X2tleTooJ3IgLT4gJ2Ega2V5KVxuICAgICAgICAtPiBnZXRfZGF0YTooJ3IgLT4gJ2IpXG4gICAgICAgIC0+ICdyIGxpc3RcbiAgICAgICAgLT4gWyBgT2sgb2YgKCdhLCAnYikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBrZXkgbGlzdCBdIClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuXG4gICgqKiB7WyBjcmVhdGVfd2l0aF9rZXkgfmdldF9rZXkgW3gxLC4uLix4bl1cbiAgICAgICAgID0gb2ZfYWxpc3QgW2dldF9rZXkgeDEsIHgxOyAuLi47IGdldF9rZXkgeG4sIHhuXSBdfSAqKVxuICB2YWwgY3JlYXRlX3dpdGhfa2V5XG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnclxuICAgICAgLCBnZXRfa2V5OignciAtPiAnYSBrZXkpXG4gICAgICAgIC0+ICdyIGxpc3RcbiAgICAgICAgLT4gWyBgT2sgb2YgKCdhLCAncikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBrZXkgbGlzdCBdIClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yXG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnclxuICAgICAgLCBnZXRfa2V5OignciAtPiAnYSBrZXkpIC0+ICdyIGxpc3QgLT4gKCdhLCAncikgdCBPcl9lcnJvci50IClcbiAgICAgICAgY3JlYXRlX29wdGlvbnNcblxuICB2YWwgY3JlYXRlX3dpdGhfa2V5X2V4blxuICAgIDogKCdhIGtleSwgJ3IsIGdldF9rZXk6KCdyIC0+ICdhIGtleSkgLT4gJ3IgbGlzdCAtPiAoJ2EsICdyKSB0KSBjcmVhdGVfb3B0aW9uc1xuXG5cbiAgdmFsIGdyb3VwXG4gICAgOiAoICdhIGtleVxuICAgICAgLCAnYlxuICAgICAgLCBnZXRfa2V5OignciAtPiAnYSBrZXkpXG4gICAgICAgIC0+IGdldF9kYXRhOignciAtPiAnYilcbiAgICAgICAgLT4gY29tYmluZTooJ2IgLT4gJ2IgLT4gJ2IpXG4gICAgICAgIC0+ICdyIGxpc3RcbiAgICAgICAgLT4gKCdhLCAnYikgdCApXG4gICAgICAgIGNyZWF0ZV9vcHRpb25zXG5lbmRcblxubW9kdWxlIHR5cGUgQ3JlYXRvcnMgPSBzaWdcbiAgdHlwZSAoJ2EsICdiKSB0XG5cbiAgKCoqIHsyIENyZWF0b3JzfSAqKVxuXG4gICgqKiBUaGUgbW9kdWxlIHlvdSBwYXNzIHRvIFtjcmVhdGVdIG11c3QgaGF2ZSBhIHR5cGUgdGhhdCBpcyBoYXNoYWJsZSwgc2V4cGFibGUsIGFuZFxuICAgICAgY29tcGFyYWJsZS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAge3ZcbiAgICAgICAgSGFzaHRibC5jcmVhdGUgKG1vZHVsZSBJbnQpOztcbiAgICAgICAgLSA6IChpbnQsICdfYSkgSGFzaHRibC50ID0gPGFic3RyPjs7XG4gICAgICB2fSAqKVxuICB2YWwgY3JlYXRlXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gKCdhLCAnYikgdFxuXG4gICgqKiBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgICAgSGFzaHRibC5vZl9hbGlzdCAobW9kdWxlIEludCkgWygzLCBcInNvbWV0aGluZ1wiKTsgKDIsIFwid2hhdGV2ZXJcIildXG4gICAgICAgICAtIDogWyBgRHVwbGljYXRlX2tleSBvZiBpbnQgfCBgT2sgb2YgKGludCwgc3RyaW5nKSBIYXNodGJsLnQgXSA9IGBPayA8YWJzdHI+XG4gICAgICB2fSAqKVxuICB2YWwgb2ZfYWxpc3RcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiAoJ2EgKiAnYikgbGlzdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleSBvZiAnYSBdXG5cbiAgKCoqIFdoZXJlYXMgW29mX2FsaXN0XSB3aWxsIHJlcG9ydCBbRHVwbGljYXRlX2tleV0gbm8gbWF0dGVyIGhvdyBtYW55IGR1cHMgdGhlcmUgYXJlIGluXG4gICAgICB5b3VyIGxpc3QsIFtvZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHNdIHdpbGwgcmVwb3J0IGVhY2ggYW5kIGV2ZXJ5IGR1cGxpY2F0ZSBlbnRyeS5cblxuICAgICAgRm9yIGV4YW1wbGU6XG5cbiAgICAgIHt2XG4gICAgICAgIEhhc2h0Ymwub2ZfYWxpc3QgKG1vZHVsZSBJbnQpIFsoMSwgXCJmb29cIik7ICgxLCBcImJhclwiKTsgKDIsIFwiZm9vXCIpOyAoMiwgXCJiYXJcIildOztcbiAgICAgICAgLSA6IFsgYER1cGxpY2F0ZV9rZXkgb2YgaW50IHwgYE9rIG9mIChpbnQsIHN0cmluZykgSGFzaHRibC50IF0gPSBgRHVwbGljYXRlX2tleSAxXG5cbiAgICAgICAgSGFzaHRibC5vZl9hbGlzdF9yZXBvcnRfYWxsX2R1cHMgKG1vZHVsZSBJbnQpIFsoMSwgXCJmb29cIik7ICgxLCBcImJhclwiKTsgKDIsIFwiZm9vXCIpOyAoMiwgXCJiYXJcIildOztcbiAgICAgICAgLSA6IFsgYER1cGxpY2F0ZV9rZXlzIG9mIGludCBsaXN0IHwgYE9rIG9mIChpbnQsIHN0cmluZykgSGFzaHRibC50IF0gPSBgRHVwbGljYXRlX2tleXMgWzE7IDJdXG4gICAgICB2fSAqKVxuICB2YWwgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gKCdhICogJ2IpIGxpc3RcbiAgICAtPiBbIGBPayBvZiAoJ2EsICdiKSB0IHwgYER1cGxpY2F0ZV9rZXlzIG9mICdhIGxpc3QgXVxuXG4gIHZhbCBvZl9hbGlzdF9vcl9lcnJvclxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYikgdCBPcl9lcnJvci50XG5cbiAgdmFsIG9mX2FsaXN0X2V4blxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYikgdFxuXG4gICgqKiBDcmVhdGVzIGEge3shTXVsdGl9IFwibXVsdGlcIn0gaGFzaHRhYmxlLCBpLmUuLCBhIGhhc2h0YWJsZSB3aGVyZSBlYWNoIGtleSBwb2ludHMgdG8gYVxuICAgICAgbGlzdCBwb3RlbnRpYWxseSBjb250YWluaW5nIG11bHRpcGxlIHZhbHVlcy4gU28gaW5zdGVhZCBvZiBzaG9ydC1jaXJjdWl0aW5nIHdpdGggYVxuICAgICAgW2BEdXBsaWNhdGVfa2V5XSB2YXJpYW50IG9uIGR1cGxpY2F0ZXMsIGFzIGluIFtvZl9hbGlzdF0sIFtvZl9hbGlzdF9tdWx0aV0gZm9sZHNcbiAgICAgIHRob3NlIHZhbHVlcyBpbnRvIGEgbGlzdCBmb3IgdGhlIGdpdmVuIGtleTpcblxuICAgICAge3ZcbiAgICAgIGxldCBoID0gSGFzaHRibC5vZl9hbGlzdF9tdWx0aSAobW9kdWxlIEludCkgWygxLCBcImFcIik7ICgxLCBcImJcIik7ICgyLCBcImNcIik7ICgyLCBcImRcIildOztcbiAgICAgIHZhbCBoIDogKGludCwgc3RyaW5nIGxpc3QpIEhhc2h0YmwudCA9IDxhYnN0cj5cblxuICAgICAgSGFzaHRibC5maW5kX2V4biBoIDE7O1xuICAgICAgLSA6IHN0cmluZyBsaXN0ID0gW1wiYlwiOyBcImFcIl1cbiAgICAgIHZ9ICopXG4gIHZhbCBvZl9hbGlzdF9tdWx0aVxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+ICgnYSAqICdiKSBsaXN0XG4gICAgLT4gKCdhLCAnYiBsaXN0KSB0XG5cbiAgKCoqIEFwcGxpZXMgdGhlIFtnZXRfa2V5XSBhbmQgW2dldF9kYXRhXSBmdW5jdGlvbnMgdG8gdGhlIFsnciBsaXN0XSB0byBjcmVhdGUgdGhlXG4gICAgICBpbml0aWFsIGtleXMgYW5kIHZhbHVlcywgcmVzcGVjdGl2ZWx5LCBmb3IgdGhlIG5ldyBoYXNodGFibGUuXG5cbiAgICAgIHtbIGNyZWF0ZV9tYXBwZWQgZ2V0X2tleSBnZXRfZGF0YSBbeDE7Li4uO3huXVxuICAgICAgICAgPSBvZl9hbGlzdCBbZ2V0X2tleSB4MSwgZ2V0X2RhdGEgeDE7IC4uLjsgZ2V0X2tleSB4biwgZ2V0X2RhdGEgeG5dXG4gICAgICBdfVxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgICBsZXQgaCA9XG4gICAgICAgICAgSGFzaHRibC5jcmVhdGVfbWFwcGVkIChtb2R1bGUgSW50KVxuICAgICAgICAgICAgfmdldF9rZXk6KGZ1biB4IC0+IHgpXG4gICAgICAgICAgICB+Z2V0X2RhdGE6KGZ1biB4IC0+IHggKyAxKVxuICAgICAgICAgICBbMTsgMjsgM107O1xuICAgICAgICB2YWwgaCA6IFsgYER1cGxpY2F0ZV9rZXlzIG9mIGludCBsaXN0IHwgYE9rIG9mIChpbnQsIGludCkgSGFzaHRibC50IF0gPSBgT2sgPGFic3RyPlxuXG4gICAgICAgIGxldCBoID1cbiAgICAgICAgICBtYXRjaCBoIHdpdGhcbiAgICAgICAgICB8IGBPayB4IC0+IHhcbiAgICAgICAgICB8IGBEdXBsaWNhdGVfa2V5cyBfIC0+IGZhaWx3aXRoIFwiXCJcbiAgICAgICAgaW5cbiAgICAgICAgSGFzaHRibC5maW5kX2V4biBoIDE7O1xuICAgICAgICAtIDogaW50ID0gMlxuICAgICAgdn0gKilcbiAgdmFsIGNyZWF0ZV9tYXBwZWRcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiBnZXRfa2V5OignciAtPiAnYSlcbiAgICAtPiBnZXRfZGF0YTooJ3IgLT4gJ2IpXG4gICAgLT4gJ3IgbGlzdFxuICAgIC0+IFsgYE9rIG9mICgnYSwgJ2IpIHQgfCBgRHVwbGljYXRlX2tleXMgb2YgJ2EgbGlzdCBdXG5cbiAgKCoqIHtbIGNyZWF0ZV93aXRoX2tleSB+Z2V0X2tleSBbeDE7Li4uO3huXVxuICAgICAgICAgPSBvZl9hbGlzdCBbZ2V0X2tleSB4MSwgeDE7IC4uLjsgZ2V0X2tleSB4biwgeG5dIF19ICopXG4gIHZhbCBjcmVhdGVfd2l0aF9rZXlcbiAgICA6ICA/Z3Jvd3RoX2FsbG93ZWQ6Ym9vbCAoKiogZGVmYXVsdHMgdG8gW3RydWVdICopXG4gICAgLT4gP3NpemU6aW50ICgqKiBpbml0aWFsIHNpemUgLS0gZGVmYXVsdCAwICopXG4gICAgLT4gJ2EgS2V5LnRcbiAgICAtPiBnZXRfa2V5OignciAtPiAnYSlcbiAgICAtPiAnciBsaXN0XG4gICAgLT4gWyBgT2sgb2YgKCdhLCAncikgdCB8IGBEdXBsaWNhdGVfa2V5cyBvZiAnYSBsaXN0IF1cblxuICB2YWwgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gZ2V0X2tleTooJ3IgLT4gJ2EpXG4gICAgLT4gJ3IgbGlzdFxuICAgIC0+ICgnYSwgJ3IpIHQgT3JfZXJyb3IudFxuXG4gIHZhbCBjcmVhdGVfd2l0aF9rZXlfZXhuXG4gICAgOiAgP2dyb3d0aF9hbGxvd2VkOmJvb2wgKCoqIGRlZmF1bHRzIHRvIFt0cnVlXSAqKVxuICAgIC0+ID9zaXplOmludCAoKiogaW5pdGlhbCBzaXplIC0tIGRlZmF1bHQgMCAqKVxuICAgIC0+ICdhIEtleS50XG4gICAgLT4gZ2V0X2tleTooJ3IgLT4gJ2EpXG4gICAgLT4gJ3IgbGlzdFxuICAgIC0+ICgnYSwgJ3IpIHRcblxuICAoKiogTGlrZSBbY3JlYXRlX21hcHBlZF0sIGFwcGxpZXMgdGhlIFtnZXRfa2V5XSBhbmQgW2dldF9kYXRhXSBmdW5jdGlvbnMgdG8gdGhlIFsnclxuICAgICAgbGlzdF0gdG8gY3JlYXRlIHRoZSBpbml0aWFsIGtleXMgYW5kIHZhbHVlcywgcmVzcGVjdGl2ZWx5LCBmb3IgdGhlIG5ldyBoYXNodGFibGUgLS1cbiAgICAgIGFuZCB0aGVuLCBsaWtlIFthZGRfbXVsdGldLCBmb2xkcyB0b2dldGhlciB2YWx1ZXMgYmVsb25naW5nIHRvIHRoZSBzYW1lIGtleXMuIEhlcmUsXG4gICAgICB0aG91Z2gsIHRoZSBmdW5jdGlvbiB1c2VkIGZvciB0aGUgZm9sZGluZyBpcyBnaXZlbiBieSBbY29tYmluZV0gKGluc3RlYWQgb2YganVzdFxuICAgICAgYmVpbmcgYSBbY29uc10pLlxuXG4gICAgICBFeGFtcGxlOlxuXG4gICAgICB7dlxuICAgICAgICAgSGFzaHRibC5ncm91cCAobW9kdWxlIEludClcbiAgICAgICAgICAgfmdldF9rZXk6KGZ1biB4IC0+IHggLyAyKVxuICAgICAgICAgICB+Z2V0X2RhdGE6KGZ1biB4IC0+IHgpXG4gICAgICAgICAgIH5jb21iaW5lOihmdW4geCB5IC0+IHggKiB5KVxuICAgICAgICAgICAgWyAxOyAyOyAzOyA0XVxuICAgICAgICAgfD4gSGFzaHRibC50b19hbGlzdDs7XG4gICAgICAgICAtIDogKGludCAqIGludCkgbGlzdCA9IFsoMiwgNCk7ICgxLCA2KTsgKDAsIDEpXVxuICAgICAgIHZ9ICopXG4gIHZhbCBncm91cFxuICAgIDogID9ncm93dGhfYWxsb3dlZDpib29sICgqKiBkZWZhdWx0cyB0byBbdHJ1ZV0gKilcbiAgICAtPiA/c2l6ZTppbnQgKCoqIGluaXRpYWwgc2l6ZSAtLSBkZWZhdWx0IDAgKilcbiAgICAtPiAnYSBLZXkudFxuICAgIC0+IGdldF9rZXk6KCdyIC0+ICdhKVxuICAgIC0+IGdldF9kYXRhOignciAtPiAnYilcbiAgICAtPiBjb21iaW5lOignYiAtPiAnYiAtPiAnYilcbiAgICAtPiAnciBsaXN0XG4gICAgLT4gKCdhLCAnYikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfd2l0aG91dF9zdWJtb2R1bGVzID0gc2lnXG4gIHZhbCBoYXNoIDogJ2EgLT4gaW50XG4gIHZhbCBoYXNoX3BhcmFtIDogaW50IC0+IGludCAtPiAnYSAtPiBpbnRcblxuICB0eXBlICgnYSwgJ2IpIHRcblxuICAoKiogV2UgcHJvdmlkZSBhIFtzZXhwX29mX3RdIGJ1dCBub3QgYSBbdF9vZl9zZXhwXSBmb3IgdGhpcyB0eXBlIGJlY2F1c2Ugb25lIG5lZWRzIHRvIGJlXG4gICAgICBleHBsaWNpdCBhYm91dCB0aGUgaGFzaCBhbmQgY29tcGFyaXNvbiBmdW5jdGlvbnMgdXNlZCB3aGVuIGNyZWF0aW5nIGEgaGFzaHRhYmxlLlxuICAgICAgTm90ZSB0aGF0IFtIYXNodGJsLlBvbHkudF0gZG9lcyBoYXZlIFtbQEBkZXJpdmluZyBzZXhwXV0sIGFuZCB1c2VzIE9DYW1sJ3MgYnVpbHQtaW5cbiAgICAgIHBvbHltb3JwaGljIGNvbXBhcmlzb24gYW5kIGFuZCBwb2x5bW9ycGhpYyBoYXNoaW5nLiAqKVxuICB2YWwgc2V4cF9vZl90IDogKCdhIC0+IFNleHAudCkgLT4gKCdiIC0+IFNleHAudCkgLT4gKCdhLCAnYikgdCAtPiBTZXhwLnRcblxuICBpbmNsdWRlIENyZWF0b3JzIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgKCoqIEBpbmxpbmUgKilcblxuICBpbmNsdWRlIEFjY2Vzc29ycyB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0IHdpdGggdHlwZSAnYSBrZXkgPSAnYVxuICAoKiogQGlubGluZSAqKVxuXG5cbiAgaW5jbHVkZSBNdWx0aSB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0IHdpdGggdHlwZSAnYSBrZXkgOj0gJ2Ega2V5XG4gICgqKiBAaW5saW5lICopXG5cbiAgdmFsIGhhc2hhYmxlX3MgOiAoJ2tleSwgXykgdCAtPiAna2V5IEtleS50XG5cbiAgaW5jbHVkZSBJbnZhcmlhbnQuUzIgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNfcG9seSA9IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBpbmNsdWRlIFNleHBsaWIwLlNleHBhYmxlLlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICB2YWwgdF9zZXhwX2dyYW1tYXJcbiAgICA6ICAnYSBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuICAgIC0+ICdiIFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgLT4gKCdhLCAnYikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5cbiAgdmFsIGhhc2hhYmxlIDogJ2EgSGFzaGFibGUudFxuXG4gIGluY2x1ZGUgSW52YXJpYW50LlMyIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRcbiAgICB3aXRoIHR5cGUgJ2Ega2V5ID0gJ2FcbiAgICB3aXRoIHR5cGUgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnMgOj1cbiAgICAgICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zX3dpdGhvdXRfZmlyc3RfY2xhc3NfbW9kdWxlXG5cbiAgaW5jbHVkZSBBY2Nlc3NvcnMgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdCB3aXRoIHR5cGUgJ2Ega2V5IDo9ICdhIGtleVxuICBpbmNsdWRlIE11bHRpIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHQgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBrZXlcbmVuZFxuXG5tb2R1bGUgdHlwZSBGb3JfZGVyaXZpbmcgPSBzaWdcbiAgdHlwZSAoJ2ssICd2KSB0XG5cbiAgbW9kdWxlIHR5cGUgU2V4cF9vZl9tID0gc2lnXG4gICAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gICAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgICBbQEBAZW5kXVxuICBlbmRcblxuICBtb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIG9mX3NleHBdXG5cbiAgICB2YWwgdF9vZl9zZXhwIDogU2V4cGxpYjAuU2V4cC50IC0+IHRcblxuICAgIFtAQEBlbmRdXG5cbiAgICBpbmNsdWRlIEtleS5TIHdpdGggdHlwZSB0IDo9IHRcbiAgZW5kXG5cbiAgbW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfZ3JhbW1hcl1cblxuICAgIHZhbCB0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcblxuICAgIFtAQEBlbmRdXG4gIGVuZFxuXG4gIG1vZHVsZSB0eXBlIEVxdWFsX20gPSBzaWcgZW5kXG5cbiAgdmFsIHNleHBfb2ZfbV9fdFxuICAgIDogIChtb2R1bGUgU2V4cF9vZl9tIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gKCd2IC0+IFNleHAudClcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgLT4gU2V4cC50XG5cbiAgdmFsIG1fX3Rfb2Zfc2V4cFxuICAgIDogIChtb2R1bGUgTV9vZl9zZXhwIHdpdGggdHlwZSB0ID0gJ2spXG4gICAgLT4gKFNleHAudCAtPiAndilcbiAgICAtPiBTZXhwLnRcbiAgICAtPiAoJ2ssICd2KSB0XG5cbiAgdmFsIG1fX3Rfc2V4cF9ncmFtbWFyXG4gICAgOiAgKG1vZHVsZSBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9ICdrKVxuICAgIC0+ICd2IFNleHBsaWIwLlNleHBfZ3JhbW1hci50XG4gICAgLT4gKCdrLCAndikgdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIHZhbCBlcXVhbF9tX190XG4gICAgOiAgKG1vZHVsZSBFcXVhbF9tKVxuICAgIC0+ICgndiAtPiAndiAtPiBib29sKVxuICAgIC0+ICgnaywgJ3YpIHRcbiAgICAtPiAoJ2ssICd2KSB0XG4gICAgLT4gYm9vbFxuZW5kXG5cbm1vZHVsZSB0eXBlIEhhc2h0YmwgPSBzaWdcbiAgKCoqIEEgaGFzaCB0YWJsZSBpcyBhIG11dGFibGUgZGF0YSBzdHJ1Y3R1cmUgaW1wbGVtZW50aW5nIGEgbWFwIGJldHdlZW4ga2V5cyBhbmQgdmFsdWVzLlxuICAgICAgSXQgc3VwcG9ydHMgY29uc3RhbnQtdGltZSBsb29rdXAgYW5kIGluLXBsYWNlIG1vZGlmaWNhdGlvbi5cblxuICAgICAgezEgVXNhZ2V9XG5cbiAgICAgIEFzIGEgc2ltcGxlIGV4YW1wbGUsIHdlJ2xsIGNyZWF0ZSBhIGhhc2ggdGFibGUgd2l0aCBzdHJpbmcga2V5cyB1c2luZyB0aGVcbiAgICAgIHt7IWNyZWF0ZX1bY3JlYXRlXX0gY29uc3RydWN0b3IsIHdoaWNoIGV4cGVjdHMgYSBtb2R1bGUgZGVmaW5pbmcgdGhlIGtleSdzIHR5cGU6XG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBoID0gSGFzaHRibC5jcmVhdGUgKG1vZHVsZSBTdHJpbmcpOztcbiAgICAgICAgdmFsIGggOiAoc3RyaW5nLCAnX2EpIEhhc2h0YmwudCA9IDxhYnN0cj5cbiAgICAgIF19XG5cbiAgICAgIFdlIGNhbiBzZXQgdGhlIHZhbHVlcyBvZiBpbmRpdmlkdWFsIGtleXMgd2l0aCB7eyFzZXR9W3NldF19LiBJZiB0aGUga2V5IGFscmVhZHkgaGFzXG4gICAgICBhIHZhbHVlLCBpdCB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuXG4gICAgICB7dlxuICAgICAgSGFzaHRibC5zZXQgaCB+a2V5OlwiZm9vXCIgfmRhdGE6NTs7XG4gICAgICAtIDogdW5pdCA9ICgpXG5cbiAgICAgIEhhc2h0Ymwuc2V0IGggfmtleTpcImZvb1wiIH5kYXRhOjY7O1xuICAgICAgLSA6IHVuaXQgPSAoKVxuXG4gICAgICBIYXNodGJsLnNldCBoIH5rZXk6XCJiYXJcIiB+ZGF0YTo2OztcbiAgICAgIC0gOiB1bml0ID0gKClcbiAgICAgIHZ9XG5cbiAgICAgIFdlIGNhbiBhY2Nlc3MgdmFsdWVzIGJ5IGtleSwgb3IgZHVtcCBhbGwgb2YgdGhlIGhhc2ggdGFibGUncyBkYXRhOlxuXG4gICAgICB7dlxuICAgICAgSGFzaHRibC5maW5kIGggXCJmb29cIjs7XG4gICAgICAtIDogaW50IG9wdGlvbiA9IFNvbWUgNlxuXG4gICAgICBIYXNodGJsLmZpbmRfZXhuIGggXCJmb29cIjs7XG4gICAgICAtIDogaW50ID0gNlxuXG4gICAgICBIYXNodGJsLnRvX2FsaXN0IGg7O1xuICAgICAgLSA6IChzdHJpbmcgKiBpbnQpIGxpc3QgPSBbKFwiZm9vXCIsIDYpOyAoXCJiYXJcIiwgNildXG4gICAgICB2fVxuXG4gICAgICB7eyFjaGFuZ2V9W2NoYW5nZV19IGxldHMgdXMgY2hhbmdlIGEga2V5J3MgdmFsdWUgYnkgYXBwbHlpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uOlxuXG4gICAgICB7dlxuICAgICAgSGFzaHRibC5jaGFuZ2UgaCBcImZvb1wiIChmdW4geCAtPlxuICAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgIHwgU29tZSB4IC0+IFNvbWUgKHggKiAyKVxuICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgICApOztcbiAgICAgIC0gOiB1bml0ID0gKClcblxuICAgICAgSGFzaHRibC50b19hbGlzdCBoOztcbiAgICAgIC0gOiAoc3RyaW5nICogaW50KSBsaXN0ID0gWyhcImZvb1wiLCAxMik7IChcImJhclwiLCA2KV1cbiAgICAgIHZ9XG5cblxuICAgICAgV2UgY2FuIHVzZSB7eyFtZXJnZX1bbWVyZ2VdfSB0byBtZXJnZSB0d28gaGFzaHRhYmxlcyB3aXRoIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXJcbiAgICAgIGhvdyB3ZSBjaG9vc2UgdmFsdWVzIHdoZW4gYSBrZXkgaXMgcHJlc2VudCBpbiB0aGUgZmlyc3QgKFwibGVmdFwiKSBoYXNodGFibGUsIHRoZVxuICAgICAgc2Vjb25kIChcInJpZ2h0XCIpLCBvciBib3RoLiBIZXJlLCB3ZSdsbCBjb25zIHRoZSB2YWx1ZXMgd2hlbiBib3RoIGhhc2h0YWJsZXMgaGF2ZSBhXG4gICAgICBrZXk6XG5cbiAgICAgIHt2XG4gICAgICBsZXQgaDEgPSBIYXNodGJsLm9mX2FsaXN0X2V4biAobW9kdWxlIEludCkgWygxLCA1KTsgKDIsIDMyMzIpXSBpblxuICAgICAgbGV0IGgyID0gSGFzaHRibC5vZl9hbGlzdF9leG4gKG1vZHVsZSBJbnQpIFsoMSwgMyldIGluXG4gICAgICBIYXNodGJsLm1lcmdlIGgxIGgyIH5mOihmdW4gfmtleTpfIC0+IGZ1bmN0aW9uXG4gICAgICAgIHwgYExlZnQgeCAtPiBTb21lIChgTGVmdCB4KVxuICAgICAgICB8IGBSaWdodCB4IC0+IFNvbWUgKGBSaWdodCB4KVxuICAgICAgICB8IGBCb3RoICh4LCB5KSAtPiBpZiB4PXkgdGhlbiBOb25lIGVsc2UgU29tZSAoYEJvdGggKHgseSkpXG4gICAgICApIHw+IEhhc2h0YmwudG9fYWxpc3Q7O1xuICAgICAgLSA6IChpbnQgKiBbPiBgQm90aCBvZiBpbnQgKiBpbnQgfCBgTGVmdCBvZiBpbnQgfCBgUmlnaHQgb2YgaW50IF0pIGxpc3QgPVxuICAgICAgWygyLCBgTGVmdCAzMjMyKTsgKDEsIGBCb3RoICg1LCAzKSldXG4gICAgICB2fVxuXG4gICAgICB7MSBJbnRlcmZhY2V9ICopXG5cbiAgaW5jbHVkZSBTX3dpdGhvdXRfc3VibW9kdWxlcyAoKiogQGlubGluZSAqKVxuXG4gIG1vZHVsZSB0eXBlIEFjY2Vzc29ycyA9IEFjY2Vzc29yc1xuICBtb2R1bGUgdHlwZSBDcmVhdG9ycyA9IENyZWF0b3JzXG4gIG1vZHVsZSB0eXBlIE11bHRpID0gTXVsdGlcbiAgbW9kdWxlIHR5cGUgU19wb2x5ID0gU19wb2x5XG4gIG1vZHVsZSB0eXBlIFNfd2l0aG91dF9zdWJtb2R1bGVzID0gU193aXRob3V0X3N1Ym1vZHVsZXNcbiAgbW9kdWxlIHR5cGUgRm9yX2Rlcml2aW5nID0gRm9yX2Rlcml2aW5nXG5cbiAgbW9kdWxlIEtleSA9IEtleVxuICBtb2R1bGUgTWVyZ2VfaW50b19hY3Rpb24gPSBNZXJnZV9pbnRvX2FjdGlvblxuXG4gIHR5cGUgbm9ucmVjICgna2V5LCAnZGF0YSwgJ3opIGNyZWF0ZV9vcHRpb25zID0gKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNcblxuICBtb2R1bGUgQ3JlYXRvcnMgKEtleSA6IHNpZ1xuICAgICAgdHlwZSAnYSB0XG5cbiAgICAgIHZhbCBoYXNoYWJsZSA6ICdhIHQgSGFzaGFibGUudFxuICAgIGVuZCkgOiBzaWdcbiAgICB0eXBlICgnYSwgJ2IpIHRfID0gKCdhIEtleS50LCAnYikgdFxuXG4gICAgdmFsIHRfb2Zfc2V4cCA6IChTZXhwLnQgLT4gJ2EgS2V5LnQpIC0+IChTZXhwLnQgLT4gJ2IpIC0+IFNleHAudCAtPiAoJ2EsICdiKSB0X1xuXG4gICAgaW5jbHVkZVxuICAgICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgICAgd2l0aCB0eXBlICgnYSwgJ2IpIHQgOj0gKCdhLCAnYikgdF9cbiAgICAgIHdpdGggdHlwZSAnYSBrZXkgOj0gJ2EgS2V5LnRcbiAgICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICdhKSBjcmVhdGVfb3B0aW9ucyA6PVxuICAgICAgICAoJ2tleSwgJ2RhdGEsICdhKSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuICBlbmRcblxuICBtb2R1bGUgUG9seSA6IFNfcG9seSB3aXRoIHR5cGUgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcblxuICAoKiogW01dIGlzIG1lYW50IHRvIGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBPQ2FtbCBhcHBsaWNhdGl2ZSBmdW5jdG9yIHR5cGVzOlxuXG4gICAgICB7W1xuICAgICAgICB0eXBlIHN0cmluZ190b19pbnRfdGFibGUgPSBpbnQgSGFzaHRibC5NKFN0cmluZykudFxuICAgICAgXX1cblxuICAgICAgd2hpY2ggc3RhbmRzIGZvcjpcblxuICAgICAge1tcbiAgICAgICAgdHlwZSBzdHJpbmdfdG9faW50X3RhYmxlID0gKFN0cmluZy50LCBpbnQpIEhhc2h0YmwudFxuICAgICAgXX1cblxuICAgICAgVGhlIHBvaW50IGlzIHRoYXQgW2ludCBIYXNodGJsLk0oU3RyaW5nKS50XSBzdXBwb3J0cyBkZXJpdmluZywgd2hlcmVhcyB0aGUgc2Vjb25kXG4gICAgICBzeW50YXggZG9lc24ndCAoYmVjYXVzZSBbdF9vZl9zZXhwXSBkb2Vzbid0IGtub3cgd2hhdCBjb21wYXJpc29uL2hhc2ggZnVuY3Rpb24gdG9cbiAgICAgIHVzZSkuICopXG4gIG1vZHVsZSBNIChLIDogVC5UKSA6IHNpZ1xuICAgIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndikgdFxuICBlbmRcblxuICBpbmNsdWRlIEZvcl9kZXJpdmluZyB3aXRoIHR5cGUgKCdhLCAnYikgdCA6PSAoJ2EsICdiKSB0XG5cbiAgKCoqLyoqKVxuXG4gICgqXyBTZWUgdGhlIEphbmUgU3RyZWV0IFN0eWxlIEd1aWRlIGZvciBhbiBleHBsYW5hdGlvbiBvZiBbUHJpdmF0ZV0gc3VibW9kdWxlczpcblxuICAgIGh0dHBzOi8vb3BlbnNvdXJjZS5qYW5lc3RyZWV0LmNvbS9zdGFuZGFyZHMvI3ByaXZhdGUtc3VibW9kdWxlcyAqKVxuICBtb2R1bGUgUHJpdmF0ZSA6IHNpZ1xuICAgIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG5cbiAgICB0eXBlIG5vbnJlYyAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZSA9XG4gICAgICAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZVxuXG4gICAgdmFsIGhhc2hhYmxlIDogKCdrZXksIF8pIHQgLT4gJ2tleSBIYXNoYWJsZS50XG4gIGVuZFxuZW5kXG4iLCIoKiBBIGZldyBzbWFsbCB0aGluZ3MgY29waWVkIGZyb20gb3RoZXIgcGFydHMgb2YgQmFzZSBiZWNhdXNlIHRoZXkgZGVwZW5kIG9uIHVzLCBzbyB3ZVxuICAgY2FuJ3QgdXNlIHRoZW0uICopXG5cbm9wZW4hIEltcG9ydFxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubW9kdWxlIEludCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgbWF4ICh4IDogdCkgeSA9IGlmIHggPiB5IHRoZW4geCBlbHNlIHlcbmVuZFxuXG4oKiBJdHMgaW1wb3J0YW50IHRoYXQgRW1wdHkgaGF2ZSBubyBhcmdzLiBJdCdzIHRlbXB0aW5nIHRvIG1ha2UgdGhpcyB0eXBlIGEgcmVjb3JkXG4gICAoZS5nLiB0byBob2xkIHRoZSBjb21wYXJlIGZ1bmN0aW9uKSwgYnV0IGEgbG90IG9mIG1lbW9yeSBpcyBzYXZlZCBieSBFbXB0eSBiZWluZyBhblxuICAgaW1tZWRpYXRlLCBzaW5jZSBhbGwgdW51c2VkIGJ1Y2tldHMgaW4gdGhlIGhhc2h0YmwgZG9uJ3QgdXNlIGFueSBtZW1vcnkgKGJlc2lkZXMgdGhlXG4gICBhcnJheSBjZWxsKSAqKVxudHlwZSAoJ2ssICd2KSB0ID1cbiAgfCBFbXB0eVxuICB8IE5vZGUgb2ZcbiAgICAgIHsgbXV0YWJsZSBsZWZ0IDogKCdrLCAndikgdFxuICAgICAgOyBrZXkgOiAna1xuICAgICAgOyBtdXRhYmxlIHZhbHVlIDogJ3ZcbiAgICAgIDsgbXV0YWJsZSBoZWlnaHQgOiBpbnRcbiAgICAgIDsgbXV0YWJsZSByaWdodCA6ICgnaywgJ3YpIHRcbiAgICAgIH1cbiAgfCBMZWFmIG9mXG4gICAgICB7IGtleSA6ICdrXG4gICAgICA7IG11dGFibGUgdmFsdWUgOiAndlxuICAgICAgfVxuXG5sZXQgZW1wdHkgPSBFbXB0eVxuXG5sZXQgaXNfZW1wdHkgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IHRydWVcbiAgfCBMZWFmIF8gfCBOb2RlIF8gLT4gZmFsc2Vcbjs7XG5cbmxldCBoZWlnaHQgPSBmdW5jdGlvblxuICB8IEVtcHR5IC0+IDBcbiAgfCBMZWFmIF8gLT4gMVxuICB8IE5vZGUgeyBsZWZ0ID0gXzsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQ7IHJpZ2h0ID0gXyB9IC0+IGhlaWdodFxuOztcblxubGV0IGludmFyaWFudCBjb21wYXJlID1cbiAgbGV0IGxlZ2FsX2xlZnRfa2V5IGtleSA9IGZ1bmN0aW9uXG4gICAgfCBFbXB0eSAtPiAoKVxuICAgIHwgTGVhZiB7IGtleSA9IGxlZnRfa2V5OyB2YWx1ZSA9IF8gfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBsZWZ0X2tleTsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPlxuICAgICAgYXNzZXJ0IChjb21wYXJlIGxlZnRfa2V5IGtleSA8IDApXG4gIGluXG4gIGxldCBsZWdhbF9yaWdodF9rZXkga2V5ID0gZnVuY3Rpb25cbiAgICB8IEVtcHR5IC0+ICgpXG4gICAgfCBMZWFmIHsga2V5ID0gcmlnaHRfa2V5OyB2YWx1ZSA9IF8gfVxuICAgIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSByaWdodF9rZXk7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gLT5cbiAgICAgIGFzc2VydCAoY29tcGFyZSByaWdodF9rZXkga2V5ID4gMClcbiAgaW5cbiAgbGV0IHJlYyBpbnYgPSBmdW5jdGlvblxuICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gKClcbiAgICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBrOyB2YWx1ZSA9IF87IGhlaWdodCA9IGg7IHJpZ2h0IH0gLT5cbiAgICAgIGxldCBobCwgaHIgPSBoZWlnaHQgbGVmdCwgaGVpZ2h0IHJpZ2h0IGluXG4gICAgICBpbnYgbGVmdDtcbiAgICAgIGludiByaWdodDtcbiAgICAgIGxlZ2FsX2xlZnRfa2V5IGsgbGVmdDtcbiAgICAgIGxlZ2FsX3JpZ2h0X2tleSBrIHJpZ2h0O1xuICAgICAgYXNzZXJ0IChoID0gSW50Lm1heCBobCBociArIDEpO1xuICAgICAgYXNzZXJ0IChhYnMgKGhsIC0gaHIpIDw9IDIpXG4gIGluXG4gIGludlxuOztcblxubGV0IGludmFyaWFudCB0IH5jb21wYXJlID0gaW52YXJpYW50IGNvbXBhcmUgdFxuXG4oKiBJbiB0aGUgZm9sbG93aW5nIGNvbW1lbnRzLFxuICAgJ3QgaXMgYmFsYW5jZWQnIG1lYW5zIHRoYXQgJ2ludmFyaWFudCB0JyBkb2VzIG5vdFxuICAgcmFpc2UgYW4gZXhjZXB0aW9uLiAgVGhpcyBpbXBsaWVzIG9mIGNvdXJzZSB0aGF0IGVhY2ggbm9kZSdzIGhlaWdodCBmaWVsZCBpc1xuICAgY29ycmVjdC5cbiAgICd0IGlzIGJhbGFuY2VhYmxlJyBtZWFucyB0aGF0IGhlaWdodCBvZiB0aGUgbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgb2YgdFxuICAgZGlmZmVyIGJ5IGF0IG1vc3QgMy4gKilcblxuKCogQHByZTogbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgaGF2ZSBjb3JyZWN0IGhlaWdodHNcbiAgIEBwb3N0OiBvdXRwdXQgaGFzIHRoZSBjb3JyZWN0IGhlaWdodCAqKVxubGV0IHVwZGF0ZV9oZWlnaHQgPSBmdW5jdGlvblxuICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBvbGRfaGVpZ2h0OyByaWdodCB9IGFzIHgpIC0+XG4gICAgbGV0IG5ld19oZWlnaHQgPSBJbnQubWF4IChoZWlnaHQgbGVmdCkgKGhlaWdodCByaWdodCkgKyAxIGluXG4gICAgaWYgbmV3X2hlaWdodCA8PiBvbGRfaGVpZ2h0IHRoZW4geC5oZWlnaHQgPC0gbmV3X2hlaWdodFxuICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuOztcblxuKCogQHByZTogbGVmdCBhbmQgcmlnaHQgc3VidHJlZXMgYXJlIGJhbGFuY2VkXG4gICBAcHJlOiB0cmVlIGlzIGJhbGFuY2VhYmxlXG4gICBAcG9zdDogb3V0cHV0IGlzIGJhbGFuY2VkIChpbiBwYXJ0aWN1bGFyLCBoZWlnaHQgaXMgY29ycmVjdCkgKilcbmxldCBiYWxhbmNlIHRyZWUgPVxuICBtYXRjaCB0cmVlIHdpdGhcbiAgfCBFbXB0eSB8IExlYWYgXyAtPiB0cmVlXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gYXMgcm9vdF9ub2RlKSAtPlxuICAgIGxldCBobCA9IGhlaWdodCBsZWZ0XG4gICAgYW5kIGhyID0gaGVpZ2h0IHJpZ2h0IGluXG4gICAgKCogKyAyIGlzIGNyaXRpY2FsbHkgaW1wb3J0YW50LCBsb3dlcmluZyBpdCB0byAxIHdpbGwgYnJlYWsgdGhlIExlYWZcbiAgICAgICBhc3N1bXB0aW9ucyBpbiB0aGUgY29kZSBiZWxvdywgYW5kIHdpbGwgZm9yY2UgdXMgdG8gcHJvbW90ZSBsZWFmIG5vZGVzIGluXG4gICAgICAgdGhlIGJhbGFuY2Ugcm91dGluZS4gSXQncyBhbHNvIGZhc3Rlciwgc2luY2UgaXQgd2lsbCBiYWxhbmNlIGxlc3Mgb2Z0ZW4uXG4gICAgICAgTm90ZSB0aGF0IHRoZSBmb2xsb3dpbmcgY29kZSBpcyBkZWxpY2F0ZS4gIFRoZSB1cGRhdGVfaGVpZ2h0IGNhbGxzIG11c3RcbiAgICAgICBvY2N1ciBpbiB0aGUgY29ycmVjdCBvcmRlciwgc2luY2UgdXBkYXRlX2hlaWdodCBhc3N1bWVzIGl0cyBjaGlsZHJlbiBoYXZlXG4gICAgICAgdGhlIGNvcnJlY3QgaGVpZ2h0cy4gICopXG4gICAgaWYgaGwgPiBociArIDJcbiAgICB0aGVuIChcbiAgICAgIG1hdGNoIGxlZnQgd2l0aFxuICAgICAgKCogSXQgY2Fubm90IGJlIGEgbGVhZiwgYmVjYXVzZSBldmVuIGlmIHJpZ2h0IGlzIGVtcHR5LCBhIGxlYWZcbiAgICAgICAgIGlzIG9ubHkgaGVpZ2h0IDEgKilcbiAgICAgIHwgRW1wdHkgfCBMZWFmIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IE5vZGVcbiAgICAgICAgICAoeyBsZWZ0ID0gbGVmdF9ub2RlX2xlZnRcbiAgICAgICAgICAgOyBrZXkgPSBfXG4gICAgICAgICAgIDsgdmFsdWUgPSBfXG4gICAgICAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgICAgICA7IHJpZ2h0ID0gbGVmdF9ub2RlX3JpZ2h0XG4gICAgICAgICAgIH0gYXMgbGVmdF9ub2RlKSAtPlxuICAgICAgICBpZiBoZWlnaHQgbGVmdF9ub2RlX2xlZnQgPj0gaGVpZ2h0IGxlZnRfbm9kZV9yaWdodFxuICAgICAgICB0aGVuIChcbiAgICAgICAgICByb290X25vZGUubGVmdCA8LSBsZWZ0X25vZGVfcmlnaHQ7XG4gICAgICAgICAgbGVmdF9ub2RlLnJpZ2h0IDwtIHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCB0cmVlO1xuICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgbGVmdDtcbiAgICAgICAgICBsZWZ0KVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICAoKiBpZiByaWdodCBpcyBhIGxlYWYsIHRoZW4gbGVmdCBtdXN0IGJlIGVtcHR5LiBUaGF0IG1lYW5zXG4gICAgICAgICAgICAgaGVpZ2h0IGlzIDIuIEV2ZW4gaWYgaHIgaXMgZW1wdHkgd2Ugc3RpbGwgY2FuJ3QgZ2V0IGhlcmUuICopXG4gICAgICAgICAgbWF0Y2ggbGVmdF9ub2RlX3JpZ2h0IHdpdGhcbiAgICAgICAgICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgTm9kZVxuICAgICAgICAgICAgICAoeyBsZWZ0ID0gbHJfbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IGxyX3JpZ2h0IH0gYXNcbiAgICAgICAgICAgICAgIGxyX25vZGUpIC0+XG4gICAgICAgICAgICBsZWZ0X25vZGUucmlnaHQgPC0gbHJfbGVmdDtcbiAgICAgICAgICAgIHJvb3Rfbm9kZS5sZWZ0IDwtIGxyX3JpZ2h0O1xuICAgICAgICAgICAgbHJfbm9kZS5yaWdodCA8LSB0cmVlO1xuICAgICAgICAgICAgbHJfbm9kZS5sZWZ0IDwtIGxlZnQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IGxlZnQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IGxlZnRfbm9kZV9yaWdodDtcbiAgICAgICAgICAgIGxlZnRfbm9kZV9yaWdodCkpXG4gICAgZWxzZSBpZiBociA+IGhsICsgMlxuICAgIHRoZW4gKFxuICAgICAgKCogc2VlIGFib3ZlIGZvciBhbiBleHBsYW5hdGlvbiBvZiB3aHkgcmlnaHQgY2Fubm90IGJlIGEgbGVhZiAqKVxuICAgICAgbWF0Y2ggcmlnaHQgd2l0aFxuICAgICAgfCBFbXB0eSB8IExlYWYgXyAtPiBhc3NlcnQgZmFsc2VcbiAgICAgIHwgTm9kZVxuICAgICAgICAgICh7IGxlZnQgPSByaWdodF9ub2RlX2xlZnRcbiAgICAgICAgICAgOyBrZXkgPSBfXG4gICAgICAgICAgIDsgdmFsdWUgPSBfXG4gICAgICAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgICAgICA7IHJpZ2h0ID0gcmlnaHRfbm9kZV9yaWdodFxuICAgICAgICAgICB9IGFzIHJpZ2h0X25vZGUpIC0+XG4gICAgICAgIGlmIGhlaWdodCByaWdodF9ub2RlX3JpZ2h0ID49IGhlaWdodCByaWdodF9ub2RlX2xlZnRcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgcm9vdF9ub2RlLnJpZ2h0IDwtIHJpZ2h0X25vZGVfbGVmdDtcbiAgICAgICAgICByaWdodF9ub2RlLmxlZnQgPC0gdHJlZTtcbiAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgdXBkYXRlX2hlaWdodCByaWdodDtcbiAgICAgICAgICByaWdodClcbiAgICAgICAgZWxzZSAoXG4gICAgICAgICAgKCogc2VlIGFib3ZlIGZvciBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBjYW5ub3QgYmUgYSBsZWFmICopXG4gICAgICAgICAgbWF0Y2ggcmlnaHRfbm9kZV9sZWZ0IHdpdGhcbiAgICAgICAgICB8IEVtcHR5IHwgTGVhZiBfIC0+IGFzc2VydCBmYWxzZVxuICAgICAgICAgIHwgTm9kZVxuICAgICAgICAgICAgICAoeyBsZWZ0ID0gcmxfbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IHJsX3JpZ2h0IH0gYXNcbiAgICAgICAgICAgICAgIHJsX25vZGUpIC0+XG4gICAgICAgICAgICByaWdodF9ub2RlLmxlZnQgPC0gcmxfcmlnaHQ7XG4gICAgICAgICAgICByb290X25vZGUucmlnaHQgPC0gcmxfbGVmdDtcbiAgICAgICAgICAgIHJsX25vZGUubGVmdCA8LSB0cmVlO1xuICAgICAgICAgICAgcmxfbm9kZS5yaWdodCA8LSByaWdodDtcbiAgICAgICAgICAgIHVwZGF0ZV9oZWlnaHQgcmlnaHQ7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICAgICAgICB1cGRhdGVfaGVpZ2h0IHJpZ2h0X25vZGVfbGVmdDtcbiAgICAgICAgICAgIHJpZ2h0X25vZGVfbGVmdCkpXG4gICAgZWxzZSAoXG4gICAgICB1cGRhdGVfaGVpZ2h0IHRyZWU7XG4gICAgICB0cmVlKVxuOztcblxuKCogQHByZTogdHJlZSBpcyBiYWxhbmNlYWJsZVxuICAgQHByZTogYWJzIChoZWlnaHQgKHJpZ2h0IG5vZGUpIC0gaGVpZ2h0IChiYWxhbmNlIHRyZWUpKSA8PSAzXG4gICBAcG9zdDogcmVzdWx0IGlzIGJhbGFuY2VhYmxlICopXG5cbigqIEBwcmU6IHRyZWUgaXMgYmFsYW5jZWFibGVcbiAgIEBwcmU6IGFicyAoaGVpZ2h0IChyaWdodCBub2RlKSAtIGhlaWdodCAoYmFsYW5jZSB0cmVlKSkgPD0gM1xuICAgQHBvc3Q6IHJlc3VsdCBpcyBiYWxhbmNlYWJsZSAqKVxubGV0IHNldF9sZWZ0IG5vZGUgdHJlZSA9XG4gIGxldCB0cmVlID0gYmFsYW5jZSB0cmVlIGluXG4gIG1hdGNoIG5vZGUgd2l0aFxuICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSBhcyByKSAtPlxuICAgIGlmIHBoeXNfZXF1YWwgbGVmdCB0cmVlIHRoZW4gKCkgZWxzZSByLmxlZnQgPC0gdHJlZTtcbiAgICB1cGRhdGVfaGVpZ2h0IG5vZGVcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuOztcblxuKCogQHByZTogdHJlZSBpcyBiYWxhbmNlYWJsZVxuICAgQHByZTogYWJzIChoZWlnaHQgKGxlZnQgbm9kZSkgLSBoZWlnaHQgKGJhbGFuY2UgdHJlZSkpIDw9IDNcbiAgIEBwb3N0OiByZXN1bHQgaXMgYmFsYW5jZWFibGUgKilcbmxldCBzZXRfcmlnaHQgbm9kZSB0cmVlID1cbiAgbGV0IHRyZWUgPSBiYWxhbmNlIHRyZWUgaW5cbiAgbWF0Y2ggbm9kZSB3aXRoXG4gIHwgTm9kZSAoeyBsZWZ0ID0gXzsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHIpIC0+XG4gICAgaWYgcGh5c19lcXVhbCByaWdodCB0cmVlIHRoZW4gKCkgZWxzZSByLnJpZ2h0IDwtIHRyZWU7XG4gICAgdXBkYXRlX2hlaWdodCBub2RlXG4gIHwgXyAtPiBhc3NlcnQgZmFsc2Vcbjs7XG5cbigqIEBwcmU6IHQgaXMgYmFsYW5jZWQuXG4gICBAcG9zdDogcmVzdWx0IGlzIGJhbGFuY2VkLCB3aXRoIG5ldyBub2RlIGluc2VydGVkXG4gICBAcG9zdDogIWFkZGVkID0gdHJ1ZSBpZmYgdGhlIHNoYXBlIG9mIHRoZSBpbnB1dCB0cmVlIGNoYW5nZWQuICAqKVxubGV0IGFkZCA9XG4gIGxldCByZWMgYWRkIHQgcmVwbGFjZSBhZGRlZCBjb21wYXJlIGsgdiA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgYWRkZWQgOj0gdHJ1ZTtcbiAgICAgIExlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfVxuICAgIHwgTGVhZiAoeyBrZXkgPSBrJzsgdmFsdWUgPSBfIH0gYXMgcikgLT5cbiAgICAgIGxldCBjID0gY29tcGFyZSBrJyBrIGluXG4gICAgICAoKiBUaGlzIGNvbXBhcmUgaXMgcmV2ZXJzZWQgb24gcHVycG9zZSwgd2UgYXJlIHByZXRlbmRpbmdcbiAgICAgICAgIHRoYXQgdGhlIGxlYWYgd2FzIGp1c3QgaW5zZXJ0ZWQgaW5zdGVhZCBvZiB0aGUgb3RoZXIgd2F5XG4gICAgICAgICByb3VuZCwgdGhhdCB3YXkgd2Ugb25seSBhbGxvY2F0ZSBvbmUgbm9kZS4gKilcbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgYWRkZWQgOj0gZmFsc2U7XG4gICAgICAgIGlmIHJlcGxhY2UgdGhlbiByLnZhbHVlIDwtIHY7XG4gICAgICAgIHQpXG4gICAgICBlbHNlIChcbiAgICAgICAgYWRkZWQgOj0gdHJ1ZTtcbiAgICAgICAgaWYgYyA8IDBcbiAgICAgICAgdGhlbiBOb2RlIHsgbGVmdCA9IHQ7IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gMjsgcmlnaHQgPSBFbXB0eSB9XG4gICAgICAgIGVsc2UgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSAyOyByaWdodCA9IHQgfSlcbiAgICB8IE5vZGUgKHsgbGVmdDsga2V5ID0gayc7IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgfSBhcyByKSAtPlxuICAgICAgbGV0IGMgPSBjb21wYXJlIGsgaycgaW5cbiAgICAgIGlmIGMgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgYWRkZWQgOj0gZmFsc2U7XG4gICAgICAgIGlmIHJlcGxhY2UgdGhlbiByLnZhbHVlIDwtIHYpXG4gICAgICBlbHNlIGlmIGMgPCAwXG4gICAgICB0aGVuIHNldF9sZWZ0IHQgKGFkZCBsZWZ0IHJlcGxhY2UgYWRkZWQgY29tcGFyZSBrIHYpXG4gICAgICBlbHNlIHNldF9yaWdodCB0IChhZGQgcmlnaHQgcmVwbGFjZSBhZGRlZCBjb21wYXJlIGsgdik7XG4gICAgICB0XG4gIGluXG4gIGZ1biB0IH5yZXBsYWNlIH5jb21wYXJlIH5hZGRlZCB+a2V5IH5kYXRhIC0+XG4gICAgbGV0IHQgPSBhZGQgdCByZXBsYWNlIGFkZGVkIGNvbXBhcmUga2V5IGRhdGEgaW5cbiAgICBpZiAhYWRkZWQgdGhlbiBiYWxhbmNlIHQgZWxzZSB0XG47O1xuXG5sZXQgcmVjIGZpcnN0IHQgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiBOb25lXG4gIHwgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gIHwgTm9kZSB7IGxlZnQgPSBFbXB0eTsga2V5ID0gazsgdmFsdWUgPSB2OyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPiBTb21lIChrLCB2KVxuICB8IE5vZGUgeyBsZWZ0ID0gbDsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSAtPiBmaXJzdCBsXG47O1xuXG5sZXQgcmVjIGxhc3QgdCA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IE5vbmVcbiAgfCBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH1cbiAgfCBOb2RlIHsgbGVmdCA9IF87IGtleSA9IGs7IHZhbHVlID0gdjsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBFbXB0eSB9IC0+IFNvbWUgKGssIHYpXG4gIHwgTm9kZSB7IGxlZnQgPSBfOyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gciB9IC0+IGxhc3QgclxuOztcblxuXG5sZXRbQGlubGluZSBhbHdheXNdIHJlYyBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmNvbXBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAga1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcxXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFyZzJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH5pZl9mb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICB+aWZfbm90X2ZvdW5kXG4gID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrIGFyZzEgYXJnMlxuICB8IExlYWYgeyBrZXkgPSBrJzsgdmFsdWUgPSB2IH0gLT5cbiAgICBpZiBjb21wYXJlIGsgaycgPSAwXG4gICAgdGhlbiBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5OmsnIH5kYXRhOnYgYXJnMSBhcmcyXG4gICAgZWxzZSBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGsgYXJnMSBhcmcyXG4gIHwgTm9kZSB7IGxlZnQ7IGtleSA9IGsnOyB2YWx1ZSA9IHY7IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICBsZXQgYyA9IGNvbXBhcmUgayBrJyBpblxuICAgIGlmIGMgPSAwXG4gICAgdGhlbiBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5OmsnIH5kYXRhOnYgYXJnMSBhcmcyXG4gICAgZWxzZVxuICAgICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgICAoaWYgYyA8IDAgdGhlbiBsZWZ0IGVsc2UgcmlnaHQpXG4gICAgICAgIH5jb21wYXJlXG4gICAgICAgIGtcbiAgICAgICAgYXJnMVxuICAgICAgICBhcmcyXG4gICAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgICB+aWZfZm91bmRcbiAgICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwgPVxuICBsZXQgY2FsbF9pZl9mb3VuZCB+aWZfZm91bmQgfmtleTpfIH5kYXRhICgpICgpID0gaWZfZm91bmQgZGF0YSBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgKCkgKCkgPSBpZl9ub3RfZm91bmQga2V5IGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgKClcbiAgICAgICgpXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbCA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5IH5kYXRhICgpICgpID0gaWZfZm91bmQgfmtleSB+ZGF0YSBpblxuICBsZXQgY2FsbF9pZl9ub3RfZm91bmQgfmlmX25vdF9mb3VuZCBrZXkgKCkgKCkgPSBpZl9ub3RfZm91bmQga2V5IGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgKClcbiAgICAgICgpXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMSA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5Ol8gfmRhdGEgYXJnICgpID0gaWZfZm91bmQgZGF0YSBhcmcgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZyAoKSA9IGlmX25vdF9mb3VuZCBrZXkgYXJnIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgKClcbiAgICAgIH5jYWxsX2lmX2ZvdW5kXG4gICAgICB+Y2FsbF9pZl9ub3RfZm91bmRcbiAgICAgIH5pZl9mb3VuZFxuICAgICAgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IGZpbmRpX2FuZF9jYWxsMSA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5IH5kYXRhIGFyZyAoKSA9IGlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnIGluXG4gIGxldCBjYWxsX2lmX25vdF9mb3VuZCB+aWZfbm90X2ZvdW5kIGtleSBhcmcgKCkgPSBpZl9ub3RfZm91bmQga2V5IGFyZyBpblxuICBmdW4gdCB+Y29tcGFyZSBrIH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIC0+XG4gICAgZmluZGlfYW5kX2NhbGxfaW1wbFxuICAgICAgdFxuICAgICAgfmNvbXBhcmVcbiAgICAgIGtcbiAgICAgIGFcbiAgICAgICgpXG4gICAgICB+Y2FsbF9pZl9mb3VuZFxuICAgICAgfmNhbGxfaWZfbm90X2ZvdW5kXG4gICAgICB+aWZfZm91bmRcbiAgICAgIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kX2FuZF9jYWxsMiA9XG4gIGxldCBjYWxsX2lmX2ZvdW5kIH5pZl9mb3VuZCB+a2V5Ol8gfmRhdGEgYXJnMSBhcmcyID0gaWZfZm91bmQgZGF0YSBhcmcxIGFyZzIgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZzEgYXJnMiA9IGlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgYlxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwyID1cbiAgbGV0IGNhbGxfaWZfZm91bmQgfmlmX2ZvdW5kIH5rZXkgfmRhdGEgYXJnMSBhcmcyID0gaWZfZm91bmQgfmtleSB+ZGF0YSBhcmcxIGFyZzIgaW5cbiAgbGV0IGNhbGxfaWZfbm90X2ZvdW5kIH5pZl9ub3RfZm91bmQga2V5IGFyZzEgYXJnMiA9IGlmX25vdF9mb3VuZCBrZXkgYXJnMSBhcmcyIGluXG4gIGZ1biB0IH5jb21wYXJlIGsgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgLT5cbiAgICBmaW5kaV9hbmRfY2FsbF9pbXBsXG4gICAgICB0XG4gICAgICB+Y29tcGFyZVxuICAgICAga1xuICAgICAgYVxuICAgICAgYlxuICAgICAgfmNhbGxfaWZfZm91bmRcbiAgICAgIH5jYWxsX2lmX25vdF9mb3VuZFxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZCA9XG4gIGxldCBpZl9mb3VuZCB2ID0gU29tZSB2IGluXG4gIGxldCBpZl9ub3RfZm91bmQgXyA9IE5vbmUgaW5cbiAgZnVuIHQgfmNvbXBhcmUgayAtPiBmaW5kX2FuZF9jYWxsIHQgfmNvbXBhcmUgayB+aWZfZm91bmQgfmlmX25vdF9mb3VuZFxuOztcblxubGV0IG1lbSA9XG4gIGxldCBpZl9mb3VuZCBfID0gdHJ1ZSBpblxuICBsZXQgaWZfbm90X2ZvdW5kIF8gPSBmYWxzZSBpblxuICBmdW4gdCB+Y29tcGFyZSBrIC0+IGZpbmRfYW5kX2NhbGwgdCB+Y29tcGFyZSBrIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgcmVtb3ZlID1cbiAgbGV0IHJlYyBtaW5fZWx0IHRyZWUgPVxuICAgIG1hdGNoIHRyZWUgd2l0aFxuICAgIHwgRW1wdHkgLT4gRW1wdHlcbiAgICB8IExlYWYgXyAtPiB0cmVlXG4gICAgfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IHRyZWVcbiAgICB8IE5vZGUgeyBsZWZ0OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0ID0gXyB9IC0+IG1pbl9lbHQgbGVmdFxuICBpblxuICBsZXQgcmVjIHJlbW92ZV9taW5fZWx0IHRyZWUgPVxuICAgIG1hdGNoIHRyZWUgd2l0aFxuICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBMZWFmIF8gLT4gRW1wdHkgKCogVGhpcyBtdXN0IGJlIHRoZSByb290ICopXG4gICAgfCBOb2RlIHsgbGVmdCA9IEVtcHR5OyBrZXkgPSBfOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gLT4gcmlnaHRcbiAgICB8IE5vZGUgeyBsZWZ0ID0gTGVhZiBfOyBrZXkgPSBrOyB2YWx1ZSA9IHY7IGhlaWdodCA9IF87IHJpZ2h0ID0gRW1wdHkgfSAtPlxuICAgICAgTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9XG4gICAgfCBOb2RlIHsgbGVmdCA9IExlYWYgXzsga2V5ID0gXzsgdmFsdWUgPSBfOyBoZWlnaHQgPSBfOyByaWdodCA9IF8gfSBhcyBub2RlIC0+XG4gICAgICBzZXRfbGVmdCBub2RlIEVtcHR5O1xuICAgICAgdHJlZVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IF87IHZhbHVlID0gXzsgaGVpZ2h0ID0gXzsgcmlnaHQgPSBfIH0gYXMgbm9kZSAtPlxuICAgICAgc2V0X2xlZnQgbm9kZSAocmVtb3ZlX21pbl9lbHQgbGVmdCk7XG4gICAgICB0cmVlXG4gIGluXG4gIGxldCBtZXJnZSB0MSB0MiA9XG4gICAgbWF0Y2ggdDEsIHQyIHdpdGhcbiAgICB8IEVtcHR5LCB0IC0+IHRcbiAgICB8IHQsIEVtcHR5IC0+IHRcbiAgICB8IF8sIF8gLT5cbiAgICAgIGxldCB0cmVlID0gbWluX2VsdCB0MiBpblxuICAgICAgKG1hdGNoIHRyZWUgd2l0aFxuICAgICAgIHwgRW1wdHkgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgfCBMZWFmIHsga2V5ID0gazsgdmFsdWUgPSB2IH0gLT5cbiAgICAgICAgIGxldCB0MiA9IGJhbGFuY2UgKHJlbW92ZV9taW5fZWx0IHQyKSBpblxuICAgICAgICAgTm9kZVxuICAgICAgICAgICB7IGxlZnQgPSB0MVxuICAgICAgICAgICA7IGtleSA9IGtcbiAgICAgICAgICAgOyB2YWx1ZSA9IHZcbiAgICAgICAgICAgOyBoZWlnaHQgPSBJbnQubWF4IChoZWlnaHQgdDEpIChoZWlnaHQgdDIpICsgMVxuICAgICAgICAgICA7IHJpZ2h0ID0gdDJcbiAgICAgICAgICAgfVxuICAgICAgIHwgTm9kZSBfIGFzIG5vZGUgLT5cbiAgICAgICAgIHNldF9yaWdodCBub2RlIChyZW1vdmVfbWluX2VsdCB0Mik7XG4gICAgICAgICBzZXRfbGVmdCBub2RlIHQxO1xuICAgICAgICAgbm9kZSlcbiAgaW5cbiAgbGV0IHJlYyByZW1vdmUgdCByZW1vdmVkIGNvbXBhcmUgayA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBFbXB0eSAtPlxuICAgICAgcmVtb3ZlZCA6PSBmYWxzZTtcbiAgICAgIEVtcHR5XG4gICAgfCBMZWFmIHsga2V5ID0gayc7IHZhbHVlID0gXyB9IC0+XG4gICAgICBpZiBjb21wYXJlIGsgaycgPSAwXG4gICAgICB0aGVuIChcbiAgICAgICAgcmVtb3ZlZCA6PSB0cnVlO1xuICAgICAgICBFbXB0eSlcbiAgICAgIGVsc2UgKFxuICAgICAgICByZW1vdmVkIDo9IGZhbHNlO1xuICAgICAgICB0KVxuICAgIHwgTm9kZSB7IGxlZnQ7IGtleSA9IGsnOyB2YWx1ZSA9IF87IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICAgIGxldCBjID0gY29tcGFyZSBrIGsnIGluXG4gICAgICBpZiBjID0gMFxuICAgICAgdGhlbiAoXG4gICAgICAgIHJlbW92ZWQgOj0gdHJ1ZTtcbiAgICAgICAgbWVyZ2UgbGVmdCByaWdodClcbiAgICAgIGVsc2UgaWYgYyA8IDBcbiAgICAgIHRoZW4gKFxuICAgICAgICBzZXRfbGVmdCB0IChyZW1vdmUgbGVmdCByZW1vdmVkIGNvbXBhcmUgayk7XG4gICAgICAgIHQpXG4gICAgICBlbHNlIChcbiAgICAgICAgc2V0X3JpZ2h0IHQgKHJlbW92ZSByaWdodCByZW1vdmVkIGNvbXBhcmUgayk7XG4gICAgICAgIHQpXG4gIGluXG4gIGZ1biB0IH5yZW1vdmVkIH5jb21wYXJlIGsgLT4gYmFsYW5jZSAocmVtb3ZlIHQgcmVtb3ZlZCBjb21wYXJlIGspXG47O1xuXG5sZXQgcmVjIGZvbGQgdCB+aW5pdCB+ZiA9XG4gIG1hdGNoIHQgd2l0aFxuICB8IEVtcHR5IC0+IGluaXRcbiAgfCBMZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGEgaW5pdFxuICB8IE5vZGVcbiAgICAgIHsgbGVmdCA9IExlYWYgeyBrZXkgPSBsa2V5OyB2YWx1ZSA9IGxkYXRhIH1cbiAgICAgIDsga2V5XG4gICAgICA7IHZhbHVlID0gZGF0YVxuICAgICAgOyBoZWlnaHQgPSBfXG4gICAgICA7IHJpZ2h0ID0gTGVhZiB7IGtleSA9IHJrZXk7IHZhbHVlID0gcmRhdGEgfVxuICAgICAgfSAtPiBmIH5rZXk6cmtleSB+ZGF0YTpyZGF0YSAoZiB+a2V5IH5kYXRhIChmIH5rZXk6bGtleSB+ZGF0YTpsZGF0YSBpbml0KSlcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBMZWFmIHsga2V5ID0gbGtleTsgdmFsdWUgPSBsZGF0YSB9XG4gICAgICA7IGtleVxuICAgICAgOyB2YWx1ZSA9IGRhdGFcbiAgICAgIDsgaGVpZ2h0ID0gX1xuICAgICAgOyByaWdodCA9IEVtcHR5XG4gICAgICB9IC0+IGYgfmtleSB+ZGF0YSAoZiB+a2V5OmxrZXkgfmRhdGE6bGRhdGEgaW5pdClcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQgPSBFbXB0eVxuICAgICAgOyBrZXlcbiAgICAgIDsgdmFsdWUgPSBkYXRhXG4gICAgICA7IGhlaWdodCA9IF9cbiAgICAgIDsgcmlnaHQgPSBMZWFmIHsga2V5ID0gcmtleTsgdmFsdWUgPSByZGF0YSB9XG4gICAgICB9IC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgaW5pdClcbiAgfCBOb2RlXG4gICAgICB7IGxlZnQ7IGtleTsgdmFsdWUgPSBkYXRhOyBoZWlnaHQgPSBfOyByaWdodCA9IExlYWYgeyBrZXkgPSBya2V5OyB2YWx1ZSA9IHJkYXRhIH0gfVxuICAgIC0+IGYgfmtleTpya2V5IH5kYXRhOnJkYXRhIChmIH5rZXkgfmRhdGEgKGZvbGQgbGVmdCB+aW5pdCB+ZikpXG4gIHwgTm9kZVxuICAgICAgeyBsZWZ0ID0gTGVhZiB7IGtleSA9IGxrZXk7IHZhbHVlID0gbGRhdGEgfTsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0IH1cbiAgICAtPiBmb2xkIHJpZ2h0IH5pbml0OihmIH5rZXkgfmRhdGEgKGYgfmtleTpsa2V5IH5kYXRhOmxkYXRhIGluaXQpKSB+ZlxuICB8IE5vZGUgeyBsZWZ0OyBrZXk7IHZhbHVlID0gZGF0YTsgaGVpZ2h0ID0gXzsgcmlnaHQgfSAtPlxuICAgIGZvbGQgcmlnaHQgfmluaXQ6KGYgfmtleSB+ZGF0YSAoZm9sZCBsZWZ0IH5pbml0IH5mKSkgfmZcbjs7XG5cbmxldCByZWMgaXRlciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgRW1wdHkgLT4gKClcbiAgfCBMZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGFcbiAgfCBOb2RlIHsgbGVmdDsga2V5OyB2YWx1ZSA9IGRhdGE7IGhlaWdodCA9IF87IHJpZ2h0IH0gLT5cbiAgICBpdGVyIGxlZnQgfmY7XG4gICAgZiB+a2V5IH5kYXRhO1xuICAgIGl0ZXIgcmlnaHQgfmZcbjs7XG5cbmxldCByZWMgbWFwaV9pbnBsYWNlIHQgfmYgPVxuICBtYXRjaCB0IHdpdGhcbiAgfCBFbXB0eSAtPiAoKVxuICB8IExlYWYgKHsga2V5OyB2YWx1ZSB9IGFzIHQpIC0+IHQudmFsdWUgPC0gZiB+a2V5IH5kYXRhOnZhbHVlXG4gIHwgTm9kZSAoeyBsZWZ0OyBrZXk7IHZhbHVlOyBoZWlnaHQgPSBfOyByaWdodCB9IGFzIHQpIC0+XG4gICAgbWFwaV9pbnBsYWNlIH5mIGxlZnQ7XG4gICAgdC52YWx1ZSA8LSBmIH5rZXkgfmRhdGE6dmFsdWU7XG4gICAgbWFwaV9pbnBsYWNlIH5mIHJpZ2h0XG47O1xuXG5sZXQgY2hvb3NlX2V4biA9IGZ1bmN0aW9uXG4gIHwgRW1wdHkgLT4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0F2bHRyZWUuY2hvb3NlX2V4bl0gb2YgZW1wdHkgaGFzaHRibFwiIFtdKVxuICB8IExlYWYgeyBrZXk7IHZhbHVlOyBfIH0gfCBOb2RlIHsga2V5OyB2YWx1ZTsgXyB9IC0+IGtleSwgdmFsdWVcbjs7XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSGFzaHRibF9pbnRmXG5cbm1vZHVsZSB0eXBlIEtleSA9IEtleS5TXG5cbmxldCB3aXRoX3JldHVybiA9IFdpdGhfcmV0dXJuLndpdGhfcmV0dXJuXG5sZXQgaGFzaF9wYXJhbSA9IEhhc2hhYmxlLmhhc2hfcGFyYW1cbmxldCBoYXNoID0gSGFzaGFibGUuaGFzaFxubGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbnR5cGUgKCdrLCAndikgdCA9XG4gIHsgbXV0YWJsZSB0YWJsZSA6ICgnaywgJ3YpIEF2bHRyZWUudCBhcnJheVxuICA7IG11dGFibGUgbGVuZ3RoIDogaW50XG4gICgqIFtyZWNlbnRseV9hZGRlZF0gaXMgdGhlIHJlZmVyZW5jZSBwYXNzZWQgdG8gW0F2bHRyZWUuYWRkXS4gV2UgcHV0IGl0IGluIHRoZSBoYXNoXG4gICAgIHRhYmxlIHRvIGF2b2lkIGFsbG9jYXRpbmcgaXQgYXQgZXZlcnkgW3NldF0uICopXG4gIDsgcmVjZW50bHlfYWRkZWQgOiBib29sIHJlZlxuICA7IGdyb3d0aF9hbGxvd2VkIDogYm9vbFxuICA7IGhhc2hhYmxlIDogJ2sgSGFzaGFibGUudFxuICA7IG11dGFibGUgbXV0YXRpb25fYWxsb3dlZCA6IGJvb2wgKCogU2V0IGR1cmluZyBhbGwgaXRlcmF0aW9uIG9wZXJhdGlvbnMgKilcbiAgfVxuXG50eXBlICdhIGtleSA9ICdhXG5cbmxldCBzZXhwX29mX2tleSB0ID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5zZXhwX29mX3RcbmxldCBjb21wYXJlX2tleSB0ID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5jb21wYXJlXG5cbmxldCBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0ID1cbiAgaWYgbm90IHQubXV0YXRpb25fYWxsb3dlZCB0aGVuIGZhaWx3aXRoIFwiSGFzaHRibDogbXV0YXRpb24gbm90IGFsbG93ZWQgZHVyaW5nIGl0ZXJhdGlvblwiXG47O1xuXG5sZXQgd2l0aG91dF9tdXRhdGluZyB0IGYgPVxuICBpZiB0Lm11dGF0aW9uX2FsbG93ZWRcbiAgdGhlbiAoXG4gICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIGZhbHNlO1xuICAgIG1hdGNoIGYgKCkgd2l0aFxuICAgIHwgeCAtPlxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIHRydWU7XG4gICAgICB4XG4gICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gdHJ1ZTtcbiAgICAgIHJhaXNlIGV4bilcbiAgZWxzZSBmICgpXG47O1xuXG4oKiogSW50ZXJuYWxseSB1c2UgYSBtYXhpbXVtIHNpemUgdGhhdCBpcyBhIHBvd2VyIG9mIDIuIFJldmVyc2VzIHRoZSBhYm92ZSB0byBmaW5kIHRoZVxuICAgIGZsb29yIHBvd2VyIG9mIDIgYmVsb3cgdGhlIHN5c3RlbSBtYXggYXJyYXkgbGVuZ3RoICopXG5sZXQgbWF4X3RhYmxlX2xlbmd0aCA9IEludC5mbG9vcl9wb3cyIEFycmF5Lm1heF9sZW5ndGhcblxuKCogVGhlIGRlZmF1bHQgc2l6ZSBpcyBjaG9zZW4gdG8gYmUgMCAoYXMgb3Bwb3NlZCB0byAxMjggYXMgaXQgd2FzIGJlZm9yZSkgYmVjYXVzZTpcbiAgIC0gMTI4IGNhbiBjcmVhdGUgc3Vic3RhbnRpYWwgbWVtb3J5IG92ZXJoZWFkICh4MTApIHdoZW4gY3JlYXRpbmcgbWFueSB0YWJsZXMsIG1vc3RcbiAgICAgb2Ygd2hpY2ggYXJlIG5vdCBiaWcgKHNheSwgaWYgeW91IGhhdmUgYSBoYXNodGJsIG9mIGhhc2h0YmwpLiBBbmQgbWVtb3J5IG92ZXJoZWFkIGlzXG4gICAgIG5vdCB0aGF0IGVhc3kgdG8gcHJvZmlsZS5cbiAgIC0gaWYgYSBoYXNodGJsIGlzIGdvaW5nIHRvIGdyb3csIGl0J3Mgbm90IGNsZWFyIHdoeSAxMjggaXMgbWFya2VkbHkgYmV0dGVyIHRoYW4gb3RoZXJcbiAgICAgc2l6ZXMgKGlmIHlvdSBnb2luZyB0byBzdGljayAxMDAwIGVsZW1lbnRzLCB5b3UncmUgZ29pbmcgdG8gZ3JvdyB0aGUgaGFzaHRhYmxlIG9uY2VcbiAgICAgb3IgdHdpY2UgYW55d2F5KVxuICAgLSBpbiBvdGhlciBsYW5ndWFnZXMgKGxpa2UgcnVzdCwgcHl0aG9uLCBhbmQgYXBwYXJlbnRseSBnbyksIHRoZSBkZWZhdWx0IGlzIGFsc28gYVxuICAgICBzbWFsbCBzaXplLiAqKVxubGV0IGNyZWF0ZSA/KGdyb3d0aF9hbGxvd2VkID0gdHJ1ZSkgPyhzaXplID0gMCkgfmhhc2hhYmxlICgpID1cbiAgbGV0IHNpemUgPSBJbnQubWluIChJbnQubWF4IDEgc2l6ZSkgbWF4X3RhYmxlX2xlbmd0aCBpblxuICBsZXQgc2l6ZSA9IEludC5jZWlsX3BvdzIgc2l6ZSBpblxuICB7IHRhYmxlID0gQXJyYXkuY3JlYXRlIH5sZW46c2l6ZSBBdmx0cmVlLmVtcHR5XG4gIDsgbGVuZ3RoID0gMFxuICA7IGdyb3d0aF9hbGxvd2VkXG4gIDsgcmVjZW50bHlfYWRkZWQgPSByZWYgZmFsc2VcbiAgOyBoYXNoYWJsZVxuICA7IG11dGF0aW9uX2FsbG93ZWQgPSB0cnVlXG4gIH1cbjs7XG5cbigqKiBTdXBwbGVtZW50YWwgaGFzaC4gVGhpcyBtYXkgbm90IGJlIG5lY2Vzc2FyeSwgaXQgaXMgaW50ZW5kZWQgYXMgYSBkZWZlbnNlIGFnYWluc3QgcG9vclxuICAgIGhhc2ggZnVuY3Rpb25zLCBmb3Igd2hpY2ggdGhlIHBvd2VyIG9mIDIgc2l6ZWQgdGFibGUgd2lsbCBiZSBlc3BlY2lhbGx5IHNlbnNpdGl2ZS5cbiAgICBXaXRoIHNvbWUgdGVzdGluZyB3ZSBtYXkgY2hvb3NlIHRvIGFkZCBpdCwgYnV0IHRoaXMgdGFibGUgaXMgZGVzaWduZWQgdG8gYmUgcm9idXN0IHRvXG4gICAgY29sbGlzaW9ucywgYW5kIGluIG1vc3Qgb2YgbXkgdGVzdGluZyB0aGlzIGRlZ3JhZGVzIHBlcmZvcm1hbmNlLiAqKVxubGV0IF9zdXBwbGVtZW50YWxfaGFzaCBoID1cbiAgbGV0IGggPSBoIGx4b3IgKChoIGxzciAyMCkgbHhvciAoaCBsc3IgMTIpKSBpblxuICBoIGx4b3IgKGggbHNyIDcpIGx4b3IgKGggbHNyIDQpXG47O1xuXG5sZXQgc2xvdCB0IGtleSA9XG4gIGxldCBoYXNoID0gdC5oYXNoYWJsZS5IYXNoYWJsZS5oYXNoIGtleSBpblxuICAoKiB0aGlzIGlzIGFsd2F5cyBub24tbmVnYXRpdmUgYmVjYXVzZSB3ZSBkbyBbbGFuZF0gd2l0aCBub24tbmVnYXRpdmUgbnVtYmVyICopXG4gIGhhc2ggbGFuZCAoQXJyYXkubGVuZ3RoIHQudGFibGUgLSAxKVxuOztcblxubGV0IGFkZF93b3JrZXIgdCB+cmVwbGFjZSB+a2V5IH5kYXRhID1cbiAgbGV0IGkgPSBzbG90IHQga2V5IGluXG4gIGxldCByb290ID0gdC50YWJsZS4oaSkgaW5cbiAgbGV0IGFkZGVkID0gdC5yZWNlbnRseV9hZGRlZCBpblxuICBhZGRlZCA6PSBmYWxzZTtcbiAgbGV0IG5ld19yb290ID1cbiAgICAoKiBUaGUgYXZsIHRyZWUgbWlnaHQgcmVwbGFjZSB0aGUgdmFsdWUgW3JlcGxhY2U9dHJ1ZV0gb3IgZG8gbm90aGluZyBbcmVwbGFjZT1mYWxzZV1cbiAgICAgICB0byB0aGUgZW50cnksIGluIHRoYXQgY2FzZSB0aGUgdGFibGUgZGlkIG5vdCBnZXQgYmlnZ2VyLCBzbyB3ZSBzaG91bGQgbm90XG4gICAgICAgaW5jcmVtZW50IGxlbmd0aCwgd2UgcGFzcyBpbiB0aGUgYm9vbCByZWYgdC5hZGRlZCBzbyB0aGF0IGl0IGNhbiB0ZWxsIHVzIHdoZXRoZXJcbiAgICAgICBpdCBhZGRlZCBvciByZXBsYWNlZC4gV2UgZG8gaXQgdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbi4gU2luY2UgdGhlIGJvb2xcbiAgICAgICBpcyBhbiBpbW1lZGlhdGUgaXQgZG9lcyBub3QgZ28gdGhyb3VnaCB0aGUgd3JpdGUgYmFycmllci4gKilcbiAgICBBdmx0cmVlLmFkZCB+cmVwbGFjZSByb290IH5jb21wYXJlOihjb21wYXJlX2tleSB0KSB+YWRkZWQgfmtleSB+ZGF0YVxuICBpblxuICBpZiAhYWRkZWQgdGhlbiB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCArIDE7XG4gICgqIFRoaXMgbGl0dGxlIG9wdGltaXphdGlvbiBzYXZlcyBhIGNhbWxfbW9kaWZ5IHdoZW4gdGhlIHRyZWVcbiAgICAgaGFzbid0IGJlZW4gcmViYWxhbmNlZC4gKilcbiAgaWYgbm90IChwaHlzX2VxdWFsIG5ld19yb290IHJvb3QpIHRoZW4gdC50YWJsZS4oaSkgPC0gbmV3X3Jvb3Rcbjs7XG5cbmxldCBtYXliZV9yZXNpemVfdGFibGUgdCA9XG4gIGxldCBsZW4gPSBBcnJheS5sZW5ndGggdC50YWJsZSBpblxuICBsZXQgc2hvdWxkX2dyb3cgPSB0Lmxlbmd0aCA+IGxlbiBpblxuICBpZiBzaG91bGRfZ3JvdyAmJiB0Lmdyb3d0aF9hbGxvd2VkXG4gIHRoZW4gKFxuICAgIGxldCBuZXdfYXJyYXlfbGVuZ3RoID0gSW50Lm1pbiAobGVuICogMikgbWF4X3RhYmxlX2xlbmd0aCBpblxuICAgIGlmIG5ld19hcnJheV9sZW5ndGggPiBsZW5cbiAgICB0aGVuIChcbiAgICAgIGxldCBuZXdfdGFibGUgPSBBcnJheS5jcmVhdGUgfmxlbjpuZXdfYXJyYXlfbGVuZ3RoIEF2bHRyZWUuZW1wdHkgaW5cbiAgICAgIGxldCBvbGRfdGFibGUgPSB0LnRhYmxlIGluXG4gICAgICB0LnRhYmxlIDwtIG5ld190YWJsZTtcbiAgICAgIHQubGVuZ3RoIDwtIDA7XG4gICAgICBsZXQgZiB+a2V5IH5kYXRhID0gYWRkX3dvcmtlciB+cmVwbGFjZTp0cnVlIHQgfmtleSB+ZGF0YSBpblxuICAgICAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCBvbGRfdGFibGUgLSAxIGRvXG4gICAgICAgIEF2bHRyZWUuaXRlciBvbGRfdGFibGUuKGkpIH5mXG4gICAgICBkb25lKSlcbjs7XG5cbmxldCBzZXQgdCB+a2V5IH5kYXRhID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgYWRkX3dvcmtlciB+cmVwbGFjZTp0cnVlIHQgfmtleSB+ZGF0YTtcbiAgbWF5YmVfcmVzaXplX3RhYmxlIHRcbjs7XG5cbmxldCBhZGQgdCB+a2V5IH5kYXRhID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgYWRkX3dvcmtlciB+cmVwbGFjZTpmYWxzZSB0IH5rZXkgfmRhdGE7XG4gIGlmICEodC5yZWNlbnRseV9hZGRlZClcbiAgdGhlbiAoXG4gICAgbWF5YmVfcmVzaXplX3RhYmxlIHQ7XG4gICAgYE9rKVxuICBlbHNlIGBEdXBsaWNhdGVcbjs7XG5cbmxldCBhZGRfZXhuIHQgfmtleSB+ZGF0YSA9XG4gIG1hdGNoIGFkZCB0IH5rZXkgfmRhdGEgd2l0aFxuICB8IGBPayAtPiAoKVxuICB8IGBEdXBsaWNhdGUgLT5cbiAgICBsZXQgc2V4cF9vZl9rZXkgPSBzZXhwX29mX2tleSB0IGluXG4gICAgbGV0IGVycm9yID0gRXJyb3IuY3JlYXRlIFwiSGFzaHRibC5hZGRfZXhuIGdvdCBrZXkgYWxyZWFkeSBwcmVzZW50XCIga2V5IHNleHBfb2Zfa2V5IGluXG4gICAgRXJyb3IucmFpc2UgZXJyb3Jcbjs7XG5cbmxldCBjbGVhciB0ID1cbiAgZW5zdXJlX211dGF0aW9uX2FsbG93ZWQgdDtcbiAgZm9yIGkgPSAwIHRvIEFycmF5Lmxlbmd0aCB0LnRhYmxlIC0gMSBkb1xuICAgIHQudGFibGUuKGkpIDwtIEF2bHRyZWUuZW1wdHlcbiAgZG9uZTtcbiAgdC5sZW5ndGggPC0gMFxuOztcblxubGV0IGZpbmRfYW5kX2NhbGwgdCBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICAoKiB3aXRoIGEgZ29vZCBoYXNoIGZ1bmN0aW9uIHRoZXNlIGZpcnN0IHR3byBjYXNlcyB3aWxsIGJlIHRoZSBvdmVyd2hlbG1pbmcgbWFqb3JpdHksXG4gICAgIGFuZCBBdmx0cmVlLmZpbmQgaXMgcmVjdXJzaXZlLCBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkLCBzbyBkb2luZyB0aGlzIGF2b2lkcyBhXG4gICAgIGZ1bmN0aW9uIGNhbGwgaW4gbW9zdCBjYXNlcy4gKilcbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB2IGVsc2UgaWZfbm90X2ZvdW5kIGtleVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRfYW5kX2NhbGwgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbDEgdCBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgdiBhIGVsc2UgaWZfbm90X2ZvdW5kIGtleSBhXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZF9hbmRfY2FsbDEgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5hIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZF9hbmRfY2FsbDIgdCBrZXkgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5IGEgYlxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB2IGEgYiBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYSBiXG4gIHwgdHJlZSAtPlxuICAgIEF2bHRyZWUuZmluZF9hbmRfY2FsbDIgdHJlZSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdCkga2V5IH5hIH5iIH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZGlfYW5kX2NhbGwgdCBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICAoKiB3aXRoIGEgZ29vZCBoYXNoIGZ1bmN0aW9uIHRoZXNlIGZpcnN0IHR3byBjYXNlcyB3aWxsIGJlIHRoZSBvdmVyd2hlbG1pbmcgbWFqb3JpdHksXG4gICAgIGFuZCBBdmx0cmVlLmZpbmQgaXMgcmVjdXJzaXZlLCBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkLCBzbyBkb2luZyB0aGlzIGF2b2lkcyBhXG4gICAgIGZ1bmN0aW9uIGNhbGwgaW4gbW9zdCBjYXNlcy4gKilcbiAgbWF0Y2ggdC50YWJsZS4oc2xvdCB0IGtleSkgd2l0aFxuICB8IEF2bHRyZWUuRW1wdHkgLT4gaWZfbm90X2ZvdW5kIGtleVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB+a2V5OmsgfmRhdGE6diBlbHNlIGlmX25vdF9mb3VuZCBrZXlcbiAgfCB0cmVlIC0+XG4gICAgQXZsdHJlZS5maW5kaV9hbmRfY2FsbCB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDEgdCBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5IGFcbiAgfCBBdmx0cmVlLkxlYWYgeyBrZXkgPSBrOyB2YWx1ZSA9IHYgfSAtPlxuICAgIGlmIGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwIHRoZW4gaWZfZm91bmQgfmtleTprIH5kYXRhOnYgYSBlbHNlIGlmX25vdF9mb3VuZCBrZXkgYVxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRpX2FuZF9jYWxsMSB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXkgfmEgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBmaW5kaV9hbmRfY2FsbDIgdCBrZXkgfmEgfmIgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmQgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBpZl9ub3RfZm91bmQga2V5IGEgYlxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gdiB9IC0+XG4gICAgaWYgY29tcGFyZV9rZXkgdCBrIGtleSA9IDAgdGhlbiBpZl9mb3VuZCB+a2V5OmsgfmRhdGE6diBhIGIgZWxzZSBpZl9ub3RfZm91bmQga2V5IGEgYlxuICB8IHRyZWUgLT5cbiAgICBBdmx0cmVlLmZpbmRpX2FuZF9jYWxsMlxuICAgICAgdHJlZVxuICAgICAgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpXG4gICAgICBrZXlcbiAgICAgIH5hXG4gICAgICB+YlxuICAgICAgfmlmX2ZvdW5kXG4gICAgICB+aWZfbm90X2ZvdW5kXG47O1xuXG5sZXQgZmluZCA9XG4gIGxldCBpZl9mb3VuZCB2ID0gU29tZSB2IGluXG4gIGxldCBpZl9ub3RfZm91bmQgXyA9IE5vbmUgaW5cbiAgZnVuIHQga2V5IC0+IGZpbmRfYW5kX2NhbGwgdCBrZXkgfmlmX2ZvdW5kIH5pZl9ub3RfZm91bmRcbjs7XG5cbmxldCBtZW0gdCBrZXkgPVxuICBtYXRjaCB0LnRhYmxlLihzbG90IHQga2V5KSB3aXRoXG4gIHwgQXZsdHJlZS5FbXB0eSAtPiBmYWxzZVxuICB8IEF2bHRyZWUuTGVhZiB7IGtleSA9IGs7IHZhbHVlID0gXyB9IC0+IGNvbXBhcmVfa2V5IHQgayBrZXkgPSAwXG4gIHwgdHJlZSAtPiBBdmx0cmVlLm1lbSB0cmVlIH5jb21wYXJlOihjb21wYXJlX2tleSB0KSBrZXlcbjs7XG5cbmxldCByZW1vdmUgdCBrZXkgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICBsZXQgaSA9IHNsb3QgdCBrZXkgaW5cbiAgbGV0IHJvb3QgPSB0LnRhYmxlLihpKSBpblxuICBsZXQgYWRkZWRfb3JfcmVtb3ZlZCA9IHQucmVjZW50bHlfYWRkZWQgaW5cbiAgYWRkZWRfb3JfcmVtb3ZlZCA6PSBmYWxzZTtcbiAgbGV0IG5ld19yb290ID1cbiAgICBBdmx0cmVlLnJlbW92ZSByb290IH5yZW1vdmVkOmFkZGVkX29yX3JlbW92ZWQgfmNvbXBhcmU6KGNvbXBhcmVfa2V5IHQpIGtleVxuICBpblxuICBpZiBub3QgKHBoeXNfZXF1YWwgcm9vdCBuZXdfcm9vdCkgdGhlbiB0LnRhYmxlLihpKSA8LSBuZXdfcm9vdDtcbiAgaWYgIWFkZGVkX29yX3JlbW92ZWQgdGhlbiB0Lmxlbmd0aCA8LSB0Lmxlbmd0aCAtIDFcbjs7XG5cbmxldCBsZW5ndGggdCA9IHQubGVuZ3RoXG5sZXQgaXNfZW1wdHkgdCA9IGxlbmd0aCB0ID0gMFxuXG5sZXQgZm9sZCB0IH5pbml0IH5mID1cbiAgaWYgbGVuZ3RoIHQgPSAwXG4gIHRoZW4gaW5pdFxuICBlbHNlIChcbiAgICBsZXQgbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IGFjYyA9IHJlZiBpbml0IGluXG4gICAgbGV0IG0gPSB0Lm11dGF0aW9uX2FsbG93ZWQgaW5cbiAgICBtYXRjaFxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIGZhbHNlO1xuICAgICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICAgIG1hdGNoIEFycmF5LnVuc2FmZV9nZXQgdC50YWJsZSBpIHdpdGhcbiAgICAgICAgfCBBdmx0cmVlLkVtcHR5IC0+ICgpXG4gICAgICAgIHwgQXZsdHJlZS5MZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBhY2MgOj0gZiB+a2V5IH5kYXRhICFhY2NcbiAgICAgICAgfCBidWNrZXQgLT4gYWNjIDo9IEF2bHRyZWUuZm9sZCBidWNrZXQgfmluaXQ6IWFjYyB+ZlxuICAgICAgZG9uZVxuICAgIHdpdGhcbiAgICB8ICgpIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gbTtcbiAgICAgICFhY2NcbiAgICB8IGV4Y2VwdGlvbiBleG4gLT5cbiAgICAgIHQubXV0YXRpb25fYWxsb3dlZCA8LSBtO1xuICAgICAgcmFpc2UgZXhuKVxuOztcblxubGV0IGl0ZXJpIHQgfmYgPVxuICBpZiB0Lmxlbmd0aCA9IDBcbiAgdGhlbiAoKVxuICBlbHNlIChcbiAgICBsZXQgbiA9IEFycmF5Lmxlbmd0aCB0LnRhYmxlIGluXG4gICAgbGV0IG0gPSB0Lm11dGF0aW9uX2FsbG93ZWQgaW5cbiAgICBtYXRjaFxuICAgICAgdC5tdXRhdGlvbl9hbGxvd2VkIDwtIGZhbHNlO1xuICAgICAgZm9yIGkgPSAwIHRvIG4gLSAxIGRvXG4gICAgICAgIG1hdGNoIEFycmF5LnVuc2FmZV9nZXQgdC50YWJsZSBpIHdpdGhcbiAgICAgICAgfCBBdmx0cmVlLkVtcHR5IC0+ICgpXG4gICAgICAgIHwgQXZsdHJlZS5MZWFmIHsga2V5OyB2YWx1ZSA9IGRhdGEgfSAtPiBmIH5rZXkgfmRhdGFcbiAgICAgICAgfCBidWNrZXQgLT4gQXZsdHJlZS5pdGVyIGJ1Y2tldCB+ZlxuICAgICAgZG9uZVxuICAgIHdpdGhcbiAgICB8ICgpIC0+IHQubXV0YXRpb25fYWxsb3dlZCA8LSBtXG4gICAgfCBleGNlcHRpb24gZXhuIC0+XG4gICAgICB0Lm11dGF0aW9uX2FsbG93ZWQgPC0gbTtcbiAgICAgIHJhaXNlIGV4bilcbjs7XG5cbmxldCBpdGVyIHQgfmYgPSBpdGVyaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBpdGVyX2tleXMgdCB+ZiA9IGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOl8gLT4gZiBrZXkpXG5cbmxldCByZWMgY2hvb3NlX25vbmVtcHR5IHRhYmxlIGkgPVxuICBsZXQgYXZsdHJlZSA9IHRhYmxlLihpKSBpblxuICBpZiBBdmx0cmVlLmlzX2VtcHR5IGF2bHRyZWVcbiAgdGhlbiBjaG9vc2Vfbm9uZW1wdHkgdGFibGUgKGkgKyAxKVxuICBlbHNlIEF2bHRyZWUuY2hvb3NlX2V4biBhdmx0cmVlXG47O1xuXG5sZXQgY2hvb3NlX2V4biB0ID1cbiAgaWYgdC5sZW5ndGggPSAwIHRoZW4gcmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiW0hhc2h0YmwuY2hvb3NlX2V4bl0gb2YgZW1wdHkgaGFzaHRibFwiIFtdKTtcbiAgY2hvb3NlX25vbmVtcHR5IHQudGFibGUgMFxuOztcblxubGV0IGNob29zZSB0ID0gaWYgaXNfZW1wdHkgdCB0aGVuIE5vbmUgZWxzZSBTb21lIChjaG9vc2Vfbm9uZW1wdHkgdC50YWJsZSAwKVxuXG5sZXQgaW52YXJpYW50IGludmFyaWFudF9rZXkgaW52YXJpYW50X2RhdGEgdCA9XG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC50YWJsZSAtIDEgZG9cbiAgICBBdmx0cmVlLmludmFyaWFudCB0LnRhYmxlLihpKSB+Y29tcGFyZTooY29tcGFyZV9rZXkgdClcbiAgZG9uZTtcbiAgbGV0IHJlYWxfbGVuID1cbiAgICBmb2xkIHQgfmluaXQ6MCB+ZjooZnVuIH5rZXkgfmRhdGEgaSAtPlxuICAgICAgaW52YXJpYW50X2tleSBrZXk7XG4gICAgICBpbnZhcmlhbnRfZGF0YSBkYXRhO1xuICAgICAgaSArIDEpXG4gIGluXG4gIGFzc2VydCAocmVhbF9sZW4gPSB0Lmxlbmd0aClcbjs7XG5cbmxldCBmaW5kX2V4biA9XG4gIGxldCBpZl9mb3VuZCB2IF8gPSB2IGluXG4gIGxldCBpZl9ub3RfZm91bmQgayB0ID1cbiAgICByYWlzZVxuICAgICAgKE5vdF9mb3VuZF9zIChMaXN0IFsgQXRvbSBcIkhhc2h0YmwuZmluZF9leG46IG5vdCBmb3VuZFwiOyB0Lmhhc2hhYmxlLnNleHBfb2ZfdCBrIF0pKVxuICBpblxuICBsZXQgZmluZF9leG4gdCBrZXkgPSBmaW5kX2FuZF9jYWxsMSB0IGtleSB+YTp0IH5pZl9mb3VuZCB+aWZfbm90X2ZvdW5kIGluXG4gICgqIG5hbWVkIHRvIHByZXNlcnZlIHN5bWJvbCBpbiBjb21waWxlZCBiaW5hcnkgKilcbiAgZmluZF9leG5cbjs7XG5cbmxldCBleGlzdHNpIHQgfmYgPVxuICB3aXRoX3JldHVybiAoZnVuIHIgLT5cbiAgICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiByLnJldHVybiB0cnVlKTtcbiAgICBmYWxzZSlcbjs7XG5cbmxldCBleGlzdHMgdCB+ZiA9IGV4aXN0c2kgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5sZXQgZm9yX2FsbGkgdCB+ZiA9IG5vdCAoZXhpc3RzaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBub3QgKGYgfmtleSB+ZGF0YSkpKVxubGV0IGZvcl9hbGwgdCB+ZiA9IG5vdCAoZXhpc3RzaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IG5vdCAoZiBkYXRhKSkpXG5cbmxldCBjb3VudGkgdCB+ZiA9XG4gIGZvbGQgdCB+aW5pdDowIH5mOihmdW4gfmtleSB+ZGF0YSBhY2MgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gYWNjICsgMSBlbHNlIGFjYylcbjs7XG5cbmxldCBjb3VudCB0IH5mID1cbiAgZm9sZCB0IH5pbml0OjAgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgYWNjIC0+IGlmIGYgZGF0YSB0aGVuIGFjYyArIDEgZWxzZSBhY2MpXG47O1xuXG5sZXQgbWFwaSB0IH5mID1cbiAgbGV0IG5ld190ID1cbiAgICBjcmVhdGUgfmdyb3d0aF9hbGxvd2VkOnQuZ3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlOnQuaGFzaGFibGUgfnNpemU6dC5sZW5ndGggKClcbiAgaW5cbiAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gc2V0IG5ld190IH5rZXkgfmRhdGE6KGYgfmtleSB+ZGF0YSkpO1xuICBuZXdfdFxuOztcblxubGV0IG1hcCB0IH5mID0gbWFwaSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBjb3B5IHQgPSBtYXAgdCB+ZjpGbi5pZFxuXG5sZXQgZmlsdGVyX21hcGkgdCB+ZiA9XG4gIGxldCBuZXdfdCA9XG4gICAgY3JlYXRlIH5ncm93dGhfYWxsb3dlZDp0Lmdyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZTp0Lmhhc2hhYmxlIH5zaXplOnQubGVuZ3RoICgpXG4gIGluXG4gIGl0ZXJpIHQgfmY6KGZ1biB+a2V5IH5kYXRhIC0+XG4gICAgbWF0Y2ggZiB+a2V5IH5kYXRhIHdpdGhcbiAgICB8IFNvbWUgbmV3X2RhdGEgLT4gc2V0IG5ld190IH5rZXkgfmRhdGE6bmV3X2RhdGFcbiAgICB8IE5vbmUgLT4gKCkpO1xuICBuZXdfdFxuOztcblxubGV0IGZpbHRlcl9tYXAgdCB+ZiA9IGZpbHRlcl9tYXBpIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgZmlsdGVyaSB0IH5mID1cbiAgZmlsdGVyX21hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT4gaWYgZiB+a2V5IH5kYXRhIHRoZW4gU29tZSBkYXRhIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBmaWx0ZXIgdCB+ZiA9IGZpbHRlcmkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5sZXQgZmlsdGVyX2tleXMgdCB+ZiA9IGZpbHRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6XyAtPiBmIGtleSlcblxubGV0IHBhcnRpdGlvbl9tYXBpIHQgfmYgPVxuICBsZXQgdDAgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBsZXQgdDEgPVxuICAgIGNyZWF0ZSB+Z3Jvd3RoX2FsbG93ZWQ6dC5ncm93dGhfYWxsb3dlZCB+aGFzaGFibGU6dC5oYXNoYWJsZSB+c2l6ZTp0Lmxlbmd0aCAoKVxuICBpblxuICBpdGVyaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIG1hdGNoIChmIH5rZXkgfmRhdGEgOiBfIEVpdGhlci50KSB3aXRoXG4gICAgfCBGaXJzdCBuZXdfZGF0YSAtPiBzZXQgdDAgfmtleSB+ZGF0YTpuZXdfZGF0YVxuICAgIHwgU2Vjb25kIG5ld19kYXRhIC0+IHNldCB0MSB+a2V5IH5kYXRhOm5ld19kYXRhKTtcbiAgdDAsIHQxXG47O1xuXG5sZXQgcGFydGl0aW9uX21hcCB0IH5mID0gcGFydGl0aW9uX21hcGkgdCB+ZjooZnVuIH5rZXk6XyB+ZGF0YSAtPiBmIGRhdGEpXG5cbmxldCBwYXJ0aXRpb25pX3RmIHQgfmYgPVxuICBwYXJ0aXRpb25fbWFwaSB0IH5mOihmdW4gfmtleSB+ZGF0YSAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBGaXJzdCBkYXRhIGVsc2UgU2Vjb25kIGRhdGEpXG47O1xuXG5sZXQgcGFydGl0aW9uX3RmIHQgfmYgPSBwYXJ0aXRpb25pX3RmIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgZmluZF9vcl9hZGQgdCBpZCB+ZGVmYXVsdCA9XG4gIGZpbmRfYW5kX2NhbGwyXG4gICAgdFxuICAgIGlkXG4gICAgfmE6dFxuICAgIH5iOmRlZmF1bHRcbiAgICB+aWZfZm91bmQ6KGZ1biBkYXRhIF8gXyAtPiBkYXRhKVxuICAgIH5pZl9ub3RfZm91bmQ6KGZ1biBrZXkgdCBkZWZhdWx0IC0+XG4gICAgICBsZXQgZGVmYXVsdCA9IGRlZmF1bHQgKCkgaW5cbiAgICAgIHNldCB0IH5rZXkgfmRhdGE6ZGVmYXVsdDtcbiAgICAgIGRlZmF1bHQpXG47O1xuXG5sZXQgZmluZGlfb3JfYWRkIHQgaWQgfmRlZmF1bHQgPVxuICBmaW5kX2FuZF9jYWxsMlxuICAgIHRcbiAgICBpZFxuICAgIH5hOnRcbiAgICB+YjpkZWZhdWx0XG4gICAgfmlmX2ZvdW5kOihmdW4gZGF0YSBfIF8gLT4gZGF0YSlcbiAgICB+aWZfbm90X2ZvdW5kOihmdW4ga2V5IHQgZGVmYXVsdCAtPlxuICAgICAgbGV0IGRlZmF1bHQgPSBkZWZhdWx0IGtleSBpblxuICAgICAgc2V0IHQgfmtleSB+ZGF0YTpkZWZhdWx0O1xuICAgICAgZGVmYXVsdClcbjs7XG5cbigqIFNvbWUgaGFzaHRibCBpbXBsZW1lbnRhdGlvbnMgbWF5IGJlIGFibGUgdG8gcGVyZm9ybSB0aGlzIG1vcmUgZWZmaWNpZW50bHkgdGhhbiB0d29cbiAgIHNlcGFyYXRlIGxvb2t1cHMgKilcbmxldCBmaW5kX2FuZF9yZW1vdmUgdCBpZCA9XG4gIGxldCByZXN1bHQgPSBmaW5kIHQgaWQgaW5cbiAgaWYgT3B0aW9uLmlzX3NvbWUgcmVzdWx0IHRoZW4gcmVtb3ZlIHQgaWQ7XG4gIHJlc3VsdFxuOztcblxuXG5sZXQgY2hhbmdlIHQgaWQgfmYgPVxuICBtYXRjaCBmIChmaW5kIHQgaWQpIHdpdGhcbiAgfCBOb25lIC0+IHJlbW92ZSB0IGlkXG4gIHwgU29tZSBkYXRhIC0+IHNldCB0IH5rZXk6aWQgfmRhdGFcbjs7XG5cbmxldCB1cGRhdGVfYW5kX3JldHVybiB0IGlkIH5mID1cbiAgbGV0IGRhdGEgPSBmIChmaW5kIHQgaWQpIGluXG4gIHNldCB0IH5rZXk6aWQgfmRhdGE7XG4gIGRhdGFcbjs7XG5cbmxldCB1cGRhdGUgdCBpZCB+ZiA9IGlnbm9yZSAodXBkYXRlX2FuZF9yZXR1cm4gdCBpZCB+ZiA6IF8pXG5cbmxldCBpbmNyX2J5IH5yZW1vdmVfaWZfemVybyB0IGtleSBieSA9XG4gIGlmIHJlbW92ZV9pZl96ZXJvXG4gIHRoZW5cbiAgICBjaGFuZ2UgdCBrZXkgfmY6KGZ1biBvcHQgLT5cbiAgICAgIG1hdGNoIGJ5ICsgT3B0aW9uLnZhbHVlIG9wdCB+ZGVmYXVsdDowIHdpdGhcbiAgICAgIHwgMCAtPiBOb25lXG4gICAgICB8IG4gLT4gU29tZSBuKVxuICBlbHNlXG4gICAgdXBkYXRlIHQga2V5IH5mOihmdW5jdGlvblxuICAgICAgfCBOb25lIC0+IGJ5XG4gICAgICB8IFNvbWUgaSAtPiBieSArIGkpXG47O1xuXG5sZXQgaW5jciA/KGJ5ID0gMSkgPyhyZW1vdmVfaWZfemVybyA9IGZhbHNlKSB0IGtleSA9IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5IGJ5XG5sZXQgZGVjciA/KGJ5ID0gMSkgPyhyZW1vdmVfaWZfemVybyA9IGZhbHNlKSB0IGtleSA9IGluY3JfYnkgfnJlbW92ZV9pZl96ZXJvIHQga2V5ICgtYnkpXG5cbmxldCBhZGRfbXVsdGkgdCB+a2V5IH5kYXRhID1cbiAgdXBkYXRlIHQga2V5IH5mOihmdW5jdGlvblxuICAgIHwgTm9uZSAtPiBbIGRhdGEgXVxuICAgIHwgU29tZSBsIC0+IGRhdGEgOjogbClcbjs7XG5cbmxldCByZW1vdmVfbXVsdGkgdCBrZXkgPVxuICBtYXRjaCBmaW5kIHQga2V5IHdpdGhcbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBbXSB8IFNvbWUgWyBfIF0gLT4gcmVtb3ZlIHQga2V5XG4gIHwgU29tZSAoXyA6OiB0bCkgLT4gc2V0IHQgfmtleSB+ZGF0YTp0bFxuOztcblxubGV0IGZpbmRfbXVsdGkgdCBrZXkgPVxuICBtYXRjaCBmaW5kIHQga2V5IHdpdGhcbiAgfCBOb25lIC0+IFtdXG4gIHwgU29tZSBsIC0+IGxcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhIHJvd3MgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHMgLT4gc1xuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCByb3dzXG4gIGluXG4gIGxldCByZXMgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSB+c2l6ZSAoKSBpblxuICBsZXQgZHVwZXMgPSByZWYgW10gaW5cbiAgTGlzdC5pdGVyIHJvd3MgfmY6KGZ1biByIC0+XG4gICAgbGV0IGtleSA9IGdldF9rZXkgciBpblxuICAgIGxldCBkYXRhID0gZ2V0X2RhdGEgciBpblxuICAgIGlmIG1lbSByZXMga2V5IHRoZW4gZHVwZXMgOj0ga2V5IDo6ICFkdXBlcyBlbHNlIHNldCByZXMgfmtleSB+ZGF0YSk7XG4gIG1hdGNoICFkdXBlcyB3aXRoXG4gIHwgW10gLT4gYE9rIHJlc1xuICB8IGtleXMgLT4gYER1cGxpY2F0ZV9rZXlzIChMaXN0LmRlZHVwX2FuZF9zb3J0IH5jb21wYXJlOmhhc2hhYmxlLkhhc2hhYmxlLmNvbXBhcmUga2V5cylcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkX211bHRpID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhIHJvd3MgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHMgLT4gc1xuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCByb3dzXG4gIGluXG4gIGxldCByZXMgPSBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5zaXplIH5oYXNoYWJsZSAoKSBpblxuICBMaXN0Lml0ZXIgcm93cyB+ZjooZnVuIHIgLT5cbiAgICBsZXQga2V5ID0gZ2V0X2tleSByIGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByIGluXG4gICAgYWRkX211bHRpIHJlcyB+a2V5IH5kYXRhKTtcbiAgcmVzXG47O1xuXG5sZXQgb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3QgPVxuICBtYXRjaCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXk6ZnN0IH5nZXRfZGF0YTpzbmQgbHN0IHdpdGhcbiAgfCBgT2sgdCAtPiBgT2sgdFxuICB8IGBEdXBsaWNhdGVfa2V5cyBrIC0+IGBEdXBsaWNhdGVfa2V5IChMaXN0LmhkX2V4biBrKVxuOztcblxubGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIGNyZWF0ZV9tYXBwZWQgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Rcbjs7XG5cbmxldCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIG1hdGNoIG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgbHN0IHdpdGhcbiAgfCBgT2sgdiAtPiBSZXN1bHQuT2sgdlxuICB8IGBEdXBsaWNhdGVfa2V5IGtleSAtPlxuICAgIGxldCBzZXhwX29mX2tleSA9IGhhc2hhYmxlLkhhc2hhYmxlLnNleHBfb2ZfdCBpblxuICAgIE9yX2Vycm9yLmVycm9yIFwiSGFzaHRibC5vZl9hbGlzdF9leG46IGR1cGxpY2F0ZSBrZXlcIiBrZXkgc2V4cF9vZl9rZXlcbjs7XG5cbmxldCBvZl9hbGlzdF9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSBsc3QgPVxuICBtYXRjaCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCB3aXRoXG4gIHwgUmVzdWx0Lk9rIHYgLT4gdlxuICB8IFJlc3VsdC5FcnJvciBlIC0+IEVycm9yLnJhaXNlIGVcbjs7XG5cbmxldCBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIGxzdCA9XG4gIGNyZWF0ZV9tYXBwZWRfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleTpmc3QgfmdldF9kYXRhOnNuZCBsc3Rcbjs7XG5cbmxldCB0b19hbGlzdCB0ID0gZm9sZCB+ZjooZnVuIH5rZXkgfmRhdGEgbGlzdCAtPiAoa2V5LCBkYXRhKSA6OiBsaXN0KSB+aW5pdDpbXSB0XG5cbmxldCBzZXhwX29mX3Qgc2V4cF9vZl9rZXkgc2V4cF9vZl9kYXRhIHQgPVxuICB0XG4gIHw+IHRvX2FsaXN0XG4gIHw+IExpc3Quc29ydCB+Y29tcGFyZTooZnVuIChrMSwgXykgKGsyLCBfKSAtPiB0Lmhhc2hhYmxlLmNvbXBhcmUgazEgazIpXG4gIHw+IHNleHBfb2ZfbGlzdCAoc2V4cF9vZl9wYWlyIHNleHBfb2Zfa2V5IHNleHBfb2ZfZGF0YSlcbjs7XG5cbmxldCB0X29mX3NleHAgfmhhc2hhYmxlIGtfb2Zfc2V4cCBkX29mX3NleHAgc2V4cCA9XG4gIGxldCBhbGlzdCA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIGtfb2Zfc2V4cCBkX29mX3NleHApIHNleHAgaW5cbiAgbWF0Y2ggb2ZfYWxpc3Qgfmhhc2hhYmxlIGFsaXN0IH5zaXplOihMaXN0Lmxlbmd0aCBhbGlzdCkgd2l0aFxuICB8IGBPayB2IC0+IHZcbiAgfCBgRHVwbGljYXRlX2tleSBrIC0+XG4gICAgKCogZmluZCB0aGUgc2V4cCBvZiBhIGR1cGxpY2F0ZSBrZXksIHNvIHRoZSBlcnJvciBpcyBuYXJyb3dlZCB0byBhIGtleSBhbmQgbm90XG4gICAgICAgdGhlIHdob2xlIG1hcCAqKVxuICAgIGxldCBhbGlzdF9zZXhwcyA9IGxpc3Rfb2Zfc2V4cCAocGFpcl9vZl9zZXhwIEZuLmlkIEZuLmlkKSBzZXhwIGluXG4gICAgbGV0IGZvdW5kX2ZpcnN0X2sgPSByZWYgZmFsc2UgaW5cbiAgICBMaXN0Lml0ZXIyX2V4biBhbGlzdCBhbGlzdF9zZXhwcyB+ZjooZnVuIChrMiwgXykgKGsyX3NleHAsIF8pIC0+XG4gICAgICBpZiBoYXNoYWJsZS5jb21wYXJlIGsgazIgPSAwXG4gICAgICB0aGVuXG4gICAgICAgIGlmICFmb3VuZF9maXJzdF9rXG4gICAgICAgIHRoZW4gb2Zfc2V4cF9lcnJvciBcIkhhc2h0YmwudF9vZl9zZXhwOiBkdXBsaWNhdGUga2V5XCIgazJfc2V4cFxuICAgICAgICBlbHNlIGZvdW5kX2ZpcnN0X2sgOj0gdHJ1ZSk7XG4gICAgYXNzZXJ0IGZhbHNlXG47O1xuXG5sZXQgdF9zZXhwX2dyYW1tYXJcbiAgICAgICh0eXBlIGsgdilcbiAgICAgIChrX2dyYW1tYXIgOiBrIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgICAgKHZfZ3JhbW1hciA6IHYgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpXG4gIDogKGssIHYpIHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnRcbiAgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LkFzc29jLnRfc2V4cF9ncmFtbWFyIGtfZ3JhbW1hciB2X2dyYW1tYXIpXG47O1xuXG5sZXQga2V5cyB0ID0gZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YTpfIGFjYyAtPiBrZXkgOjogYWNjKVxubGV0IGRhdGEgdCA9IGZvbGQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgbGlzdCAtPiBkYXRhIDo6IGxpc3QpIH5pbml0OltdIHRcblxubGV0IGFkZF90b19ncm91cHMgZ3JvdXBzIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSB+cm93cyA9XG4gIExpc3QuaXRlciByb3dzIH5mOihmdW4gcm93IC0+XG4gICAgbGV0IGtleSA9IGdldF9rZXkgcm93IGluXG4gICAgbGV0IGRhdGEgPSBnZXRfZGF0YSByb3cgaW5cbiAgICBsZXQgZGF0YSA9XG4gICAgICBtYXRjaCBmaW5kIGdyb3VwcyBrZXkgd2l0aFxuICAgICAgfCBOb25lIC0+IGRhdGFcbiAgICAgIHwgU29tZSBvbGQgLT4gY29tYmluZSBvbGQgZGF0YVxuICAgIGluXG4gICAgc2V0IGdyb3VwcyB+a2V5IH5kYXRhKVxuOztcblxubGV0IGdyb3VwID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIHJvd3MgPVxuICBsZXQgcmVzID0gY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgKCkgaW5cbiAgYWRkX3RvX2dyb3VwcyByZXMgfmdldF9rZXkgfmdldF9kYXRhIH5jb21iaW5lIH5yb3dzO1xuICByZXNcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzID1cbiAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IH5nZXRfZGF0YTpGbi5pZCByb3dzXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgfmdldF9rZXkgcm93cyA9XG4gIG1hdGNoIGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmhhc2hhYmxlIH5nZXRfa2V5IHJvd3Mgd2l0aFxuICB8IGBPayB0IC0+IFJlc3VsdC5PayB0XG4gIHwgYER1cGxpY2F0ZV9rZXlzIGtleXMgLT5cbiAgICBsZXQgc2V4cF9vZl9rZXkgPSBoYXNoYWJsZS5IYXNoYWJsZS5zZXhwX29mX3QgaW5cbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcIkhhc2h0YmwuY3JlYXRlX3dpdGhfa2V5OiBkdXBsaWNhdGUga2V5c1wiXG4gICAgICAgICBbIFwia2V5c1wiLCBzZXhwX29mX2xpc3Qgc2V4cF9vZl9rZXkga2V5cyBdKVxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9leG4gP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzID1cbiAgT3JfZXJyb3Iub2tfZXhuIChjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5oYXNoYWJsZSB+Z2V0X2tleSByb3dzKVxuOztcblxubGV0IG1lcmdlID1cbiAgbGV0IG1heWJlX3NldCB0IH5rZXkgfmYgZCA9XG4gICAgbWF0Y2ggZiB+a2V5IGQgd2l0aFxuICAgIHwgTm9uZSAtPiAoKVxuICAgIHwgU29tZSB2IC0+IHNldCB0IH5rZXkgfmRhdGE6dlxuICBpblxuICBmdW4gdF9sZWZ0IHRfcmlnaHQgfmYgLT5cbiAgICBpZiBub3QgKEhhc2hhYmxlLmVxdWFsIHRfbGVmdC5oYXNoYWJsZSB0X3JpZ2h0Lmhhc2hhYmxlKVxuICAgIHRoZW4gaW52YWxpZF9hcmcgXCJIYXNodGJsLm1lcmdlOiBkaWZmZXJlbnQgJ2hhc2hhYmxlJyB2YWx1ZXNcIjtcbiAgICBsZXQgbmV3X3QgPVxuICAgICAgY3JlYXRlXG4gICAgICAgIH5ncm93dGhfYWxsb3dlZDp0X2xlZnQuZ3Jvd3RoX2FsbG93ZWRcbiAgICAgICAgfmhhc2hhYmxlOnRfbGVmdC5oYXNoYWJsZVxuICAgICAgICB+c2l6ZTp0X2xlZnQubGVuZ3RoXG4gICAgICAgICgpXG4gICAgaW5cbiAgICB3aXRob3V0X211dGF0aW5nIHRfbGVmdCAoZnVuICgpIC0+XG4gICAgICB3aXRob3V0X211dGF0aW5nIHRfcmlnaHQgKGZ1biAoKSAtPlxuICAgICAgICBpdGVyaSB0X2xlZnQgfmY6KGZ1biB+a2V5IH5kYXRhOmxlZnQgLT5cbiAgICAgICAgICBtYXRjaCBmaW5kIHRfcmlnaHQga2V5IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gbWF5YmVfc2V0IG5ld190IH5rZXkgfmYgKGBMZWZ0IGxlZnQpXG4gICAgICAgICAgfCBTb21lIHJpZ2h0IC0+IG1heWJlX3NldCBuZXdfdCB+a2V5IH5mIChgQm90aCAobGVmdCwgcmlnaHQpKSk7XG4gICAgICAgIGl0ZXJpIHRfcmlnaHQgfmY6KGZ1biB+a2V5IH5kYXRhOnJpZ2h0IC0+XG4gICAgICAgICAgbWF0Y2ggZmluZCB0X2xlZnQga2V5IHdpdGhcbiAgICAgICAgICB8IE5vbmUgLT4gbWF5YmVfc2V0IG5ld190IH5rZXkgfmYgKGBSaWdodCByaWdodClcbiAgICAgICAgICB8IFNvbWUgXyAtPiAoKVxuICAgICAgICAgICgqIGFscmVhZHkgZG9uZSBhYm92ZSAqKSkpKTtcbiAgICBuZXdfdFxuOztcblxubGV0IG1lcmdlX2ludG8gfnNyYyB+ZHN0IH5mID1cbiAgaXRlcmkgc3JjIH5mOihmdW4gfmtleSB+ZGF0YSAtPlxuICAgIGxldCBkc3RfZGF0YSA9IGZpbmQgZHN0IGtleSBpblxuICAgIGxldCBhY3Rpb24gPSB3aXRob3V0X211dGF0aW5nIGRzdCAoZnVuICgpIC0+IGYgfmtleSBkYXRhIGRzdF9kYXRhKSBpblxuICAgIG1hdGNoIChhY3Rpb24gOiBfIE1lcmdlX2ludG9fYWN0aW9uLnQpIHdpdGhcbiAgICB8IFJlbW92ZSAtPiByZW1vdmUgZHN0IGtleVxuICAgIHwgU2V0X3RvIGRhdGEgLT5cbiAgICAgIChtYXRjaCBkc3RfZGF0YSB3aXRoXG4gICAgICAgfCBOb25lIC0+IHNldCBkc3QgfmtleSB+ZGF0YVxuICAgICAgIHwgU29tZSBkc3RfZGF0YSAtPiBpZiBub3QgKHBoeXNfZXF1YWwgZHN0X2RhdGEgZGF0YSkgdGhlbiBzZXQgZHN0IH5rZXkgfmRhdGEpKVxuOztcblxubGV0IGZpbHRlcmlfaW5wbGFjZSB0IH5mID1cbiAgbGV0IHRvX3JlbW92ZSA9XG4gICAgZm9sZCB0IH5pbml0OltdIH5mOihmdW4gfmtleSB+ZGF0YSBhYyAtPiBpZiBmIH5rZXkgfmRhdGEgdGhlbiBhYyBlbHNlIGtleSA6OiBhYylcbiAgaW5cbiAgTGlzdC5pdGVyIHRvX3JlbW92ZSB+ZjooZnVuIGtleSAtPiByZW1vdmUgdCBrZXkpXG47O1xuXG5sZXQgZmlsdGVyX2lucGxhY2UgdCB+ZiA9IGZpbHRlcmlfaW5wbGFjZSB0IH5mOihmdW4gfmtleTpfIH5kYXRhIC0+IGYgZGF0YSlcbmxldCBmaWx0ZXJfa2V5c19pbnBsYWNlIHQgfmYgPSBmaWx0ZXJpX2lucGxhY2UgdCB+ZjooZnVuIH5rZXkgfmRhdGE6XyAtPiBmIGtleSlcblxubGV0IGZpbHRlcl9tYXBpX2lucGxhY2UgdCB+ZiA9XG4gIGxldCBtYXBfcmVzdWx0cyA9IGZvbGQgdCB+aW5pdDpbXSB+ZjooZnVuIH5rZXkgfmRhdGEgYWMgLT4gKGtleSwgZiB+a2V5IH5kYXRhKSA6OiBhYykgaW5cbiAgTGlzdC5pdGVyIG1hcF9yZXN1bHRzIH5mOihmdW4gKGtleSwgcmVzdWx0KSAtPlxuICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgfCBOb25lIC0+IHJlbW92ZSB0IGtleVxuICAgIHwgU29tZSBkYXRhIC0+IHNldCB0IH5rZXkgfmRhdGEpXG47O1xuXG5sZXQgZmlsdGVyX21hcF9pbnBsYWNlIHQgfmYgPSBmaWx0ZXJfbWFwaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgbWFwaV9pbnBsYWNlIHQgfmYgPVxuICBlbnN1cmVfbXV0YXRpb25fYWxsb3dlZCB0O1xuICB3aXRob3V0X211dGF0aW5nIHQgKGZ1biAoKSAtPiBBcnJheS5pdGVyIHQudGFibGUgfmY6KEF2bHRyZWUubWFwaV9pbnBsYWNlIH5mKSlcbjs7XG5cbmxldCBtYXBfaW5wbGFjZSB0IH5mID0gbWFwaV9pbnBsYWNlIHQgfmY6KGZ1biB+a2V5Ol8gfmRhdGEgLT4gZiBkYXRhKVxuXG5sZXQgZXF1YWwgZXF1YWwgdCB0JyA9XG4gIGxlbmd0aCB0ID0gbGVuZ3RoIHQnXG4gICYmIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgIHdpdGhvdXRfbXV0YXRpbmcgdCcgKGZ1biAoKSAtPlxuICAgICAgaXRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGEgLT5cbiAgICAgICAgbWF0Y2ggZmluZCB0JyBrZXkgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gci5yZXR1cm4gZmFsc2VcbiAgICAgICAgfCBTb21lIGRhdGEnIC0+IGlmIG5vdCAoZXF1YWwgZGF0YSBkYXRhJykgdGhlbiByLnJldHVybiBmYWxzZSkpO1xuICAgIHRydWUpXG47O1xuXG5sZXQgc2ltaWxhciA9IGVxdWFsXG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGludmFyaWFudCA9IGludmFyaWFudFxuICBsZXQgY2hvb3NlID0gY2hvb3NlXG4gIGxldCBjaG9vc2VfZXhuID0gY2hvb3NlX2V4blxuICBsZXQgY2xlYXIgPSBjbGVhclxuICBsZXQgY29weSA9IGNvcHlcbiAgbGV0IHJlbW92ZSA9IHJlbW92ZVxuICBsZXQgc2V0ID0gc2V0XG4gIGxldCBhZGQgPSBhZGRcbiAgbGV0IGFkZF9leG4gPSBhZGRfZXhuXG4gIGxldCBjaGFuZ2UgPSBjaGFuZ2VcbiAgbGV0IHVwZGF0ZSA9IHVwZGF0ZVxuICBsZXQgdXBkYXRlX2FuZF9yZXR1cm4gPSB1cGRhdGVfYW5kX3JldHVyblxuICBsZXQgYWRkX211bHRpID0gYWRkX211bHRpXG4gIGxldCByZW1vdmVfbXVsdGkgPSByZW1vdmVfbXVsdGlcbiAgbGV0IGZpbmRfbXVsdGkgPSBmaW5kX211bHRpXG4gIGxldCBtZW0gPSBtZW1cbiAgbGV0IGl0ZXJfa2V5cyA9IGl0ZXJfa2V5c1xuICBsZXQgaXRlciA9IGl0ZXJcbiAgbGV0IGl0ZXJpID0gaXRlcmlcbiAgbGV0IGV4aXN0cyA9IGV4aXN0c1xuICBsZXQgZXhpc3RzaSA9IGV4aXN0c2lcbiAgbGV0IGZvcl9hbGwgPSBmb3JfYWxsXG4gIGxldCBmb3JfYWxsaSA9IGZvcl9hbGxpXG4gIGxldCBjb3VudCA9IGNvdW50XG4gIGxldCBjb3VudGkgPSBjb3VudGlcbiAgbGV0IGZvbGQgPSBmb2xkXG4gIGxldCBsZW5ndGggPSBsZW5ndGhcbiAgbGV0IGlzX2VtcHR5ID0gaXNfZW1wdHlcbiAgbGV0IG1hcCA9IG1hcFxuICBsZXQgbWFwaSA9IG1hcGlcbiAgbGV0IGZpbHRlcl9tYXAgPSBmaWx0ZXJfbWFwXG4gIGxldCBmaWx0ZXJfbWFwaSA9IGZpbHRlcl9tYXBpXG4gIGxldCBmaWx0ZXJfa2V5cyA9IGZpbHRlcl9rZXlzXG4gIGxldCBmaWx0ZXIgPSBmaWx0ZXJcbiAgbGV0IGZpbHRlcmkgPSBmaWx0ZXJpXG4gIGxldCBwYXJ0aXRpb25fbWFwID0gcGFydGl0aW9uX21hcFxuICBsZXQgcGFydGl0aW9uX21hcGkgPSBwYXJ0aXRpb25fbWFwaVxuICBsZXQgcGFydGl0aW9uX3RmID0gcGFydGl0aW9uX3RmXG4gIGxldCBwYXJ0aXRpb25pX3RmID0gcGFydGl0aW9uaV90ZlxuICBsZXQgZmluZF9vcl9hZGQgPSBmaW5kX29yX2FkZFxuICBsZXQgZmluZGlfb3JfYWRkID0gZmluZGlfb3JfYWRkXG4gIGxldCBmaW5kID0gZmluZFxuICBsZXQgZmluZF9leG4gPSBmaW5kX2V4blxuICBsZXQgZmluZF9hbmRfY2FsbCA9IGZpbmRfYW5kX2NhbGxcbiAgbGV0IGZpbmRfYW5kX2NhbGwxID0gZmluZF9hbmRfY2FsbDFcbiAgbGV0IGZpbmRfYW5kX2NhbGwyID0gZmluZF9hbmRfY2FsbDJcbiAgbGV0IGZpbmRpX2FuZF9jYWxsID0gZmluZGlfYW5kX2NhbGxcbiAgbGV0IGZpbmRpX2FuZF9jYWxsMSA9IGZpbmRpX2FuZF9jYWxsMVxuICBsZXQgZmluZGlfYW5kX2NhbGwyID0gZmluZGlfYW5kX2NhbGwyXG4gIGxldCBmaW5kX2FuZF9yZW1vdmUgPSBmaW5kX2FuZF9yZW1vdmVcbiAgbGV0IHRvX2FsaXN0ID0gdG9fYWxpc3RcbiAgbGV0IG1lcmdlID0gbWVyZ2VcbiAgbGV0IG1lcmdlX2ludG8gPSBtZXJnZV9pbnRvXG4gIGxldCBrZXlzID0ga2V5c1xuICBsZXQgZGF0YSA9IGRhdGFcbiAgbGV0IGZpbHRlcl9rZXlzX2lucGxhY2UgPSBmaWx0ZXJfa2V5c19pbnBsYWNlXG4gIGxldCBmaWx0ZXJfaW5wbGFjZSA9IGZpbHRlcl9pbnBsYWNlXG4gIGxldCBmaWx0ZXJpX2lucGxhY2UgPSBmaWx0ZXJpX2lucGxhY2VcbiAgbGV0IG1hcF9pbnBsYWNlID0gbWFwX2lucGxhY2VcbiAgbGV0IG1hcGlfaW5wbGFjZSA9IG1hcGlfaW5wbGFjZVxuICBsZXQgZmlsdGVyX21hcF9pbnBsYWNlID0gZmlsdGVyX21hcF9pbnBsYWNlXG4gIGxldCBmaWx0ZXJfbWFwaV9pbnBsYWNlID0gZmlsdGVyX21hcGlfaW5wbGFjZVxuICBsZXQgZXF1YWwgPSBlcXVhbFxuICBsZXQgc2ltaWxhciA9IHNpbWlsYXJcbiAgbGV0IGluY3IgPSBpbmNyXG4gIGxldCBkZWNyID0gZGVjclxuICBsZXQgc2V4cF9vZl9rZXkgPSBzZXhwX29mX2tleVxuZW5kXG5cbm1vZHVsZSBDcmVhdG9ycyAoS2V5IDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaGFzaGFibGUgOiAnYSB0IEhhc2hhYmxlLnRcbiAgZW5kKSA6IHNpZ1xuICB0eXBlICgnYSwgJ2IpIHRfID0gKCdhIEtleS50LCAnYikgdFxuXG4gIHZhbCB0X29mX3NleHAgOiAoU2V4cC50IC0+ICdhIEtleS50KSAtPiAoU2V4cC50IC0+ICdiKSAtPiBTZXhwLnQgLT4gKCdhLCAnYikgdF9cblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAoJ2EsICdiKSB0IDo9ICgnYSwgJ2IpIHRfXG4gICAgd2l0aCB0eXBlICdhIGtleSA6PSAnYSBLZXkudFxuICAgIHdpdGggdHlwZSAoJ2tleSwgJ2RhdGEsICdhKSBjcmVhdGVfb3B0aW9ucyA6PVxuICAgICAgKCdrZXksICdkYXRhLCAnYSkgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcbmVuZCA9IHN0cnVjdFxuICBsZXQgaGFzaGFibGUgPSBLZXkuaGFzaGFibGVcblxuICB0eXBlICgnYSwgJ2IpIHRfID0gKCdhIEtleS50LCAnYikgdFxuXG4gIGxldCBjcmVhdGUgP2dyb3d0aF9hbGxvd2VkID9zaXplICgpID0gY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+aGFzaGFibGUgKClcbiAgbGV0IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsID0gb2ZfYWxpc3QgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG5cbiAgbGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCBvZl9hbGlzdF9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkIH5oYXNoYWJsZSA/c2l6ZSBsXG4gIDs7XG5cbiAgbGV0IG9mX2FsaXN0X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAga19vZl9zZXhwIGRfb2Zfc2V4cCBzZXhwID0gdF9vZl9zZXhwIH5oYXNoYWJsZSBrX29mX3NleHAgZF9vZl9zZXhwIHNleHBcblxuICBsZXQgb2ZfYWxpc3RfbXVsdGkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGwgPVxuICAgIG9mX2FsaXN0X211bHRpID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSB+Z2V0X2RhdGEgbCA9XG4gICAgY3JlYXRlX21hcHBlZCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSBsXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZV93aXRoX2tleSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5ID9ncm93dGhfYWxsb3dlZCB+aGFzaGFibGUgP3NpemUgfmdldF9rZXkgbFxuICA7O1xuXG4gIGxldCBjcmVhdGVfd2l0aF9rZXlfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IGwgPVxuICAgIGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IGxcbiAgOztcblxuICBsZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbCA9XG4gICAgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IGxcbiAgOztcblxuICBsZXQgZ3JvdXAgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsID1cbiAgICBncm91cCA/Z3Jvd3RoX2FsbG93ZWQgfmhhc2hhYmxlID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsXG4gIDs7XG5lbmRcblxubW9kdWxlIFBvbHkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgKCdhLCAnYikgdCA9ICgnYSwgJ2IpIHRcbiAgdHlwZSAnYSBrZXkgPSAnYVxuXG4gIGxldCBoYXNoYWJsZSA9IEhhc2hhYmxlLnBvbHlcblxuICBpbmNsdWRlIENyZWF0b3JzIChzdHJ1Y3RcbiAgICAgIHR5cGUgJ2EgdCA9ICdhXG5cbiAgICAgIGxldCBoYXNoYWJsZSA9IGhhc2hhYmxlXG4gICAgZW5kKVxuXG4gIGluY2x1ZGUgQWNjZXNzb3JzXG5cbiAgbGV0IHNleHBfb2ZfdCA9IHNleHBfb2ZfdFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgPSB0X3NleHBfZ3JhbW1hclxuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIG1vZHVsZSB0eXBlIENyZWF0b3JzX2dlbmVyaWMgPSBDcmVhdG9yc19nZW5lcmljXG4gIG1vZHVsZSB0eXBlIEhhc2hhYmxlID0gSGFzaGFibGUuSGFzaGFibGVcblxuICB0eXBlIG5vbnJlYyAoJ2tleSwgJ2RhdGEsICd6KSBjcmVhdGVfb3B0aW9uc193aXRob3V0X2ZpcnN0X2NsYXNzX21vZHVsZSA9XG4gICAgKCdrZXksICdkYXRhLCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcblxuICBsZXQgaGFzaGFibGUgdCA9IHQuaGFzaGFibGVcbmVuZFxuXG5sZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtID1cbiAgY3JlYXRlIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoKVxuOztcblxubGV0IG9mX2FsaXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbFxuOztcblxubGV0IG9mX2FsaXN0X3JlcG9ydF9hbGxfZHVwcyA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3RfcmVwb3J0X2FsbF9kdXBzIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3Rfb3JfZXJyb3IgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gbCA9XG4gIG9mX2FsaXN0X29yX2Vycm9yIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBsXG47O1xuXG5sZXQgb2ZfYWxpc3RfZXhuID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBvZl9hbGlzdF9leG4gfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBvZl9hbGlzdF9tdWx0aSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSBsID1cbiAgb2ZfYWxpc3RfbXVsdGkgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIGxcbjs7XG5cbmxldCBjcmVhdGVfbWFwcGVkID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IH5nZXRfZGF0YSBsID1cbiAgY3JlYXRlX21hcHBlZCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgfmdldF9kYXRhIGxcbjs7XG5cbmxldCBjcmVhdGVfd2l0aF9rZXkgP2dyb3d0aF9hbGxvd2VkID9zaXplIG0gfmdldF9rZXkgbCA9XG4gIGNyZWF0ZV93aXRoX2tleSB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbFxuOztcblxubGV0IGNyZWF0ZV93aXRoX2tleV9vcl9lcnJvciA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5X29yX2Vycm9yIH5oYXNoYWJsZTooSGFzaGFibGUub2Zfa2V5IG0pID9ncm93dGhfYWxsb3dlZCA/c2l6ZSB+Z2V0X2tleSBsXG47O1xuXG5sZXQgY3JlYXRlX3dpdGhfa2V5X2V4biA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSB+Z2V0X2tleSBsID1cbiAgY3JlYXRlX3dpdGhfa2V5X2V4biB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSBtKSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgfmdldF9rZXkgbFxuOztcblxubGV0IGdyb3VwID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsID1cbiAgZ3JvdXAgfmhhc2hhYmxlOihIYXNoYWJsZS5vZl9rZXkgbSkgP2dyb3d0aF9hbGxvd2VkID9zaXplIH5nZXRfa2V5IH5nZXRfZGF0YSB+Y29tYmluZSBsXG47O1xuXG5sZXQgaGFzaGFibGVfcyB0ID0gSGFzaGFibGUudG9fa2V5IHQuaGFzaGFibGVcblxubW9kdWxlIE0gKEsgOiBULlQpID0gc3RydWN0XG4gIHR5cGUgbm9ucmVjICd2IHQgPSAoSy50LCAndikgdFxuZW5kXG5cbm1vZHVsZSB0eXBlIFNleHBfb2ZfbSA9IHNpZ1xuICB0eXBlIHQgW0BAZGVyaXZpbmdfaW5saW5lIHNleHBfb2ZdXG5cbiAgdmFsIHNleHBfb2ZfdCA6IHQgLT4gU2V4cGxpYjAuU2V4cC50XG5cbiAgW0BAQGVuZF1cbmVuZFxuXG5tb2R1bGUgdHlwZSBNX29mX3NleHAgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBvZl9zZXhwXVxuXG4gIHZhbCB0X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdFxuXG4gIFtAQEBlbmRdXG5cbiAgaW5jbHVkZSBLZXkuUyB3aXRoIHR5cGUgdCA6PSB0XG5lbmRcblxubW9kdWxlIHR5cGUgTV9zZXhwX2dyYW1tYXIgPSBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX2dyYW1tYXJdXG5cbiAgdmFsIHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudFxuXG4gIFtAQEBlbmRdXG5lbmRcblxubW9kdWxlIHR5cGUgRXF1YWxfbSA9IHNpZyBlbmRcblxubGV0IHNleHBfb2ZfbV9fdCAodHlwZSBrKSAobW9kdWxlIEsgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBrKSBzZXhwX29mX3YgdCA9XG4gIHNleHBfb2ZfdCBLLnNleHBfb2ZfdCBzZXhwX29mX3YgdFxuOztcblxubGV0IG1fX3Rfb2Zfc2V4cCAodHlwZSBrKSAobW9kdWxlIEsgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBrKSB2X29mX3NleHAgc2V4cCA9XG4gIHRfb2Zfc2V4cCB+aGFzaGFibGU6KEhhc2hhYmxlLm9mX2tleSAobW9kdWxlIEspKSBLLnRfb2Zfc2V4cCB2X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGspIChtb2R1bGUgSyA6IE1fc2V4cF9ncmFtbWFyIHdpdGggdHlwZSB0ID0gaykgdl9ncmFtbWFyID1cbiAgdF9zZXhwX2dyYW1tYXIgSy50X3NleHBfZ3JhbW1hciB2X2dyYW1tYXJcbjs7XG5cbmxldCBlcXVhbF9tX190IChtb2R1bGUgXyA6IEVxdWFsX20pIGVxdWFsX3YgdDEgdDIgPSBlcXVhbCBlcXVhbF92IHQxIHQyXG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgSGFzaF9zZXRfaW50ZlxuXG5sZXQgaGFzaGFibGVfcyA9IEhhc2h0YmwuaGFzaGFibGVfc1xubGV0IGhhc2hhYmxlID0gSGFzaHRibC5Qcml2YXRlLmhhc2hhYmxlXG5sZXQgcG9seV9oYXNoYWJsZSA9IEhhc2h0YmwuUG9seS5oYXNoYWJsZVxubGV0IHdpdGhfcmV0dXJuID0gV2l0aF9yZXR1cm4ud2l0aF9yZXR1cm5cblxudHlwZSAnYSB0ID0gKCdhLCB1bml0KSBIYXNodGJsLnRcbnR5cGUgJ2EgaGFzaF9zZXQgPSAnYSB0XG50eXBlICdhIGVsdCA9ICdhXG5cbm1vZHVsZSBBY2Nlc3NvcnMgPSBzdHJ1Y3RcbiAgbGV0IGhhc2hhYmxlID0gaGFzaGFibGVcbiAgbGV0IGNsZWFyID0gSGFzaHRibC5jbGVhclxuICBsZXQgbGVuZ3RoID0gSGFzaHRibC5sZW5ndGhcbiAgbGV0IG1lbSA9IEhhc2h0YmwubWVtXG4gIGxldCBpc19lbXB0eSB0ID0gSGFzaHRibC5pc19lbXB0eSB0XG5cbiAgbGV0IGZpbmRfbWFwIHQgfmYgPVxuICAgIHdpdGhfcmV0dXJuIChmdW4gciAtPlxuICAgICAgSGFzaHRibC5pdGVyX2tleXMgdCB+ZjooZnVuIGVsdCAtPlxuICAgICAgICBtYXRjaCBmIGVsdCB3aXRoXG4gICAgICAgIHwgTm9uZSAtPiAoKVxuICAgICAgICB8IFNvbWUgXyBhcyBvIC0+IHIucmV0dXJuIG8pO1xuICAgICAgTm9uZSlcbiAgOztcblxuICBsZXQgZmluZCB0IH5mID0gZmluZF9tYXAgdCB+ZjooZnVuIGEgLT4gaWYgZiBhIHRoZW4gU29tZSBhIGVsc2UgTm9uZSlcbiAgbGV0IGFkZCB0IGsgPSBIYXNodGJsLnNldCB0IH5rZXk6ayB+ZGF0YTooKVxuXG4gIGxldCBzdHJpY3RfYWRkIHQgayA9XG4gICAgaWYgbWVtIHQga1xuICAgIHRoZW4gT3JfZXJyb3IuZXJyb3Jfc3RyaW5nIFwiZWxlbWVudCBhbHJlYWR5IGV4aXN0c1wiXG4gICAgZWxzZSAoXG4gICAgICBIYXNodGJsLnNldCB0IH5rZXk6ayB+ZGF0YTooKTtcbiAgICAgIFJlc3VsdC5PayAoKSlcbiAgOztcblxuICBsZXQgc3RyaWN0X2FkZF9leG4gdCBrID0gT3JfZXJyb3Iub2tfZXhuIChzdHJpY3RfYWRkIHQgaylcbiAgbGV0IHJlbW92ZSA9IEhhc2h0YmwucmVtb3ZlXG5cbiAgbGV0IHN0cmljdF9yZW1vdmUgdCBrID1cbiAgICBpZiBtZW0gdCBrXG4gICAgdGhlbiAoXG4gICAgICByZW1vdmUgdCBrO1xuICAgICAgUmVzdWx0Lk9rICgpKVxuICAgIGVsc2UgT3JfZXJyb3IuZXJyb3IgXCJlbGVtZW50IG5vdCBpbiBzZXRcIiBrIChIYXNodGJsLnNleHBfb2Zfa2V5IHQpXG4gIDs7XG5cbiAgbGV0IHN0cmljdF9yZW1vdmVfZXhuIHQgayA9IE9yX2Vycm9yLm9rX2V4biAoc3RyaWN0X3JlbW92ZSB0IGspXG4gIGxldCBmb2xkIHQgfmluaXQgfmYgPSBIYXNodGJsLmZvbGQgdCB+aW5pdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgYWNjIC0+IGYgYWNjIGtleSlcbiAgbGV0IGl0ZXIgdCB+ZiA9IEhhc2h0YmwuaXRlcl9rZXlzIHQgfmZcbiAgbGV0IGNvdW50IHQgfmYgPSBDb250YWluZXIuY291bnQgfmZvbGQgdCB+ZlxuICBsZXQgc3VtIG0gdCB+ZiA9IENvbnRhaW5lci5zdW0gfmZvbGQgbSB0IH5mXG4gIGxldCBtaW5fZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWluX2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBtYXhfZWx0IHQgfmNvbXBhcmUgPSBDb250YWluZXIubWF4X2VsdCB+Zm9sZCB0IH5jb21wYXJlXG4gIGxldCBmb2xkX3Jlc3VsdCB0IH5pbml0IH5mID0gQ29udGFpbmVyLmZvbGRfcmVzdWx0IH5mb2xkIH5pbml0IH5mIHRcbiAgbGV0IGZvbGRfdW50aWwgdCB+aW5pdCB+ZiA9IENvbnRhaW5lci5mb2xkX3VudGlsIH5mb2xkIH5pbml0IH5mIHRcbiAgbGV0IHRvX2xpc3QgPSBIYXNodGJsLmtleXNcblxuICBsZXQgc2V4cF9vZl90IHNleHBfb2ZfZSB0ID1cbiAgICBzZXhwX29mX2xpc3Qgc2V4cF9vZl9lICh0b19saXN0IHQgfD4gTGlzdC5zb3J0IH5jb21wYXJlOihoYXNoYWJsZSB0KS5jb21wYXJlKVxuICA7O1xuXG4gIGxldCB0b19hcnJheSB0ID1cbiAgICBsZXQgbGVuID0gbGVuZ3RoIHQgaW5cbiAgICBsZXQgaW5kZXggPSByZWYgKGxlbiAtIDEpIGluXG4gICAgZm9sZCB0IH5pbml0Olt8fF0gfmY6KGZ1biBhY2Mga2V5IC0+XG4gICAgICBpZiBBcnJheS5sZW5ndGggYWNjID0gMFxuICAgICAgdGhlbiBBcnJheS5jcmVhdGUgfmxlbiBrZXlcbiAgICAgIGVsc2UgKFxuICAgICAgICBpbmRleCA6PSAhaW5kZXggLSAxO1xuICAgICAgICBhY2MuKCFpbmRleCkgPC0ga2V5O1xuICAgICAgICBhY2MpKVxuICA7O1xuXG4gIGxldCBleGlzdHMgdCB+ZiA9IEhhc2h0YmwuZXhpc3RzaSB0IH5mOihmdW4gfmtleSB+ZGF0YTooKSAtPiBmIGtleSlcbiAgbGV0IGZvcl9hbGwgdCB+ZiA9IG5vdCAoSGFzaHRibC5leGlzdHNpIHQgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IG5vdCAoZiBrZXkpKSlcbiAgbGV0IGVxdWFsIHQxIHQyID0gSGFzaHRibC5lcXVhbCAoZnVuICgpICgpIC0+IHRydWUpIHQxIHQyXG4gIGxldCBjb3B5IHQgPSBIYXNodGJsLmNvcHkgdFxuICBsZXQgZmlsdGVyIHQgfmYgPSBIYXNodGJsLmZpbHRlcmkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gZiBrZXkpXG4gIGxldCB1bmlvbiB0MSB0MiA9IEhhc2h0YmwubWVyZ2UgdDEgdDIgfmY6KGZ1biB+a2V5Ol8gXyAtPiBTb21lICgpKVxuICBsZXQgZGlmZiB0MSB0MiA9IGZpbHRlciB0MSB+ZjooZnVuIGtleSAtPiBub3QgKEhhc2h0YmwubWVtIHQyIGtleSkpXG5cbiAgbGV0IGludGVyIHQxIHQyID1cbiAgICBsZXQgc21hbGxlciwgbGFyZ2VyID0gaWYgbGVuZ3RoIHQxID4gbGVuZ3RoIHQyIHRoZW4gdDIsIHQxIGVsc2UgdDEsIHQyIGluXG4gICAgSGFzaHRibC5maWx0ZXJpIHNtYWxsZXIgfmY6KGZ1biB+a2V5IH5kYXRhOigpIC0+IEhhc2h0YmwubWVtIGxhcmdlciBrZXkpXG4gIDs7XG5cbiAgbGV0IGZpbHRlcl9pbnBsYWNlIHQgfmYgPVxuICAgIGxldCB0b19yZW1vdmUgPSBmb2xkIHQgfmluaXQ6W10gfmY6KGZ1biBhYyB4IC0+IGlmIGYgeCB0aGVuIGFjIGVsc2UgeCA6OiBhYykgaW5cbiAgICBMaXN0Lml0ZXIgdG9fcmVtb3ZlIH5mOihmdW4geCAtPiByZW1vdmUgdCB4KVxuICA7O1xuXG4gIGxldCBvZl9oYXNodGJsX2tleXMgaGFzaHRibCA9IEhhc2h0YmwubWFwIGhhc2h0YmwgfmY6aWdub3JlXG4gIGxldCB0b19oYXNodGJsIHQgfmYgPSBIYXNodGJsLm1hcGkgdCB+ZjooZnVuIH5rZXkgfmRhdGE6KCkgLT4gZiBrZXkpXG5lbmRcblxuaW5jbHVkZSBBY2Nlc3NvcnNcblxubGV0IGNyZWF0ZSA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbSA9IEhhc2h0YmwuY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtXG5cbmxldCBvZl9saXN0ID9ncm93dGhfYWxsb3dlZCA/c2l6ZSBtIGwgPVxuICBsZXQgc2l6ZSA9XG4gICAgbWF0Y2ggc2l6ZSB3aXRoXG4gICAgfCBTb21lIHggLT4geFxuICAgIHwgTm9uZSAtPiBMaXN0Lmxlbmd0aCBsXG4gIGluXG4gIGxldCB0ID0gSGFzaHRibC5jcmVhdGUgP2dyb3d0aF9hbGxvd2VkIH5zaXplIG0gaW5cbiAgTGlzdC5pdGVyIGwgfmY6KGZ1biBrIC0+IGFkZCB0IGspO1xuICB0XG47O1xuXG5sZXQgdF9vZl9zZXhwIG0gZV9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBTZXhwLkF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiSGFzaF9zZXQudF9vZl9zZXhwIHJlcXVpcmVzIGEgbGlzdFwiIHNleHBcbiAgfCBTZXhwLkxpc3QgbGlzdCAtPlxuICAgIGxldCB0ID0gY3JlYXRlIG0gfnNpemU6KExpc3QubGVuZ3RoIGxpc3QpIGluXG4gICAgTGlzdC5pdGVyIGxpc3QgfmY6KGZ1biBzZXhwIC0+XG4gICAgICBsZXQgZSA9IGVfb2Zfc2V4cCBzZXhwIGluXG4gICAgICBtYXRjaCBzdHJpY3RfYWRkIHQgZSB3aXRoXG4gICAgICB8IE9rICgpIC0+ICgpXG4gICAgICB8IEVycm9yIF8gLT4gb2Zfc2V4cF9lcnJvciBcIkhhc2hfc2V0LnRfb2Zfc2V4cCBnb3QgYSBkdXBsaWNhdGUgZWxlbWVudFwiIHNleHApO1xuICAgIHRcbjs7XG5cbm1vZHVsZSBDcmVhdG9ycyAoRWx0IDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgaGFzaGFibGUgOiAnYSB0IEhhc2hhYmxlLnRcbiAgZW5kKSA6IHNpZ1xuICB2YWwgdF9vZl9zZXhwIDogKFNleHAudCAtPiAnYSBFbHQudCkgLT4gU2V4cC50IC0+ICdhIEVsdC50IHRcblxuICBpbmNsdWRlXG4gICAgQ3JlYXRvcnNfZ2VuZXJpY1xuICAgIHdpdGggdHlwZSAnYSB0IDo9ICdhIEVsdC50IHRcbiAgICB3aXRoIHR5cGUgJ2EgZWx0IDo9ICdhIEVsdC50XG4gICAgd2l0aCB0eXBlICgnZWx0LCAneikgY3JlYXRlX29wdGlvbnMgOj1cbiAgICAgICgnZWx0LCAneikgY3JlYXRlX29wdGlvbnNfd2l0aG91dF9maXJzdF9jbGFzc19tb2R1bGVcbmVuZCA9IHN0cnVjdFxuICBsZXQgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoKSA9XG4gICAgY3JlYXRlID9ncm93dGhfYWxsb3dlZCA/c2l6ZSAoSGFzaGFibGUudG9fa2V5IEVsdC5oYXNoYWJsZSlcbiAgOztcblxuICBsZXQgb2ZfbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgbCA9XG4gICAgb2ZfbGlzdCA/Z3Jvd3RoX2FsbG93ZWQgP3NpemUgKEhhc2hhYmxlLnRvX2tleSBFbHQuaGFzaGFibGUpIGxcbiAgOztcblxuICBsZXQgdF9vZl9zZXhwIGVfb2Zfc2V4cCBzZXhwID0gdF9vZl9zZXhwIChIYXNoYWJsZS50b19rZXkgRWx0Lmhhc2hhYmxlKSBlX29mX3NleHAgc2V4cFxuZW5kXG5cbm1vZHVsZSBQb2x5ID0gc3RydWN0XG4gIHR5cGUgJ2EgdCA9ICdhIGhhc2hfc2V0XG4gIHR5cGUgJ2EgZWx0ID0gJ2FcblxuICBsZXQgaGFzaGFibGUgPSBwb2x5X2hhc2hhYmxlXG5cbiAgaW5jbHVkZSBDcmVhdG9ycyAoc3RydWN0XG4gICAgICB0eXBlICdhIHQgPSAnYVxuXG4gICAgICBsZXQgaGFzaGFibGUgPSBoYXNoYWJsZVxuICAgIGVuZClcblxuICBpbmNsdWRlIEFjY2Vzc29yc1xuXG4gIGxldCBzZXhwX29mX3QgPSBzZXhwX29mX3RcbiAgbGV0IHRfc2V4cF9ncmFtbWFyIGdyYW1tYXIgPSBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChMaXN0LnRfc2V4cF9ncmFtbWFyIGdyYW1tYXIpXG5lbmRcblxubW9kdWxlIE0gKEVsdCA6IFQuVCkgPSBzdHJ1Y3RcbiAgdHlwZSBub25yZWMgdCA9IEVsdC50IHRcbmVuZFxuXG5sZXQgc2V4cF9vZl9tX190ICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBTZXhwX29mX20gd2l0aCB0eXBlIHQgPSBlbHQpIHQgPVxuICBzZXhwX29mX3QgRWx0LnNleHBfb2ZfdCB0XG47O1xuXG5sZXQgbV9fdF9vZl9zZXhwICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX29mX3NleHAgd2l0aCB0eXBlIHQgPSBlbHQpIHNleHAgPVxuICB0X29mX3NleHAgKG1vZHVsZSBFbHQpIEVsdC50X29mX3NleHAgc2V4cFxuOztcblxubGV0IG1fX3Rfc2V4cF9ncmFtbWFyICh0eXBlIGVsdCkgKG1vZHVsZSBFbHQgOiBNX3NleHBfZ3JhbW1hciB3aXRoIHR5cGUgdCA9IGVsdCkgPVxuICBTZXhwbGliMC5TZXhwX2dyYW1tYXIuY29lcmNlIChsaXN0X3NleHBfZ3JhbW1hciBFbHQudF9zZXhwX2dyYW1tYXIpXG47O1xuXG5sZXQgZXF1YWxfbV9fdCAobW9kdWxlIF8gOiBFcXVhbF9tKSB0MSB0MiA9IGVxdWFsIHQxIHQyXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBoYXNoYWJsZSA9IEhhc2h0YmwuUHJpdmF0ZS5oYXNoYWJsZVxuZW5kXG4iLCJvcGVuISBJbXBvcnRcbm9wZW4hIFByaW50ZlxubW9kdWxlIEJ5dGVzID0gQnl0ZXMwXG5pbmNsdWRlIEZsb2F0MFxuXG5sZXQgcmFpc2VfcyA9IEVycm9yLnJhaXNlX3NcblxubW9kdWxlIFQgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gZmxvYXQgW0BAZGVyaXZpbmdfaW5saW5lIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgKGhhc2hfZm9sZF90IDogUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKSA9XG4gICAgaGFzaF9mb2xkX2Zsb2F0XG5cbiAgYW5kIChoYXNoIDogdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gaGFzaF9mbG9hdCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB0X29mX3NleHAgPSAoZmxvYXRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICBsZXQgc2V4cF9vZl90ID0gKHNleHBfb2ZfZmxvYXQgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0ICh0X3NleHBfZ3JhbW1hciA6IHQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID0gZmxvYXRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICBsZXQgaGFzaGFibGUgOiB0IEhhc2hhYmxlLnQgPSB7IGhhc2g7IGNvbXBhcmU7IHNleHBfb2ZfdCB9XG4gIGxldCBjb21wYXJlID0gRmxvYXRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLmNvbXBhcmVcbmVuZFxuXG5pbmNsdWRlIFRcbmluY2x1ZGUgQ29tcGFyYXRvci5NYWtlIChUKVxuXG4oKiBPcGVuIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZSBhZnRlciBpbmNsdWRpbmcgZnVuY3RvciBpbnN0YW50aWF0aW9ucyBzbyB0aGV5IGRvIG5vdFxuICAgc2hhZG93IGl0cyBkZWZpbml0aW9ucy4gVGhpcyBpcyBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uXG4gICBmdW5jdGlvbnMgYXJlIGF2YWlsYWJsZSB3aXRoaW4gdGhpcyBtb2R1bGUuICopXG5vcGVuIEZsb2F0X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG5sZXQgaW52YXJpYW50IChfIDogdCkgPSAoKVxubGV0IHRvX2Zsb2F0IHggPSB4XG5sZXQgb2ZfZmxvYXQgeCA9IHhcblxubGV0IG9mX3N0cmluZyBzID1cbiAgdHJ5IGZsb2F0X29mX3N0cmluZyBzIHdpdGhcbiAgfCBfIC0+IGludmFsaWRfYXJnZiBcIkZsb2F0Lm9mX3N0cmluZyAlc1wiIHMgKClcbjs7XG5cbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxuKCogU3RvbGVuIGZyb20gW3BlcnZhc2l2ZXMubWxdLiAgQWRkcyBhIFwiLlwiIGF0IHRoZSBlbmQgaWYgbmVlZGVkLiAgSXQgaXMgaW5cbiAgIFtwZXJ2YXNpdmVzLm1saV0sIGJ1dCBpdCBhbHNvIHNheXMgbm90IHRvIHVzZSBpdCBkaXJlY3RseSwgc28gd2UgY29weSBhbmQgcGFzdGUgdGhlXG4gICBjb2RlLiBJdCBtYWtlcyB0aGUgYXNzdW1wdGlvbiBvbiB0aGUgc3RyaW5nIHBhc3NlZCBpbiBhcmd1bWVudCB0aGF0IGl0IHdhcyByZXR1cm5lZCBieVxuICAgW2Zvcm1hdF9mbG9hdF0uICopXG5sZXQgdmFsaWRfZmxvYXRfbGV4ZW0gcyA9XG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCByZWMgbG9vcCBpID1cbiAgICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPj0gKSBpIGxcbiAgICB0aGVuIHMgXiBcIi5cIlxuICAgIGVsc2UgKFxuICAgICAgbWF0Y2ggcy5baV0gd2l0aFxuICAgICAgfCAnMCcgLi4gJzknIHwgJy0nIC0+IGxvb3AgKGkgKyAxKVxuICAgICAgfCBfIC0+IHMpXG4gIGluXG4gIGxvb3AgMFxuOztcblxuKCogTGV0IFt5XSBiZSBhIHBvd2VyIG9mIDIuICBUaGVuIHRoZSBuZXh0IHJlcHJlc2VudGFibGUgZmxvYXQgaXM6XG4gICBbeiA9IHkgKiAoMSArIDIgKiogLTUyKV1cbiAgIGFuZCB0aGUgcHJldmlvdXMgb25lIGlzXG4gICBbeCA9IHkgKiAoMSAtIDIgKiogLTUzKV1cblxuICAgSW4gZ2VuZXJhbCwgZXZlcnkgdHdvIGFkamFjZW50IGZsb2F0cyBhcmUgd2l0aGluIGEgZmFjdG9yIG9mIGJldHdlZW4gWzEgKyAyKiotNTNdXG4gICBhbmQgWzEgKyAyKiotNTJdIGZyb20gZWFjaCBvdGhlciwgdGhhdCBpcyB3aXRoaW4gWzEgKyAxLjFlLTE2XSBhbmQgWzEgKyAyLjNlLTE2XS5cblxuICAgU28gaWYgdGhlIGRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgYSBmbG9hdCBzdGFydHMgd2l0aCBcIjFcIiwgdGhlbiBpdHMgYWRqYWNlbnQgZmxvYXRzXG4gICB3aWxsIHVzdWFsbHkgZGlmZmVyIGZyb20gaXQgYnkgMSwgYW5kIHNvbWV0aW1lcyBieSAyLCBhdCB0aGUgMTd0aCBzaWduaWZpY2FudCBkaWdpdFxuICAgKGNvdW50aW5nIGZyb20gMSkuXG5cbiAgIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB0aGUgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBzdGFydHMgd2l0aCBcIjlcIiwgdGhlbiB0aGUgYWRqYWNlbnRcbiAgIGZsb2F0cyB3aWxsIGJlIG9mZiBieSBubyBtb3JlIHRoYW4gMjMgYXQgdGhlIDE2dGggYW5kIDE3dGggc2lnbmlmaWNhbnQgZGlnaXRzLlxuXG4gICBFLmcuOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE3Z1wiICgxMDI0LiAqLiAoMS4gLS4gMi4qKiAoLTUzLikpKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3XG4gICAgIC0gOiBzdHJpbmcgPSBcIjEwMjMuOTk5OTk5OTk5OTk5OVwiXG4gICB2fVxuICAgUHJpbnRpbmcgYSBjb3VwbGUgb2YgZXh0cmEgZGlnaXRzIHJldmVhbHMgdGhhdCB0aGUgZGlmZmVyZW5jZSBpbmRlZWQgaXMgcm91Z2hseSAxMSBhdFxuICAgZGlnaXRzIDE3dGggYW5kIDE4dGggKHRoYXQgaXMsIDEzdGggYW5kIDE0dGggYWZ0ZXIgXCIuXCIpOlxuXG4gICB7dlxuICAgICAjIHNwcmludGYgXCIlLjE5Z1wiICgxMDI0LiAqLiAoMS4gLS4gMi4qKiAoLTUzLikpKTs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExMTExMTFcbiAgICAgICAgICAgICAgICAgICAxMjM0IDU2Nzg5MDEyMzQ1Njc4OVxuICAgICAtIDogc3RyaW5nID0gXCIxMDIzLjk5OTk5OTk5OTk5OTg4NlwiXG4gICB2fVxuXG4gICBUaGUgdWxwICh0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIGFkamFjZW50IGZsb2F0cykgaXMgdHdpY2UgYXMgYmlnIG9uIHRoZSBvdGhlciBzaWRlIG9mXG4gICAxMDI0LjpcblxuICAge3ZcbiAgICAgIyBzcHJpbnRmIFwiJS4xOWdcIiAoMTAyNC4gKi4gKDEuICsuIDIuKiogKC01Mi4pKSk7O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMTExMTExXG4gICAgICAgICAgICAgICAgICAgMTIzNCA1Njc4OTAxMjM0NTY3ODlcbiAgICAgLSA6IHN0cmluZyA9IFwiMTAyNC4wMDAwMDAwMDAwMDAyMjdcIlxuICAgdn1cblxuICAgTm93IHRha2UgYSBwb3dlciBvZiAyIHdoaWNoIHN0YXJ0cyB3aXRoIDk5OlxuXG4gICB7dlxuICAgICAjIDIuKio5My4gOztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTExMTExMVxuICAgICAgICAgICAgICAgICAxIDIzNDU2Nzg5MDEyMzQ1Njc4XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQyMmUrMjdcblxuICAgICAjIDIuKio5My4gKi4gKDEuICsuIDIuKiogKC01Mi4pKTs7XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQ0NGUrMjdcblxuICAgICAjIDIuKio5My4gKi4gKDEuIC0uIDIuKiogKC01My4pKTs7XG4gICAgIC0gOiBmbG9hdCA9IDkuOTAzNTIwMzE0MjgzMDQxMWUrMjdcbiAgIHZ9XG5cbiAgIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gMioqOTMgYW5kIGl0cyB0d28gbmVpZ2hib3JzIGlzIHNsaWdodGx5IG1vcmUgdGhhbiwgcmVzcGVjdGl2ZWx5LFxuICAgMSBhbmQgMiBhdCBzaWduaWZpY2FudCBkaWdpdCAxNi5cblxuICAgVGhvc2UgZXhhbXBsZXMgc2hvdyB0aGF0OlxuICAgLSAxNyBzaWduaWZpY2FudCBkaWdpdHMgaXMgYWx3YXlzIHN1ZmZpY2llbnQgdG8gcmVwcmVzZW50IGEgZmxvYXQgd2l0aG91dCBhbWJpZ3VpdHlcbiAgIC0gMTV0aCBzaWduaWZpY2FudCBkaWdpdCBjYW4gYWx3YXlzIGJlIHJlcHJlc2VudGVkIGFjY3VyYXRlbHlcbiAgIC0gY29udmVydGluZyBhIGRlY2ltYWwgbnVtYmVyIHdpdGggMTYgc2lnbmlmaWNhbnQgZGlnaXRzIHRvIGl0cyBuZWFyZXN0IGZsb2F0IGFuZCBiYWNrXG4gICAgIGNhbiBjaGFuZ2UgdGhlIGxhc3QgZGVjaW1hbCBkaWdpdCBieSBubyBtb3JlIHRoYW4gMVxuXG4gICBUbyBtYWtlIHN1cmUgdGhhdCBmbG9hdHMgb2J0YWluZWQgYnkgY29udmVyc2lvbiBmcm9tIGRlY2ltYWwgZnJhY3Rpb25zIChlLmcuIFwiMy4xNFwiKVxuICAgYXJlIHByaW50ZWQgd2l0aG91dCB0cmFpbGluZyBub24temVybyBkaWdpdHMsIG9uZSBzaG91bGQgY2hvb3NlIHRoZSBmaXJzdCBhbW9uZyB0aGVcbiAgICclLjE1ZycsICclLjE2ZycsIGFuZCAnJS4xN2cnIHJlcHJlc2VudGF0aW9ucyB3aGljaCBkb2VzIHJvdW5kLXRyaXA6XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTRcIiAgICAgICAgICAgICAgICAgICAgICgqIHBpY2sgdGhpcyBvbmUgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xNmdcIiAzLjE0OztcbiAgICAgLSA6IHN0cmluZyA9IFwiMy4xNFwiXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgMy4xNDs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjMuMTQwMDAwMDAwMDAwMDAwMVwiICAgICAgICgqIGRvIG5vdCBwaWNrIHRoaXMgb25lICopXG5cbiAgICAgIyBzcHJpbnRmIFwiJS4xNWdcIiA4LjAwMDAwMDAwMDAwMDAwMjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjhcIiAgICAgICAgICAgICAgICAgICAgICAgICgqIGRvIG5vdCBwaWNrIHRoaXMgb25lLS1kb2VzIG5vdCByb3VuZC10cmlwICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgOC4wMDAwMDAwMDAwMDAwMDI7O1xuICAgICAtIDogc3RyaW5nID0gXCI4LjAwMDAwMDAwMDAwMDAwMlwiICAgICAgICAoKiBwcmVmZXIgdGhpcyBvbmUgKilcbiAgICAgIyBzcHJpbnRmIFwiJS4xN2dcIiA4LjAwMDAwMDAwMDAwMDAwMjs7XG4gICAgIC0gOiBzdHJpbmcgPSBcIjguMDAwMDAwMDAwMDAwMDAxOFwiICAgICAgICgqIHRoaXMgb25lIGhhcyBvbmUgZGlnaXQgb2YganVuayBhdCB0aGUgZW5kICopXG4gICB2fVxuXG4gICBTa2lwcGluZyB0aGUgJyUuMTZnJyBpbiB0aGUgYWJvdmUgcHJvY2VkdXJlIHNhdmVzIHVzIHNvbWUgdGltZSwgYnV0IGl0IG1lYW5zIHRoYXQsIGFzXG4gICBzZWVuIGluIHRoZSBzZWNvbmQgZXhhbXBsZSBhYm92ZSwgb2NjYXNpb25hbGx5IG51bWJlcnMgd2l0aCBleGFjdGx5IDE2IHNpZ25pZmljYW50XG4gICBkaWdpdHMgd2lsbCBoYXZlIGFuIGVycm9yIGludHJvZHVjZWQgYXQgdGhlIDE3dGggZGlnaXQuICBUaGF0IGlzIHByb2JhYmx5IE9LIGZvclxuICAgdHlwaWNhbCB1c2UsIGJlY2F1c2UgYSBudW1iZXIgd2l0aCAxNiBzaWduaWZpY2FudCBkaWdpdHMgaXMgXCJ1Z2x5XCIgYWxyZWFkeS4gIEFkZGluZyBvbmVcbiAgIG1vcmUgZG9lc24ndCBtYWtlIGl0IG11Y2ggd29yc2UgZm9yIGEgaHVtYW4gcmVhZGVyLlxuXG4gICBPbiB0aGUgb3RoZXIgaGFuZCwgd2UgY2Fubm90IHNraXAgJyUuMTVnJyBhbmQgb25seSBsb29rIGF0ICclLjE2ZycgYW5kICclLjE3ZycsIHNpbmNlXG4gICB0aGUgaW5hY2N1cmFjeSBhdCB0aGUgMTZ0aCBkaWdpdCBtaWdodCBpbnRyb2R1Y2UgdGhlIG5vaXNlIHdlIHdhbnQgdG8gYXZvaWQ6XG5cbiAgIHt2XG4gICAgICMgc3ByaW50ZiBcIiUuMTVnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MlwiICAgICAgICAgICAgICAgICAgICAoKiBwaWNrIHRoaXMgb25lICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTZnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MjAwMDAwMDAwMDAwMVwiICAgICAgICAoKiBkbyBub3QgcGljayB0aGlzIG9uZS0tanVuayBhdCB0aGUgZW5kICopXG4gICAgICMgc3ByaW50ZiBcIiUuMTdnXCIgOS45OTI7O1xuICAgICAtIDogc3RyaW5nID0gXCI5Ljk5MjAwMDAwMDAwMDAwMDlcIlxuICAgdn1cbiopXG5sZXQgdG9fc3RyaW5nIHggPVxuICB2YWxpZF9mbG9hdF9sZXhlbVxuICAgIChsZXQgeSA9IGZvcm1hdF9mbG9hdCBcIiUuMTVnXCIgeCBpblxuICAgICBpZiBmbG9hdF9vZl9zdHJpbmcgeSA9IHggdGhlbiB5IGVsc2UgZm9ybWF0X2Zsb2F0IFwiJS4xN2dcIiB4KVxuOztcblxubGV0IG1heF92YWx1ZSA9IGluZmluaXR5XG5sZXQgbWluX3ZhbHVlID0gbmVnX2luZmluaXR5XG5sZXQgbWluX3Bvc2l0aXZlX3N1Ym5vcm1hbF92YWx1ZSA9IDIuICoqIC0xMDc0LlxubGV0IG1pbl9wb3NpdGl2ZV9ub3JtYWxfdmFsdWUgPSAyLiAqKiAtMTAyMi5cbmxldCB6ZXJvID0gMC5cbmxldCBvbmUgPSAxLlxubGV0IG1pbnVzX29uZSA9IC0xLlxubGV0IHBpID0gMHgzLjI0M0Y2QTg4ODVBMzA4RDMxMzE5OEEyRTAzNzA3M1xubGV0IHNxcnRfcGkgPSAweDEuQzVCRjg5MUI0RUY2QUE3OUMzQjA1MjBENURCOTM4XG5sZXQgc3FydF8ycGkgPSAweDIuODFCMjYzRkVDNEUwQjJDQUY5NDgzRjVDRTQ1OURDXG5sZXQgZXVsZXIgPSAweDAuOTNDNDY3RTM3REIwQzdBNEQxQkUzRjgxMDE1MkNCXG5sZXQgb2ZfaW50ID0gSW50LnRvX2Zsb2F0XG5sZXQgdG9faW50ID0gSW50Lm9mX2Zsb2F0XG5sZXQgb2ZfaW50NjMgaSA9IEludDYzLnRvX2Zsb2F0IGlcbmxldCBvZl9pbnQ2NCBpID0gQ2FtbC5JbnQ2NC50b19mbG9hdCBpXG5sZXQgdG9faW50NjQgPSBDYW1sLkludDY0Lm9mX2Zsb2F0XG5sZXQgaXJvdW5kX2xib3VuZCA9IGxvd2VyX2JvdW5kX2Zvcl9pbnQgSW50Lm51bV9iaXRzXG5sZXQgaXJvdW5kX3Vib3VuZCA9IHVwcGVyX2JvdW5kX2Zvcl9pbnQgSW50Lm51bV9iaXRzXG5cbigqIFRoZSBwZXJmb3JtYW5jZSBvZiB0aGUgXCJleG5cIiByb3VuZGluZyBmdW5jdGlvbnMgaXMgaW1wb3J0YW50LCBzbyB0aGV5IGFyZSB3cml0dGVuXG4gICBvdXQgc2VwYXJhdGVseSwgYW5kIHR1bmVkIGluZGl2aWR1YWxseS4gIChXZSBjb3VsZCBoYXZlIHRoZSBvcHRpb24gdmVyc2lvbnMgY2FsbFxuICAgdGhlIFwiZXhuXCIgdmVyc2lvbnMsIGJ1dCB0aGF0IGltcG9zZXMgYXJndWFibHkgZ3JhdHVpdG91cyBvdmVyaGVhZC0tLWVzcGVjaWFsbHlcbiAgIGluIHRoZSBjYXNlIHdoZXJlIHRoZSBjYXB0dXJlIG9mIGJhY2t0cmFjZXMgaXMgZW5hYmxlZCB1cG9uIFwid2l0aFwiLS0tYW5kIHRoYXQgc2VlbXNcbiAgIG5vdCB3b3J0aCBpdCB3aGVuIGNvbXBhcmVkIHRvIHRoZSByZWxhdGl2ZWx5IHNtYWxsIGFtb3VudCBvZiBjb2RlIGR1cGxpY2F0aW9uLikgKilcblxuKCogRXJyb3IgcmVwb3J0aW5nIGJlbG93IGlzIHZlcnkgY2FyZWZ1bGx5IGFycmFuZ2VkIHNvIHRoYXQsIGUuZy4sIFtpcm91bmRfbmVhcmVzdF9leG5dXG4gICBpdHNlbGYgY2FuIGJlIGlubGluZWQgaW50byBjYWxsZXJzIHN1Y2ggdGhhdCB0aGV5IGRvbid0IG5lZWQgdG8gYWxsb2NhdGUgYSBib3ggZm9yIHRoZVxuICAgW2Zsb2F0XSBhcmd1bWVudC4gIFRoaXMgaXMgZG9uZSB3aXRoIGEgYm94IFtib3hdIGZ1bmN0aW9uIGNhcmVmdWxseSBjaG9zZW4gdG8gYWxsb3cgdGhlXG4gICBjb21waWxlciB0byBjcmVhdGUgYSBzZXBhcmF0ZSBib3ggZm9yIHRoZSBmbG9hdCBvbmx5IGluIGVycm9yIGNhc2VzLiAgU2VlLCBlLmcuLFxuICAgWy4uLy4uL3plcm8vdGVzdC9wcmljZV90ZXN0Lm1sXSBmb3IgYSBtZWNoYW5pY2FsIHRlc3Qgb2YgdGhpcyBwcm9wZXJ0eSB3aGVuIGJ1aWxkaW5nXG4gICB3aXRoIFtYX0xJQlJBUllfSU5MSU5JTkc9dHJ1ZV0uICopXG5cbmxldCBpcm91bmRfdXAgdCA9XG4gIGlmIHQgPiAwLjBcbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gY2VpbCB0IGluXG4gICAgaWYgdCcgPD0gaXJvdW5kX3Vib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCcpIGVsc2UgTm9uZSlcbiAgZWxzZSBpZiB0ID49IGlyb3VuZF9sYm91bmRcbiAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBpcm91bmRfdXBfZXhuIHQgPVxuICBpZiB0ID4gMC4wXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGNlaWwgdCBpblxuICAgIGlmIHQnIDw9IGlyb3VuZF91Ym91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF91cF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCIgKGJveCB0KSAoKSlcbiAgZWxzZSBpZiB0ID49IGlyb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfdXBfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIiAoYm94IHQpICgpXG47O1xuXG5sZXQgaXJvdW5kX2Rvd24gdCA9XG4gIGlmIHQgPj0gMC4wXG4gIHRoZW4gaWYgdCA8PSBpcm91bmRfdWJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KSBlbHNlIE5vbmVcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgdCBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmQgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnKSBlbHNlIE5vbmUpXG47O1xuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGlyb3VuZF9kb3duX2V4biB0ID1cbiAgaWYgdCA+PSAwLjBcbiAgdGhlblxuICAgIGlmIHQgPD0gaXJvdW5kX3Vib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfZG93bl9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCIgKGJveCB0KSAoKVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciB0IGluXG4gICAgaWYgdCcgPj0gaXJvdW5kX2xib3VuZFxuICAgIHRoZW4gSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0J1xuICAgIGVsc2VcbiAgICAgIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9kb3duX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCIgKGJveCB0KSAoKSlcbjs7XG5cbmxldCBpcm91bmRfdG93YXJkc196ZXJvIHQgPVxuICBpZiB0ID49IGlyb3VuZF9sYm91bmQgJiYgdCA8PSBpcm91bmRfdWJvdW5kXG4gIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0KVxuICBlbHNlIE5vbmVcbjs7XG5cbmxldFtAb2NhbWwuaW5saW5lIGFsd2F5c10gaXJvdW5kX3Rvd2FyZHNfemVyb19leG4gdCA9XG4gIGlmIHQgPj0gaXJvdW5kX2xib3VuZCAmJiB0IDw9IGlyb3VuZF91Ym91bmRcbiAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnZlxuICAgICAgXCJGbG9hdC5pcm91bmRfdG93YXJkc196ZXJvX2V4bjogYXJndW1lbnQgKCVmKSBpcyBvdXQgb2YgcmFuZ2Ugb3IgTmFOXCJcbiAgICAgIChib3ggdClcbiAgICAgICgpXG47O1xuXG4oKiBPdXRzaWRlIG9mIHRoZSByYW5nZSAocm91bmRfbmVhcmVzdF9sYi4ucm91bmRfbmVhcmVzdF91YiksIGFsbCByZXByZXNlbnRhYmxlIGRvdWJsZXNcbiAgIGFyZSBpbnRlZ2VycyBpbiB0aGUgbWF0aGVtYXRpY2FsIHNlbnNlLCBhbmQgW3JvdW5kX25lYXJlc3RdIHNob3VsZCBiZSBpZGVudGl0eS5cblxuICAgSG93ZXZlciwgZm9yIG9kZCBudW1iZXJzIHdpdGggdGhlIGFic29sdXRlIHZhbHVlIGJldHdlZW4gMioqNTIgYW5kIDIqKjUzLCB0aGUgZm9ybXVsYVxuICAgW3JvdW5kX25lYXJlc3QgeCA9IGZsb29yICh4ICsgMC41KV0gZG9lcyBub3QgaG9sZDpcblxuICAge3ZcbiAgICAgIyBsZXQgbmFpdmVfcm91bmRfbmVhcmVzdCB4ID0gZmxvb3IgKHggKy4gMC41KTs7XG4gICAgICMgbGV0IHggPSAyLiAqKiA1Mi4gKy4gMS47O1xuICAgICB2YWwgeCA6IGZsb2F0ID0gNDUwMzU5OTYyNzM3MDQ5Ny5cbiAgICAgIyBuYWl2ZV9yb3VuZF9uZWFyZXN0IHg7O1xuICAgICAtIDogICAgIGZsb2F0ID0gNDUwMzU5OTYyNzM3MDQ5OC5cbiAgIHZ9XG4qKVxuXG5sZXQgcm91bmRfbmVhcmVzdF9sYiA9IC0uKDIuICoqIDUyLilcbmxldCByb3VuZF9uZWFyZXN0X3ViID0gMi4gKiogNTIuXG5cbigqIEZvciBbeCA9IG9uZV91bHAgYERvd24gMC41XSwgdGhlIGZvcm11bGEgW2Zsb29yICh4ICsuIDAuNSldIGZvciByb3VuZGluZyB0byBuZWFyZXN0XG4gICBkb2VzIG5vdCB3b3JrLCBiZWNhdXNlIHRoZSBleGFjdCByZXN1bHQgaXMgaGFsZndheSBiZXR3ZWVuIFtvbmVfdWxwIGBEb3duIDEuXSBhbmQgWzEuXSxcbiAgIGFuZCBpdCBnZXRzIHJvdW5kZWQgdXAgdG8gWzEuXSBkdWUgdG8gdGhlIHJvdW5kLXRpZXMtdG8tZXZlbiBydWxlLiAqKVxubGV0IG9uZV91bHBfbGVzc190aGFuX2hhbGYgPSBvbmVfdWxwIGBEb3duIDAuNVxuXG5sZXRbQG9jYW1sLmlubGluZSBhbHdheXNdIGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQgPVxuICB0XG4gICsuXG4gIGlmIHQgPSBvbmVfdWxwX2xlc3NfdGhhbl9oYWxmXG4gIHRoZW4gb25lX3VscF9sZXNzX3RoYW5faGFsZiAoKiBzaW5jZSB0IDwgMC41LCBtYWtlIHN1cmUgdGhlIHJlc3VsdCBpcyA8IDEuMCAqKVxuICBlbHNlIDAuNVxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0XzMyIHQgPVxuICBpZiB0ID49IDAuXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQgaW5cbiAgICBpZiB0JyA8PSBpcm91bmRfdWJvdW5kIHRoZW4gU29tZSAoSW50Lm9mX2Zsb2F0X3VuY2hlY2tlZCB0JykgZWxzZSBOb25lKVxuICBlbHNlIChcbiAgICBsZXQgdCcgPSBmbG9vciAodCArLiAwLjUpIGluXG4gICAgaWYgdCcgPj0gaXJvdW5kX2xib3VuZCB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCcpIGVsc2UgTm9uZSlcbjs7XG5cbmxldCBpcm91bmRfbmVhcmVzdF82NCB0ID1cbiAgaWYgdCA+PSAwLlxuICB0aGVuXG4gICAgaWYgdCA8IHJvdW5kX25lYXJlc3RfdWJcbiAgICB0aGVuIFNvbWUgKEludC5vZl9mbG9hdF91bmNoZWNrZWQgKGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQpKVxuICAgIGVsc2UgaWYgdCA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQpXG4gICAgZWxzZSBOb25lXG4gIGVsc2UgaWYgdCA+IHJvdW5kX25lYXJlc3RfbGJcbiAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIChmbG9vciAodCArLiAwLjUpKSlcbiAgZWxzZSBpZiB0ID49IGlyb3VuZF9sYm91bmRcbiAgdGhlbiBTb21lIChJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQpXG4gIGVsc2UgTm9uZVxuOztcblxubGV0IGlyb3VuZF9uZWFyZXN0ID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IGlyb3VuZF9uZWFyZXN0XzY0XG4gIHwgVzMyIC0+IGlyb3VuZF9uZWFyZXN0XzMyXG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3RfZXhuXzMyIHQgPVxuICBpZiB0ID49IDAuXG4gIHRoZW4gKFxuICAgIGxldCB0JyA9IGFkZF9oYWxmX2Zvcl9yb3VuZF9uZWFyZXN0IHQgaW5cbiAgICBpZiB0JyA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZSBpbnZhbGlkX2FyZ2YgXCJGbG9hdC5pcm91bmRfbmVhcmVzdF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCIgKGJveCB0KSAoKSlcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgKHQgKy4gMC41KSBpblxuICAgIGlmIHQnID49IGlyb3VuZF9sYm91bmRcbiAgICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9uZWFyZXN0X2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGxcIiAoYm94IHQpICgpKVxuOztcblxubGV0W0BvY2FtbC5pbmxpbmUgYWx3YXlzXSBpcm91bmRfbmVhcmVzdF9leG5fNjQgdCA9XG4gIGlmIHQgPj0gMC5cbiAgdGhlblxuICAgIGlmIHQgPCByb3VuZF9uZWFyZXN0X3ViXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIChhZGRfaGFsZl9mb3Jfcm91bmRfbmVhcmVzdCB0KVxuICAgIGVsc2UgaWYgdCA8PSBpcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIHRcbiAgICBlbHNlIGludmFsaWRfYXJnZiBcIkZsb2F0Lmlyb3VuZF9uZWFyZXN0X2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gbGFyZ2VcIiAoYm94IHQpICgpXG4gIGVsc2UgaWYgdCA+IHJvdW5kX25lYXJlc3RfbGJcbiAgdGhlbiBJbnQub2ZfZmxvYXRfdW5jaGVja2VkIChmbG9vciAodCArLiAwLjUpKVxuICBlbHNlIGlmIHQgPj0gaXJvdW5kX2xib3VuZFxuICB0aGVuIEludC5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmdmIFwiRmxvYXQuaXJvdW5kX25lYXJlc3RfZXhuOiBhcmd1bWVudCAoJWYpIGlzIHRvbyBzbWFsbCBvciBOYU5cIiAoYm94IHQpICgpXG47O1xuXG5sZXQgaXJvdW5kX25lYXJlc3RfZXhuID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IGlyb3VuZF9uZWFyZXN0X2V4bl82NFxuICB8IFczMiAtPiBpcm91bmRfbmVhcmVzdF9leG5fMzJcbjs7XG5cbigqIFRoZSBmb2xsb3dpbmcgW2lyb3VuZF9leG5dIGFuZCBbaXJvdW5kXSBmdW5jdGlvbnMgYXJlIHNsb3dlciB0aGFuIHRoZSBvbmVzIGFib3ZlLlxuICAgVGhlaXIgZXF1aXZhbGVuY2UgdG8gdGhvc2UgZnVuY3Rpb25zIGlzIHRlc3RlZCBpbiB0aGUgdW5pdCB0ZXN0cyBiZWxvdy4gKilcblxubGV0W0BpbmxpbmVdIGlyb3VuZF9leG4gPyhkaXIgPSBgTmVhcmVzdCkgdCA9XG4gIG1hdGNoIGRpciB3aXRoXG4gIHwgYFplcm8gLT4gaXJvdW5kX3Rvd2FyZHNfemVyb19leG4gdFxuICB8IGBOZWFyZXN0IC0+IGlyb3VuZF9uZWFyZXN0X2V4biB0XG4gIHwgYFVwIC0+IGlyb3VuZF91cF9leG4gdFxuICB8IGBEb3duIC0+IGlyb3VuZF9kb3duX2V4biB0XG47O1xuXG5sZXQgaXJvdW5kID8oZGlyID0gYE5lYXJlc3QpIHQgPVxuICB0cnkgU29tZSAoaXJvdW5kX2V4biB+ZGlyIHQpIHdpdGhcbiAgfCBfIC0+IE5vbmVcbjs7XG5cbmxldCBpc19pbmYgdCA9IDEuIC8uIHQgPSAwLlxubGV0IGlzX2Zpbml0ZSB0ID0gdCAtLiB0ID0gMC5cblxubGV0IG1pbl9pbmFuICh4IDogdCkgeSA9XG4gIGlmIGlzX25hbiB5IHRoZW4geCBlbHNlIGlmIGlzX25hbiB4IHRoZW4geSBlbHNlIGlmIHggPCB5IHRoZW4geCBlbHNlIHlcbjs7XG5cbmxldCBtYXhfaW5hbiAoeCA6IHQpIHkgPVxuICBpZiBpc19uYW4geSB0aGVuIHggZWxzZSBpZiBpc19uYW4geCB0aGVuIHkgZWxzZSBpZiB4ID4geSB0aGVuIHggZWxzZSB5XG47O1xuXG5sZXQgYWRkID0gKCArLiApXG5sZXQgc3ViID0gKCAtLiApXG5sZXQgbmVnID0gKCB+LS4gKVxubGV0IGFicyA9IGFic19mbG9hdFxubGV0IHNjYWxlID0gKCAqLiApXG5sZXQgc3F1YXJlIHggPSB4ICouIHhcblxubW9kdWxlIFBhcnRzIDogc2lnXG4gIHR5cGUgdFxuXG4gIHZhbCBmcmFjdGlvbmFsIDogdCAtPiBmbG9hdFxuICB2YWwgaW50ZWdyYWwgOiB0IC0+IGZsb2F0XG4gIHZhbCBtb2RmIDogZmxvYXQgLT4gdFxuZW5kID0gc3RydWN0XG4gIHR5cGUgdCA9IGZsb2F0ICogZmxvYXRcblxuICBsZXQgZnJhY3Rpb25hbCB0ID0gZnN0IHRcbiAgbGV0IGludGVncmFsIHQgPSBzbmQgdFxuICBsZXQgbW9kZiA9IG1vZGZcbmVuZFxuXG5sZXQgbW9kZiA9IFBhcnRzLm1vZGZcbmxldCByb3VuZF9kb3duID0gZmxvb3JcbmxldCByb3VuZF91cCA9IGNlaWxcbmxldCByb3VuZF90b3dhcmRzX3plcm8gdCA9IGlmIHQgPj0gMC4gdGhlbiByb3VuZF9kb3duIHQgZWxzZSByb3VuZF91cCB0XG5cbigqIHNlZSB0aGUgY29tbWVudCBhYm92ZSBbcm91bmRfbmVhcmVzdF9sYl0gYW5kIFtyb3VuZF9uZWFyZXN0X3ViXSBmb3IgYW4gZXhwbGFuYXRpb24gKilcbmxldFtAb2NhbWwuaW5saW5lXSByb3VuZF9uZWFyZXN0X2lubGluZSB0ID1cbiAgaWYgdCA+IHJvdW5kX25lYXJlc3RfbGIgJiYgdCA8IHJvdW5kX25lYXJlc3RfdWJcbiAgdGhlbiBmbG9vciAoYWRkX2hhbGZfZm9yX3JvdW5kX25lYXJlc3QgdClcbiAgZWxzZSB0ICsuIDAuXG47O1xuXG5sZXQgcm91bmRfbmVhcmVzdCB0ID0gKHJvdW5kX25lYXJlc3RfaW5saW5lIFtAb2NhbWwuaW5saW5lZCBhbHdheXNdKSB0XG5cbmxldCByb3VuZF9uZWFyZXN0X2hhbGZfdG9fZXZlbiB0ID1cbiAgaWYgdCA8PSByb3VuZF9uZWFyZXN0X2xiIHx8IHQgPj0gcm91bmRfbmVhcmVzdF91YlxuICB0aGVuIHQgKy4gMC5cbiAgZWxzZSAoXG4gICAgbGV0IGZsb29yID0gZmxvb3IgdCBpblxuICAgICgqIFtjZWlsX29yX3N1Y2MgPSBpZiB0IGlzIGFuIGludGVnZXIgdGhlbiB0ICsuIDEuIGVsc2UgY2VpbCB0XS4gIEZhc3RlciB0aGFuIFtjZWlsXS4gKilcbiAgICBsZXQgY2VpbF9vcl9zdWNjID0gZmxvb3IgKy4gMS4gaW5cbiAgICBsZXQgZGlmZl9mbG9vciA9IHQgLS4gZmxvb3IgaW5cbiAgICBsZXQgZGlmZl9jZWlsID0gY2VpbF9vcl9zdWNjIC0uIHQgaW5cbiAgICBpZiBkaWZmX2Zsb29yIDwgZGlmZl9jZWlsXG4gICAgdGhlbiBmbG9vclxuICAgIGVsc2UgaWYgZGlmZl9mbG9vciA+IGRpZmZfY2VpbFxuICAgIHRoZW4gY2VpbF9vcl9zdWNjXG4gICAgZWxzZSBpZiAoKiBleGFjdCB0aWUsIHBpY2sgdGhlIGV2ZW4gKilcbiAgICAgIG1vZF9mbG9hdCBmbG9vciAyLiA9IDAuXG4gICAgdGhlbiBmbG9vclxuICAgIGVsc2UgY2VpbF9vcl9zdWNjKVxuOztcblxubGV0IGludDYzX3JvdW5kX2xib3VuZCA9IGxvd2VyX2JvdW5kX2Zvcl9pbnQgSW50NjMubnVtX2JpdHNcbmxldCBpbnQ2M19yb3VuZF91Ym91bmQgPSB1cHBlcl9ib3VuZF9mb3JfaW50IEludDYzLm51bV9iaXRzXG5cbmxldCBpbnQ2M19yb3VuZF91cF9leG4gdCA9XG4gIGlmIHQgPiAwLjBcbiAgdGhlbiAoXG4gICAgbGV0IHQnID0gY2VpbCB0IGluXG4gICAgaWYgdCcgPD0gaW50NjNfcm91bmRfdWJvdW5kXG4gICAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdCdcbiAgICBlbHNlXG4gICAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgICAgXCJGbG9hdC5pbnQ2M19yb3VuZF91cF9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCJcbiAgICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICAgKCkpXG4gIGVsc2UgaWYgdCA+PSBpbnQ2M19yb3VuZF9sYm91bmRcbiAgdGhlbiBJbnQ2My5vZl9mbG9hdF91bmNoZWNrZWQgdFxuICBlbHNlXG4gICAgaW52YWxpZF9hcmdmXG4gICAgICBcIkZsb2F0LmludDYzX3JvdW5kX3VwX2V4bjogYXJndW1lbnQgKCVmKSBpcyB0b28gc21hbGwgb3IgTmFOXCJcbiAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAoKVxuOztcblxubGV0IGludDYzX3JvdW5kX2Rvd25fZXhuIHQgPVxuICBpZiB0ID49IDAuMFxuICB0aGVuXG4gICAgaWYgdCA8PSBpbnQ2M19yb3VuZF91Ym91bmRcbiAgICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfZG93bl9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCJcbiAgICAgICAgKEZsb2F0MC5ib3ggdClcbiAgICAgICAgKClcbiAgZWxzZSAoXG4gICAgbGV0IHQnID0gZmxvb3IgdCBpblxuICAgIGlmIHQnID49IGludDYzX3JvdW5kX2xib3VuZFxuICAgIHRoZW4gSW50NjMub2ZfZmxvYXRfdW5jaGVja2VkIHQnXG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfZG93bl9leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiXG4gICAgICAgIChGbG9hdDAuYm94IHQpXG4gICAgICAgICgpKVxuOztcblxubGV0IGludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuIHQwID1cbiAgbGV0IHQgPSAocm91bmRfbmVhcmVzdF9pbmxpbmUgW0BvY2FtbC5pbmxpbmVkIGFsd2F5c10pIHQwIGluXG4gIGlmIHQgPiAwLlxuICB0aGVuXG4gICAgaWYgdCA8PSBpbnQ2M19yb3VuZF91Ym91bmRcbiAgICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gICAgZWxzZVxuICAgICAgaW52YWxpZF9hcmdmXG4gICAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIGxhcmdlXCJcbiAgICAgICAgKGJveCB0MClcbiAgICAgICAgKClcbiAgZWxzZSBpZiB0ID49IGludDYzX3JvdW5kX2xib3VuZFxuICB0aGVuIEludDYzLm9mX2Zsb2F0X3VuY2hlY2tlZCB0XG4gIGVsc2VcbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwiRmxvYXQuaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG46IGFyZ3VtZW50ICglZikgaXMgdG9vIHNtYWxsIG9yIE5hTlwiXG4gICAgICAoYm94IHQwKVxuICAgICAgKClcbjs7XG5cbmxldCBpbnQ2M19yb3VuZF9uZWFyZXN0X2FyY2g2NF9ub2FsbG9jX2V4biBmID0gSW50NjMub2ZfaW50IChpcm91bmRfbmVhcmVzdF9leG4gZilcblxubGV0IGludDYzX3JvdW5kX25lYXJlc3RfZXhuID1cbiAgbWF0Y2ggV29yZF9zaXplLndvcmRfc2l6ZSB3aXRoXG4gIHwgVzY0IC0+IGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuXG4gIHwgVzMyIC0+IGludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuXG47O1xuXG5sZXQgcm91bmQgPyhkaXIgPSBgTmVhcmVzdCkgdCA9XG4gIG1hdGNoIGRpciB3aXRoXG4gIHwgYE5lYXJlc3QgLT4gcm91bmRfbmVhcmVzdCB0XG4gIHwgYERvd24gLT4gcm91bmRfZG93biB0XG4gIHwgYFVwIC0+IHJvdW5kX3VwIHRcbiAgfCBgWmVybyAtPiByb3VuZF90b3dhcmRzX3plcm8gdFxuOztcblxubW9kdWxlIENsYXNzID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBJbmZpbml0ZVxuICAgIHwgTmFuXG4gICAgfCBOb3JtYWxcbiAgICB8IFN1Ym5vcm1hbFxuICAgIHwgWmVyb1xuICBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZW51bWVyYXRlLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmUgPSAoUHB4X2NvbXBhcmVfbGliLnBvbHltb3JwaGljX2NvbXBhcmUgOiB0IC0+IHQgLT4gaW50KVxuICBsZXQgYWxsID0gKFsgSW5maW5pdGU7IE5hbjsgTm9ybWFsOyBTdWJub3JtYWw7IFplcm8gXSA6IHQgbGlzdClcblxuICBsZXQgdF9vZl9zZXhwID1cbiAgICAobGV0IGVycm9yX3NvdXJjZV9fMDA2XyA9IFwiZmxvYXQubWwuQ2xhc3MudFwiIGluXG4gICAgIGZ1bmN0aW9uXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcImluZmluaXRlXCIgfCBcIkluZmluaXRlXCIpIC0+IEluZmluaXRlXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5hblwiIHwgXCJOYW5cIikgLT4gTmFuXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcIm5vcm1hbFwiIHwgXCJOb3JtYWxcIikgLT4gTm9ybWFsXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInN1Ym5vcm1hbFwiIHwgXCJTdWJub3JtYWxcIikgLT4gU3Vibm9ybWFsXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5BdG9tIChcInplcm9cIiB8IFwiWmVyb1wiKSAtPiBaZXJvXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwiaW5maW5pdGVcIiB8IFwiSW5maW5pdGVcIikgOjogXykgYXNcbiAgICAgICBzZXhwX18wMDdfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJuYW5cIiB8IFwiTmFuXCIpIDo6IF8pIGFzIHNleHBfXzAwN18gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3Iuc3RhZ19ub19hcmdzIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDdfXG4gICAgIHwgU2V4cGxpYjAuU2V4cC5MaXN0IChTZXhwbGliMC5TZXhwLkF0b20gKFwibm9ybWFsXCIgfCBcIk5vcm1hbFwiKSA6OiBfKSBhcyBzZXhwX18wMDdfIC0+XG4gICAgICAgU2V4cGxpYjAuU2V4cF9jb252X2Vycm9yLnN0YWdfbm9fYXJncyBlcnJvcl9zb3VyY2VfXzAwNl8gc2V4cF9fMDA3X1xuICAgICB8IFNleHBsaWIwLlNleHAuTGlzdCAoU2V4cGxpYjAuU2V4cC5BdG9tIChcInN1Ym5vcm1hbFwiIHwgXCJTdWJub3JtYWxcIikgOjogXykgYXNcbiAgICAgICBzZXhwX18wMDdfIC0+IFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuQXRvbSAoXCJ6ZXJvXCIgfCBcIlplcm9cIikgOjogXykgYXMgc2V4cF9fMDA3XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5zdGFnX25vX2FyZ3MgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwN19cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgKFNleHBsaWIwLlNleHAuTGlzdCBfIDo6IF8pIGFzIHNleHBfXzAwNV8gLT5cbiAgICAgICBTZXhwbGliMC5TZXhwX2NvbnZfZXJyb3IubmVzdGVkX2xpc3RfaW52YWxpZF9zdW0gZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICAgfCBTZXhwbGliMC5TZXhwLkxpc3QgW10gYXMgc2V4cF9fMDA1XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci5lbXB0eV9saXN0X2ludmFsaWRfc3VtIGVycm9yX3NvdXJjZV9fMDA2XyBzZXhwX18wMDVfXG4gICAgIHwgc2V4cF9fMDA1XyAtPlxuICAgICAgIFNleHBsaWIwLlNleHBfY29udl9lcnJvci51bmV4cGVjdGVkX3N0YWcgZXJyb3Jfc291cmNlX18wMDZfIHNleHBfXzAwNV9cbiAgICAgICA6IFNleHBsaWIwLlNleHAudCAtPiB0KVxuICA7O1xuXG4gIGxldCBzZXhwX29mX3QgPVxuICAgIChmdW5jdGlvblxuICAgICAgfCBJbmZpbml0ZSAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJJbmZpbml0ZVwiXG4gICAgICB8IE5hbiAtPiBTZXhwbGliMC5TZXhwLkF0b20gXCJOYW5cIlxuICAgICAgfCBOb3JtYWwgLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiTm9ybWFsXCJcbiAgICAgIHwgU3Vibm9ybWFsIC0+IFNleHBsaWIwLlNleHAuQXRvbSBcIlN1Ym5vcm1hbFwiXG4gICAgICB8IFplcm8gLT4gU2V4cGxpYjAuU2V4cC5BdG9tIFwiWmVyb1wiXG4gICAgICAgICAgICAgICAgOiB0IC0+IFNleHBsaWIwLlNleHAudClcbiAgOztcblxuICBsZXQgKHRfc2V4cF9ncmFtbWFyIDogdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIHsgdW50eXBlZCA9XG4gICAgICAgIFZhcmlhbnRcbiAgICAgICAgICB7IGNhc2Vfc2Vuc2l0aXZpdHkgPSBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgWyBOb190YWcgeyBuYW1lID0gXCJJbmZpbml0ZVwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJOYW5cIjsgY2xhdXNlX2tpbmQgPSBBdG9tX2NsYXVzZSB9XG4gICAgICAgICAgICAgIDsgTm9fdGFnIHsgbmFtZSA9IFwiTm9ybWFsXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICA7IE5vX3RhZyB7IG5hbWUgPSBcIlN1Ym5vcm1hbFwiOyBjbGF1c2Vfa2luZCA9IEF0b21fY2xhdXNlIH1cbiAgICAgICAgICAgICAgOyBOb190YWcgeyBuYW1lID0gXCJaZXJvXCI7IGNsYXVzZV9raW5kID0gQXRvbV9jbGF1c2UgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgIH1cbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIGxldCB0b19zdHJpbmcgdCA9IHN0cmluZ19vZl9zZXhwIChzZXhwX29mX3QgdClcbiAgbGV0IG9mX3N0cmluZyBzID0gdF9vZl9zZXhwIChzZXhwX29mX3N0cmluZyBzKVxuZW5kXG5cbmxldCBjbGFzc2lmeSB0ID1cbiAgbGV0IG1vZHVsZSBDID0gQ2xhc3MgaW5cbiAgbWF0Y2ggY2xhc3NpZnlfZmxvYXQgdCB3aXRoXG4gIHwgRlBfbm9ybWFsIC0+IEMuTm9ybWFsXG4gIHwgRlBfc3Vibm9ybWFsIC0+IEMuU3Vibm9ybWFsXG4gIHwgRlBfemVybyAtPiBDLlplcm9cbiAgfCBGUF9pbmZpbml0ZSAtPiBDLkluZmluaXRlXG4gIHwgRlBfbmFuIC0+IEMuTmFuXG47O1xuXG5sZXQgaW5zZXJ0X3VuZGVyc2NvcmVzID8oZGVsaW1pdGVyID0gJ18nKSA/KHN0cmlwX3plcm8gPSBmYWxzZSkgc3RyaW5nID1cbiAgbWF0Y2ggU3RyaW5nLmxzcGxpdDIgc3RyaW5nIH5vbjonLicgd2l0aFxuICB8IE5vbmUgLT4gSW50X2NvbnZlcnNpb25zLmluc2VydF9kZWxpbWl0ZXIgc3RyaW5nIH5kZWxpbWl0ZXJcbiAgfCBTb21lIChsZWZ0LCByaWdodCkgLT5cbiAgICBsZXQgbGVmdCA9IEludF9jb252ZXJzaW9ucy5pbnNlcnRfZGVsaW1pdGVyIGxlZnQgfmRlbGltaXRlciBpblxuICAgIGxldCByaWdodCA9XG4gICAgICBpZiBzdHJpcF96ZXJvIHRoZW4gU3RyaW5nLnJzdHJpcCByaWdodCB+ZHJvcDooZnVuIGMgLT4gQ2hhci4oID0gKSBjICcwJykgZWxzZSByaWdodFxuICAgIGluXG4gICAgKG1hdGNoIHJpZ2h0IHdpdGhcbiAgICAgfCBcIlwiIC0+IGxlZnRcbiAgICAgfCBfIC0+IGxlZnQgXiBcIi5cIiBeIHJpZ2h0KVxuOztcblxubGV0IHRvX3N0cmluZ19odW0gP2RlbGltaXRlciA/KGRlY2ltYWxzID0gMykgP3N0cmlwX3plcm8gPyhleHBsaWNpdF9wbHVzID0gZmFsc2UpIGYgPVxuICBpZiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlLiggPCApIGRlY2ltYWxzIDBcbiAgdGhlbiBpbnZhbGlkX2FyZ2YgXCJ0b19zdHJpbmdfaHVtOiBpbnZhbGlkIGFyZ3VtZW50IH5kZWNpbWFscz0lZFwiIGRlY2ltYWxzICgpO1xuICBtYXRjaCBjbGFzc2lmeSBmIHdpdGhcbiAgfCBDbGFzcy5JbmZpbml0ZSAtPiBpZiBmID4gMC4gdGhlbiBcImluZlwiIGVsc2UgXCItaW5mXCJcbiAgfCBDbGFzcy5OYW4gLT4gXCJuYW5cIlxuICB8IENsYXNzLk5vcm1hbCB8IENsYXNzLlN1Ym5vcm1hbCB8IENsYXNzLlplcm8gLT5cbiAgICBsZXQgcyA9XG4gICAgICBpZiBleHBsaWNpdF9wbHVzIHRoZW4gc3ByaW50ZiBcIiUrLipmXCIgZGVjaW1hbHMgZiBlbHNlIHNwcmludGYgXCIlLipmXCIgZGVjaW1hbHMgZlxuICAgIGluXG4gICAgaW5zZXJ0X3VuZGVyc2NvcmVzIHMgP2RlbGltaXRlciA/c3RyaXBfemVyb1xuOztcblxubGV0IHNleHBfb2ZfdCB0ID1cbiAgbGV0IHNleHAgPSBzZXhwX29mX3QgdCBpblxuICBtYXRjaCAhU2V4cC5vZl9mbG9hdF9zdHlsZSB3aXRoXG4gIHwgYE5vX3VuZGVyc2NvcmVzIC0+IHNleHBcbiAgfCBgVW5kZXJzY29yZXMgLT5cbiAgICAobWF0Y2ggc2V4cCB3aXRoXG4gICAgIHwgTGlzdCBfIC0+XG4gICAgICAgcmFpc2Vfc1xuICAgICAgICAgKFNleHAubWVzc2FnZVxuICAgICAgICAgICAgXCJbc2V4cF9vZl9mbG9hdF0gcHJvZHVjZWQgc3RyYW5nZSBzZXhwXCJcbiAgICAgICAgICAgIFsgXCJzZXhwXCIsIFNleHAuc2V4cF9vZl90IHNleHAgXSlcbiAgICAgfCBBdG9tIHN0cmluZyAtPlxuICAgICAgIGlmIFN0cmluZy5jb250YWlucyBzdHJpbmcgJ0UnIHRoZW4gc2V4cCBlbHNlIEF0b20gKGluc2VydF91bmRlcnNjb3JlcyBzdHJpbmcpKVxuOztcblxubGV0IHRvX3BhZGRlZF9jb21wYWN0X3N0cmluZ19jdXN0b20gdCA/KHByZWZpeCA9IFwiXCIpIH5raWxvIH5tZWdhIH5naWdhIH50ZXJhID9wZXRhICgpID1cbiAgKCogUm91bmQgYSByYXRpbyB0b3dhcmQgdGhlIG5lYXJlc3QgaW50ZWdlciwgcmVzb2x2aW5nIHRpZXMgdG93YXJkIHRoZSBuZWFyZXN0IGV2ZW5cbiAgICAgbnVtYmVyLiAgRm9yIHNhbmUgaW5wdXRzIChpbiBwYXJ0aWN1bGFyLCB3aGVuIFtkZW5vbWluYXRvcl0gaXMgYW4gaW50ZWdlciBhbmRcbiAgICAgW2FicyBudW1lcmF0b3IgPCAyZTUyXSkgdGhpcyBzaG91bGQgYmUgYWNjdXJhdGUuICBPdGhlcndpc2UsIHRoZSByZXN1bHQgbWlnaHQgYmUgYVxuICAgICBsaXR0bGUgYml0IG9mZiwgYnV0IHdlIGRvbid0IHJlYWxseSB1c2UgdGhhdCBjYXNlLiAqKVxuICBsZXQgaXJvdW5kX3JhdGlvX2V4biB+bnVtZXJhdG9yIH5kZW5vbWluYXRvciA9XG4gICAgbGV0IGsgPSBmbG9vciAobnVtZXJhdG9yIC8uIGRlbm9taW5hdG9yKSBpblxuICAgICgqIGlmIFthYnMgayA8IDJlNTNdLCB0aGVuIGJvdGggW2tdIGFuZCBbayArLiAxLl0gYXJlIGFjY3VyYXRlbHkgcmVwcmVzZW50ZWQsIGFuZCBpblxuICAgICAgIHBhcnRpY3VsYXIgW2sgKy4gMS4gPiBrXS4gIElmIFtkZW5vbWluYXRvcl0gaXMgYWxzbyBhbiBpbnRlZ2VyLCBhbmRcbiAgICAgICBbYWJzIChkZW5vbWluYXRvciAqLiAoayArLiAxKSkgPCAyZTUzXSAoYW5kIGluIHNvbWUgb3RoZXIgY2FzZXMsIHRvbyksIHRoZW4gW2xvd2VyXVxuICAgICAgIGFuZCBbaGlnaGVyXSBhcmUgYWN0dWFsbHkgYm90aCBhY2N1cmF0ZS4gIFNpbmNlIChyb3VnaGx5KVxuICAgICAgIFtudW1lcmF0b3IgPSBkZW5vbWluYXRvciAqLiBrXSB0aGVuIGZvciBbYWJzIG51bWVyYXRvciA8IDJlNTJdIHdlIHNob3VsZCBiZVxuICAgICAgIGZpbmUuICopXG4gICAgbGV0IGxvd2VyID0gZGVub21pbmF0b3IgKi4gayBpblxuICAgIGxldCBoaWdoZXIgPSBkZW5vbWluYXRvciAqLiAoayArLiAxLikgaW5cbiAgICAoKiBTdWJ0cmFjdGluZyBudW1iZXJzIHdpdGhpbiBhIGZhY3RvciBvZiB0d28gZnJvbSBlYWNoIG90aGVyIGlzIGFjY3VyYXRlLlxuICAgICAgIFNvIGVpdGhlciB0aGUgdHdvIHN1YnRyYWN0aW9ucyBiZWxvdyBhcmUgYWNjdXJhdGUsIG9yIGsgPSAwLCBvciBrID0gLTEuXG4gICAgICAgSW4gY2FzZSBvZiBhIHRpZSwgcm91bmQgdG8gZXZlbi4gKilcbiAgICBsZXQgZGlmZl9yaWdodCA9IGhpZ2hlciAtLiBudW1lcmF0b3IgaW5cbiAgICBsZXQgZGlmZl9sZWZ0ID0gbnVtZXJhdG9yIC0uIGxvd2VyIGluXG4gICAgbGV0IGsgPSBpcm91bmRfbmVhcmVzdF9leG4gayBpblxuICAgIGlmIGRpZmZfcmlnaHQgPCBkaWZmX2xlZnRcbiAgICB0aGVuIGsgKyAxXG4gICAgZWxzZSBpZiBkaWZmX3JpZ2h0ID4gZGlmZl9sZWZ0XG4gICAgdGhlbiBrXG4gICAgZWxzZSBpZiAoKiBhIHRpZSAqKVxuICAgICAgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS4oID0gKSAoayBtb2QgMikgMFxuICAgIHRoZW4ga1xuICAgIGVsc2UgayArIDFcbiAgaW5cbiAgbWF0Y2ggY2xhc3NpZnkgdCB3aXRoXG4gIHwgQ2xhc3MuSW5maW5pdGUgLT4gaWYgdCA8IDAuMCB0aGVuIFwiLWluZiAgXCIgZWxzZSBcImluZiAgXCJcbiAgfCBDbGFzcy5OYW4gLT4gXCJuYW4gIFwiXG4gIHwgQ2xhc3MuU3Vibm9ybWFsIHwgQ2xhc3MuTm9ybWFsIHwgQ2xhc3MuWmVybyAtPlxuICAgIGxldCBnbyB0ID1cbiAgICAgIGxldCBjb252X29uZSB0ID1cbiAgICAgICAgYXNzZXJ0ICgwLiA8PSB0ICYmIHQgPCA5OTkuOTUpO1xuICAgICAgICBsZXQgeCA9IHByZWZpeCBeIGZvcm1hdF9mbG9hdCBcIiUuMWZcIiB0IGluXG4gICAgICAgICgqIEZpeCB0aGUgXCIuMFwiIHN1ZmZpeCAqKVxuICAgICAgICBpZiBTdHJpbmcuaXNfc3VmZml4IHggfnN1ZmZpeDpcIi4wXCJcbiAgICAgICAgdGhlbiAoXG4gICAgICAgICAgbGV0IHggPSBCeXRlcy5vZl9zdHJpbmcgeCBpblxuICAgICAgICAgIGxldCBuID0gQnl0ZXMubGVuZ3RoIHggaW5cbiAgICAgICAgICBCeXRlcy5zZXQgeCAobiAtIDEpICcgJztcbiAgICAgICAgICBCeXRlcy5zZXQgeCAobiAtIDIpICcgJztcbiAgICAgICAgICBCeXRlcy51bnNhZmVfdG9fc3RyaW5nIH5ub19tdXRhdGlvbl93aGlsZV9zdHJpbmdfcmVhY2hhYmxlOngpXG4gICAgICAgIGVsc2UgeFxuICAgICAgaW5cbiAgICAgIGxldCBjb252IG1hZyB0IGRlbm9taW5hdG9yID1cbiAgICAgICAgYXNzZXJ0IChcbiAgICAgICAgICAoZGVub21pbmF0b3IgPSAxMDAuICYmIHQgPj0gOTk5Ljk1KVxuICAgICAgICAgIHx8IChkZW5vbWluYXRvciA+PSAxMDBfMDAwLiAmJiB0ID49IHJvdW5kX25lYXJlc3QgKGRlbm9taW5hdG9yICouIDkuOTk5XzUpKSk7XG4gICAgICAgIGFzc2VydCAodCA8IHJvdW5kX25lYXJlc3QgKGRlbm9taW5hdG9yICouIDlfOTk5LjUpKTtcbiAgICAgICAgbGV0IGksIGQgPVxuICAgICAgICAgIGxldCBrID0gaXJvdW5kX3JhdGlvX2V4biB+bnVtZXJhdG9yOnQgfmRlbm9taW5hdG9yIGluXG4gICAgICAgICAgKCogW21vZF0gaXMgb2theSBoZXJlIGJlY2F1c2Ugd2Uga25vdyBpID49IDAuICopXG4gICAgICAgICAgayAvIDEwLCBrIG1vZCAxMFxuICAgICAgICBpblxuICAgICAgICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgICAgIGFzc2VydCAoMCA8PSBpICYmIGkgPCAxMDAwKTtcbiAgICAgICAgYXNzZXJ0ICgwIDw9IGQgJiYgZCA8IDEwKTtcbiAgICAgICAgaWYgZCA9IDBcbiAgICAgICAgdGhlbiBzcHJpbnRmIFwiJXMlZCVzIFwiIHByZWZpeCBpIG1hZ1xuICAgICAgICBlbHNlIHNwcmludGYgXCIlcyVkJXMlZFwiIHByZWZpeCBpIG1hZyBkXG4gICAgICBpblxuICAgICAgKCogV2hpbGUgdGhlIHN0YW5kYXJkIG1ldHJpYyBwcmVmaXhlcyAoZS5nLiBjYXBpdGFsIFwiTVwiIHJhdGhlciB0aGFuIFwibVwiLCBbMV0pIGFyZVxuICAgICAgICAgbm9taW5hbGx5IG1vcmUgY29ycmVjdCwgdGhpcyBoaW5kZXJzIHJlYWRhYmlsaXR5IGluIG91ciBjYXNlLiAgRS5nLiwgMTBHNiBhbmRcbiAgICAgICAgIDEwNjYgbG9vayB0b28gc2ltaWxhci4gIFRoYXQncyBhbiBleHRyZW1lIGV4YW1wbGUsIGJ1dCBpbiBnZW5lcmFsIGssbSxnLHQscFxuICAgICAgICAgcHJvYmFibHkgc3RhbmQgb3V0IGJldHRlciB0aGFuIEssTSxHLFQsUCB3aGVuIGludGVyc3BlcnNlZCB3aXRoIGRpZ2l0cy5cblxuICAgICAgICAgWzFdIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWV0cmljX3ByZWZpeCAqKVxuICAgICAgKCogVGhlIHRyaWNrIGhlcmUgaXMgdGhhdDpcbiAgICAgICAgIC0gdGhlIGZpcnN0IGJvdW5kYXJ5ICg5OTkuOTUpIGFzIGEgZmxvYXQgaXMgc2xpZ2h0bHkgb3Zlci1yZXByZXNlbnRlZCAoc28gaXQgaXNcbiAgICAgICAgICAgYmV0dGVyIGFwcHJveGltYXRlZCBhcyBcIjFrXCIgdGhhbiBhcyBcIjk5OS45XCIpLFxuICAgICAgICAgLSB0aGUgb3RoZXIgYm91bmRhcmllcyBhcmUgYWNjdXJhdGVseSByZXByZXNlbnRlZCwgYmVjYXVzZSB0aGV5IGFyZSBpbnRlZ2Vycy5cbiAgICAgICAgICAgVGhhdCdzIHdoeSB0aGUgc3RyaWN0IGVxdWFsaXRpZXMgYmVsb3cgZG8gZXhhY3RseSB3aGF0IHdlIHdhbnQuICopXG4gICAgICBpZiB0IDwgOTk5Ljk1RTBcbiAgICAgIHRoZW4gY29udl9vbmUgdFxuICAgICAgZWxzZSBpZiB0IDwgOTk5Ljk1RTNcbiAgICAgIHRoZW4gY29udiBraWxvIHQgMTAwLlxuICAgICAgZWxzZSBpZiB0IDwgOTk5Ljk1RTZcbiAgICAgIHRoZW4gY29udiBtZWdhIHQgMTAwXzAwMC5cbiAgICAgIGVsc2UgaWYgdCA8IDk5OS45NUU5XG4gICAgICB0aGVuIGNvbnYgZ2lnYSB0IDEwMF8wMDBfMDAwLlxuICAgICAgZWxzZSBpZiB0IDwgOTk5Ljk1RTEyXG4gICAgICB0aGVuIGNvbnYgdGVyYSB0IDEwMF8wMDBfMDAwXzAwMC5cbiAgICAgIGVsc2UgKFxuICAgICAgICBtYXRjaCBwZXRhIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHNwcmludGYgXCIlcyUuMWVcIiBwcmVmaXggdFxuICAgICAgICB8IFNvbWUgcGV0YSAtPlxuICAgICAgICAgIGlmIHQgPCA5OTkuOTVFMTVcbiAgICAgICAgICB0aGVuIGNvbnYgcGV0YSB0IDEwMF8wMDBfMDAwXzAwMF8wMDAuXG4gICAgICAgICAgZWxzZSBzcHJpbnRmIFwiJXMlLjFlXCIgcHJlZml4IHQpXG4gICAgaW5cbiAgICBpZiB0ID49IDAuIHRoZW4gZ28gdCBlbHNlIFwiLVwiIF4gZ28gfi0udFxuOztcblxubGV0IHRvX3BhZGRlZF9jb21wYWN0X3N0cmluZyB0ID1cbiAgdG9fcGFkZGVkX2NvbXBhY3Rfc3RyaW5nX2N1c3RvbSB0IH5raWxvOlwia1wiIH5tZWdhOlwibVwiIH5naWdhOlwiZ1wiIH50ZXJhOlwidFwiIH5wZXRhOlwicFwiICgpXG47O1xuXG4oKiBQZXJmb3JtYW5jZSBub3RlOiBJbml0aWFsaXppbmcgdGhlIGFjY3VtdWxhdG9yIHRvIDEgcmVzdWx0cyBpbiBvbmUgZXh0cmFcbiAgIG11bHRpcGx5OyBlLmcuLCB0byBjb21wdXRlIHggKiogNCwgd2UgaW4gcHJpbmNpcGxlIG9ubHkgbmVlZCAyIG11bHRpcGxpZXMsXG4gICBidXQgdGhpcyBmdW5jdGlvbiB3aWxsIGhhdmUgMyBtdWx0aXBsaWVzLiAgSG93ZXZlciwgYXR0ZW1wdHMgdG8gYXZvaWQgdGhpc1xuICAgKGxpa2UgZGVjcmVtZW50aW5nIG4gYW5kIGluaXRpYWxpemluZyBhY2N1bSB0byBiZSB4LCBvciBoYW5kbGluZyBzbWFsbFxuICAgZXhwb25lbnRzIGFzIGEgc3BlY2lhbCBjYXNlKSBoYXZlIG5vdCB5aWVsZGVkIGFueXRoaW5nIHRoYXQgaXMgYSBuZXRcbiAgIGltcHJvdmVtZW50LlxuKilcbmxldCBpbnRfcG93IHggbiA9XG4gIGxldCBvcGVuIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgaW5cbiAgaWYgbiA9IDBcbiAgdGhlbiAxLlxuICBlbHNlIChcbiAgICAoKiBVc2luZyBbeCArLiAoLTAuKV0gb24gdGhlIGZvbGxvd2luZyBsaW5lIGNvbnZpbmNlcyB0aGUgY29tcGlsZXIgdG8gYXZvaWQgYSBjZXJ0YWluXG4gICAgICAgYm94aW5nICh0aGF0IHdvdWxkIHJlc3VsdCBpbiBhbGxvY2F0aW9uIGluIGVhY2ggaXRlcmF0aW9uKS4gIFNvb24sIHRoZSBjb21waWxlclxuICAgICAgIHNob3VsZG4ndCBuZWVkIHRoaXMgXCJoaW50XCIgdG8gYXZvaWQgdGhlIGJveGluZy4gIFRoZSByZWFzb24gd2UgYWRkIC0wIHJhdGhlciB0aGFuIDBcbiAgICAgICBpcyB0aGF0IFt4ICsuICgtMC4pXSBpcyBhcHBhcmVudGx5IGFsd2F5cyB0aGUgc2FtZSBhcyBbeF0sIHdoZXJlYXMgW3ggKy4gMC5dIGlzXG4gICAgICAgbm90LCBpbiB0aGF0IGl0IHNlbmRzIFstMC5dIHRvIFswLl0uICBUaGlzIG1ha2VzIGEgZGlmZmVyZW5jZSBiZWNhdXNlIHdlIHdhbnRcbiAgICAgICBbaW50X3BvdyAoLTAuKSAoLTEpXSB0byByZXR1cm4gbmVnX2luZmluaXR5IGp1c3QgbGlrZSBbLTAuICoqIC0xLl0gd291bGQuICAqKVxuICAgIGxldCB4ID0gcmVmICh4ICsuIC0wLikgaW5cbiAgICBsZXQgbiA9IHJlZiBuIGluXG4gICAgbGV0IGFjY3VtID0gcmVmIDEuIGluXG4gICAgaWYgIW4gPCAwXG4gICAgdGhlbiAoXG4gICAgICAoKiB4ICoqIG4gPSAoMS94KSAqKiAtbiAqKVxuICAgICAgeCA6PSAxLiAvLiAheDtcbiAgICAgIG4gOj0gfi0gKCFuKTtcbiAgICAgIGlmICFuIDwgMFxuICAgICAgdGhlbiAoXG4gICAgICAgICgqIG4gbXVzdCBoYXZlIGJlZW4gbWluX2ludCwgc28gaXQgaXMgbm93IHNvIGJpZyB0aGF0IGl0IGhhcyB3cmFwcGVkIGFyb3VuZC5cbiAgICAgICAgICAgV2UgZGVjcmVtZW50IGl0IHNvIHRoYXQgaXQgbG9va3MgcG9zaXRpdmUgYWdhaW4sIGJ1dCBhY2NvcmRpbmdseSBoYXZlXG4gICAgICAgICAgIHRvIHB1dCBhbiBleHRyYSBmYWN0b3Igb2YgeCBpbiB0aGUgYWNjdW11bGF0b3IuXG4gICAgICAgICopXG4gICAgICAgIGFjY3VtIDo9ICF4O1xuICAgICAgICBkZWNyIG4pKTtcbiAgICAoKiBMZXR0aW5nIFthXSBkZW5vdGUgKHRoZSBvcmlnaW5hbCB2YWx1ZSBvZikgW3ggKiogbl0sIHdlIG1haW50YWluXG4gICAgICAgdGhlIGludmFyaWFudCB0aGF0IFsoeCAqKiBuKSAqLiBhY2N1bSA9IGFdLiAqKVxuICAgIHdoaWxlICFuID4gMSBkb1xuICAgICAgaWYgIW4gbGFuZCAxIDw+IDAgdGhlbiBhY2N1bSA6PSAheCAqLiAhYWNjdW07XG4gICAgICB4IDo9ICF4ICouICF4O1xuICAgICAgbiA6PSAhbiBsc3IgMVxuICAgIGRvbmU7XG4gICAgKCogbiBpcyBuZWNlc3NhcmlseSAxIGF0IHRoaXMgcG9pbnQsIHNvIHRoZXJlIGlzIG9uZSBhZGRpdGlvbmFsXG4gICAgICAgbXVsdGlwbGljYXRpb24gYnkgeC4gKilcbiAgICAheCAqLiAhYWNjdW0pXG47O1xuXG5sZXQgcm91bmRfZ2VuIHggfmhvdyA9XG4gIGlmIHggPSAwLlxuICB0aGVuIDAuXG4gIGVsc2UgaWYgbm90IChpc19maW5pdGUgeClcbiAgdGhlbiB4XG4gIGVsc2UgKFxuICAgICgqIFNpZ25pZmljYW50IGRpZ2l0cyBhbmQgZGVjaW1hbCBkaWdpdHMuICopXG4gICAgbGV0IHNkLCBkZCA9XG4gICAgICBtYXRjaCBob3cgd2l0aFxuICAgICAgfCBgc2lnbmlmaWNhbnRfZGlnaXRzIHNkIC0+XG4gICAgICAgIGxldCBkZCA9IHNkIC0gdG9faW50IChyb3VuZF91cCAobG9nMTAgKGFicyB4KSkpIGluXG4gICAgICAgIHNkLCBkZFxuICAgICAgfCBgZGVjaW1hbF9kaWdpdHMgZGQgLT5cbiAgICAgICAgbGV0IHNkID0gZGQgKyB0b19pbnQgKHJvdW5kX3VwIChsb2cxMCAoYWJzIHgpKSkgaW5cbiAgICAgICAgc2QsIGRkXG4gICAgaW5cbiAgICBsZXQgb3BlbiBJbnRfcmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlIGluXG4gICAgaWYgc2QgPCAwXG4gICAgdGhlbiAwLlxuICAgIGVsc2UgaWYgc2QgPj0gMTdcbiAgICB0aGVuIHhcbiAgICBlbHNlIChcbiAgICAgICgqIENob29zZSB0aGUgb3JkZXIgdGhhdCBpcyBleGFjdGx5IHJlcHJlc2VudGFibGUgYXMgYSBmbG9hdC4gU21hbGwgcG9zaXRpdmVcbiAgICAgICAgIGludGVnZXJzIGFyZSwgYnV0IHRoZWlyIGludmVyc2VzIGluIG1vc3QgY2FzZXMgYXJlIG5vdC4gKilcbiAgICAgIGxldCBhYnNfZGQgPSBJbnQuYWJzIGRkIGluXG4gICAgICBpZiBhYnNfZGQgPiAyMiB8fCBzZCA+PSAxNlxuICAgICAgKCogMTAqKjIyIGlzIGV4YWN0bHkgcmVwcmVzZW50YWJsZSBhcyBhIGZsb2F0LCBidXQgMTAqKjIzIGlzIG5vdCwgc28gdXNlIHRoZSBzbG93XG4gICAgICAgICBwYXRoLiAgU2ltaWxhcmx5LCBpZiB3ZSBuZWVkIDE2IHNpZ25pZmljYW50IGRpZ2l0cyBpbiB0aGUgcmVzdWx0LCB0aGVuIHRoZSBpbnRlZ2VyXG4gICAgICAgICBbcm91bmRfbmVhcmVzdCAoeCA8b3A+IG9yZGVyKV0gbWlnaHQgbm90IGJlIGV4YWN0bHkgcmVwcmVzZW50YWJsZSBhcyBhIGZsb2F0LCBzaW5jZVxuICAgICAgICAgZm9yIHNvbWUgcmFuZ2VzIHdlIG9ubHkgaGF2ZSAxNSBkaWdpdHMgb2YgcHJlY2lzaW9uIGd1YXJhbnRlZWQuXG5cbiAgICAgICAgIFRoYXQgc2FpZCwgd2UgYXJlIHN0aWxsIHJvdW5kaW5nIHR3aWNlIGhlcmU6XG5cbiAgICAgICAgIDEpIGZpcnN0IHRpbWUgd2hlbiByb3VuZGluZyBbeCAqLiBvcmRlcl0gb3IgW3ggLy4gb3JkZXJdIHRvIHRoZSBuZWFyZXN0IGZsb2F0XG4gICAgICAgICAoanVzdCB0aGUgbm9ybWFsIHdheSBmbG9hdGluZy1wb2ludCBtdWx0aXBsaWNhdGlvbiBvciBkaXZpc2lvbiB3b3JrcyksXG5cbiAgICAgICAgIDIpIHNlY29uZCB0aW1lIHdoZW4gYXBwbHlpbmcgW3JvdW5kX25lYXJlc3RfaGFsZl90b19ldmVuXSB0byB0aGUgcmVzdWx0IG9mIHRoZVxuICAgICAgICAgYWJvdmUgb3BlcmF0aW9uXG5cbiAgICAgICAgIFNvIGZvciBhcmd1bWVudHMgd2l0aGluIGFuIHVscCBmcm9tIGEgdGllIHdlIG1pZ2h0IHN0aWxsIHByb2R1Y2UgYW4gb2ZmLWJ5LW9uZVxuICAgICAgICAgcmVzdWx0LiAqKVxuICAgICAgdGhlbiBvZl9zdHJpbmcgKHNwcmludGYgXCIlLipnXCIgc2QgeClcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgb3JkZXIgPSBpbnRfcG93IDEwLiBhYnNfZGQgaW5cbiAgICAgICAgaWYgZGQgPj0gMFxuICAgICAgICB0aGVuIHJvdW5kX25lYXJlc3RfaGFsZl90b19ldmVuICh4ICouIG9yZGVyKSAvLiBvcmRlclxuICAgICAgICBlbHNlIHJvdW5kX25lYXJlc3RfaGFsZl90b19ldmVuICh4IC8uIG9yZGVyKSAqLiBvcmRlcikpKVxuOztcblxubGV0IHJvdW5kX3NpZ25pZmljYW50IHggfnNpZ25pZmljYW50X2RpZ2l0cyA9XG4gIGlmIEludF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUuKCA8PSApIHNpZ25pZmljYW50X2RpZ2l0cyAwXG4gIHRoZW5cbiAgICBpbnZhbGlkX2FyZ2ZcbiAgICAgIFwiRmxvYXQucm91bmRfc2lnbmlmaWNhbnQ6IGludmFsaWQgYXJndW1lbnQgc2lnbmlmaWNhbnRfZGlnaXRzOiVkXCJcbiAgICAgIHNpZ25pZmljYW50X2RpZ2l0c1xuICAgICAgKClcbiAgZWxzZSByb3VuZF9nZW4geCB+aG93Oihgc2lnbmlmaWNhbnRfZGlnaXRzIHNpZ25pZmljYW50X2RpZ2l0cylcbjs7XG5cbmxldCByb3VuZF9kZWNpbWFsIHggfmRlY2ltYWxfZGlnaXRzID0gcm91bmRfZ2VuIHggfmhvdzooYGRlY2ltYWxfZGlnaXRzIGRlY2ltYWxfZGlnaXRzKVxubGV0IGJldHdlZW4gdCB+bG93IH5oaWdoID0gbG93IDw9IHQgJiYgdCA8PSBoaWdoXG5cbmxldCBjbGFtcF9leG4gdCB+bWluIH5tYXggPVxuICAoKiBBbHNvIGZhaWxzIGlmIFttaW5dIG9yIFttYXhdIGlzIG5hbiAqKVxuICBhc3NlcnQgKG1pbiA8PSBtYXgpO1xuICAoKiBjbGFtcF91bmNoZWNrZWQgaXMgaW4gZmxvYXQwLm1sICopXG4gIGNsYW1wX3VuY2hlY2tlZCB0IH5taW4gfm1heFxuOztcblxubGV0IGNsYW1wIHQgfm1pbiB+bWF4ID1cbiAgKCogQWxzbyBmYWlscyBpZiBbbWluXSBvciBbbWF4XSBpcyBuYW4gKilcbiAgaWYgbWluIDw9IG1heFxuICB0aGVuIE9rIChjbGFtcF91bmNoZWNrZWQgdCB+bWluIH5tYXgpXG4gIGVsc2VcbiAgICBPcl9lcnJvci5lcnJvcl9zXG4gICAgICAoU2V4cC5tZXNzYWdlXG4gICAgICAgICBcImNsYW1wIHJlcXVpcmVzIFttaW4gPD0gbWF4XVwiXG4gICAgICAgICBbIFwibWluXCIsIFQuc2V4cF9vZl90IG1pbjsgXCJtYXhcIiwgVC5zZXhwX29mX3QgbWF4IF0pXG47O1xuXG5sZXQgKCArICkgPSAoICsuIClcbmxldCAoIC0gKSA9ICggLS4gKVxubGV0ICggKiApID0gKCAqLiApXG5sZXQgKCAqKiApID0gKCAqKiApXG5sZXQgKCAvICkgPSAoIC8uIClcbmxldCAoICUgKSA9ICggJS4gKVxubGV0ICggfi0gKSA9ICggfi0uIClcblxubGV0IHNpZ25fZXhuIHQgOiBTaWduLnQgPVxuICBpZiB0ID4gMC5cbiAgdGhlbiBQb3NcbiAgZWxzZSBpZiB0IDwgMC5cbiAgdGhlbiBOZWdcbiAgZWxzZSBpZiB0ID0gMC5cbiAgdGhlbiBaZXJvXG4gIGVsc2UgRXJyb3IucmFpc2VfcyAoU2V4cC5tZXNzYWdlIFwiRmxvYXQuc2lnbl9leG4gb2YgTkFOXCIgWyBcIlwiLCBzZXhwX29mX3QgdCBdKVxuOztcblxubGV0IHNpZ25fb3JfbmFuIHQgOiBTaWduX29yX25hbi50ID1cbiAgaWYgdCA+IDAuIHRoZW4gUG9zIGVsc2UgaWYgdCA8IDAuIHRoZW4gTmVnIGVsc2UgaWYgdCA9IDAuIHRoZW4gWmVybyBlbHNlIE5hblxuOztcblxubGV0IGllZWVfbmVnYXRpdmUgdCA9XG4gIGxldCBiaXRzID0gQ2FtbC5JbnQ2NC5iaXRzX29mX2Zsb2F0IHQgaW5cbiAgUG9seS4oYml0cyA8IENhbWwuSW50NjQuemVybylcbjs7XG5cbmxldCBleHBvbmVudF9iaXRzID0gMTFcbmxldCBtYW50aXNzYV9iaXRzID0gNTJcbmxldCBleHBvbmVudF9tYXNrNjQgPSBJbnQ2NC4oc2hpZnRfbGVmdCBvbmUgZXhwb25lbnRfYml0cyAtIG9uZSlcbmxldCBleHBvbmVudF9tYXNrID0gSW50NjQudG9faW50X2V4biBleHBvbmVudF9tYXNrNjRcbmxldCBtYW50aXNzYV9tYXNrID0gSW50NjMuKHNoaWZ0X2xlZnQgb25lIG1hbnRpc3NhX2JpdHMgLSBvbmUpXG5sZXQgbWFudGlzc2FfbWFzazY0ID0gSW50NjMudG9faW50NjQgbWFudGlzc2FfbWFza1xuXG5sZXQgaWVlZV9leHBvbmVudCB0ID1cbiAgbGV0IGJpdHMgPSBDYW1sLkludDY0LmJpdHNfb2ZfZmxvYXQgdCBpblxuICBJbnQ2NC4oYml0X2FuZCAoc2hpZnRfcmlnaHRfbG9naWNhbCBiaXRzIG1hbnRpc3NhX2JpdHMpIGV4cG9uZW50X21hc2s2NClcbiAgfD4gQ2FtbC5JbnQ2NC50b19pbnRcbjs7XG5cbmxldCBpZWVlX21hbnRpc3NhIHQgPVxuICBsZXQgYml0cyA9IENhbWwuSW50NjQuYml0c19vZl9mbG9hdCB0IGluXG4gIEludDYzLm9mX2ludDY0X2V4biBDYW1sLkludDY0Lihsb2dhbmQgYml0cyBtYW50aXNzYV9tYXNrNjQpXG47O1xuXG5sZXQgY3JlYXRlX2llZWVfZXhuIH5uZWdhdGl2ZSB+ZXhwb25lbnQgfm1hbnRpc3NhID1cbiAgaWYgSW50LihiaXRfYW5kIGV4cG9uZW50IGV4cG9uZW50X21hc2sgPD4gZXhwb25lbnQpXG4gIHRoZW4gZmFpbHdpdGhmIFwiZXhwb25lbnQgJWQgb3V0IG9mIHJhbmdlIFswLCAlZF1cIiBleHBvbmVudCBleHBvbmVudF9tYXNrICgpXG4gIGVsc2UgaWYgSW50NjMuKGJpdF9hbmQgbWFudGlzc2EgbWFudGlzc2FfbWFzayA8PiBtYW50aXNzYSlcbiAgdGhlblxuICAgIGZhaWx3aXRoZlxuICAgICAgXCJtYW50aXNzYSAlcyBvdXQgb2YgcmFuZ2UgWzAsICVzXVwiXG4gICAgICAoSW50NjMudG9fc3RyaW5nIG1hbnRpc3NhKVxuICAgICAgKEludDYzLnRvX3N0cmluZyBtYW50aXNzYV9tYXNrKVxuICAgICAgKClcbiAgZWxzZSAoXG4gICAgbGV0IHNpZ25fYml0cyA9IGlmIG5lZ2F0aXZlIHRoZW4gQ2FtbC5JbnQ2NC5taW5faW50IGVsc2UgQ2FtbC5JbnQ2NC56ZXJvIGluXG4gICAgbGV0IGV4cHRfYml0cyA9IENhbWwuSW50NjQuc2hpZnRfbGVmdCAoQ2FtbC5JbnQ2NC5vZl9pbnQgZXhwb25lbnQpIG1hbnRpc3NhX2JpdHMgaW5cbiAgICBsZXQgbWFudF9iaXRzID0gSW50NjMudG9faW50NjQgbWFudGlzc2EgaW5cbiAgICBsZXQgYml0cyA9IENhbWwuSW50NjQuKGxvZ29yIHNpZ25fYml0cyAobG9nb3IgZXhwdF9iaXRzIG1hbnRfYml0cykpIGluXG4gICAgQ2FtbC5JbnQ2NC5mbG9hdF9vZl9iaXRzIGJpdHMpXG47O1xuXG5sZXQgY3JlYXRlX2llZWUgfm5lZ2F0aXZlIH5leHBvbmVudCB+bWFudGlzc2EgPVxuICBPcl9lcnJvci50cnlfd2l0aCAoZnVuICgpIC0+IGNyZWF0ZV9pZWVlX2V4biB+bmVnYXRpdmUgfmV4cG9uZW50IH5tYW50aXNzYSlcbjs7XG5cbm1vZHVsZSBUZXJzZSA9IHN0cnVjdFxuICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gIGxldCB0X29mX3NleHAgPSB0X29mX3NleHBcbiAgbGV0IHRvX3N0cmluZyB4ID0gUHJpbnRmLnNwcmludGYgXCIlLjhHXCIgeFxuICBsZXQgc2V4cF9vZl90IHggPSBTZXhwLkF0b20gKHRvX3N0cmluZyB4KVxuICBsZXQgb2Zfc3RyaW5nIHggPSBvZl9zdHJpbmcgeFxuICBsZXQgdF9zZXhwX2dyYW1tYXIgPSB0X3NleHBfZ3JhbW1hclxuZW5kXG5cbmluY2x1ZGUgQ29tcGFyYWJsZS5XaXRoX3plcm8gKHN0cnVjdFxuICAgIGluY2x1ZGUgVFxuXG4gICAgbGV0IHplcm8gPSB6ZXJvXG4gIGVuZClcblxuKCogVGhlc2UgYXJlIHBhcnRseSBoZXJlIGFzIGEgcGVyZm9ybWFuY2UgaGFjayB0byBhdm9pZCBzb21lIGJveGluZyB3ZSdyZSBnZXR0aW5nIHdpdGhcbiAgIHRoZSB2ZXJzaW9ucyB3ZSBnZXQgZnJvbSBbV2l0aF96ZXJvXS4gIFRoZXkgYWxzbyBtYWtlIFtGbG9hdC5pc19uZWdhdGl2ZSBuYW5dIGFuZFxuICAgW0Zsb2F0LmlzX25vbl9wb3NpdGl2ZSBuYW5dIHJldHVybiBbZmFsc2VdOyB0aGUgdmVyc2lvbnMgd2UgZ2V0IGZyb20gW1dpdGhfemVyb10gcmV0dXJuXG4gICBbdHJ1ZV0uICopXG5sZXQgaXNfcG9zaXRpdmUgdCA9IHQgPiAwLlxubGV0IGlzX25vbl9uZWdhdGl2ZSB0ID0gdCA+PSAwLlxubGV0IGlzX25lZ2F0aXZlIHQgPSB0IDwgMC5cbmxldCBpc19ub25fcG9zaXRpdmUgdCA9IHQgPD0gMC5cblxuaW5jbHVkZSBQcmV0dHlfcHJpbnRlci5SZWdpc3RlciAoc3RydWN0XG4gICAgaW5jbHVkZSBUXG5cbiAgICBsZXQgbW9kdWxlX25hbWUgPSBcIkJhc2UuRmxvYXRcIlxuICAgIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdcbiAgZW5kKVxuXG5tb2R1bGUgTyA9IHN0cnVjdFxuICBsZXQgKCArICkgPSAoICsgKVxuICBsZXQgKCAtICkgPSAoIC0gKVxuICBsZXQgKCAqICkgPSAoICogKVxuICBsZXQgKCAvICkgPSAoIC8gKVxuICBsZXQgKCAlICkgPSAoICUgKVxuICBsZXQgKCB+LSApID0gKCB+LSApXG4gIGxldCAoICoqICkgPSAoICoqIClcblxuICBpbmNsdWRlIChGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmUgOiBDb21wYXJpc29ucy5JbmZpeCB3aXRoIHR5cGUgdCA6PSB0KVxuXG4gIGxldCBhYnMgPSBhYnNcbiAgbGV0IG5lZyA9IG5lZ1xuICBsZXQgemVybyA9IHplcm9cbiAgbGV0IG9mX2ludCA9IG9mX2ludFxuICBsZXQgb2ZfZmxvYXQgeCA9IHhcbmVuZFxuXG5tb2R1bGUgT19kb3QgPSBzdHJ1Y3RcbiAgbGV0ICggKi4gKSA9ICggKiApXG4gIGxldCAoICsuICkgPSAoICsgKVxuICBsZXQgKCAtLiApID0gKCAtIClcbiAgbGV0ICggLy4gKSA9ICggLyApXG4gIGxldCAoICUuICkgPSAoICUgKVxuICBsZXQgKCB+LS4gKSA9ICggfi0gKVxuICBsZXQgKCAqKi4gKSA9ICggKiogKVxuZW5kXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGxldCBib3ggPSBib3hcbiAgbGV0IGNsYW1wX3VuY2hlY2tlZCA9IGNsYW1wX3VuY2hlY2tlZFxuICBsZXQgbG93ZXJfYm91bmRfZm9yX2ludCA9IGxvd2VyX2JvdW5kX2Zvcl9pbnRcbiAgbGV0IHVwcGVyX2JvdW5kX2Zvcl9pbnQgPSB1cHBlcl9ib3VuZF9mb3JfaW50XG4gIGxldCBzcGVjaWFsaXplZF9oYXNoID0gaGFzaF9mbG9hdFxuICBsZXQgb25lX3VscF9sZXNzX3RoYW5faGFsZiA9IG9uZV91bHBfbGVzc190aGFuX2hhbGZcbiAgbGV0IGludDYzX3JvdW5kX25lYXJlc3RfcG9ydGFibGVfYWxsb2NfZXhuID0gaW50NjNfcm91bmRfbmVhcmVzdF9wb3J0YWJsZV9hbGxvY19leG5cbiAgbGV0IGludDYzX3JvdW5kX25lYXJlc3RfYXJjaDY0X25vYWxsb2NfZXhuID0gaW50NjNfcm91bmRfbmVhcmVzdF9hcmNoNjRfbm9hbGxvY19leG5cbiAgbGV0IGlyb3VuZF9uZWFyZXN0X2V4bl82NCA9IGlyb3VuZF9uZWFyZXN0X2V4bl82NFxuZW5kXG5cbigqIEluY2x1ZGUgdHlwZS1zcGVjaWZpYyBbUmVwbGFjZV9wb2x5bW9ycGhpY19jb21wYXJlXSBhdCB0aGUgZW5kLCBhZnRlclxuICAgaW5jbHVkaW5nIGZ1bmN0b3IgYXBwbGljYXRpb24gdGhhdCBjb3VsZCBzaGFkb3cgaXRzIGRlZmluaXRpb25zLiBUaGlzIGlzXG4gICBoZXJlIHNvIHRoYXQgZWZmaWNpZW50IHZlcnNpb25zIG9mIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9ucyBhcmUgZXhwb3J0ZWQgYnlcbiAgIHRoaXMgbW9kdWxlLiAqKVxuaW5jbHVkZSBGbG9hdF9yZXBsYWNlX3BvbHltb3JwaGljX2NvbXBhcmVcblxuKCogVGhlc2UgZnVuY3Rpb25zIHNwZWNpZmljYWxseSByZXBsYWNlIGRlZmF1bHRzIGluIHJlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZS5cblxuICAgVGhlIGRlc2lyZWQgYmVoYXZpb3IgaGVyZSBpcyB0byBwcm9wYWdhdGUgYSBuYW4gaWYgZWl0aGVyIGFyZ3VtZW50IGlzIG5hbi4gQmVjYXVzZSB0aGVcbiAgIGZpcnN0IGNvbXBhcmlzb24gd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlIGlmIGVpdGhlciBhcmd1bWVudCBpcyBuYW4sIGl0IHN1ZmZpY2VzIHRvXG4gICBjaGVjayBpZiB4IGlzIG5hbi4gVGhlbiwgd2hlbiB4IGlzIG5hbiBvciBib3RoIHggYW5kIHkgYXJlIG5hbiwgd2UgcmV0dXJuIHggPSBuYW47IGFuZFxuICAgd2hlbiB5IGlzIG5hbiBidXQgbm90IHgsIHdlIHJldHVybiB5ID0gbmFuLlxuXG4gICBUaGVyZSBhcmUgdmFyaW91cyB3YXlzIHRvIGltcGxlbWVudCB0aGVzZSBmdW5jdGlvbnMuICBUaGUgYmVuY2htYXJrIGJlbG93IHNob3dzIGEgZmV3XG4gICBkaWZmZXJlbnQgdmVyc2lvbnMuICBUaGlzIGJlbmNobWFyayB3YXMgcnVuIG92ZXIgYW4gYXJyYXkgb2YgcmFuZG9tIGZsb2F0cyAobm9uZSBvZlxuICAgd2hpY2ggYXJlIG5hbikuXG5cbiAgIOKUjOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUrOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUkFxuICAg4pSCIE5hbWUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4pSCIFRpbWUvUnVuIOKUglxuICAg4pSc4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSkXG4gICDilIIgaWYgaXNfbmFuIHggdGhlbiB4IGVsc2UgaWYgeCA8IHkgdGhlbiB4IGVsc2UgeSDilIIgICAyLjQydXMg4pSCXG4gICDilIIgaWYgaXNfbmFuIHggfHwgeCA8IHkgdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAyLjAydXMg4pSCXG4gICDilIIgaWYgeCA8IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeSAgICAgICAgICAgICDilIIgICAxLjg4dXMg4pSCXG4gICDilJTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLTilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilJhcblxuICAgVGhlIGJlbmNobWFyayBiZWxvdyB3YXMgcnVuIHdoZW4geCA+IHkgaXMgYWx3YXlzIHRydWUgKGFnYWluLCBubyBuYW4gdmFsdWVzKS5cblxuICAg4pSM4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSs4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSQXG4gICDilIIgTmFtZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDilIIgVGltZS9SdW4g4pSCXG4gICDilJzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilKRcbiAgIOKUgiBpZiBpc19uYW4geCB0aGVuIHggZWxzZSBpZiB4IDwgeSB0aGVuIHggZWxzZSB5IOKUgiAgIDIuODN1cyDilIJcbiAgIOKUgiBpZiBpc19uYW4geCB8fCB4IDwgeSB0aGVuIHggZWxzZSB5ICAgICAgICAgICAgIOKUgiAgIDEuOTd1cyDilIJcbiAgIOKUgiBpZiB4IDwgeSB8fCBpc19uYW4geCB0aGVuIHggZWxzZSB5ICAgICAgICAgICAgIOKUgiAgIDEuNTZ1cyDilIJcbiAgIOKUlOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUtOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUmFxuKilcbmxldCBtaW4gKHggOiB0KSB5ID0gaWYgeCA8IHkgfHwgaXNfbmFuIHggdGhlbiB4IGVsc2UgeVxubGV0IG1heCAoeCA6IHQpIHkgPSBpZiB4ID4geSB8fCBpc19uYW4geCB0aGVuIHggZWxzZSB5XG4iLCJvcGVuISBJbXBvcnRcbmluY2x1ZGUgQnVmZmVyX2ludGZcbmluY2x1ZGUgQ2FtbC5CdWZmZXJcblxubGV0IGNvbnRlbnRzX2J5dGVzID0gdG9fYnl0ZXNcbmxldCBhZGRfc3Vic3RyaW5nIHQgcyB+cG9zIH5sZW4gPSBhZGRfc3Vic3RyaW5nIHQgcyBwb3MgbGVuXG5sZXQgYWRkX3N1YmJ5dGVzIHQgcyB+cG9zIH5sZW4gPSBhZGRfc3ViYnl0ZXMgdCBzIHBvcyBsZW5cbmxldCBzZXhwX29mX3QgdCA9IHNleHBfb2Zfc3RyaW5nIChjb250ZW50cyB0KVxuXG5tb2R1bGUgVG9fYnl0ZXMgPVxuICBCbGl0Lk1ha2VfZGlzdGluY3RcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIG5vbnJlYyB0ID0gdFxuXG4gICAgICBsZXQgbGVuZ3RoID0gbGVuZ3RoXG4gICAgZW5kKVxuICAgIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IEJ5dGVzLnRcblxuICAgICAgbGV0IGNyZWF0ZSB+bGVuID0gQnl0ZXMuY3JlYXRlIGxlblxuICAgICAgbGV0IGxlbmd0aCA9IEJ5dGVzLmxlbmd0aFxuXG4gICAgICBsZXQgdW5zYWZlX2JsaXQgfnNyYyB+c3JjX3BvcyB+ZHN0IH5kc3RfcG9zIH5sZW4gPVxuICAgICAgICBDYW1sLkJ1ZmZlci5ibGl0IHNyYyBzcmNfcG9zIGRzdCBkc3RfcG9zIGxlblxuICAgICAgOztcbiAgICBlbmQpXG5cbmluY2x1ZGUgVG9fYnl0ZXNcbm1vZHVsZSBUb19zdHJpbmcgPSBCbGl0Lk1ha2VfdG9fc3RyaW5nIChDYW1sLkJ1ZmZlcikgKFRvX2J5dGVzKVxuIiwib3BlbiEgSW1wb3J0XG5tb2R1bGUgU3lzID0gU3lzMFxuXG50eXBlIHQgPSBDYW1sLlByaW50ZXhjLnJhd19iYWNrdHJhY2VcblxubGV0IGVsaWRlID0gcmVmIGZhbHNlXG5sZXQgZWxpZGVkX21lc3NhZ2UgPSBcIjxiYWNrdHJhY2UgZWxpZGVkIGluIHRlc3Q+XCJcblxubGV0IGdldCA/KGF0X21vc3RfbnVtX2ZyYW1lcyA9IEludC5tYXhfdmFsdWUpICgpID1cbiAgQ2FtbC5QcmludGV4Yy5nZXRfY2FsbHN0YWNrIGF0X21vc3RfbnVtX2ZyYW1lc1xuOztcblxubGV0IHRvX3N0cmluZyB0ID1cbiAgaWYgIWVsaWRlIHRoZW4gZWxpZGVkX21lc3NhZ2UgZWxzZSBDYW1sLlByaW50ZXhjLnJhd19iYWNrdHJhY2VfdG9fc3RyaW5nIHRcbjs7XG5cbmxldCB0b19zdHJpbmdfbGlzdCB0ID0gU3RyaW5nLnNwbGl0X2xpbmVzICh0b19zdHJpbmcgdClcbmxldCBzZXhwX29mX3QgdCA9IFNleHAuTGlzdCAoTGlzdC5tYXAgKHRvX3N0cmluZ19saXN0IHQpIH5mOihmdW4geCAtPiBTZXhwLkF0b20geCkpXG5cbm1vZHVsZSBFeG4gPSBzdHJ1Y3RcbiAgbGV0IHNldF9yZWNvcmRpbmcgPSBDYW1sLlByaW50ZXhjLnJlY29yZF9iYWNrdHJhY2VcbiAgbGV0IGFtX3JlY29yZGluZyA9IENhbWwuUHJpbnRleGMuYmFja3RyYWNlX3N0YXR1c1xuICBsZXQgbW9zdF9yZWNlbnQgKCkgPSBDYW1sLlByaW50ZXhjLmdldF9yYXdfYmFja3RyYWNlICgpXG5cbiAgbGV0IG1vc3RfcmVjZW50X2Zvcl9leG4gZXhuID1cbiAgICBpZiBFeG4uaXNfcGh5c19lcXVhbF9tb3N0X3JlY2VudCBleG4gdGhlbiBTb21lIChtb3N0X3JlY2VudCAoKSkgZWxzZSBOb25lXG4gIDs7XG5cbiAgKCogV2UgdHVybiBvbiBiYWNrdHJhY2VzIGJ5IGRlZmF1bHQgaWYgT0NBTUxSVU5QQVJBTSBkb2Vzbid0IGV4cGxpY2l0bHkgbWVudGlvbiB0aGVtLiAqKVxuICBsZXQgbWF5YmVfc2V0X3JlY29yZGluZyAoKSA9XG4gICAgbGV0IG9jYW1scnVucGFyYW1fbWVudGlvbnNfYmFja3RyYWNlcyA9XG4gICAgICBtYXRjaCBTeXMuZ2V0ZW52IFwiT0NBTUxSVU5QQVJBTVwiIHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmYWxzZVxuICAgICAgfCBTb21lIHggLT4gTGlzdC5leGlzdHMgKFN0cmluZy5zcGxpdCB4IH5vbjonLCcpIH5mOihTdHJpbmcuaXNfcHJlZml4IH5wcmVmaXg6XCJiXCIpXG4gICAgaW5cbiAgICBpZiBub3Qgb2NhbWxydW5wYXJhbV9tZW50aW9uc19iYWNrdHJhY2VzIHRoZW4gc2V0X3JlY29yZGluZyB0cnVlXG4gIDs7XG5cbiAgKCogdGhlIGNhbGxlciBzZXQgc29tZXRoaW5nLCB0aGV5IGFyZSByZXNwb25zaWJsZSAqKVxuXG4gIGxldCB3aXRoX3JlY29yZGluZyBiIH5mID1cbiAgICBsZXQgc2F2ZWQgPSBhbV9yZWNvcmRpbmcgKCkgaW5cbiAgICBzZXRfcmVjb3JkaW5nIGI7XG4gICAgRXhuLnByb3RlY3QgfmYgfmZpbmFsbHk6KGZ1biAoKSAtPiBzZXRfcmVjb3JkaW5nIHNhdmVkKVxuICA7O1xuZW5kXG5cbmxldCBpbml0aWFsaXplX21vZHVsZSAoKSA9IEV4bi5tYXliZV9zZXRfcmVjb3JkaW5nICgpXG4iLCIoKiogVGhpcyBtb2R1bGUgaXMgdGhlIHRvcGxldmVsIG9mIHRoZSBCYXNlIGxpYnJhcnk7IGl0J3Mgd2hhdCB5b3UgZ2V0IHdoZW4geW91IHdyaXRlXG4gICAgW29wZW4gQmFzZV0uXG5cbiAgICBUaGUgZ29hbCBvZiBCYXNlIGlzIGJvdGggdG8gYmUgYSBtb3JlIGNvbXBsZXRlIHN0YW5kYXJkIGxpYnJhcnksIHdpdGggcmljaGVyIEFQSXMsXG4gICAgYW5kIHRvIGJlIG1vcmUgY29uc2lzdGVudCBpbiBpdHMgZGVzaWduLiBGb3IgaW5zdGFuY2UsIGluIHRoZSBzdGFuZGFyZCBsaWJyYXJ5XG4gICAgc29tZSB0aGluZ3MgaGF2ZSBtb2R1bGVzIGFuZCBvdGhlcnMgZG9uJ3Q7IGluIEJhc2UsIGV2ZXJ5dGhpbmcgaXMgYSBtb2R1bGUuXG5cbiAgICBCYXNlIGV4dGVuZHMgc29tZSBtb2R1bGVzIGFuZCBkYXRhIHN0cnVjdHVyZXMgZnJvbSB0aGUgc3RhbmRhcmQgbGlicmFyeSwgbGlrZSBbQXJyYXldLFxuICAgIFtCdWZmZXJdLCBbQnl0ZXNdLCBbQ2hhcl0sIFtIYXNodGJsXSwgW0ludDMyXSwgW0ludDY0XSwgW0xhenldLCBbTGlzdF0sIFtNYXBdLFxuICAgIFtOYXRpdmVpbnRdLCBbUHJpbnRmXSwgW1JhbmRvbV0sIFtTZXRdLCBbU3RyaW5nXSwgW1N5c10sIGFuZCBbVWNoYXJdLiBPbmUga2V5XG4gICAgZGlmZmVyZW5jZSBpcyB0aGF0IEJhc2UgZG9lc24ndCB1c2UgZXhjZXB0aW9ucyBhcyBtdWNoIGFzIHRoZSBzdGFuZGFyZCBsaWJyYXJ5IGFuZFxuICAgIGluc3RlYWQgbWFrZXMgaGVhdnkgdXNlIG9mIHRoZSBbUmVzdWx0XSB0eXBlLCBhcyBpbjpcblxuICAgIHtbIHR5cGUgKCdhLCdiKSByZXN1bHQgPSBPayBvZiAnYSB8IEVycm9yIG9mICdiIF19XG5cbiAgICBCYXNlIGFsc28gYWRkcyBlbnRpcmVseSBuZXcgbW9kdWxlcywgbW9zdCBub3RhYmx5OlxuXG4gICAgLSBbQ29tcGFyYWJsZV0sIFtDb21wYXJhdG9yXSwgYW5kIFtDb21wYXJpc29uc10gaW4gbGlldSBvZiBwb2x5bW9ycGhpYyBjb21wYXJlLlxuICAgIC0gW0NvbnRhaW5lcl0sIHdoaWNoIHByb3ZpZGVzIGEgY29uc2lzdGVudCBpbnRlcmZhY2UgYWNyb3NzIGNvbnRhaW5lci1saWtlIGRhdGFcbiAgICAgIHN0cnVjdHVyZXMgKGFycmF5cywgbGlzdHMsIHN0cmluZ3MpLlxuICAgIC0gW1Jlc3VsdF0sIFtFcnJvcl0sIGFuZCBbT3JfZXJyb3JdLCBzdXBwb3J0aW5nIHRoZSBvci1lcnJvciBwYXR0ZXJuLlxuKilcblxuKCpfIFdlIGhpZGUgdGhpcyBmcm9tIHRoZSB3ZWIgZG9jcyBiZWNhdXNlIHRoZSBsaW5lIHdyYXBwaW5nIGlzIGJhZCwgbWFraW5nIGl0XG4gIHByZXR0eSBtdWNoIGluc2NydXRhYmxlLiAqKVxuKCoqLyoqKVxuXG4oKiBUaGUgaW50ZW50IGlzIHRvIHNoYWRvdyBhbGwgb2YgSU5SSUEncyBzdGFuZGFyZCBsaWJyYXJ5LiAgTW9kdWxlcyBiZWxvdyB3b3VsZCBjYXVzZVxuICAgY29tcGlsYXRpb24gZXJyb3JzIHdpdGhvdXQgYmVpbmcgcmVtb3ZlZCBmcm9tIFtTaGFkb3dfc3RkbGliXSBiZWZvcmUgaW5jbHVzaW9uLiAqKVxuXG5pbmNsdWRlIChcbiAgU2hhZG93X3N0ZGxpYiA6XG4gICAgbW9kdWxlIHR5cGUgb2Ygc3RydWN0XG4gICAgaW5jbHVkZSBTaGFkb3dfc3RkbGliXG4gIGVuZFxuICAoKiBNb2R1bGVzIGRlZmluZWQgaW4gQmFzZSAqKVxuICB3aXRoIG1vZHVsZSBBcnJheSA6PSBTaGFkb3dfc3RkbGliLkFycmF5XG4gIHdpdGggbW9kdWxlIEF0b21pYyA6PSBTaGFkb3dfc3RkbGliLkF0b21pY1xuICB3aXRoIG1vZHVsZSBCb29sIDo9IFNoYWRvd19zdGRsaWIuQm9vbFxuICB3aXRoIG1vZHVsZSBCdWZmZXIgOj0gU2hhZG93X3N0ZGxpYi5CdWZmZXJcbiAgd2l0aCBtb2R1bGUgQnl0ZXMgOj0gU2hhZG93X3N0ZGxpYi5CeXRlc1xuICB3aXRoIG1vZHVsZSBDaGFyIDo9IFNoYWRvd19zdGRsaWIuQ2hhclxuICB3aXRoIG1vZHVsZSBFaXRoZXIgOj0gU2hhZG93X3N0ZGxpYi5FaXRoZXJcbiAgd2l0aCBtb2R1bGUgRmxvYXQgOj0gU2hhZG93X3N0ZGxpYi5GbG9hdFxuICB3aXRoIG1vZHVsZSBIYXNodGJsIDo9IFNoYWRvd19zdGRsaWIuSGFzaHRibFxuICB3aXRoIG1vZHVsZSBJbl9jaGFubmVsIDo9IFNoYWRvd19zdGRsaWIuSW5fY2hhbm5lbFxuICB3aXRoIG1vZHVsZSBJbnQgOj0gU2hhZG93X3N0ZGxpYi5JbnRcbiAgd2l0aCBtb2R1bGUgSW50MzIgOj0gU2hhZG93X3N0ZGxpYi5JbnQzMlxuICB3aXRoIG1vZHVsZSBJbnQ2NCA6PSBTaGFkb3dfc3RkbGliLkludDY0XG4gIHdpdGggbW9kdWxlIExhenkgOj0gU2hhZG93X3N0ZGxpYi5MYXp5XG4gIHdpdGggbW9kdWxlIExpc3QgOj0gU2hhZG93X3N0ZGxpYi5MaXN0XG4gIHdpdGggbW9kdWxlIE1hcCA6PSBTaGFkb3dfc3RkbGliLk1hcFxuICB3aXRoIG1vZHVsZSBOYXRpdmVpbnQgOj0gU2hhZG93X3N0ZGxpYi5OYXRpdmVpbnRcbiAgd2l0aCBtb2R1bGUgT3B0aW9uIDo9IFNoYWRvd19zdGRsaWIuT3B0aW9uXG4gIHdpdGggbW9kdWxlIE91dF9jaGFubmVsIDo9IFNoYWRvd19zdGRsaWIuT3V0X2NoYW5uZWxcbiAgd2l0aCBtb2R1bGUgUHJpbnRmIDo9IFNoYWRvd19zdGRsaWIuUHJpbnRmXG4gIHdpdGggbW9kdWxlIFF1ZXVlIDo9IFNoYWRvd19zdGRsaWIuUXVldWVcbiAgd2l0aCBtb2R1bGUgUmFuZG9tIDo9IFNoYWRvd19zdGRsaWIuUmFuZG9tXG4gIHdpdGggbW9kdWxlIFJlc3VsdCA6PSBTaGFkb3dfc3RkbGliLlJlc3VsdFxuICB3aXRoIG1vZHVsZSBTZXQgOj0gU2hhZG93X3N0ZGxpYi5TZXRcbiAgd2l0aCBtb2R1bGUgU3RhY2sgOj0gU2hhZG93X3N0ZGxpYi5TdGFja1xuICB3aXRoIG1vZHVsZSBTdHJpbmcgOj0gU2hhZG93X3N0ZGxpYi5TdHJpbmdcbiAgd2l0aCBtb2R1bGUgU3lzIDo9IFNoYWRvd19zdGRsaWIuU3lzXG4gIHdpdGggbW9kdWxlIFVjaGFyIDo9IFNoYWRvd19zdGRsaWIuVWNoYXJcbiAgd2l0aCBtb2R1bGUgVW5pdCA6PSBTaGFkb3dfc3RkbGliLlVuaXRcbiAgKCogU3VwcG9ydCBmb3IgZ2VuZXJhdGVkIGxleGVycyAqKVxuICB3aXRoIG1vZHVsZSBMZXhpbmcgOj0gU2hhZG93X3N0ZGxpYi5MZXhpbmdcbiAgd2l0aCB0eXBlICgnYSwgJ2IsICdjKSBmb3JtYXQgOj0gKCdhLCAnYiwgJ2MpIGZvcm1hdFxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0IDo9ICgnYSwgJ2IsICdjLCAnZCkgZm9ybWF0NFxuICB3aXRoIHR5cGUgKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDYgOj0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcbiAgd2l0aCB0eXBlICdhIHJlZiA6PSAnYSByZWYpIFtAb2NhbWwud2FybmluZyBcIi0zXCJdXG5cbigqKi8qKilcblxub3BlbiEgSW1wb3J0XG5tb2R1bGUgQXBwbGljYXRpdmUgPSBBcHBsaWNhdGl2ZVxubW9kdWxlIEFycmF5ID0gQXJyYXlcbm1vZHVsZSBBdmx0cmVlID0gQXZsdHJlZVxubW9kdWxlIEJhY2t0cmFjZSA9IEJhY2t0cmFjZVxubW9kdWxlIEJpbmFyeV9zZWFyY2ggPSBCaW5hcnlfc2VhcmNoXG5tb2R1bGUgQmluYXJ5X3NlYXJjaGFibGUgPSBCaW5hcnlfc2VhcmNoYWJsZVxubW9kdWxlIEJsaXQgPSBCbGl0XG5tb2R1bGUgQm9vbCA9IEJvb2xcbm1vZHVsZSBCdWZmZXIgPSBCdWZmZXJcbm1vZHVsZSBCeXRlcyA9IEJ5dGVzXG5tb2R1bGUgQ2hhciA9IENoYXJcbm1vZHVsZSBDb21wYXJhYmxlID0gQ29tcGFyYWJsZVxubW9kdWxlIENvbXBhcmF0b3IgPSBDb21wYXJhdG9yXG5tb2R1bGUgQ29tcGFyaXNvbnMgPSBDb21wYXJpc29uc1xubW9kdWxlIENvbnRhaW5lciA9IENvbnRhaW5lclxubW9kdWxlIEVpdGhlciA9IEVpdGhlclxubW9kdWxlIEVxdWFsID0gRXF1YWxcbm1vZHVsZSBFcnJvciA9IEVycm9yXG5tb2R1bGUgRXhuID0gRXhuXG5tb2R1bGUgRmllbGQgPSBGaWVsZFxubW9kdWxlIEZsb2F0ID0gRmxvYXRcbm1vZHVsZSBGbG9hdGFibGUgPSBGbG9hdGFibGVcbm1vZHVsZSBGbiA9IEZuXG5tb2R1bGUgRm9ybWF0dGVyID0gRm9ybWF0dGVyXG5tb2R1bGUgSGFzaCA9IEhhc2hcbm1vZHVsZSBIYXNoX3NldCA9IEhhc2hfc2V0XG5tb2R1bGUgSGFzaGFibGUgPSBIYXNoYWJsZVxubW9kdWxlIEhhc2hlciA9IEhhc2hlclxubW9kdWxlIEhhc2h0YmwgPSBIYXNodGJsXG5tb2R1bGUgSWRlbnRpZmlhYmxlID0gSWRlbnRpZmlhYmxlXG5tb2R1bGUgSW5kZXhlZF9jb250YWluZXIgPSBJbmRleGVkX2NvbnRhaW5lclxubW9kdWxlIEluZm8gPSBJbmZvXG5tb2R1bGUgSW50ID0gSW50XG5tb2R1bGUgSW50X2NvbnZlcnNpb25zID0gSW50X2NvbnZlcnNpb25zXG5tb2R1bGUgSW50MzIgPSBJbnQzMlxubW9kdWxlIEludDYzID0gSW50NjNcbm1vZHVsZSBJbnQ2NCA9IEludDY0XG5tb2R1bGUgSW50YWJsZSA9IEludGFibGVcbm1vZHVsZSBJbnRfbWF0aCA9IEludF9tYXRoXG5tb2R1bGUgSW52YXJpYW50ID0gSW52YXJpYW50XG5tb2R1bGUgTGF6eSA9IExhenlcbm1vZHVsZSBMaXN0ID0gTGlzdFxubW9kdWxlIE1hcCA9IE1hcFxubW9kdWxlIE1heWJlX2JvdW5kID0gTWF5YmVfYm91bmRcbm1vZHVsZSBNb25hZCA9IE1vbmFkXG5tb2R1bGUgTmF0aXZlaW50ID0gTmF0aXZlaW50XG5tb2R1bGUgTm90aGluZyA9IE5vdGhpbmdcbm1vZHVsZSBPcHRpb24gPSBPcHRpb25cbm1vZHVsZSBPcHRpb25fYXJyYXkgPSBPcHRpb25fYXJyYXlcbm1vZHVsZSBPcl9lcnJvciA9IE9yX2Vycm9yXG5tb2R1bGUgT3JkZXJlZF9jb2xsZWN0aW9uX2NvbW1vbiA9IE9yZGVyZWRfY29sbGVjdGlvbl9jb21tb25cbm1vZHVsZSBPcmRlcmluZyA9IE9yZGVyaW5nXG5tb2R1bGUgUG9seSA9IFBvbHlcbm1vZHVsZSBQb2x5bW9ycGhpY19jb21wYXJlID0gUG9seSBbQEBkZXByZWNhdGVkIFwiW3NpbmNlIDIwMTgtMTFdIHVzZSBbUG9seV0gaW5zdGVhZFwiXVxuXG5tb2R1bGUgUG9wY291bnQgPSBQb3Bjb3VudFxuW0BAZGVwcmVjYXRlZCBcIltzaW5jZSAyMDE4LTEwXSB1c2UgW3BvcGNvdW50XSBmdW5jdGlvbnMgaW4gdGhlIGluZGl2aWR1YWwgaW50IG1vZHVsZXNcIl1cblxubW9kdWxlIFByZXR0eV9wcmludGVyID0gUHJldHR5X3ByaW50ZXJcbm1vZHVsZSBQcmludGYgPSBQcmludGZcbm1vZHVsZSBMaW5rZWRfcXVldWUgPSBMaW5rZWRfcXVldWVcbm1vZHVsZSBRdWV1ZSA9IFF1ZXVlXG5tb2R1bGUgUmFuZG9tID0gUmFuZG9tXG5tb2R1bGUgUmVmID0gUmVmXG5tb2R1bGUgUmVzdWx0ID0gUmVzdWx0XG5tb2R1bGUgU2VxdWVuY2UgPSBTZXF1ZW5jZVxubW9kdWxlIFNldCA9IFNldFxubW9kdWxlIFNleHBhYmxlID0gU2V4cGFibGVcbm1vZHVsZSBTaWduID0gU2lnblxubW9kdWxlIFNpZ25fb3JfbmFuID0gU2lnbl9vcl9uYW5cbm1vZHVsZSBTb3VyY2VfY29kZV9wb3NpdGlvbiA9IFNvdXJjZV9jb2RlX3Bvc2l0aW9uXG5tb2R1bGUgU3RhY2sgPSBTdGFja1xubW9kdWxlIFN0YWdlZCA9IFN0YWdlZFxubW9kdWxlIFN0cmluZyA9IFN0cmluZ1xubW9kdWxlIFN0cmluZ2FibGUgPSBTdHJpbmdhYmxlXG5tb2R1bGUgU3lzID0gU3lzXG5tb2R1bGUgVCA9IFRcbm1vZHVsZSBUeXBlX2VxdWFsID0gVHlwZV9lcXVhbFxubW9kdWxlIFVuaWZvcm1fYXJyYXkgPSBVbmlmb3JtX2FycmF5XG5tb2R1bGUgVW5pdCA9IFVuaXRcbm1vZHVsZSBVY2hhciA9IFVjaGFyXG5tb2R1bGUgVmFyaWFudCA9IFZhcmlhbnRcbm1vZHVsZSBXaXRoX3JldHVybiA9IFdpdGhfcmV0dXJuXG5tb2R1bGUgV29yZF9zaXplID0gV29yZF9zaXplXG5cbigqIEF2b2lkIGEgbGV2ZWwgb2YgaW5kaXJlY3Rpb24gZm9yIHVzZXMgb2YgdGhlIHNpZ25hdHVyZXMgZGVmaW5lZCBpbiBbVF0uICopXG5pbmNsdWRlIFRcblxuKCogVGhpcyBpcyBhIGhhY2sgc28gdGhhdCBvZG9jIGNyZWF0ZXMgYmV0dGVyIGRvY3VtZW50YXRpb24uICopXG5tb2R1bGUgU2V4cCA9IHN0cnVjdFxuICBpbmNsdWRlIFNleHBfd2l0aF9jb21wYXJhYmxlICgqKiBAaW5saW5lICopXG5lbmRcblxuKCoqLyoqKVxuXG5tb2R1bGUgRXhwb3J0ZWRfZm9yX3NwZWNpZmljX3VzZXMgPSBzdHJ1Y3RcbiAgbW9kdWxlIEZpZWxkc2xpYiA9IEZpZWxkc2xpYlxuICBtb2R1bGUgUHB4X2hhc2hfbGliID0gUHB4X2hhc2hfbGliXG4gIG1vZHVsZSBWYXJpYW50c2xpYiA9IFZhcmlhbnRzbGliXG4gIG1vZHVsZSBQcHhfY29tcGFyZV9saWIgPSBQcHhfY29tcGFyZV9saWJcbiAgbW9kdWxlIFBweF9lbnVtZXJhdGVfbGliID0gUHB4X2VudW1lcmF0ZV9saWJcblxuICBsZXQgYW1fdGVzdGluZyA9IGFtX3Rlc3RpbmdcbmVuZFxuXG4oKiovKiopXG5cbm1vZHVsZSBFeHBvcnQgPSBzdHJ1Y3RcbiAgKCogW2Rlcml2aW5nIGhhc2hdIGlzIG1pc3NpbmcgZm9yIFthcnJheV0gYW5kIFtyZWZdIHNpbmNlIHRoZXNlIHR5cGVzIGFyZSBtdXRhYmxlLiAqKVxuICB0eXBlICdhIGFycmF5ID0gJ2EgQXJyYXkudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9hcnJheSA6ICdhLiAoJ2EgLT4gJ2EgLT4gaW50KSAtPiAnYSBhcnJheSAtPiAnYSBhcnJheSAtPiBpbnQgPSBBcnJheS5jb21wYXJlXG4gIGxldCBlcXVhbF9hcnJheSA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgYXJyYXkgLT4gJ2EgYXJyYXkgLT4gYm9vbCA9IEFycmF5LmVxdWFsXG5cbiAgbGV0IGFycmF5X29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIGFycmF5ID1cbiAgICBBcnJheS50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9hcnJheSA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSBhcnJheSAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIEFycmF5LnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCAoYXJyYXlfc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIGFycmF5IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KVxuICAgID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBBcnJheS50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGJvb2wgPSBCb29sLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfYm9vbCA9IChCb29sLmNvbXBhcmUgOiBib29sIC0+IGJvb2wgLT4gaW50KVxuICBsZXQgZXF1YWxfYm9vbCA9IChCb29sLmVxdWFsIDogYm9vbCAtPiBib29sIC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfYm9vbCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gYm9vbCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEJvb2wuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfYm9vbCA6IGJvb2wgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEJvb2wuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBib29sX29mX3NleHAgPSAoQm9vbC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gYm9vbClcbiAgbGV0IHNleHBfb2ZfYm9vbCA9IChCb29sLnNleHBfb2ZfdCA6IGJvb2wgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGJvb2xfc2V4cF9ncmFtbWFyIDogYm9vbCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBCb29sLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGNoYXIgPSBDaGFyLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfY2hhciA9IChDaGFyLmNvbXBhcmUgOiBjaGFyIC0+IGNoYXIgLT4gaW50KVxuICBsZXQgZXF1YWxfY2hhciA9IChDaGFyLmVxdWFsIDogY2hhciAtPiBjaGFyIC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfY2hhciA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gY2hhciAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIENoYXIuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfY2hhciA6IGNoYXIgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IENoYXIuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBjaGFyX29mX3NleHAgPSAoQ2hhci50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gY2hhcilcbiAgbGV0IHNleHBfb2ZfY2hhciA9IChDaGFyLnNleHBfb2ZfdCA6IGNoYXIgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGNoYXJfc2V4cF9ncmFtbWFyIDogY2hhciBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBDaGFyLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGV4biA9IEV4bi50IFtAQGRlcml2aW5nX2lubGluZSBzZXhwX29mXVxuXG4gIGxldCBzZXhwX29mX2V4biA9IChFeG4uc2V4cF9vZl90IDogZXhuIC0+IFNleHBsaWIwLlNleHAudClcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgZmxvYXQgPSBGbG9hdC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2Zsb2F0ID0gKEZsb2F0LmNvbXBhcmUgOiBmbG9hdCAtPiBmbG9hdCAtPiBpbnQpXG4gIGxldCBlcXVhbF9mbG9hdCA9IChGbG9hdC5lcXVhbCA6IGZsb2F0IC0+IGZsb2F0IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfZmxvYXQgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGZsb2F0IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgRmxvYXQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfZmxvYXQgOiBmbG9hdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gRmxvYXQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBmbG9hdF9vZl9zZXhwID0gKEZsb2F0LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBmbG9hdClcbiAgbGV0IHNleHBfb2ZfZmxvYXQgPSAoRmxvYXQuc2V4cF9vZl90IDogZmxvYXQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGZsb2F0X3NleHBfZ3JhbW1hciA6IGZsb2F0IFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEZsb2F0LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGludCA9IEludC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2ludCA9IChJbnQuY29tcGFyZSA6IGludCAtPiBpbnQgLT4gaW50KVxuICBsZXQgZXF1YWxfaW50ID0gKEludC5lcXVhbCA6IGludCAtPiBpbnQgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9pbnQgOiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSkgPVxuICAgIEludC5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9pbnQgOiBpbnQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEludC5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IGludF9vZl9zZXhwID0gKEludC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gaW50KVxuICBsZXQgc2V4cF9vZl9pbnQgPSAoSW50LnNleHBfb2ZfdCA6IGludCAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoaW50X3NleHBfZ3JhbW1hciA6IGludCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBJbnQudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgaW50MzIgPSBJbnQzMi50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2ludDMyID0gKEludDMyLmNvbXBhcmUgOiBpbnQzMiAtPiBpbnQzMiAtPiBpbnQpXG4gIGxldCBlcXVhbF9pbnQzMiA9IChJbnQzMi5lcXVhbCA6IGludDMyIC0+IGludDMyIC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfaW50MzIgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IGludDMyIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgSW50MzIuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfaW50MzIgOiBpbnQzMiAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gSW50MzIuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCBpbnQzMl9vZl9zZXhwID0gKEludDMyLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBpbnQzMilcbiAgbGV0IHNleHBfb2ZfaW50MzIgPSAoSW50MzIuc2V4cF9vZl90IDogaW50MzIgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGludDMyX3NleHBfZ3JhbW1hciA6IGludDMyIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEludDMyLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIGludDY0ID0gSW50NjQudCBbQEBkZXJpdmluZ19pbmxpbmUgY29tcGFyZSwgZXF1YWwsIGhhc2gsIHNleHAsIHNleHBfZ3JhbW1hcl1cblxuICBsZXQgY29tcGFyZV9pbnQ2NCA9IChJbnQ2NC5jb21wYXJlIDogaW50NjQgLT4gaW50NjQgLT4gaW50KVxuICBsZXQgZXF1YWxfaW50NjQgPSAoSW50NjQuZXF1YWwgOiBpbnQ2NCAtPiBpbnQ2NCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX2ludDY0IDpcbiAgICAgICAgIFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSAtPiBpbnQ2NCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIEludDY0Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX2ludDY0IDogaW50NjQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IEludDY0Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgaW50NjRfb2Zfc2V4cCA9IChJbnQ2NC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gaW50NjQpXG4gIGxldCBzZXhwX29mX2ludDY0ID0gKEludDY0LnNleHBfb2ZfdCA6IGludDY0IC0+IFNleHBsaWIwLlNleHAudClcbiAgbGV0IChpbnQ2NF9zZXhwX2dyYW1tYXIgOiBpbnQ2NCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBJbnQ2NC50X3NleHBfZ3JhbW1hclxuXG4gIFtAQEBlbmRdXG5cbiAgdHlwZSAnYSBsaXN0ID0gJ2EgTGlzdC50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2xpc3QgOiAnYS4gKCdhIC0+ICdhIC0+IGludCkgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0IC0+IGludCA9IExpc3QuY29tcGFyZVxuICBsZXQgZXF1YWxfbGlzdCA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgbGlzdCAtPiAnYSBsaXN0IC0+IGJvb2wgPSBMaXN0LmVxdWFsXG5cbiAgbGV0IGhhc2hfZm9sZF9saXN0IDpcbiAgICAnYS5cbiAgICAoUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+ICdhIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGVcbiAgICAtPiAnYSBsaXN0XG4gICAgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlXG4gICAgPVxuICAgIExpc3QuaGFzaF9mb2xkX3RcbiAgOztcblxuICBsZXQgbGlzdF9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSBsaXN0ID1cbiAgICBMaXN0LnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX2xpc3QgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgbGlzdCAtPiBTZXhwbGliMC5TZXhwLnQgPVxuICAgIExpc3Quc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IChsaXN0X3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIGxpc3QgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBmdW4gXydhX3NleHBfZ3JhbW1hciAtPiBMaXN0LnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgbmF0aXZlaW50ID0gTmF0aXZlaW50LnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfbmF0aXZlaW50ID0gKE5hdGl2ZWludC5jb21wYXJlIDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBpbnQpXG4gIGxldCBlcXVhbF9uYXRpdmVpbnQgPSAoTmF0aXZlaW50LmVxdWFsIDogbmF0aXZlaW50IC0+IG5hdGl2ZWludCAtPiBib29sKVxuXG4gIGxldCAoaGFzaF9mb2xkX25hdGl2ZWludCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gbmF0aXZlaW50IC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZSlcbiAgICA9XG4gICAgTmF0aXZlaW50Lmhhc2hfZm9sZF90XG5cbiAgYW5kIChoYXNoX25hdGl2ZWludCA6IG5hdGl2ZWludCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guaGFzaF92YWx1ZSkgPVxuICAgIGxldCBmdW5jID0gTmF0aXZlaW50Lmhhc2ggaW5cbiAgICBmdW4geCAtPiBmdW5jIHhcbiAgOztcblxuICBsZXQgbmF0aXZlaW50X29mX3NleHAgPSAoTmF0aXZlaW50LnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBuYXRpdmVpbnQpXG4gIGxldCBzZXhwX29mX25hdGl2ZWludCA9IChOYXRpdmVpbnQuc2V4cF9vZl90IDogbmF0aXZlaW50IC0+IFNleHBsaWIwLlNleHAudClcblxuICBsZXQgKG5hdGl2ZWludF9zZXhwX2dyYW1tYXIgOiBuYXRpdmVpbnQgU2V4cGxpYjAuU2V4cF9ncmFtbWFyLnQpID1cbiAgICBOYXRpdmVpbnQudF9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgJ2Egb3B0aW9uID0gJ2EgT3B0aW9uLnRcbiAgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfb3B0aW9uIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIG9wdGlvbiAtPiAnYSBvcHRpb24gLT4gaW50ID1cbiAgICBPcHRpb24uY29tcGFyZVxuICA7O1xuXG4gIGxldCBlcXVhbF9vcHRpb24gOiAnYS4gKCdhIC0+ICdhIC0+IGJvb2wpIC0+ICdhIG9wdGlvbiAtPiAnYSBvcHRpb24gLT4gYm9vbCA9XG4gICAgT3B0aW9uLmVxdWFsXG4gIDs7XG5cbiAgbGV0IGhhc2hfZm9sZF9vcHRpb24gOlxuICAgICdhLlxuICAgIChQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gJ2EgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlKVxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgIC0+ICdhIG9wdGlvblxuICAgIC0+IFBweF9oYXNoX2xpYi5TdGQuSGFzaC5zdGF0ZVxuICAgID1cbiAgICBPcHRpb24uaGFzaF9mb2xkX3RcbiAgOztcblxuICBsZXQgb3B0aW9uX29mX3NleHAgOiAnYS4gKFNleHBsaWIwLlNleHAudCAtPiAnYSkgLT4gU2V4cGxpYjAuU2V4cC50IC0+ICdhIG9wdGlvbiA9XG4gICAgT3B0aW9uLnRfb2Zfc2V4cFxuICA7O1xuXG4gIGxldCBzZXhwX29mX29wdGlvbiA6ICdhLiAoJ2EgLT4gU2V4cGxpYjAuU2V4cC50KSAtPiAnYSBvcHRpb24gLT4gU2V4cGxpYjAuU2V4cC50ID1cbiAgICBPcHRpb24uc2V4cF9vZl90XG4gIDs7XG5cbiAgbGV0IChvcHRpb25fc2V4cF9ncmFtbWFyIDpcbiAgICAgICAgICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIG9wdGlvbiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudClcbiAgICA9XG4gICAgZnVuIF8nYV9zZXhwX2dyYW1tYXIgLT4gT3B0aW9uLnRfc2V4cF9ncmFtbWFyIF8nYV9zZXhwX2dyYW1tYXJcbiAgOztcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgJ2EgcmVmID0gJ2EgUmVmLnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfcmVmIDogJ2EuICgnYSAtPiAnYSAtPiBpbnQpIC0+ICdhIHJlZiAtPiAnYSByZWYgLT4gaW50ID0gUmVmLmNvbXBhcmVcbiAgbGV0IGVxdWFsX3JlZiA6ICdhLiAoJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgcmVmIC0+ICdhIHJlZiAtPiBib29sID0gUmVmLmVxdWFsXG5cbiAgbGV0IHJlZl9vZl9zZXhwIDogJ2EuIChTZXhwbGliMC5TZXhwLnQgLT4gJ2EpIC0+IFNleHBsaWIwLlNleHAudCAtPiAnYSByZWYgPVxuICAgIFJlZi50X29mX3NleHBcbiAgOztcblxuICBsZXQgc2V4cF9vZl9yZWYgOiAnYS4gKCdhIC0+IFNleHBsaWIwLlNleHAudCkgLT4gJ2EgcmVmIC0+IFNleHBsaWIwLlNleHAudCA9XG4gICAgUmVmLnNleHBfb2ZfdFxuICA7O1xuXG4gIGxldCAocmVmX3NleHBfZ3JhbW1hciA6ICdhIFNleHBsaWIwLlNleHBfZ3JhbW1hci50IC0+ICdhIHJlZiBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPVxuICAgIGZ1biBfJ2Ffc2V4cF9ncmFtbWFyIC0+IFJlZi50X3NleHBfZ3JhbW1hciBfJ2Ffc2V4cF9ncmFtbWFyXG4gIDs7XG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIHN0cmluZyA9IFN0cmluZy50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgaGFzaCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX3N0cmluZyA9IChTdHJpbmcuY29tcGFyZSA6IHN0cmluZyAtPiBzdHJpbmcgLT4gaW50KVxuICBsZXQgZXF1YWxfc3RyaW5nID0gKFN0cmluZy5lcXVhbCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbClcblxuICBsZXQgKGhhc2hfZm9sZF9zdHJpbmcgOlxuICAgICAgICAgUHB4X2hhc2hfbGliLlN0ZC5IYXNoLnN0YXRlIC0+IHN0cmluZyAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIFN0cmluZy5oYXNoX2ZvbGRfdFxuXG4gIGFuZCAoaGFzaF9zdHJpbmcgOiBzdHJpbmcgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFN0cmluZy5oYXNoIGluXG4gICAgZnVuIHggLT4gZnVuYyB4XG4gIDs7XG5cbiAgbGV0IHN0cmluZ19vZl9zZXhwID0gKFN0cmluZy50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gc3RyaW5nKVxuICBsZXQgc2V4cF9vZl9zdHJpbmcgPSAoU3RyaW5nLnNleHBfb2ZfdCA6IHN0cmluZyAtPiBTZXhwbGliMC5TZXhwLnQpXG4gIGxldCAoc3RyaW5nX3NleHBfZ3JhbW1hciA6IHN0cmluZyBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBTdHJpbmcudF9zZXhwX2dyYW1tYXJcblxuICBbQEBAZW5kXVxuXG4gIHR5cGUgYnl0ZXMgPSBCeXRlcy50IFtAQGRlcml2aW5nX2lubGluZSBjb21wYXJlLCBlcXVhbCwgc2V4cCwgc2V4cF9ncmFtbWFyXVxuXG4gIGxldCBjb21wYXJlX2J5dGVzID0gKEJ5dGVzLmNvbXBhcmUgOiBieXRlcyAtPiBieXRlcyAtPiBpbnQpXG4gIGxldCBlcXVhbF9ieXRlcyA9IChCeXRlcy5lcXVhbCA6IGJ5dGVzIC0+IGJ5dGVzIC0+IGJvb2wpXG4gIGxldCBieXRlc19vZl9zZXhwID0gKEJ5dGVzLnRfb2Zfc2V4cCA6IFNleHBsaWIwLlNleHAudCAtPiBieXRlcylcbiAgbGV0IHNleHBfb2ZfYnl0ZXMgPSAoQnl0ZXMuc2V4cF9vZl90IDogYnl0ZXMgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKGJ5dGVzX3NleHBfZ3JhbW1hciA6IGJ5dGVzIFNleHBsaWIwLlNleHBfZ3JhbW1hci50KSA9IEJ5dGVzLnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICB0eXBlIHVuaXQgPSBVbml0LnQgW0BAZGVyaXZpbmdfaW5saW5lIGNvbXBhcmUsIGVxdWFsLCBoYXNoLCBzZXhwLCBzZXhwX2dyYW1tYXJdXG5cbiAgbGV0IGNvbXBhcmVfdW5pdCA9IChVbml0LmNvbXBhcmUgOiB1bml0IC0+IHVuaXQgLT4gaW50KVxuICBsZXQgZXF1YWxfdW5pdCA9IChVbml0LmVxdWFsIDogdW5pdCAtPiB1bml0IC0+IGJvb2wpXG5cbiAgbGV0IChoYXNoX2ZvbGRfdW5pdCA6XG4gICAgICAgICBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUgLT4gdW5pdCAtPiBQcHhfaGFzaF9saWIuU3RkLkhhc2guc3RhdGUpXG4gICAgPVxuICAgIFVuaXQuaGFzaF9mb2xkX3RcblxuICBhbmQgKGhhc2hfdW5pdCA6IHVuaXQgLT4gUHB4X2hhc2hfbGliLlN0ZC5IYXNoLmhhc2hfdmFsdWUpID1cbiAgICBsZXQgZnVuYyA9IFVuaXQuaGFzaCBpblxuICAgIGZ1biB4IC0+IGZ1bmMgeFxuICA7O1xuXG4gIGxldCB1bml0X29mX3NleHAgPSAoVW5pdC50X29mX3NleHAgOiBTZXhwbGliMC5TZXhwLnQgLT4gdW5pdClcbiAgbGV0IHNleHBfb2ZfdW5pdCA9IChVbml0LnNleHBfb2ZfdCA6IHVuaXQgLT4gU2V4cGxpYjAuU2V4cC50KVxuICBsZXQgKHVuaXRfc2V4cF9ncmFtbWFyIDogdW5pdCBTZXhwbGliMC5TZXhwX2dyYW1tYXIudCkgPSBVbml0LnRfc2V4cF9ncmFtbWFyXG5cbiAgW0BAQGVuZF1cblxuICAoKiogRm9ybWF0IHN0dWZmICopXG5cbiAgdHlwZSBub25yZWMgKCdhLCAnYiwgJ2MpIGZvcm1hdCA9ICgnYSwgJ2IsICdjKSBmb3JtYXRcbiAgdHlwZSBub25yZWMgKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0ID0gKCdhLCAnYiwgJ2MsICdkKSBmb3JtYXQ0XG4gIHR5cGUgbm9ucmVjICgnYSwgJ2IsICdjLCAnZCwgJ2UsICdmKSBmb3JtYXQ2ID0gKCdhLCAnYiwgJ2MsICdkLCAnZSwgJ2YpIGZvcm1hdDZcblxuICAoKiogTGlzdCBvcGVyYXRvcnMgKilcblxuICBpbmNsdWRlIExpc3QuSW5maXhcblxuICAoKiogSW50IG9wZXJhdG9ycyBhbmQgY29tcGFyaXNvbnMgKilcblxuICBpbmNsdWRlIEludC5PXG4gIGluY2x1ZGUgSW50X3JlcGxhY2VfcG9seW1vcnBoaWNfY29tcGFyZVxuXG4gICgqKiBGbG9hdCBvcGVyYXRvcnMgKilcblxuICBpbmNsdWRlIEZsb2F0Lk9fZG90XG5cbiAgKCogVGhpcyBpcyBkZWNsYXJlZCBhcyBhbiBleHRlcm5hbCB0byBiZSBvcHRpbWl6ZWQgYXdheSBpbiBtb3JlIGNvbnRleHRzLiAqKVxuXG4gICgqKiBSZXZlcnNlIGFwcGxpY2F0aW9uIG9wZXJhdG9yLiBbeCB8PiBnIHw+IGZdIGlzIGVxdWl2YWxlbnQgdG8gW2YgKGcgKHgpKV0uICopXG4gIGV4dGVybmFsICggfD4gKSA6ICdhIC0+ICgnYSAtPiAnYikgLT4gJ2IgPSBcIiVyZXZhcHBseVwiXG5cbiAgKCoqIEFwcGxpY2F0aW9uIG9wZXJhdG9yLiBbZyBAQCBmIEBAIHhdIGlzIGVxdWl2YWxlbnQgdG8gW2cgKGYgKHgpKV0uICopXG4gIGV4dGVybmFsICggQEAgKSA6ICgnYSAtPiAnYikgLT4gJ2EgLT4gJ2IgPSBcIiVhcHBseVwiXG5cbiAgKCoqIEJvb2xlYW4gb3BlcmF0aW9ucyAqKVxuXG4gICgqIFRoZXNlIG5lZWQgdG8gYmUgZGVjbGFyZWQgYXMgYW4gZXh0ZXJuYWwgdG8gZ2V0IHRoZSBsYXp5IGJlaGF2aW9yICopXG4gIGV4dGVybmFsICggJiYgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdWFuZFwiXG4gIGV4dGVybmFsICggfHwgKSA6IGJvb2wgLT4gYm9vbCAtPiBib29sID0gXCIlc2VxdW9yXCJcbiAgZXh0ZXJuYWwgbm90IDogYm9vbCAtPiBib29sID0gXCIlYm9vbG5vdFwiXG5cbiAgKCogVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGFzIGFuIGV4dGVybmFsIGZvciB0aGUgd2FybmluZ3MgdG8gd29yayBwcm9wZXJseS4gKilcbiAgZXh0ZXJuYWwgaWdub3JlIDogXyAtPiB1bml0ID0gXCIlaWdub3JlXCJcblxuICAoKiogQ29tbW9uIHN0cmluZyBvcGVyYXRpb25zICopXG4gIGxldCAoIF4gKSA9IFN0cmluZy4oIF4gKVxuXG4gICgqKiBSZWZlcmVuY2Ugb3BlcmF0aW9ucyAqKVxuXG4gICgqIERlY2xhcmVkIGFzIGFuIGV4dGVybmFscyBzbyB0aGF0IHRoZSBjb21waWxlciBza2lwcyB0aGUgY2FtbF9tb2RpZnkgd2hlbiBwb3NzaWJsZSBhbmRcbiAgICAgdG8ga2VlcCByZWZlcmVuY2UgdW5ib3hpbmcgd29ya2luZyAqKVxuICBleHRlcm5hbCAoICEgKSA6ICdhIHJlZiAtPiAnYSA9IFwiJWZpZWxkMFwiXG4gIGV4dGVybmFsIHJlZiA6ICdhIC0+ICdhIHJlZiA9IFwiJW1ha2VtdXRhYmxlXCJcbiAgZXh0ZXJuYWwgKCA6PSApIDogJ2EgcmVmIC0+ICdhIC0+IHVuaXQgPSBcIiVzZXRmaWVsZDBcIlxuXG4gICgqKiBQYWlyIG9wZXJhdGlvbnMgKilcblxuICBsZXQgZnN0ID0gZnN0XG4gIGxldCBzbmQgPSBzbmRcblxuICAoKiogRXhjZXB0aW9ucyBzdHVmZiAqKVxuXG4gICgqIERlY2xhcmVkIGFzIGFuIGV4dGVybmFsIHNvIHRoYXQgdGhlIGNvbXBpbGVyIG1heSByZXdyaXRlICclcmFpc2UnIGFzICclcmVyYWlzZScuICopXG4gIGV4dGVybmFsIHJhaXNlIDogZXhuIC0+IF8gPSBcIiVyYWlzZVwiXG5cbiAgbGV0IGZhaWx3aXRoID0gZmFpbHdpdGhcbiAgbGV0IGludmFsaWRfYXJnID0gaW52YWxpZF9hcmdcbiAgbGV0IHJhaXNlX3MgPSBFcnJvci5yYWlzZV9zXG5cbiAgKCoqIE1pc2MgKilcblxuICBsZXQgcGh5c19lcXVhbCA9IHBoeXNfZXF1YWxcblxuICBleHRlcm5hbCBmb3JjZSA6ICdhIExhenkudCAtPiAnYSA9IFwiJWxhenlfZm9yY2VcIlxuZW5kXG5cbmluY2x1ZGUgRXhwb3J0XG5cbmluY2x1ZGUgQ29udGFpbmVyX2ludGYuRXhwb3J0ICgqKiBAaW5saW5lICopXG5cbmV4Y2VwdGlvbiBOb3RfZm91bmRfcyA9IE5vdF9mb3VuZF9zXG5cbigqIFdlIHBlcmZvcm0gdGhlc2Ugc2lkZSBlZmZlY3RzIGhlcmUgYmVjYXVzZSB3ZSB3YW50IHRoZW0gdG8gcnVuIGZvciBhbnkgY29kZSB0aGF0IHVzZXNcbiAgIFtCYXNlXS4gIElmIHRoaXMgd2VyZSBpbiBhbm90aGVyIG1vZHVsZSBpbiBbQmFzZV0gdGhhdCB3YXMgbm90IHVzZWQgaW4gc29tZSBwcm9ncmFtLFxuICAgdGhlbiB0aGUgc2lkZSBlZmZlY3RzIG1pZ2h0IG5vdCBiZSBydW4gaW4gdGhhdCBwcm9ncmFtLiAgVGhpcyB3aWxsIHJ1biBhcyBsb25nIGFzIHRoZVxuICAgcHJvZ3JhbSByZWZlcnMgdG8gYXQgbGVhc3Qgb25lIHZhbHVlIGRpcmVjdGx5IGluIFtCYXNlXTsgcmVmZXJyaW5nIHRvIHZhbHVlcyBpblxuICAgW0Jhc2UuQm9vbF0sIGZvciBleGFtcGxlLCBpcyBub3Qgc3VmZmljaWVudC4gKilcbmxldCAoKSA9IEJhY2t0cmFjZS5pbml0aWFsaXplX21vZHVsZSAoKVxuIl19
