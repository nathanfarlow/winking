// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.1.1

//# unitInfo: Provides: Bin_shape_lib
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Bin_shape_lib = [0];
   runtime.caml_register_global(0, Bin_shape_lib, "Bin_shape_lib");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Bin_shape_lib__Bin_shape
//# unitInfo: Requires: Assert_failure, Base, Base__Comparator, Base__Int, Base__List, Base__Map, Base__Option, Base__Printf, Base__String, Md5_lib, Ppx_compare_lib, Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Annotate = "Annotate",
    cst_Application = "Application",
    cst_Base = "Base",
    cst_Exp = "Exp",
    cst_Poly_variant = "Poly_variant",
    cst_Rec_app = "Rec_app",
    cst_Record = "Record",
    cst_Tuple = "Tuple",
    cst_Var = "Var",
    cst_Variant = "Variant",
    cst_annotate$0 = "annotate",
    cst_application$0 = "application",
    cst_base$0 = "base",
    cst_exp = "exp",
    cst_poly_variant$0 = "poly_variant",
    cst_rec_app$0 = "rec_app",
    cst_record$0 = "record",
    cst_sorted$0 = "sorted",
    cst_tuple$0 = "tuple",
    cst_var$0 = "var",
    cst_variant$0 = "variant",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_compare = runtime.caml_string_compare,
    caml_string_notequal = runtime.caml_string_notequal;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    error_source_026 = "shape/src/bin_shape.ml.Sorted_table.t",
    error_source_042 = "shape/src/bin_shape.ml.Canonical_exp_constructor.t",
    error_source_206 = "shape/src/bin_shape.ml.Canonical_full.Exp1.t0",
    Assert_failure = global_data.Assert_failure,
    Base_List = global_data.Base__List,
    Base = global_data.Base,
    Base_Option = global_data.Base__Option,
    Base_Map = global_data.Base__Map,
    Base_Comparator = global_data.Base__Comparator,
    Ppx_compare_lib = global_data.Ppx_compare_lib,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Base_String = global_data.Base__String,
    Base_Int = global_data.Base__Int,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Base_Printf = global_data.Base__Printf,
    Md5_lib = global_data.Md5_lib,
    sexp_of_t = Base_String[28],
    of_string = Base_String[29],
    to_string = Base_String[30],
    t_of_sexp = Base_String[27],
    sexp_of_t$0 = Base_String[28],
    of_string$0 = Base_String[29],
    to_string$0 = Base_String[30],
    compare = Base_String[37],
    _M_ = [0, "shape/src/bin_shape.ml.For_typerep.Not_a_tuple"],
    _N_ = [0, "_none_", 0, -1],
    cst_Free_type_variable_Vid = "Free type variable: '%{Vid}",
    _J_ = [0, 0],
    cst_Free_type_variable = "Free type variable: '",
    _K_ =
      [0,
       [11,
        "The shape for an inherited type is not described as a polymorphic-variant: ",
        [2, 0, 0]],
       "The shape for an inherited type is not described as a polymorphic-variant: %s"],
    cst_apply_incorrect_type_appli = "apply, incorrect type application arity",
    cst_top_level = "top-level",
    _y_ = [0, cst_Annotate],
    _z_ = [0, cst_Base],
    _A_ = [0, cst_Record],
    _B_ = [0, cst_Variant],
    _C_ = [0, cst_Tuple],
    _D_ = [0, cst_Poly_variant],
    _E_ = [0, cst_Var],
    _F_ = [0, cst_Rec_app],
    _G_ = [0, "Top_app"],
    cst_impossible_lookup_group_un =
      "impossible: lookup_group, unbound type-identifier: %{Tid}",
    _x_ = [0, 0],
    cst_impossible_lookup_group_un$0 =
      "impossible: lookup_group, unbound type-identifier: ",
    _u_ = [0, "members"],
    _v_ = [0, "loc"],
    _w_ = [0, "gid"],
    _s_ = [0, "Constr"],
    _t_ = [0, "Inherit"],
    _r_ = [0, cst_Exp],
    cst_annotate = cst_annotate$0,
    cst_base = cst_base$0,
    cst_tuple = cst_tuple$0,
    cst_record = cst_record$0,
    cst_variant = cst_variant$0,
    cst_poly_variant = cst_poly_variant$0,
    cst_application = cst_application$0,
    cst_rec_app = cst_rec_app$0,
    cst_var = cst_var$0,
    _q_ = [0, "..."],
    _h_ = [0, cst_Annotate],
    _i_ = [0, cst_Base],
    _j_ = [0, cst_Tuple],
    _k_ = [0, cst_Record],
    _l_ = [0, cst_Variant],
    _m_ = [0, cst_Poly_variant],
    _n_ = [0, cst_Application],
    _o_ = [0, cst_Rec_app],
    _p_ = [0, cst_Var],
    cst_some = "some",
    cst_none = "none",
    _g_ = [0, ""],
    _f_ =
      [0,
       [11,
        "Different shapes for duplicated polymorphic constructor: `",
        [2, 0, 0]],
       "Different shapes for duplicated polymorphic constructor: `%s"],
    _e_ = [0, 17724, 0],
    _d_ = [0, cst_sorted$0],
    _c_ = [0, "shape/src/bin_shape.ml", 33, 2],
    cst_sorted = cst_sorted$0,
    cst_Location_s = "%{Location}: %s",
    _a_ = [11, ": ", [2, 0, 0]],
    _b_ = [0, 0],
    cst_Bin_shape_lib_Bin_shape_Fo =
      "Bin_shape_lib.Bin_shape.For_typerep.Not_a_tuple";
   function eval_fail(loc, fmt){
    function _bL_(s){
     var
      _bM_ =
        [0,
         [24,
          _b_,
          function(param, custom_printf_001){
           return caml_call1(to_string, custom_printf_001);
          },
          _a_],
         cst_Location_s],
      _bN_ = caml_call3(Base_Printf[2], _bM_, loc, s);
     return caml_call1(Base[200], _bN_);
    }
    return caml_call2(Base_Printf[4], _bL_, fmt);
   }
   function equal_option(equal, a, b){
    if(a){
     if(b){var y = b[1], x = a[1]; return caml_call2(equal, x, y);}
    }
    else if(! b) return 1;
    return 0;
   }
   function create(loc, eq, xs$1){
    function _bJ_(param, _bK_){
     var s2 = _bK_[1], s1 = param[1];
     return caml_call2(Base_String[37], s1, s2);
    }
    var sorted = caml_call2(Base_List[62], xs$1, _bJ_);
    if(sorted){
     var
      xs$0 = sorted[2],
      match$0 = sorted[1],
      last_value$1 = match$0[2],
      last_key$1 = match$0[1],
      acc$1 = [0, [0, last_key$1, last_value$1], 0],
      acc = acc$1,
      last_key = last_key$1,
      last_value = last_value$1,
      param = xs$0;
     for(;;){
      if(param){
       var
        xs = param[2],
        match = param[1],
        last_value$0 = match[2],
        last_key$0 = match[1];
       if(! caml_call2(Base_String[33], last_key, last_key$0)){
        var
         acc$0 = [0, [0, last_key$0, last_value$0], acc],
         acc = acc$0,
         last_key = last_key$0,
         last_value = last_value$0,
         param = xs;
        continue;
       }
       if(caml_call2(eq, last_value, last_value$0)){var param = xs; continue;}
       var match$1 = [0, -1062743954, last_key$0];
      }
      else
       var match$1 = [0, 17724, caml_call1(Base_List[38], acc)];
      break;
     }
    }
    else
     var match$1 = _e_;
    if(17724 <= match$1[1]){var sorted$0 = match$1[2]; return [0, sorted$0];}
    var s = match$1[2];
    return caml_call2(eval_fail(loc, _f_), s, 0);
   }
   function map(t, f){
    function _bI_(param){
     var v = param[2], k = param[1];
     return [0, k, caml_call1(f, v)];
    }
    return [0, caml_call2(Base_List[76], t[1], _bI_)];
   }
   var
    compare$0 = Md5_lib[1],
    to_binary = Md5_lib[3],
    to_hex = Md5_lib[6],
    of_hex_exn = Md5_lib[7],
    string = Md5_lib[8];
   function to_md5(t){return t;}
   function of_md5(t){return t;}
   function sexp_of_t$1(t){
    var _bH_ = caml_call1(to_hex, t);
    return caml_call1(Base[164], _bH_);
   }
   function t_of_sexp$0(s){
    return caml_call1(of_hex_exn, caml_call1(Base[163], s));
   }
   function uuid(u){return caml_call1(string, caml_call1(to_string$0, u));}
   function int$0(x){return caml_call1(string, caml_call1(Base_Int[11], x));}
   function pair(x, y){
    var _bF_ = caml_call1(to_binary, y), _bG_ = caml_call1(to_binary, x);
    return caml_call1(string, caml_call2(Base[197], _bG_, _bF_));
   }
   function list(l){
    var _bE_ = caml_call2(Base_List[76], l, to_binary);
    return caml_call1(string, caml_call2(Base_String[54], _g_, _bE_));
   }
   function constructor(s, l){
    var _bD_ = caml_call1(to_binary, list(l));
    return caml_call1(string, caml_call2(Base[197], s, _bD_));
   }
   function t_of_sexp$1(of_a_039, sexp_044){
    if(0 === sexp_044[0]){
     var
      _bm_ = sexp_044[1],
      _bn_ = caml_string_compare(_bm_, cst_annotate$0),
      switch$0 = 0;
     if(0 <= _bn_)
      if(0 < _bn_)
       if(caml_string_notequal(_bm_, cst_application$0))
        if(caml_string_notequal(_bm_, cst_base$0))
         if(caml_string_notequal(_bm_, cst_poly_variant$0))
          if(caml_string_notequal(_bm_, cst_rec_app$0))
           if(caml_string_notequal(_bm_, cst_record$0))
            if(caml_string_notequal(_bm_, cst_tuple$0))
             if(caml_string_notequal(_bm_, cst_var$0)){
              if(! caml_string_notequal(_bm_, cst_variant$0)) switch$0 = 5;
             }
             else
              switch$0 = 9;
            else
             switch$0 = 3;
           else
            switch$0 = 4;
          else
           switch$0 = 8;
         else
          switch$0 = 6;
        else
         switch$0 = 2;
       else
        switch$0 = 7;
      else
       switch$0 = 1;
     else if(caml_string_notequal(_bm_, cst_Annotate))
      if(caml_string_notequal(_bm_, cst_Application))
       if(caml_string_notequal(_bm_, cst_Base))
        if(caml_string_notequal(_bm_, cst_Poly_variant))
         if(caml_string_notequal(_bm_, cst_Rec_app))
          if(caml_string_notequal(_bm_, cst_Record))
           if(caml_string_notequal(_bm_, cst_Tuple))
            if(caml_string_notequal(_bm_, cst_Var)){
             if(! caml_string_notequal(_bm_, cst_Variant)) switch$0 = 5;
            }
            else
             switch$0 = 9;
           else
            switch$0 = 3;
          else
           switch$0 = 4;
         else
          switch$0 = 8;
        else
         switch$0 = 6;
       else
        switch$0 = 2;
      else
       switch$0 = 7;
     else
      switch$0 = 1;
     switch(switch$0){
       case 1:
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
       case 2:
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
       case 3:
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
       case 4:
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
       case 5:
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
       case 6:
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
       case 7:
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
       case 8:
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
       case 9:
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_042, sexp_044);
     }
    }
    else{
     var _bo_ = sexp_044[1];
     if(! _bo_)
      return caml_call2
              (Sexplib0_Sexp_conv_error[7], error_source_042, sexp_044);
     var _bp_ = _bo_[1];
     if(0 !== _bp_[0])
      return caml_call2
              (Sexplib0_Sexp_conv_error[6], error_source_042, sexp_044);
     var
      tag_045 = _bp_[1],
      _bq_ = caml_string_compare(tag_045, cst_annotate$0),
      switch$1 = 0;
     if(0 <= _bq_){
      if(0 < _bq_)
       if(caml_string_notequal(tag_045, cst_application$0))
        if(caml_string_notequal(tag_045, cst_base$0))
         if(caml_string_notequal(tag_045, cst_poly_variant$0))
          if(caml_string_notequal(tag_045, cst_rec_app$0))
           if(caml_string_notequal(tag_045, cst_record$0))
            if(caml_string_notequal(tag_045, cst_tuple$0))
             if(caml_string_notequal(tag_045, cst_var$0))
              if(caml_string_notequal(tag_045, cst_variant$0))
               switch$1 = 9;
              else
               switch$1 = 4;
             else
              switch$1 = 8;
            else
             switch$1 = 2;
           else
            switch$1 = 3;
          else
           switch$1 = 7;
         else
          switch$1 = 5;
        else
         switch$1 = 1;
       else
        switch$1 = 6;
     }
     else if(caml_string_notequal(tag_045, cst_Annotate))
      if(caml_string_notequal(tag_045, cst_Application))
       if(caml_string_notequal(tag_045, cst_Base))
        if(caml_string_notequal(tag_045, cst_Poly_variant))
         if(caml_string_notequal(tag_045, cst_Rec_app))
          if(caml_string_notequal(tag_045, cst_Record))
           if(caml_string_notequal(tag_045, cst_Tuple))
            if(caml_string_notequal(tag_045, cst_Var))
             if(caml_string_notequal(tag_045, cst_Variant))
              switch$1 = 9;
             else
              switch$1 = 4;
            else
             switch$1 = 8;
           else
            switch$1 = 2;
          else
           switch$1 = 3;
         else
          switch$1 = 7;
        else
         switch$1 = 5;
       else
        switch$1 = 1;
      else
       switch$1 = 6;
     switch(switch$1){
       case 0:
        var sexp_args_046 = _bo_[2];
        if(sexp_args_046){
         var _bw_ = sexp_args_046[2];
         if(_bw_ && ! _bw_[2]){
          var
           arg1_048 = _bw_[1],
           arg0_047 = sexp_args_046[1],
           res0_049 = caml_call1(t_of_sexp, arg0_047),
           res1_050 = caml_call1(of_a_039, arg1_048);
          return [0, res0_049, res1_050];
         }
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_042,
                 tag_045,
                 sexp_044);
       case 1:
        var sexp_args_053 = _bo_[2];
        if(sexp_args_053){
         var _bu_ = sexp_args_053[2];
         if(_bu_ && ! _bu_[2]){
          var
           arg1_055 = _bu_[1],
           arg0_054 = sexp_args_053[1],
           res0_056 = caml_call1(t_of_sexp, arg0_054),
           res1_057 = caml_call2(Base[138], of_a_039, arg1_055);
          return [1, res0_056, res1_057];
         }
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_042,
                 tag_045,
                 sexp_044);
       case 2:
        var sexp_args_060 = _bo_[2];
        if(sexp_args_060 && ! sexp_args_060[2]){
         var
          arg0_061 = sexp_args_060[1],
          res0_062 = caml_call2(Base[138], of_a_039, arg0_061);
         return [2, res0_062];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_042,
                 tag_045,
                 sexp_044);
       case 3:
        var sexp_args_065 = _bo_[2];
        if(sexp_args_065 && ! sexp_args_065[2]){
         var
          arg0_071 = sexp_args_065[1],
          _bs_ =
            function(sexp_070){
             if(1 === sexp_070[0]){
              var _bB_ = sexp_070[1];
              if(_bB_){
               var _bC_ = _bB_[2];
               if(_bC_ && ! _bC_[2]){
                var
                 arg1_067 = _bC_[1],
                 arg0_066 = _bB_[1],
                 res0_068 = caml_call1(Base[163], arg0_066),
                 res1_069 = caml_call1(of_a_039, arg1_067);
                return [0, res0_068, res1_069];
               }
              }
             }
             return caml_call3
                     (Sexplib0_Sexp_conv_error[2], error_source_042, 2, sexp_070);
            },
          res0_072 = caml_call2(Base[138], _bs_, arg0_071);
         return [3, res0_072];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_042,
                 tag_045,
                 sexp_044);
       case 4:
        var sexp_args_075 = _bo_[2];
        if(sexp_args_075 && ! sexp_args_075[2]){
         var
          arg0_081 = sexp_args_075[1],
          _br_ =
            function(sexp_080){
             if(1 === sexp_080[0]){
              var _bz_ = sexp_080[1];
              if(_bz_){
               var _bA_ = _bz_[2];
               if(_bA_ && ! _bA_[2]){
                var
                 arg1_077 = _bA_[1],
                 arg0_076 = _bz_[1],
                 res0_078 = caml_call1(Base[163], arg0_076),
                 res1_079 = caml_call2(Base[138], of_a_039, arg1_077);
                return [0, res0_078, res1_079];
               }
              }
             }
             return caml_call3
                     (Sexplib0_Sexp_conv_error[2], error_source_042, 2, sexp_080);
            },
          res0_082 = caml_call2(Base[138], _br_, arg0_081);
         return [4, res0_082];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_042,
                 tag_045,
                 sexp_044);
       case 5:
        var sexp_args_085 = _bo_[2];
        if(sexp_args_085 && ! sexp_args_085[2]){
         var
          arg0_086 = sexp_args_085[1],
          of_a_010 = caml_call1(Base[151], of_a_039);
         if(0 === arg0_086[0])
          var
           res0_087 =
             caml_call2
              (Sexplib0_Sexp_conv_error[16], error_source_026, arg0_086);
         else{
          var
           field_sexps_013 = arg0_086[1],
           sorted_014 = [0, 0],
           duplicates_016 = [0, 0],
           extra_017 = [0, 0],
           param = field_sexps_013;
          for(;;){
           if(param){
            var sexp_012 = param[1];
            if(1 === sexp_012[0]){
             var _bj_ = sexp_012[1];
             if(_bj_){
              var _bk_ = _bj_[1];
              if(0 === _bk_[0]){
               var
                field_sexps_020 = _bj_[2],
                field_name_018 = _bk_[1],
                switch$2 = 0;
               if(field_sexps_020 && field_sexps_020[2]) switch$2 = 1;
               if(! switch$2){
                var tail_029 = param[2];
                if(caml_string_notequal(field_name_018, cst_sorted$0)){
                 if(Sexplib0_Sexp_conv[26][1])
                  extra_017[1] = [0, field_name_018, extra_017[1]];
                }
                else if(sorted_014[1])
                 duplicates_016[1] = [0, field_name_018, duplicates_016[1]];
                else{
                 if(field_sexps_020){
                  if(field_sexps_020[2])
                   throw caml_maybe_attach_backtrace
                          ([0, Assert_failure, _c_], 1);
                  var x_030 = field_sexps_020[1], field_sexp_019 = x_030;
                 }
                 else
                  var
                   field_sexp_019 =
                     caml_call2
                      (Sexplib0_Sexp_conv_error[10], error_source_026, arg0_086);
                 var
                  _bl_ =
                    function(sexp_025){
                     if(1 === sexp_025[0]){
                      var _bx_ = sexp_025[1];
                      if(_bx_){
                       var _by_ = _bx_[2];
                       if(_by_ && ! _by_[2]){
                        var
                         arg1_022 = _by_[1],
                         arg0_021 = _bx_[1],
                         res0_023 = caml_call1(Base[163], arg0_021),
                         res1_024 = caml_call1(of_a_010, arg1_022);
                        return [0, res0_023, res1_024];
                       }
                      }
                     }
                     return caml_call3
                             (Sexplib0_Sexp_conv_error[2], error_source_026, 2, sexp_025);
                    },
                  fvalue_027 = caml_call2(Base[138], _bl_, field_sexp_019);
                 sorted_014[1] = [0, fvalue_027];
                }
                var param = tail_029;
                continue;
               }
              }
             }
            }
            caml_call2
             (Sexplib0_Sexp_conv_error[10], error_source_026, sexp_012);
           }
           if(duplicates_016[1])
            var
             res0_087 =
               caml_call3
                (Sexplib0_Sexp_conv_error[12],
                 error_source_026,
                 duplicates_016[1],
                 arg0_086);
           else if(extra_017[1])
            var
             res0_087 =
               caml_call3
                (Sexplib0_Sexp_conv_error[13],
                 error_source_026,
                 extra_017[1],
                 arg0_086);
           else{
            var match = sorted_014[1];
            if(match)
             var sorted_015 = match[1], res0_087 = [0, sorted_015];
            else
             var
              res0_087 =
                caml_call3
                 (Sexplib0_Sexp_conv_error[15],
                  error_source_026,
                  arg0_086,
                  [0, [0, 0 === sorted_014[1] ? 1 : 0, cst_sorted], 0]);
           }
           break;
          }
         }
         return [5, res0_087];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_042,
                 tag_045,
                 sexp_044);
       case 6:
        var sexp_args_090 = _bo_[2];
        if(sexp_args_090){
         var _bv_ = sexp_args_090[2];
         if(_bv_ && ! _bv_[2]){
          var
           arg1_092 = _bv_[1],
           arg0_091 = sexp_args_090[1],
           res0_093 = caml_call1(of_a_039, arg0_091),
           res1_094 = caml_call2(Base[138], of_a_039, arg1_092);
          return [6, res0_093, res1_094];
         }
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_042,
                 tag_045,
                 sexp_044);
       case 7:
        var sexp_args_097 = _bo_[2];
        if(sexp_args_097){
         var _bt_ = sexp_args_097[2];
         if(_bt_ && ! _bt_[2]){
          var
           arg1_099 = _bt_[1],
           arg0_098 = sexp_args_097[1],
           res0_100 = caml_call1(Base[118], arg0_098),
           res1_101 = caml_call2(Base[138], of_a_039, arg1_099);
          return [7, res0_100, res1_101];
         }
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_042,
                 tag_045,
                 sexp_044);
       case 8:
        var sexp_args_104 = _bo_[2];
        if(sexp_args_104 && ! sexp_args_104[2]){
         var
          arg0_105 = sexp_args_104[1],
          res0_106 = caml_call1(Base[118], arg0_105);
         return [8, res0_106];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_042,
                 tag_045,
                 sexp_044);
     }
    }
    return caml_call2(Sexplib0_Sexp_conv_error[8], error_source_042, sexp_044);
   }
   function sexp_of_t$2(of_a_108, param){
    switch(param[0]){
      case 0:
       var
        arg1_110 = param[2],
        arg0_109 = param[1],
        res0_111 = caml_call1(sexp_of_t$0, arg0_109),
        res1_112 = caml_call1(of_a_108, arg1_110);
       return [1, [0, _h_, [0, res0_111, [0, res1_112, 0]]]];
      case 1:
       var
        arg1_114 = param[2],
        arg0_113 = param[1],
        res0_115 = caml_call1(sexp_of_t$0, arg0_113),
        res1_116 = caml_call2(Base[139], of_a_108, arg1_114);
       return [1, [0, _i_, [0, res0_115, [0, res1_116, 0]]]];
      case 2:
       var
        arg0_117 = param[1],
        res0_118 = caml_call2(Base[139], of_a_108, arg0_117);
       return [1, [0, _j_, [0, res0_118, 0]]];
      case 3:
       var
        arg0_123 = param[1],
        _bh_ =
          function(param){
           var
            arg1_120 = param[2],
            arg0_119 = param[1],
            res0_121 = caml_call1(Base[164], arg0_119),
            res1_122 = caml_call1(of_a_108, arg1_120);
           return [1, [0, res0_121, [0, res1_122, 0]]];
          },
        res0_124 = caml_call2(Base[139], _bh_, arg0_123);
       return [1, [0, _k_, [0, res0_124, 0]]];
      case 4:
       var
        arg0_129 = param[1],
        _bi_ =
          function(param){
           var
            arg1_126 = param[2],
            arg0_125 = param[1],
            res0_127 = caml_call1(Base[164], arg0_125),
            res1_128 = caml_call2(Base[139], of_a_108, arg1_126);
           return [1, [0, res0_127, [0, res1_128, 0]]];
          },
        res0_130 = caml_call2(Base[139], _bi_, arg0_129);
       return [1, [0, _l_, [0, res0_130, 0]]];
      case 5:
       var
        arg0_131 = param[1],
        of_a_031 = caml_call1(Base[152], of_a_108),
        sorted_033 = arg0_131[1],
        bnds_032 = 0,
        _bg_ =
          function(param){
           var
            arg1_036 = param[2],
            arg0_035 = param[1],
            res0_037 = caml_call1(Base[164], arg0_035),
            res1_038 = caml_call1(of_a_031, arg1_036);
           return [1, [0, res0_037, [0, res1_038, 0]]];
          },
        arg_034 = caml_call2(Base[139], _bg_, sorted_033),
        bnds_032$0 = [0, [1, [0, _d_, [0, arg_034, 0]]], bnds_032],
        res0_132 = [1, bnds_032$0];
       return [1, [0, _m_, [0, res0_132, 0]]];
      case 6:
       var
        arg1_134 = param[2],
        arg0_133 = param[1],
        res0_135 = caml_call1(of_a_108, arg0_133),
        res1_136 = caml_call2(Base[139], of_a_108, arg1_134);
       return [1, [0, _n_, [0, res0_135, [0, res1_136, 0]]]];
      case 7:
       var
        arg1_138 = param[2],
        arg0_137 = param[1],
        res0_139 = caml_call1(Base[119], arg0_137),
        res1_140 = caml_call2(Base[139], of_a_108, arg1_138);
       return [1, [0, _o_, [0, res0_139, [0, res1_140, 0]]]];
      default:
       var arg0_141 = param[1], res0_142 = caml_call1(Base[119], arg0_141);
       return [1, [0, _p_, [0, res0_142, 0]]];
    }
   }
   function map$0(x, f){
    switch(x[0]){
      case 0:
       var x$0 = x[2], u = x[1]; return [0, u, caml_call1(f, x$0)];
      case 1:
       var xs = x[2], s = x[1];
       return [1, s, caml_call2(Base_List[76], xs, f)];
      case 2:
       var xs$0 = x[1]; return [2, caml_call2(Base_List[76], xs$0, f)];
      case 3:
       var
        l = x[1],
        _bb_ =
          function(param){
           var x = param[2], s = param[1];
           return [0, s, caml_call1(f, x)];
          };
       return [3, caml_call2(Base_List[76], l, _bb_)];
      case 4:
       var
        l$0 = x[1],
        _bc_ =
          function(param){
           var xs = param[2], s = param[1];
           return [0, s, caml_call2(Base_List[76], xs, f)];
          };
       return [4, caml_call2(Base_List[76], l$0, _bc_)];
      case 5:
       var t = x[1], _bd_ = Base_Option[21];
       return [5, map(t, function(_bf_){return caml_call2(_bd_, _bf_, f);})];
      case 6:
       var l$1 = x[2], x$1 = x[1], _be_ = caml_call2(Base_List[76], l$1, f);
       return [6, caml_call1(f, x$1), _be_];
      case 7:
       var l$2 = x[2], t$0 = x[1];
       return [7, t$0, caml_call2(Base_List[76], l$2, f)];
      default: var v = x[1]; return [8, v];
    }
   }
   function to_string$1(t){
    var _ba_ = sexp_of_t$2(function(param){return _q_;}, t);
    return caml_call1(Base[84][15], _ba_);
   }
   function digest_layer(param){
    switch(param[0]){
      case 0:
       var x = param[2], u = param[1];
       return constructor(cst_annotate, [0, uuid(u), [0, x, 0]]);
      case 1:
       var l = param[2], u$0 = param[1], _a2_ = [0, list(l), 0];
       return constructor(cst_base, [0, uuid(u$0), _a2_]);
      case 2:
       var l$0 = param[1]; return constructor(cst_tuple, [0, list(l$0), 0]);
      case 3:
       var
        l$1 = param[1],
        _a3_ = 0,
        _a4_ =
          function(param){
           var t = param[2], s = param[1];
           return pair(caml_call1(string, s), t);
          };
       return constructor
               (cst_record,
                [0, list(caml_call2(Base_List[76], l$1, _a4_)), _a3_]);
      case 4:
       var
        l$2 = param[1],
        _a5_ = 0,
        _a6_ =
          function(param){
           var l = param[2], s = param[1], _a$_ = list(l);
           return pair(caml_call1(string, s), _a$_);
          };
       return constructor
               (cst_variant,
                [0, list(caml_call2(Base_List[76], l$2, _a6_)), _a5_]);
      case 5:
       var
        table = param[1],
        _a7_ = 0,
        _a8_ =
          function(param){
           var y = param[2], x$0 = param[1];
           if(y)
            var x = y[1], _a__ = constructor(cst_some, [0, x, 0]);
           else
            var _a__ = constructor(cst_none, 0);
           return pair(caml_call1(string, x$0), _a__);
          };
       return constructor
               (cst_poly_variant,
                [0, list(caml_call2(Base_List[76], table[1], _a8_)), _a7_]);
      case 6:
       var l$3 = param[2], x$0 = param[1];
       return constructor(cst_application, [0, x$0, [0, list(l$3), 0]]);
      case 7:
       var l$4 = param[2], n = param[1], _a9_ = [0, list(l$4), 0];
       return constructor(cst_rec_app, [0, int$0(n), _a9_]);
      default:
       var n$0 = param[1]; return constructor(cst_var, [0, int$0(n$0), 0]);
    }
   }
   function to_digest(param){var x = param[1]; return x;}
   function to_digest$0(x){
    switch(x[0]){
      case 0:
       var x$0 = x[1]; return digest_layer([5, x$0]);
      case 1:
       var x$1 = x[1][2]; return x$1;
      default: var x$2 = x[1]; return x$2;
    }
   }
   function equal(x, y){
    var _a1_ = to_digest$0(y);
    return 0 === caml_call2(compare$0, to_digest$0(x), _a1_) ? 1 : 0;
   }
   function opaque(x){return [2, to_digest$0(x)];}
   function create$0(x){
    var x$0 = map$0(x, to_digest$0), desc = to_string$1(x$0);
    switch(x$0[0]){
      case 0:
       return [1, [0, desc, digest_layer(x$0)]];
      case 1:
       return [1, [0, desc, digest_layer(x$0)]];
      case 5:
       var l = x$0[1]; return [0, l];
      case 6:
       return [1, [0, desc, digest_layer(x$0)]];
      case 7:
       return [1, [0, desc, digest_layer(x$0)]];
      default: return [1, [0, desc, digest_layer(x$0)]];
    }
   }
   function var$0(x){return create$0([8, x]);}
   function apply(def, l){return create$0([6, def, l]);}
   function recurse(tid, l){return create$0([7, tid, l]);}
   function get_poly_variant(x){
    if(1 === x[0]){var desc = x[1][1]; return [1, desc];}
    var l = x[1], _aY_ = Base_Option[21];
    function _aZ_(x){return [2, x];}
    return [0, map(l, function(_a0_){return caml_call2(_aY_, _a0_, _aZ_);})];
   }
   var Def = [0];
   function annotate(u, x){return create$0([0, u, x]);}
   function basetype(u, l){return create$0([1, u, l]);}
   function tuple(l){return create$0([2, l]);}
   function poly_variant(loc, l){
    return create$0
            ([5,
              create
               (loc,
                function(_aW_, _aX_){return equal_option(equal, _aW_, _aX_);},
                l)]);
   }
   function var$1(x){return create$0([8, x]);}
   function apply$0(x, l){return create$0([6, x, l]);}
   function recurse$0(t, l){return create$0([7, t, l]);}
   function define(x){return x;}
   function record(l){return create$0([3, l]);}
   function variant(l){return create$0([4, l]);}
   function create$1(e){return [0, to_digest$0(e)];}
   var
    Canonical_digest =
      [0,
       to_digest,
       [0, var$0, recurse, apply, opaque, get_poly_variant],
       Def,
       [0,
        annotate,
        basetype,
        tuple,
        poly_variant,
        var$1,
        recurse$0,
        apply$0,
        define,
        record,
        variant,
        create$1]];
   function compare_t0(a_198, b_199){
    if(caml_call2(Ppx_compare_lib[1], a_198, b_199)) return 0;
    var b_201 = b_199[1], a_200 = a_198[1];
    function cmp_a(a_202, b_203){return compare_t0(a_202, b_203);}
    if(caml_call2(Ppx_compare_lib[1], a_200, b_201)) return 0;
    var switch$0 = 0;
    switch(a_200[0]){
      case 0:
       var a_146 = a_200[1];
       if(0 !== b_201[0]) return -1;
       var
        b_149 = b_201[2],
        b_147 = b_201[1],
        a_148 = a_200[2],
        n = caml_call2(compare, a_146, b_147);
       return 0 === n ? cmp_a(a_148, b_149) : n;
      case 1:
       var a_152 = a_200[2], a_150 = a_200[1];
       switch(b_201[0]){
         case 0: break;
         case 1:
          var
           b_153 = b_201[2],
           b_151 = b_201[1],
           n$0 = caml_call2(compare, a_150, b_151);
          if(0 !== n$0) return n$0;
          var _aO_ = function(a_154, b_155){return cmp_a(a_154, b_155);};
          return caml_call3(Base[135], _aO_, a_152, b_153);
         default: return -1;
       }
       break;
      case 2:
       var a_156 = a_200[1];
       switch(b_201[0]){
         case 0: break;
         case 1:
          switch$0 = 1; break;
         case 2:
          var
           b_157 = b_201[1],
           _aP_ = function(a_158, b_159){return cmp_a(a_158, b_159);};
          return caml_call3(Base[135], _aP_, a_156, b_157);
         default: return -1;
       }
       break;
      case 3:
       var a_160 = a_200[1];
       switch(b_201[0]){
         case 0: break;
         case 1:
          switch$0 = 1; break;
         case 2:
          switch$0 = 2; break;
         case 3:
          var
           b_161 = b_201[1],
           _aQ_ =
             function(a_162, b_163){
              var
               t_165 = a_162[2],
               t_164 = a_162[1],
               t_167 = b_163[2],
               t_166 = b_163[1],
               n = caml_call2(Base[159], t_164, t_166);
              return 0 === n ? cmp_a(t_165, t_167) : n;
             };
          return caml_call3(Base[135], _aQ_, a_160, b_161);
         default: return -1;
       }
       break;
      case 4:
       var a_168 = a_200[1];
       switch(b_201[0]){
         case 0: break;
         case 1:
          switch$0 = 1; break;
         case 2:
          switch$0 = 2; break;
         case 3:
          switch$0 = 3; break;
         case 4:
          var
           b_169 = b_201[1],
           _aR_ =
             function(a_170, b_171){
              var
               t_173 = a_170[2],
               t_172 = a_170[1],
               t_175 = b_171[2],
               t_174 = b_171[1],
               n = caml_call2(Base[159], t_172, t_174);
              if(0 !== n) return n;
              function _aV_(a_176, b_177){return cmp_a(a_176, b_177);}
              return caml_call3(Base[135], _aV_, t_173, t_175);
             };
          return caml_call3(Base[135], _aR_, a_168, b_169);
         default: return -1;
       }
       break;
      case 5:
       var a_002 = a_200[1];
       switch(b_201[0]){
         case 0: break;
         case 1:
          switch$0 = 1; break;
         case 2:
          switch$0 = 2; break;
         case 3:
          switch$0 = 3; break;
         case 4:
          switch$0 = 4; break;
         case 5:
          var b_179 = b_201[1];
          if(caml_call2(Ppx_compare_lib[1], a_002, b_179)) return 0;
          var
           _aL_ = b_179[1],
           _aM_ = a_002[1],
           _aN_ =
             function(a_004, b_005){
              var
               t_007 = a_004[2],
               t_006 = a_004[1],
               t_009 = b_005[2],
               t_008 = b_005[1],
               n = caml_call2(Base[159], t_006, t_008);
              if(0 !== n) return n;
              function _aU_(a_182, b_183){return cmp_a(a_182, b_183);}
              return caml_call3(Base[148], _aU_, t_007, t_009);
             };
          return caml_call3(Base[135], _aN_, _aM_, _aL_);
         default: return -1;
       }
       break;
      case 6:
       var a_186 = a_200[2], a_184 = a_200[1];
       switch(b_201[0]){
         case 0: break;
         case 1:
          switch$0 = 1; break;
         case 2:
          switch$0 = 2; break;
         case 3:
          switch$0 = 3; break;
         case 4:
          switch$0 = 4; break;
         case 5:
          switch$0 = 5; break;
         case 6:
          var b_187 = b_201[2], b_185 = b_201[1], n$1 = cmp_a(a_184, b_185);
          if(0 !== n$1) return n$1;
          var _aS_ = function(a_188, b_189){return cmp_a(a_188, b_189);};
          return caml_call3(Base[135], _aS_, a_186, b_187);
         default: return -1;
       }
       break;
      case 7:
       var a_192 = a_200[2], a_190 = a_200[1];
       switch(b_201[0]){
         case 0: break;
         case 1:
          switch$0 = 1; break;
         case 2:
          switch$0 = 2; break;
         case 3:
          switch$0 = 3; break;
         case 4:
          switch$0 = 4; break;
         case 5:
          switch$0 = 5; break;
         case 6:
          switch$0 = 6; break;
         case 7:
          var
           b_193 = b_201[2],
           b_191 = b_201[1],
           n$2 = caml_call2(Base[114], a_190, b_191);
          if(0 !== n$2) return n$2;
          var _aT_ = function(a_194, b_195){return cmp_a(a_194, b_195);};
          return caml_call3(Base[135], _aT_, a_192, b_193);
         default: return -1;
       }
       break;
      default:
       var a_196 = a_200[1];
       switch(b_201[0]){
         case 0: break;
         case 1:
          switch$0 = 1; break;
         case 2:
          switch$0 = 2; break;
         case 3:
          switch$0 = 3; break;
         case 4:
          switch$0 = 4; break;
         case 5:
          switch$0 = 5; break;
         case 6:
          switch$0 = 6; break;
         case 7:
          return 1;
         default:
          var b_197 = b_201[1]; return caml_call2(Base[114], a_196, b_197);
       }
    }
    switch(switch$0){
      case 0:
       return 1;
      case 1:
       return 1;
      case 2:
       return 1;
      case 3:
       return 1;
      case 4:
       return 1;
      case 5:
       return 1;
      default: return 1;
    }
   }
   var t0_of_sexp = function _aK_(_aJ_){return _aK_.fun(_aJ_);};
   runtime.caml_update_dummy
    (t0_of_sexp,
     function(sexp_208){
      if(0 === sexp_208[0]){
       var _aG_ = sexp_208[1], switch$0 = 0;
       if
        (caml_string_notequal(_aG_, cst_Exp)
         && caml_string_notequal(_aG_, cst_exp))
        switch$0 = 1;
       if(! switch$0)
        return caml_call2
                (Sexplib0_Sexp_conv_error[5], error_source_206, sexp_208);
      }
      else{
       var _aH_ = sexp_208[1];
       if(! _aH_)
        return caml_call2
                (Sexplib0_Sexp_conv_error[7], error_source_206, sexp_208);
       var _aI_ = _aH_[1];
       if(0 !== _aI_[0])
        return caml_call2
                (Sexplib0_Sexp_conv_error[6], error_source_206, sexp_208);
       var tag_209 = _aI_[1], switch$1 = 0;
       if
        (caml_string_notequal(tag_209, cst_Exp)
         && caml_string_notequal(tag_209, cst_exp))
        switch$1 = 1;
       if(! switch$1){
        var sexp_args_210 = _aH_[2];
        if(sexp_args_210 && ! sexp_args_210[2]){
         var
          arg0_211 = sexp_args_210[1],
          res0_212 = t_of_sexp$1(t0_of_sexp, arg0_211);
         return [0, res0_212];
        }
        return caml_call3
                (Sexplib0_Sexp_conv_error[4],
                 error_source_206,
                 tag_209,
                 sexp_208);
       }
      }
      return caml_call2
              (Sexplib0_Sexp_conv_error[8], error_source_206, sexp_208);
     });
   function sexp_of_t0(param){
    var arg0_213 = param[1], res0_214 = sexp_of_t$2(sexp_of_t0, arg0_213);
    return [1, [0, _r_, [0, res0_214, 0]]];
   }
   function equal_t0(x, y){return 0 === compare_t0(x, y) ? 1 : 0;}
   function var$2(x){return [0, [8, x]];}
   function apply$1(d, xs){return [0, [6, d, xs]];}
   function recurse$1(r, xs){return [0, [7, r, xs]];}
   function get_poly_variant$0(param){
    var cc = param[1];
    if(5 !== cc[0]) return [1, to_string$1(cc)];
    var tab = cc[1];
    return [0, tab];
   }
   function opaque$0(t){return t;}
   function to_digest$1(param){
    var e = param[1];
    return digest_layer(map$0(e, to_digest$1));
   }
   function to_digest$2(e){return to_digest$1(e);}
   function annotate$0(u, x){return [0, [0, u, x]];}
   function basetype$0(u, xs){return [0, [1, u, xs]];}
   function tuple$0(xs){return [0, [2, xs]];}
   function poly_variant$0(loc, xs){
    return [0,
            [5,
             create
              (loc,
               function(_aE_, _aF_){
                return equal_option(equal_t0, _aE_, _aF_);
               },
               xs)]];
   }
   function var$3(n){return [0, [8, n]];}
   function recurse$2(r, xs){return recurse$1(r, xs);}
   function apply$2(d, xs){return apply$1(d, xs);}
   function define$0(x){return x;}
   function record$0(xs){return [0, [3, xs]];}
   function variant$0(xs){return [0, [4, xs]];}
   function create$2(exp){return exp;}
   var
    Create =
      [0,
       annotate$0,
       basetype$0,
       tuple$0,
       poly_variant$0,
       var$3,
       recurse$2,
       apply$2,
       define$0,
       record$0,
       variant$0,
       create$2];
   function to_string_hum(t){
    var _aD_ = sexp_of_t0(t);
    return caml_call2(Base[84][13], 0, _aD_);
   }
   var
    Def$0 = [0],
    Exp1 = [0, var$2, recurse$1, apply$1, opaque$0, get_poly_variant$0],
    sexp_of_t$3 = Base_String[28],
    of_string$1 = Base_String[29],
    to_string$2 = Base_String[30],
    symbol = Base_String[33],
    compare$1 = Base_String[37],
    equal$0 = Base_String[121],
    sexp_of_t$4 = Base_String[28],
    of_string$2 = Base_String[29],
    to_string$3 = Base_String[30],
    comparator = Base_String[45],
    compare$2 = Base[114],
    sexp_of_t$5 = Base[119],
    r = [0, 0];
   function create$3(loc, trips){
    var gid = r[1];
    r[1] = 1 + gid | 0;
    function _aC_(param){
     var t = param[3], vs = param[2], x = param[1];
     return [0, x, [0, vs, t]];
    }
    var members = caml_call2(Base_List[76], trips, _aC_);
    return [0, gid, loc, members];
   }
   function lookup(g, tid){
    var match = caml_call3(Base_List[129][5], g[3], symbol, tid);
    if(match){var scheme = match[1]; return scheme;}
    var
     _az_ = 0,
     _aA_ = 0,
     _aB_ =
       [0,
        [11,
         cst_impossible_lookup_group_un$0,
         [24,
          _x_,
          function(param, custom_printf_285){
           return caml_call1(to_string$2, custom_printf_285);
          },
          _aA_]],
        cst_impossible_lookup_group_un];
    return caml_call2(eval_fail(g[2], _aB_), tid, _az_);
   }
   function annotate$1(v0, v1){return [0, v0, v1];}
   function basetype$1(v0, v1){return [1, v0, v1];}
   function record$1(v0){return [2, v0];}
   function variant$1(v0){return [3, v0];}
   function tuple$1(v0){return [4, v0];}
   function rec_app(v0, v1){return [7, v0, v1];}
   function top_app(v0, v1, v2){return [8, v0, v1, v2];}
   function sexp_of_t$6(param){
    switch(param[0]){
      case 0:
       var
        arg1_287 = param[2],
        arg0_286 = param[1],
        res0_288 = caml_call1(sexp_of_t$0, arg0_286),
        res1_289 = sexp_of_t$6(arg1_287);
       return [1, [0, _y_, [0, res0_288, [0, res1_289, 0]]]];
      case 1:
       var
        arg1_291 = param[2],
        arg0_290 = param[1],
        res0_292 = caml_call1(sexp_of_t$0, arg0_290),
        res1_293 = caml_call2(Base[139], sexp_of_t$6, arg1_291);
       return [1, [0, _z_, [0, res0_292, [0, res1_293, 0]]]];
      case 2:
       var
        arg0_298 = param[1],
        _aw_ =
          function(param){
           var
            arg1_295 = param[2],
            arg0_294 = param[1],
            res0_296 = caml_call1(Base[164], arg0_294),
            res1_297 = sexp_of_t$6(arg1_295);
           return [1, [0, res0_296, [0, res1_297, 0]]];
          },
        res0_299 = caml_call2(Base[139], _aw_, arg0_298);
       return [1, [0, _A_, [0, res0_299, 0]]];
      case 3:
       var
        arg0_304 = param[1],
        _ax_ =
          function(param){
           var
            arg1_301 = param[2],
            arg0_300 = param[1],
            res0_302 = caml_call1(Base[164], arg0_300),
            res1_303 = caml_call2(Base[139], sexp_of_t$6, arg1_301);
           return [1, [0, res0_302, [0, res1_303, 0]]];
          },
        res0_305 = caml_call2(Base[139], _ax_, arg0_304);
       return [1, [0, _B_, [0, res0_305, 0]]];
      case 4:
       var
        arg0_306 = param[1],
        res0_307 = caml_call2(Base[139], sexp_of_t$6, arg0_306);
       return [1, [0, _C_, [0, res0_307, 0]]];
      case 5:
       var
        arg0_312 = param[1],
        arg1_309 = arg0_312[2],
        arg0_308 = arg0_312[1],
        res0_310 = caml_call1(sexp_of_t, arg0_308),
        _ay_ =
          function(param){
           if(-59723313 <= param[1]){
            var
             v_245 = param[2],
             arg1_247 = v_245[2],
             arg0_246 = v_245[1],
             res0_248 = caml_call1(Base[164], arg0_246),
             res1_249 = caml_call2(Base[152], sexp_of_t$6, arg1_247);
            return [1, [0, _s_, [0, [1, [0, res0_248, [0, res1_249, 0]]], 0]]];
           }
           var
            v_250 = param[2],
            arg1_252 = v_250[2],
            arg0_251 = v_250[1],
            res0_253 = caml_call1(sexp_of_t, arg0_251),
            res1_254 = sexp_of_t$6(arg1_252);
           return [1, [0, _t_, [0, [1, [0, res0_253, [0, res1_254, 0]]], 0]]];
          },
        res1_311 = caml_call2(Base[139], _ay_, arg1_309),
        res0_313 = [1, [0, res0_310, [0, res1_311, 0]]];
       return [1, [0, _D_, [0, res0_313, 0]]];
      case 6:
       var
        arg0_318 = param[1],
        arg1_315 = arg0_318[2],
        arg0_314 = arg0_318[1],
        res0_316 = caml_call1(sexp_of_t, arg0_314),
        res1_317 = caml_call1(sexp_of_t$4, arg1_315),
        res0_319 = [1, [0, res0_316, [0, res1_317, 0]]];
       return [1, [0, _E_, [0, res0_319, 0]]];
      case 7:
       var
        arg1_321 = param[2],
        arg0_320 = param[1],
        res0_322 = caml_call1(sexp_of_t$3, arg0_320),
        res1_323 = caml_call2(Base[139], sexp_of_t$6, arg1_321);
       return [1, [0, _F_, [0, res0_322, [0, res1_323, 0]]]];
      default:
       var
        arg2_326 = param[3],
        arg1_325 = param[2],
        arg0_324 = param[1],
        members_275 = arg0_324[3],
        loc_273 = arg0_324[2],
        gid_271 = arg0_324[1],
        bnds_270 = 0,
        _av_ =
          function(param){
           var
            arg1_282 = param[2],
            arg0_281 = param[1],
            res0_283 = caml_call1(sexp_of_t$3, arg0_281),
            arg1_278 = arg1_282[2],
            arg0_277 = arg1_282[1],
            res0_279 = caml_call2(Base[139], sexp_of_t$4, arg0_277),
            res1_280 = sexp_of_t$6(arg1_278),
            res1_284 = [1, [0, res0_279, [0, res1_280, 0]]];
           return [1, [0, res0_283, [0, res1_284, 0]]];
          },
        arg_276 = caml_call2(Base[139], _av_, members_275),
        bnds_270$0 = [0, [1, [0, _u_, [0, arg_276, 0]]], bnds_270],
        arg_274 = caml_call1(sexp_of_t, loc_273),
        bnds_270$1 = [0, [1, [0, _v_, [0, arg_274, 0]]], bnds_270$0],
        arg_272 = caml_call1(sexp_of_t$5, gid_271),
        bnds_270$2 = [0, [1, [0, _w_, [0, arg_272, 0]]], bnds_270$1],
        res0_327 = [1, bnds_270$2],
        res1_328 = caml_call1(sexp_of_t$3, arg1_325),
        res2_329 = caml_call2(Base[139], sexp_of_t$6, arg2_326);
       return [1, [0, _G_, [0, res0_327, [0, res1_328, [0, res2_329, 0]]]]];
    }
   }
   function constr(s, t){return [0, -59723313, [0, s, t]];}
   function inherit(loc, t){return [0, -72987685, [0, loc, t]];}
   function var$4(loc, t){return [6, [0, loc, t]];}
   function poly_variant$1(loc, xs){return [5, [0, loc, xs]];}
   function is_cyclic_0(via_VR, group, tid){
    var set = [0, 0];
    function visited(tid){
     return caml_call3(Base_List[6], set[1], tid, equal$0);
    }
    function trav(param){
     var param$0 = param;
     for(;;){
      switch(param$0[0]){
        case 0:
         var t = param$0[2], param$0 = t; continue;
        case 1:
         var ts = param$0[2]; break;
        case 2:
         var xs = param$0[1];
         if(! via_VR) return 0;
         var _as_ = function(param){var t = param[2]; return trav(t);};
         return caml_call2(Base_List[9], xs, _as_);
        case 3:
         var xs$0 = param$0[1];
         if(! via_VR) return 0;
         var
          _at_ =
            function(param){
             var ts = param[2];
             return caml_call2(Base_List[9], ts, trav);
            };
         return caml_call2(Base_List[9], xs$0, _at_);
        case 4:
         var ts = param$0[1]; break;
        case 5:
         var
          cs = param$0[1][2],
          _au_ =
            function(param){
             if(-59723313 > param[1]){
              var t$0 = param[2][2];
              return trav(t$0);
             }
             var match = param[2][2];
             if(! match) return 0;
             var t = match[1];
             return trav(t);
            };
         return caml_call2(Base_List[9], cs, _au_);
        case 6:
         return 0;
        case 7:
         var ts$0 = param$0[2], tid = param$0[1];
         if(! visited(tid)){set[1] = [0, tid, set[1]]; trav_tid(tid);}
         return caml_call2(Base_List[9], ts$0, trav);
        default: var ts = param$0[3];
      }
      return caml_call2(Base_List[9], ts, trav);
     }
    }
    function trav_tid(tid){
     var body = lookup(group, tid)[2];
     return trav(body);
    }
    trav_tid(tid);
    var res = visited(tid);
    return res;
   }
   var _H_ = 1, _I_ = 0;
   function Evaluation(Canonical){
    var func = Base_List[10], _P_ = caml_call1(Base_Map[6], [0, comparator]);
    function _Q_(t, param){
     var v = param[2], k = param[1];
     return caml_call3(Base_Map[28], t, k, v);
    }
    function create(_ar_){return caml_call3(func, _ar_, _P_, _Q_);}
    function lookup$0(t, k){return caml_call2(Base_Map[36], t, k);}
    var Venv = [0, lookup$0, create], Applicand = [0];
    function compare(a_330, b_331){
     var
      t_333 = a_330[2],
      t_332 = a_330[1],
      t_335 = b_331[2],
      t_334 = b_331[1],
      n = caml_call2(compare$2, t_332, t_334);
     return 0 === n ? caml_call2(compare$1, t_333, t_335) : n;
    }
    function sexp_of_t(param){
     var
      arg1_337 = param[2],
      arg0_336 = param[1],
      res0_338 = caml_call1(sexp_of_t$5, arg0_336),
      res1_339 = caml_call1(sexp_of_t$3, arg1_337);
     return [1, [0, res0_338, [0, res1_339, 0]]];
    }
    var
     T = [0, compare, sexp_of_t],
     include = caml_call1(Base_Comparator[5], T),
     comparator$0 = include[1];
    function find(t, k){return caml_call2(Base_Map[36], t, k);}
    var empty = caml_call1(Base_Map[6], [0, comparator$0]);
    function extend(t, k, v){return caml_call3(Base_Map[28], t, k, v);}
    var Tenv = [0, find, empty, extend];
    function return$0(x, param, tenv){return x;}
    function bind(t, f, depth, tenv){
     var x = caml_call2(t, depth, tenv);
     return caml_call2(caml_call1(f, x), depth, tenv);
    }
    function look_env(key, param, tenv){
     var result = caml_call2(Tenv[1], tenv, key);
     function _aq_(param){var x = param[2]; return [0, x];}
     return caml_call2(Base_Option[21], result, _aq_);
    }
    function extend_new_tid(key, def_t, depth, tenv){
     var
      value = [0, -271630457, depth],
      tenv$0 = caml_call3(Tenv[3], tenv, key, value);
     return [1, caml_call2(def_t, depth + 1 | 0, tenv$0)];
    }
    function exec(t){return caml_call2(t, 0, Tenv[2]);}
    var
     Defining = [0, return$0, bind, look_env, extend_new_tid, exec],
     symbol_bind = Defining[2],
     return$1 = Defining[1];
    function sequence_defining(xs, f){
     function loop(acc_ys, param){
      if(! param)
       return caml_call1(return$1, caml_call1(Base_List[38], acc_ys));
      var xs = param[2], x = param[1];
      function _ap_(y){return loop([0, y, acc_ys], xs);}
      return caml_call2(symbol_bind, caml_call1(f, x), _ap_);
     }
     return loop(0, xs);
    }
    function _R_(group, venv, t){
     switch(t[0]){
       case 0:
        var
         t$0 = t[2],
         s = t[1],
         _ab_ =
           function(v){
            return caml_call1(return$1, caml_call2(Canonical[4][1], s, v));
           };
        return caml_call2(symbol_bind, _R_(group, venv, t$0), _ab_);
       case 1:
        var
         ts = t[2],
         s$0 = t[1],
         _ac_ =
           function(vs){
            return caml_call1(return$1, caml_call2(Canonical[4][2], s$0, vs));
           };
        return caml_call2(symbol_bind, eval_list(group, venv, ts), _ac_);
       case 2:
        var
         binds = t[1],
         _ad_ =
           function(binds){
            return caml_call1(return$1, caml_call1(Canonical[4][9], binds));
           };
        return caml_call2
                (symbol_bind,
                 sequence_defining
                  (binds,
                   function(param){
                    var x = param[2], s = param[1];
                    function _ao_(y){return caml_call1(return$1, [0, s, y]);}
                    return caml_call2(symbol_bind, _R_(group, venv, x), _ao_);
                   }),
                 _ad_);
       case 3:
        var
         alts = t[1],
         _ae_ =
           function(alts){
            return caml_call1(return$1, caml_call1(Canonical[4][10], alts));
           };
        return caml_call2
                (symbol_bind,
                 sequence_defining
                  (alts,
                   function(param){
                    var xs = param[2], s = param[1];
                    function _an_(ys){return caml_call1(return$1, [0, s, ys]);}
                    return caml_call2
                            (symbol_bind, eval_list(group, venv, xs), _an_);
                   }),
                 _ae_);
       case 4:
        var
         ts$0 = t[1],
         _af_ =
           function(vs){
            return caml_call1(return$1, caml_call1(Canonical[4][3], vs));
           };
        return caml_call2(symbol_bind, eval_list(group, venv, ts$0), _af_);
       case 5:
        var
         match = t[1],
         cs = match[2],
         loc = match[1],
         _ag_ =
           function(xss){
            var _am_ = caml_call1(Base_List[138], xss);
            return caml_call1
                    (return$1, caml_call2(Canonical[4][4], loc, _am_));
           };
        return caml_call2
                (symbol_bind,
                 sequence_defining
                  (cs,
                   function(_al_){return eval_poly_constr(group, venv, _al_);}),
                 _ag_);
       case 6:
        var
         match$0 = t[1],
         vid = match$0[2],
         loc$0 = match$0[1],
         match$1 = caml_call2(Venv[1], venv, vid);
        if(match$1){var x = match$1[1]; return caml_call1(return$1, x);}
        var _ah_ = 0, _ai_ = 0;
        return caml_call2
                (eval_fail
                  (loc$0,
                   [0,
                    [11,
                     cst_Free_type_variable,
                     [24,
                      _J_,
                      function(param, custom_printf_340){
                       return caml_call1(to_string$3, custom_printf_340);
                      },
                      _ai_]],
                    cst_Free_type_variable_Vid]),
                 vid,
                 _ah_);
       case 7:
        var
         args = t[2],
         tid = t[1],
         _aj_ = function(args){return eval_app(group, tid, args);};
        return caml_call2(symbol_bind, eval_list(group, venv, args), _aj_);
       default:
        var
         args$0 = t[3],
         tid$0 = t[2],
         in_group = t[1],
         _ak_ = function(args){return eval_app(in_group, tid$0, args);};
        return caml_call2(symbol_bind, eval_list(group, venv, args$0), _ak_);
     }
    }
    function eval_list(group, venv, ts){
     return sequence_defining
             (ts, function(_aa_){return _R_(group, venv, _aa_);});
    }
    function eval_poly_constr(group, venv, c){
     if(-59723313 > c[1]){
      var
       match$0 = c[2],
       t$0 = match$0[2],
       loc = match$0[1],
       _$_ =
         function(v){
          var match = caml_call1(Canonical[2][5], v);
          if(0 === match[0]){
           var tab = match[1];
           return caml_call1(return$1, tab[1]);
          }
          var desc = match[1];
          return caml_call2(eval_fail(loc, _K_), desc, 0);
         };
      return caml_call2(symbol_bind, _R_(group, venv, t$0), _$_);
     }
     var _Z_ = c[2], match = _Z_[2], s = _Z_[1];
     if(! match) return caml_call1(return$1, [0, [0, s, 0], 0]);
     var t = match[1];
     function ___(v){
      return caml_call1
              (return$1, [0, [0, s, [0, caml_call1(Canonical[2][4], v)]], 0]);
     }
     return caml_call2(symbol_bind, _R_(group, venv, t), ___);
    }
    function eval_definition(group, formals, body){
     function _W_(i, x){return [0, x, caml_call1(Canonical[2][1], i)];}
     var
      _X_ = caml_call2(Base_List[96], formals, _W_),
      venv = caml_call1(Venv[2], _X_);
     function _Y_(v){
      return caml_call1(return$1, caml_call1(Canonical[4][8], v));
     }
     return caml_call2(symbol_bind, _R_(group, venv, body), _Y_);
    }
    function eval_app(group, tid, args){
     var
      gid = group[1],
      match = lookup(group, tid),
      body = match[2],
      formals = match[1];
     switch(body[0]){
       case 2:
       case 3:
        var record_or_normal_variant = 1; break;
       default: var record_or_normal_variant = 0;
     }
     var
      cyclic = is_cyclic_0(_H_, group, tid),
      cyclic_no_VR = is_cyclic_0(_I_, group, tid),
      switch$0 = 0;
     if(record_or_normal_variant && cyclic) switch$0 = 1;
     if(! switch$0 && ! cyclic_no_VR){
      var match$0 = caml_call2(Base_List[94], formals, args);
      if(match$0)
       var x = match$0[1], venv = caml_call1(Venv[2], x);
      else
       var venv = caml_call1(Base[200], cst_apply_incorrect_type_appli);
      return _R_(group, venv, body);
     }
     function _T_(param){
      if(0 === param[0]){
       var r = param[1];
       return caml_call1(return$1, caml_call2(Canonical[2][2], r, args));
      }
      var def = param[1];
      return caml_call1(return$1, caml_call2(Canonical[2][3], def, args));
     }
     function _U_(param){
      if(param){var recurse = param[1]; return caml_call1(return$1, recurse);}
      var _V_ = eval_definition(group, formals, body);
      return caml_call2(Defining[4], [0, gid, tid], _V_);
     }
     return caml_call2
             (symbol_bind,
              caml_call2
               (symbol_bind, caml_call1(Defining[3], [0, gid, tid]), _U_),
              _T_);
    }
    function eval$0(t){
     var
      group = create$3(caml_call1(of_string, cst_top_level), 0),
      venv = caml_call1(Venv[2], 0),
      _S_ = _R_(group, venv, t),
      v = caml_call1(Defining[5], _S_);
     return caml_call1(Canonical[4][11], v);
    }
    return [0,
            Venv,
            Applicand,
            Tenv,
            Defining,
            symbol_bind,
            return$1,
            sequence_defining,
            eval_list,
            eval_poly_constr,
            eval_definition,
            eval_app,
            eval$0];
   }
   var
    Exp = [0],
    include = Evaluation([0, to_digest$2, Exp1, Def$0, Create]),
    eval$0 = include[12],
    Evaluation_to_digest = Evaluation(Canonical_digest);
   function eval_to_digest(exp){
    var _O_ = caml_call1(Evaluation_to_digest[12], exp);
    return caml_call1(Canonical_digest[1], _O_);
   }
   function eval_to_digest_string(exp){
    return caml_call1(to_hex, eval_to_digest(exp));
   }
   var
    Not_a_tuple =
      [248, cst_Bin_shape_lib_Bin_shape_Fo, runtime.caml_fresh_oo_id(0)];
   function _L_(param){
    if(param[1] !== Not_a_tuple)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _N_], 1);
    var arg0_341 = param[2], res0_342 = sexp_of_t$6(arg0_341);
    return [1, [0, _M_, [0, res0_342, 0]]];
   }
   caml_call4(Sexplib0_Sexp_conv[70][1], 0, 0, Not_a_tuple, _L_);
   function deconstruct_tuple_exn(t){
    if(4 !== t[0]) throw caml_maybe_attach_backtrace([0, Not_a_tuple, t], 1);
    var ts = t[1];
    return ts;
   }
   var
    Bin_shape_lib_Bin_shape =
      [0,
       sexp_of_t$6,
       [0, of_string$1],
       [0, of_string$2],
       [0, of_string],
       [0, of_string$0],
       create$3,
       tuple$1,
       record$1,
       variant$1,
       constr,
       inherit,
       poly_variant$1,
       rec_app,
       top_app,
       var$4,
       basetype$1,
       annotate$1,
       [0, compare$0, t_of_sexp$0, sexp_of_t$1, to_hex, to_md5, of_md5],
       [0,
        compare_t0,
        sexp_of_t0,
        to_string_hum,
        to_digest$2,
        Exp,
        Def$0,
        [0,
         Create[1],
         Create[2],
         Create[3],
         Create[4],
         Create[5],
         Create[7],
         Create[6],
         Create[8],
         Create[9],
         Create[10],
         Create[11]]],
       eval$0,
       eval_to_digest,
       eval_to_digest_string,
       [0, deconstruct_tuple_exn]];
   runtime.caml_register_global
    (133, Bin_shape_lib_Bin_shape, "Bin_shape_lib__Bin_shape");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Bin_shape_lib__Std
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Bin_shape_lib_Std = [0];
   runtime.caml_register_global(0, Bin_shape_lib_Std, "Bin_shape_lib__Std");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiaW5fc2hhcGVfbGliLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJlcnJvcl9zb3VyY2VfMDI2IiwiZXJyb3Jfc291cmNlXzA0MiIsImVycm9yX3NvdXJjZV8yMDYiLCJzZXhwX29mX3QiLCJvZl9zdHJpbmciLCJ0b19zdHJpbmciLCJ0X29mX3NleHAiLCJzZXhwX29mX3QkMCIsIm9mX3N0cmluZyQwIiwidG9fc3RyaW5nJDAiLCJjb21wYXJlIiwiZXZhbF9mYWlsIiwibG9jIiwiZm10IiwicyIsImN1c3RvbV9wcmludGZfMDAxIiwiZXF1YWxfb3B0aW9uIiwiZXF1YWwiLCJhIiwiYiIsInkiLCJ4IiwiY3JlYXRlIiwiZXEiLCJ4cyQxIiwiczIiLCJzMSIsInNvcnRlZCIsInhzJDAiLCJsYXN0X3ZhbHVlJDEiLCJsYXN0X2tleSQxIiwiYWNjIiwibGFzdF9rZXkiLCJsYXN0X3ZhbHVlIiwieHMiLCJsYXN0X3ZhbHVlJDAiLCJsYXN0X2tleSQwIiwic29ydGVkJDAiLCJtYXAiLCJ0IiwiZiIsInYiLCJrIiwidG9fbWQ1Iiwib2ZfbWQ1Iiwic2V4cF9vZl90JDEiLCJ0X29mX3NleHAkMCIsInV1aWQiLCJ1IiwiaW50JDAiLCJwYWlyIiwibGlzdCIsImwiLCJjb25zdHJ1Y3RvciIsInRfb2Zfc2V4cCQxIiwib2ZfYV8wMzkiLCJzZXhwXzA0NCIsInRhZ18wNDUiLCJzZXhwX2FyZ3NfMDQ2IiwiYXJnMV8wNDgiLCJhcmcwXzA0NyIsInJlczBfMDQ5IiwicmVzMV8wNTAiLCJzZXhwX2FyZ3NfMDUzIiwiYXJnMV8wNTUiLCJhcmcwXzA1NCIsInJlczBfMDU2IiwicmVzMV8wNTciLCJzZXhwX2FyZ3NfMDYwIiwiYXJnMF8wNjEiLCJyZXMwXzA2MiIsInNleHBfYXJnc18wNjUiLCJhcmcwXzA3MSIsInNleHBfMDcwIiwiYXJnMV8wNjciLCJhcmcwXzA2NiIsInJlczBfMDY4IiwicmVzMV8wNjkiLCJyZXMwXzA3MiIsInNleHBfYXJnc18wNzUiLCJhcmcwXzA4MSIsInNleHBfMDgwIiwiYXJnMV8wNzciLCJhcmcwXzA3NiIsInJlczBfMDc4IiwicmVzMV8wNzkiLCJyZXMwXzA4MiIsInNleHBfYXJnc18wODUiLCJhcmcwXzA4NiIsIm9mX2FfMDEwIiwicmVzMF8wODciLCJmaWVsZF9zZXhwc18wMTMiLCJzb3J0ZWRfMDE0IiwiZHVwbGljYXRlc18wMTYiLCJleHRyYV8wMTciLCJzZXhwXzAxMiIsImZpZWxkX3NleHBzXzAyMCIsImZpZWxkX25hbWVfMDE4IiwidGFpbF8wMjkiLCJ4XzAzMCIsImZpZWxkX3NleHBfMDE5Iiwic2V4cF8wMjUiLCJhcmcxXzAyMiIsImFyZzBfMDIxIiwicmVzMF8wMjMiLCJyZXMxXzAyNCIsImZ2YWx1ZV8wMjciLCJzb3J0ZWRfMDE1Iiwic2V4cF9hcmdzXzA5MCIsImFyZzFfMDkyIiwiYXJnMF8wOTEiLCJyZXMwXzA5MyIsInJlczFfMDk0Iiwic2V4cF9hcmdzXzA5NyIsImFyZzFfMDk5IiwiYXJnMF8wOTgiLCJyZXMwXzEwMCIsInJlczFfMTAxIiwic2V4cF9hcmdzXzEwNCIsImFyZzBfMTA1IiwicmVzMF8xMDYiLCJzZXhwX29mX3QkMiIsIm9mX2FfMTA4IiwiYXJnMV8xMTAiLCJhcmcwXzEwOSIsInJlczBfMTExIiwicmVzMV8xMTIiLCJhcmcxXzExNCIsImFyZzBfMTEzIiwicmVzMF8xMTUiLCJyZXMxXzExNiIsImFyZzBfMTE3IiwicmVzMF8xMTgiLCJhcmcwXzEyMyIsImFyZzFfMTIwIiwiYXJnMF8xMTkiLCJyZXMwXzEyMSIsInJlczFfMTIyIiwicmVzMF8xMjQiLCJhcmcwXzEyOSIsImFyZzFfMTI2IiwiYXJnMF8xMjUiLCJyZXMwXzEyNyIsInJlczFfMTI4IiwicmVzMF8xMzAiLCJhcmcwXzEzMSIsIm9mX2FfMDMxIiwic29ydGVkXzAzMyIsImJuZHNfMDMyIiwiYXJnMV8wMzYiLCJhcmcwXzAzNSIsInJlczBfMDM3IiwicmVzMV8wMzgiLCJhcmdfMDM0IiwiYm5kc18wMzIkMCIsInJlczBfMTMyIiwiYXJnMV8xMzQiLCJhcmcwXzEzMyIsInJlczBfMTM1IiwicmVzMV8xMzYiLCJhcmcxXzEzOCIsImFyZzBfMTM3IiwicmVzMF8xMzkiLCJyZXMxXzE0MCIsImFyZzBfMTQxIiwicmVzMF8xNDIiLCJtYXAkMCIsIngkMCIsImwkMCIsImwkMSIsIngkMSIsImwkMiIsInQkMCIsInRvX3N0cmluZyQxIiwiZGlnZXN0X2xheWVyIiwidSQwIiwidGFibGUiLCJsJDMiLCJsJDQiLCJuIiwibiQwIiwidG9fZGlnZXN0IiwidG9fZGlnZXN0JDAiLCJ4JDIiLCJvcGFxdWUiLCJjcmVhdGUkMCIsImRlc2MiLCJ2YXIkMCIsImFwcGx5IiwiZGVmIiwicmVjdXJzZSIsInRpZCIsImdldF9wb2x5X3ZhcmlhbnQiLCJhbm5vdGF0ZSIsImJhc2V0eXBlIiwidHVwbGUiLCJwb2x5X3ZhcmlhbnQiLCJ2YXIkMSIsImFwcGx5JDAiLCJyZWN1cnNlJDAiLCJkZWZpbmUiLCJyZWNvcmQiLCJ2YXJpYW50IiwiY3JlYXRlJDEiLCJlIiwiY29tcGFyZV90MCIsImFfMTk4IiwiYl8xOTkiLCJiXzIwMSIsImFfMjAwIiwiY21wX2EiLCJhXzIwMiIsImJfMjAzIiwiYV8xNDYiLCJiXzE0OSIsImJfMTQ3IiwiYV8xNDgiLCJhXzE1MiIsImFfMTUwIiwiYl8xNTMiLCJiXzE1MSIsImFfMTU0IiwiYl8xNTUiLCJhXzE1NiIsImJfMTU3IiwiYV8xNTgiLCJiXzE1OSIsImFfMTYwIiwiYl8xNjEiLCJhXzE2MiIsImJfMTYzIiwidF8xNjUiLCJ0XzE2NCIsInRfMTY3IiwidF8xNjYiLCJhXzE2OCIsImJfMTY5IiwiYV8xNzAiLCJiXzE3MSIsInRfMTczIiwidF8xNzIiLCJ0XzE3NSIsInRfMTc0IiwiYV8xNzYiLCJiXzE3NyIsImFfMDAyIiwiYl8xNzkiLCJhXzAwNCIsImJfMDA1IiwidF8wMDciLCJ0XzAwNiIsInRfMDA5IiwidF8wMDgiLCJhXzE4MiIsImJfMTgzIiwiYV8xODYiLCJhXzE4NCIsImJfMTg3IiwiYl8xODUiLCJuJDEiLCJhXzE4OCIsImJfMTg5IiwiYV8xOTIiLCJhXzE5MCIsImJfMTkzIiwiYl8xOTEiLCJuJDIiLCJhXzE5NCIsImJfMTk1IiwiYV8xOTYiLCJiXzE5NyIsInQwX29mX3NleHAiLCJzZXhwXzIwOCIsInRhZ18yMDkiLCJzZXhwX2FyZ3NfMjEwIiwiYXJnMF8yMTEiLCJyZXMwXzIxMiIsInNleHBfb2ZfdDAiLCJhcmcwXzIxMyIsInJlczBfMjE0IiwiZXF1YWxfdDAiLCJ2YXIkMiIsImFwcGx5JDEiLCJkIiwicmVjdXJzZSQxIiwiciIsImdldF9wb2x5X3ZhcmlhbnQkMCIsImNjIiwidGFiIiwib3BhcXVlJDAiLCJ0b19kaWdlc3QkMSIsInRvX2RpZ2VzdCQyIiwiYW5ub3RhdGUkMCIsImJhc2V0eXBlJDAiLCJ0dXBsZSQwIiwicG9seV92YXJpYW50JDAiLCJ2YXIkMyIsInJlY3Vyc2UkMiIsImFwcGx5JDIiLCJkZWZpbmUkMCIsInJlY29yZCQwIiwidmFyaWFudCQwIiwiY3JlYXRlJDIiLCJleHAiLCJ0b19zdHJpbmdfaHVtIiwic2V4cF9vZl90JDMiLCJvZl9zdHJpbmckMSIsInRvX3N0cmluZyQyIiwic3ltYm9sIiwiY29tcGFyZSQxIiwiZXF1YWwkMCIsInNleHBfb2ZfdCQ0Iiwib2Zfc3RyaW5nJDIiLCJ0b19zdHJpbmckMyIsImNvbXBhcmF0b3IiLCJjb21wYXJlJDIiLCJzZXhwX29mX3QkNSIsImNyZWF0ZSQzIiwidHJpcHMiLCJnaWQiLCJ2cyIsIm1lbWJlcnMiLCJsb29rdXAiLCJnIiwic2NoZW1lIiwiY3VzdG9tX3ByaW50Zl8yODUiLCJhbm5vdGF0ZSQxIiwidjAiLCJ2MSIsImJhc2V0eXBlJDEiLCJyZWNvcmQkMSIsInZhcmlhbnQkMSIsInR1cGxlJDEiLCJyZWNfYXBwIiwidG9wX2FwcCIsInYyIiwic2V4cF9vZl90JDYiLCJhcmcxXzI4NyIsImFyZzBfMjg2IiwicmVzMF8yODgiLCJyZXMxXzI4OSIsImFyZzFfMjkxIiwiYXJnMF8yOTAiLCJyZXMwXzI5MiIsInJlczFfMjkzIiwiYXJnMF8yOTgiLCJhcmcxXzI5NSIsImFyZzBfMjk0IiwicmVzMF8yOTYiLCJyZXMxXzI5NyIsInJlczBfMjk5IiwiYXJnMF8zMDQiLCJhcmcxXzMwMSIsImFyZzBfMzAwIiwicmVzMF8zMDIiLCJyZXMxXzMwMyIsInJlczBfMzA1IiwiYXJnMF8zMDYiLCJyZXMwXzMwNyIsImFyZzBfMzEyIiwiYXJnMV8zMDkiLCJhcmcwXzMwOCIsInJlczBfMzEwIiwidl8yNDUiLCJhcmcxXzI0NyIsImFyZzBfMjQ2IiwicmVzMF8yNDgiLCJyZXMxXzI0OSIsInZfMjUwIiwiYXJnMV8yNTIiLCJhcmcwXzI1MSIsInJlczBfMjUzIiwicmVzMV8yNTQiLCJyZXMxXzMxMSIsInJlczBfMzEzIiwiYXJnMF8zMTgiLCJhcmcxXzMxNSIsImFyZzBfMzE0IiwicmVzMF8zMTYiLCJyZXMxXzMxNyIsInJlczBfMzE5IiwiYXJnMV8zMjEiLCJhcmcwXzMyMCIsInJlczBfMzIyIiwicmVzMV8zMjMiLCJhcmcyXzMyNiIsImFyZzFfMzI1IiwiYXJnMF8zMjQiLCJtZW1iZXJzXzI3NSIsImxvY18yNzMiLCJnaWRfMjcxIiwiYm5kc18yNzAiLCJhcmcxXzI4MiIsImFyZzBfMjgxIiwicmVzMF8yODMiLCJhcmcxXzI3OCIsImFyZzBfMjc3IiwicmVzMF8yNzkiLCJyZXMxXzI4MCIsInJlczFfMjg0IiwiYXJnXzI3NiIsImJuZHNfMjcwJDAiLCJhcmdfMjc0IiwiYm5kc18yNzAkMSIsImFyZ18yNzIiLCJibmRzXzI3MCQyIiwicmVzMF8zMjciLCJyZXMxXzMyOCIsInJlczJfMzI5IiwiY29uc3RyIiwiaW5oZXJpdCIsInZhciQ0IiwicG9seV92YXJpYW50JDEiLCJpc19jeWNsaWNfMCIsInZpYV9WUiIsImdyb3VwIiwic2V0IiwidmlzaXRlZCIsInRyYXYiLCJ0cyIsImNzIiwidHMkMCIsInRyYXZfdGlkIiwiYm9keSIsInJlcyIsImxvb2t1cCQwIiwiYV8zMzAiLCJiXzMzMSIsInRfMzMzIiwidF8zMzIiLCJ0XzMzNSIsInRfMzM0IiwiYXJnMV8zMzciLCJhcmcwXzMzNiIsInJlczBfMzM4IiwicmVzMV8zMzkiLCJmaW5kIiwiZW1wdHkiLCJleHRlbmQiLCJyZXR1cm4kMCIsInRlbnYiLCJiaW5kIiwiZGVwdGgiLCJsb29rX2VudiIsImtleSIsInJlc3VsdCIsImV4dGVuZF9uZXdfdGlkIiwiZGVmX3QiLCJ2YWx1ZSIsInRlbnYkMCIsImV4ZWMiLCJzeW1ib2xfYmluZCIsInJldHVybiQxIiwic2VxdWVuY2VfZGVmaW5pbmciLCJsb29wIiwiYWNjX3lzIiwidmVudiIsInMkMCIsImV2YWxfbGlzdCIsImJpbmRzIiwiYWx0cyIsInlzIiwieHNzIiwiZXZhbF9wb2x5X2NvbnN0ciIsInZpZCIsImxvYyQwIiwiY3VzdG9tX3ByaW50Zl8zNDAiLCJhcmdzIiwiZXZhbF9hcHAiLCJhcmdzJDAiLCJ0aWQkMCIsImluX2dyb3VwIiwiYyIsImV2YWxfZGVmaW5pdGlvbiIsImZvcm1hbHMiLCJpIiwicmVjb3JkX29yX25vcm1hbF92YXJpYW50IiwiY3ljbGljIiwiY3ljbGljX25vX1ZSIiwiZXZhbCQwIiwiZXZhbF90b19kaWdlc3QiLCJldmFsX3RvX2RpZ2VzdF9zdHJpbmciLCJkZWNvbnN0cnVjdF90dXBsZV9leG4iXSwic291cmNlcyI6WyIvaG9tZS9uYXRoYW4vLm9wYW0vZGVmYXVsdC9saWIvYmluX3Byb3Qvc2hhcGUvYmluX3NoYXBlLm1sIiwiL3Vzci9saWIvb2NhbWwvc3RyaW5nLm1saSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWdDRUE7SUFtRUFDO0lBbU9FQzs7Ozs7Ozs7Ozs7Ozs7SUNyVElDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7WURISlEsVUFBVUMsS0FBSUM7a0JBQ0tDO0tBQUs7Ozs7OzBCQUEwQkM7NkJDRTlDVixXREY4Q1U7VUFBaUI7OztNQUFs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QkFaRXBJLEtBREloSTs7SUEyQmU7YUFJdkJnUyxPQUNFeGI7S0FDRjtNQUFJd1gsUUFoUkpsRyxTQWdSa0IsV0NodEJoQnpUO01EaXRCRW9jLE9BQU87TUFDVyxVQUZsQnpDLE9BQ0F5QyxNQUZGamE7TUFHRUUsSUFBSTtLQUNSLG9DQURJQTtJQUNxQjtJQXpOYTs7Ozs7WUEwRnRDMFo7WUFDQUM7WUFFQUM7WUEwREFLO1lBR0FLO1lBcUJBVTtZQUtBTDtZQWdDQVc7O0dBWVM7OzZCQTVhTDVMO0lBZ2FKNEw7O1lBcUJGQyxlQUFlakw7SUFBbUMsK0NBQW5DQTtJQUFtQztHQUErQjtZQUNqRmtMLHNCQUFzQmxMO0lBQU0sT0FBYyxtQkFEMUNpTCxlQUNzQmpMO0dBQXdDO0dBR2hFOzs7O0k7O3dDQWhWT2lDOzs7O1lBa1ZIa0osc0JBQXNCM2I7SUFDeEIsU0FEd0JBLE1BR2pCLG1EQUhpQkE7UUFFaEI0WCxLQUZnQjVYO0lBRVYsT0FBTjRYO0dBQ29COzs7O09BclZ2Qm5GO1dDdlpEOUI7Ozs7T0RnY0ZXO09BZEplOzs7T0FrQkk2RTtPQUNBQztPQUVBRTtPQXJCSi9FOztPQW9CSThFO09BRUFsRjtPQXRCSkg7c0JBaFhJeFIsYUFEQUQscUJBRkFGLFFBQ0FDOztRQTRPSmlLOztRQUlBbUc7UUFGUWI7Ozs7Ozs7Ozs7Ozs7OztPQWdhSjRMO09BcUJGQztPQUNBQztXQUtFQzs7OztFIiwic291cmNlc0NvbnRlbnQiOlsib3BlbiEgQmFzZVxuXG5tb2R1bGUgTG9jYXRpb24gOiBzaWdcbiAgaW5jbHVkZSBJZGVudGlmaWFibGUuU1xuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgU3RyaW5nXG5lbmRcblxubW9kdWxlIFV1aWQgOiBzaWdcbiAgaW5jbHVkZSBJZGVudGlmaWFibGUuU1xuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgU3RyaW5nXG5lbmRcblxubGV0IGV2YWxfZmFpbCBsb2MgZm10ID1cbiAgUHJpbnRmLmtzcHJpbnRmIChmdW4gcyAtPiBmYWlsd2l0aCAoUHJpbnRmLnNwcmludGYgIVwiJXtMb2NhdGlvbn06ICVzXCIgbG9jIHMpKSBmbXRcbjs7XG5cbmxldCBlcXVhbF9vcHRpb24gZXF1YWwgYSBiID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgU29tZSBfLCBOb25lIHwgTm9uZSwgU29tZSBfIC0+IGZhbHNlXG4gIHwgTm9uZSwgTm9uZSAtPiB0cnVlXG4gIHwgU29tZSB4LCBTb21lIHkgLT4gZXF1YWwgeCB5XG47O1xuXG5tb2R1bGUgU29ydGVkX3RhYmxlIDogc2lnXG4gIHR5cGUgJ2EgdCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gIHZhbCBjcmVhdGUgOiBMb2NhdGlvbi50IC0+IGVxOignYSAtPiAnYSAtPiBib29sKSAtPiAoc3RyaW5nICogJ2EpIGxpc3QgLT4gJ2EgdFxuICB2YWwgZXhwb3NlIDogJ2EgdCAtPiAoc3RyaW5nICogJ2EpIGxpc3RcbiAgdmFsIG1hcCA6ICdhIHQgLT4gZjooJ2EgLT4gJ2IpIC0+ICdiIHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSB7IHNvcnRlZCA6IChzdHJpbmcgKiAnYSkgbGlzdCB9IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgbGV0IG1lcmdlX2NoZWNrX2FkamFjZW50X2R1cHNcbiAgICA6ICBlcTooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gKHN0cmluZyAqICdhKSBsaXN0XG4gICAgICAtPiBbIGBPayBvZiAoc3RyaW5nICogJ2EpIGxpc3QgfCBgTWlzbWF0Y2ggb2Ygc3RyaW5nIF1cbiAgICA9XG4gICAgZnVuIH5lcSAtPlxuICAgIGxldCByZWMgbG9vcCBhY2Mgfmxhc3Rfa2V5IH5sYXN0X3ZhbHVlID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gYE9rIChMaXN0LnJldiBhY2MpXG4gICAgICB8IChrZXksIHZhbHVlKSA6OiB4cyAtPlxuICAgICAgICBpZiBTdHJpbmcuKGxhc3Rfa2V5ID0ga2V5KVxuICAgICAgICB0aGVuXG4gICAgICAgICAgaWYgZXEgbGFzdF92YWx1ZSB2YWx1ZSB0aGVuIGxvb3AgYWNjIH5sYXN0X2tleSB+bGFzdF92YWx1ZSB4cyBlbHNlIGBNaXNtYXRjaCBrZXlcbiAgICAgICAgZWxzZSBsb29wICgoa2V5LCB2YWx1ZSkgOjogYWNjKSB+bGFzdF9rZXk6a2V5IH5sYXN0X3ZhbHVlOnZhbHVlIHhzXG4gICAgaW5cbiAgICBmdW5jdGlvblxuICAgIHwgW10gLT4gYE9rIFtdXG4gICAgfCAoa2V5LCB2YWx1ZSkgOjogeHMgLT4gbG9vcCBbIGtleSwgdmFsdWUgXSB+bGFzdF9rZXk6a2V5IH5sYXN0X3ZhbHVlOnZhbHVlIHhzXG4gIDs7XG5cbiAgbGV0IGNyZWF0ZSBsb2MgfmVxIHhzID1cbiAgICBsZXQgc29ydGVkID0gTGlzdC5zb3J0IH5jb21wYXJlOihmdW4gKHMxLCBfKSAoczIsIF8pIC0+IFN0cmluZy5jb21wYXJlIHMxIHMyKSB4cyBpblxuICAgIG1hdGNoIG1lcmdlX2NoZWNrX2FkamFjZW50X2R1cHMgfmVxIHNvcnRlZCB3aXRoXG4gICAgfCBgT2sgc29ydGVkIC0+IHsgc29ydGVkIH1cbiAgICB8IGBNaXNtYXRjaCBzIC0+XG4gICAgICBldmFsX2ZhaWwgbG9jIFwiRGlmZmVyZW50IHNoYXBlcyBmb3IgZHVwbGljYXRlZCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3RvcjogYCVzXCIgcyAoKVxuICA7O1xuXG4gIGxldCBleHBvc2UgdCA9IHQuc29ydGVkXG4gIGxldCBtYXAgdCB+ZiA9IHsgc29ydGVkID0gTGlzdC5tYXAgdC5zb3J0ZWQgfmY6KGZ1biAoaywgdikgLT4gaywgZiB2KSB9XG5lbmRcblxubW9kdWxlIERpZ2VzdCA6IHNpZ1xuICB0eXBlIHQgPSBNZDVfbGliLnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICB2YWwgdG9fbWQ1IDogdCAtPiBNZDVfbGliLnRcbiAgdmFsIG9mX21kNSA6IE1kNV9saWIudCAtPiB0XG4gIHZhbCB0b19oZXggOiB0IC0+IHN0cmluZ1xuICB2YWwgY29uc3RydWN0b3IgOiBzdHJpbmcgLT4gdCBsaXN0IC0+IHRcbiAgdmFsIGxpc3QgOiB0IGxpc3QgLT4gdFxuICB2YWwgcGFpciA6IHQgLT4gdCAtPiB0XG4gIHZhbCBzdHJpbmcgOiBzdHJpbmcgLT4gdFxuICB2YWwgdXVpZCA6IFV1aWQudCAtPiB0XG4gIHZhbCBpbnQgOiBpbnQgLT4gdFxuICB2YWwgb3B0aW9uIDogdCBvcHRpb24gLT4gdFxuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgTWQ1X2xpYlxuXG4gIGxldCB0b19tZDUgdCA9IHRcbiAgbGV0IG9mX21kNSB0ID0gdFxuICBsZXQgc2V4cF9vZl90IHQgPSB0IHw+IHRvX2hleCB8PiBzZXhwX29mX3N0cmluZ1xuICBsZXQgdF9vZl9zZXhwIHMgPSBzIHw+IHN0cmluZ19vZl9zZXhwIHw+IG9mX2hleF9leG5cbiAgbGV0IHV1aWQgdSA9IHN0cmluZyAoVXVpZC50b19zdHJpbmcgdSlcbiAgbGV0IGludCB4ID0gc3RyaW5nIChJbnQudG9fc3RyaW5nIHgpXG4gIGxldCBwYWlyIHggeSA9IHN0cmluZyAodG9fYmluYXJ5IHggXiB0b19iaW5hcnkgeSlcbiAgbGV0IGxpc3QgbCA9IHN0cmluZyAoU3RyaW5nLmNvbmNhdCB+c2VwOlwiXCIgKExpc3QubWFwIH5mOnRvX2JpbmFyeSBsKSlcbiAgbGV0IGNvbnN0cnVjdG9yIHMgbCA9IHN0cmluZyAocyBeIHRvX2JpbmFyeSAobGlzdCBsKSlcblxuICBsZXQgb3B0aW9uID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gY29uc3RydWN0b3IgXCJub25lXCIgW11cbiAgICB8IFNvbWUgeCAtPiBjb25zdHJ1Y3RvciBcInNvbWVcIiBbIHggXVxuICA7O1xuZW5kXG5cbm1vZHVsZSBDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yID0gc3RydWN0XG4gICgqIFsnYSB0XSBpcyBhIG5vbi1yZWN1cnNpdmUgdHlwZSwgdXNlZCB0byByZXByZXNlbnQgMS1sYXllciBvZiBleHByZXNzaW9uLiAgVGhlXG4gICAgIHJlY3Vyc2l2ZSBrbm90IGlzIHRpZWQgYmVsb3cgaW4gW0Nhbm9uaWNhbF9mdWxsLkV4cC50XS4gKilcbiAgdHlwZSAnYSB0ID1cbiAgICB8IEFubm90YXRlIG9mIFV1aWQudCAqICdhXG4gICAgfCBCYXNlIG9mIFV1aWQudCAqICdhIGxpc3RcbiAgICB8IFR1cGxlIG9mICdhIGxpc3RcbiAgICB8IFJlY29yZCBvZiAoc3RyaW5nICogJ2EpIGxpc3RcbiAgICB8IFZhcmlhbnQgb2YgKHN0cmluZyAqICdhIGxpc3QpIGxpc3RcbiAgICAoKiBQb2x5bW9ycGhpYyB2YXJpYW50cyBhcmUgaW5zZW5zaXRpdmUgdG8gdGhlIG9yZGVyIHRoZSBjb25zdHJ1Y3RvcnMgYXJlIGxpc3RlZCAqKVxuICAgIHwgUG9seV92YXJpYW50IG9mICdhIG9wdGlvbiBTb3J0ZWRfdGFibGUudFxuICAgICgqIExlZnQtaGFuZC1zaWRlIG9mIFtBcHBsaWNhdGlvbl0gaXMgYSBwb3RlbnRpYWxseSByZWN1cnNpdmUgZGVmaW5pdGlvbjogaXRcbiAgICAgICBjYW4gcmVmZXIgdG8gaXRzZWxmIHVzaW5nIFtSZWNfYXBwIChpLCBfKV0gd2hlcmUgW2ldIGlzIHRoZSBkZXB0aCBvZiB0aGlzXG4gICAgICAgYXBwbGljYXRpb24gbm9kZSAoaG93IG1hbnkgYXBwbGljYXRpb24gbm9kZXMgYXJlIGFib3ZlIGl0KS5cbiAgICAgICBJdCBhbHNvIGhhcyBpdHMgb3duIHNjb3BlIG9mIHR5cGUgdmFyaWFibGVzIHNvIGl0IGNhbiBub3QgcmVmZXIgdG8gdHlwZSB2YXJpYWJsZXNcbiAgICAgICBvZiB0aGUgZW5jbG9zaW5nIHNjb3BlLlxuICAgICopXG4gICAgfCBBcHBsaWNhdGlvbiBvZiAnYSAqICdhIGxpc3RcbiAgICB8IFJlY19hcHAgb2YgaW50ICogJ2EgbGlzdFxuICAgIHwgVmFyIG9mIGludFxuICBbQEBkZXJpdmluZyBzZXhwLCBjb21wYXJlXVxuXG4gIGxldCBtYXAgeCB+ZiA9XG4gICAgbWF0Y2ggeCB3aXRoXG4gICAgfCBBbm5vdGF0ZSAodSwgeCkgLT4gQW5ub3RhdGUgKHUsIGYgeClcbiAgICB8IEJhc2UgKHMsIHhzKSAtPiBCYXNlIChzLCBMaXN0Lm1hcCB+ZiB4cylcbiAgICB8IFR1cGxlIHhzIC0+IFR1cGxlIChMaXN0Lm1hcCB+ZiB4cylcbiAgICB8IFJlY29yZCBsIC0+IFJlY29yZCAoTGlzdC5tYXAgbCB+ZjooZnVuIChzLCB4KSAtPiBzLCBmIHgpKVxuICAgIHwgVmFyaWFudCBsIC0+IFZhcmlhbnQgKExpc3QubWFwIGwgfmY6KGZ1biAocywgeHMpIC0+IHMsIExpc3QubWFwIH5mIHhzKSlcbiAgICB8IFBvbHlfdmFyaWFudCB0IC0+IFBvbHlfdmFyaWFudCAoU29ydGVkX3RhYmxlLm1hcCB0IH5mOihPcHRpb24ubWFwIH5mKSlcbiAgICB8IEFwcGxpY2F0aW9uICh4LCBsKSAtPiBBcHBsaWNhdGlvbiAoZiB4LCBMaXN0Lm1hcCB+ZiBsKVxuICAgIHwgUmVjX2FwcCAodCwgbCkgLT4gUmVjX2FwcCAodCwgTGlzdC5tYXAgfmYgbClcbiAgICB8IFZhciB2IC0+IFZhciB2XG4gIDs7XG5cbiAgbGV0IHRvX3N0cmluZyB0ID0gU2V4cC50b19zdHJpbmcgKHNleHBfb2ZfdCAoZnVuIF8gLT4gQXRvbSBcIi4uLlwiKSB0KVxuZW5kXG5cbm1vZHVsZSBDcmVhdGVfZGlnZXN0IDogc2lnXG4gICgqIERpZ2VzdCB2YXJpb3VzIGV4cHJlc3Npb24gZm9ybXMgKilcblxuICB2YWwgZGlnZXN0X2xheWVyIDogRGlnZXN0LnQgQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci50IC0+IERpZ2VzdC50XG5lbmQgPSBzdHJ1Y3RcbiAgbGV0IGRpZ2VzdF9sYXllciA9IGZ1bmN0aW9uXG4gICAgfCBDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLkFubm90YXRlICh1LCB4KSAtPlxuICAgICAgRGlnZXN0LmNvbnN0cnVjdG9yIFwiYW5ub3RhdGVcIiBbIERpZ2VzdC51dWlkIHU7IHggXVxuICAgIHwgQmFzZSAodSwgbCkgLT4gRGlnZXN0LmNvbnN0cnVjdG9yIFwiYmFzZVwiIFsgRGlnZXN0LnV1aWQgdTsgRGlnZXN0Lmxpc3QgbCBdXG4gICAgfCBUdXBsZSBsIC0+IERpZ2VzdC5jb25zdHJ1Y3RvciBcInR1cGxlXCIgWyBEaWdlc3QubGlzdCBsIF1cbiAgICB8IFJlY29yZCBsIC0+XG4gICAgICBEaWdlc3QuY29uc3RydWN0b3JcbiAgICAgICAgXCJyZWNvcmRcIlxuICAgICAgICBbIERpZ2VzdC5saXN0IChMaXN0Lm1hcCBsIH5mOihmdW4gKHMsIHQpIC0+IERpZ2VzdC5wYWlyIChEaWdlc3Quc3RyaW5nIHMpIHQpKSBdXG4gICAgfCBWYXJpYW50IGwgLT5cbiAgICAgIERpZ2VzdC5jb25zdHJ1Y3RvclxuICAgICAgICBcInZhcmlhbnRcIlxuICAgICAgICBbIERpZ2VzdC5saXN0XG4gICAgICAgICAgICAoTGlzdC5tYXAgbCB+ZjooZnVuIChzLCBsKSAtPiBEaWdlc3QucGFpciAoRGlnZXN0LnN0cmluZyBzKSAoRGlnZXN0Lmxpc3QgbCkpKVxuICAgICAgICBdXG4gICAgfCBQb2x5X3ZhcmlhbnQgdGFibGUgLT5cbiAgICAgIERpZ2VzdC5jb25zdHJ1Y3RvclxuICAgICAgICBcInBvbHlfdmFyaWFudFwiXG4gICAgICAgIFsgRGlnZXN0Lmxpc3RcbiAgICAgICAgICAgIChMaXN0Lm1hcCAoU29ydGVkX3RhYmxlLmV4cG9zZSB0YWJsZSkgfmY6KGZ1biAoeCwgeSkgLT5cbiAgICAgICAgICAgICAgIERpZ2VzdC5wYWlyIChEaWdlc3Quc3RyaW5nIHgpIChEaWdlc3Qub3B0aW9uIHkpKSlcbiAgICAgICAgXVxuICAgIHwgQXBwbGljYXRpb24gKHgsIGwpIC0+IERpZ2VzdC5jb25zdHJ1Y3RvciBcImFwcGxpY2F0aW9uXCIgWyB4OyBEaWdlc3QubGlzdCBsIF1cbiAgICB8IFJlY19hcHAgKG4sIGwpIC0+IERpZ2VzdC5jb25zdHJ1Y3RvciBcInJlY19hcHBcIiBbIERpZ2VzdC5pbnQgbjsgRGlnZXN0Lmxpc3QgbCBdXG4gICAgfCBWYXIgbiAtPiBEaWdlc3QuY29uc3RydWN0b3IgXCJ2YXJcIiBbIERpZ2VzdC5pbnQgbiBdXG4gIDs7XG5lbmRcblxubW9kdWxlIFZpc2liaWxpdHkgPSBzdHJ1Y3RcbiAgdHlwZSB2aXNpYmxlID0gVmlzaWJsZVxuICB0eXBlIG9wYXF1ZSA9IE9wYXF1ZVxuXG4gIGxldCBfID0gVmlzaWJsZVxuICBsZXQgXyA9IE9wYXF1ZVxuZW5kXG5cbm1vZHVsZSB0eXBlIENhbm9uaWNhbCA9IHNpZ1xuICB0eXBlIHRcblxuICB2YWwgdG9fZGlnZXN0IDogdCAtPiBEaWdlc3QudFxuXG4gIG1vZHVsZSBFeHAxIDogc2lnXG4gICAgdHlwZSBfIHRcblxuICAgIHZhbCB2YXIgOiBpbnQgLT4gXyB0XG4gICAgdmFsIHJlY3Vyc2UgOiBpbnQgLT4gXyB0IGxpc3QgLT4gXyB0XG4gICAgdmFsIGFwcGx5IDogJ2EgdCAtPiAnYSB0IGxpc3QgLT4gXyB0XG4gICAgdmFsIG9wYXF1ZSA6IF8gdCAtPiBWaXNpYmlsaXR5Lm9wYXF1ZSB0XG5cbiAgICB2YWwgZ2V0X3BvbHlfdmFyaWFudFxuICAgICAgOiAgVmlzaWJpbGl0eS52aXNpYmxlIHRcbiAgICAgIC0+IChWaXNpYmlsaXR5Lm9wYXF1ZSB0IG9wdGlvbiBTb3J0ZWRfdGFibGUudCwgc3RyaW5nKSBSZXN1bHQudFxuICBlbmRcblxuICBtb2R1bGUgRGVmIDogc2lnXG4gICAgdHlwZSB0ID0gVmlzaWJpbGl0eS52aXNpYmxlIEV4cDEudFxuICBlbmRcblxuICBtb2R1bGUgQ3JlYXRlIDogc2lnXG4gICAgdmFsIGFubm90YXRlIDogVXVpZC50IC0+IF8gRXhwMS50IC0+IF8gRXhwMS50XG4gICAgdmFsIGJhc2V0eXBlIDogVXVpZC50IC0+IF8gRXhwMS50IGxpc3QgLT4gXyBFeHAxLnRcbiAgICB2YWwgdHVwbGUgOiBfIEV4cDEudCBsaXN0IC0+IF8gRXhwMS50XG4gICAgdmFsIHBvbHlfdmFyaWFudCA6IExvY2F0aW9uLnQgLT4gKHN0cmluZyAqIF8gRXhwMS50IG9wdGlvbikgbGlzdCAtPiBfIEV4cDEudFxuICAgIHZhbCB2YXIgOiBpbnQgLT4gXyBFeHAxLnRcbiAgICB2YWwgcmVjdXJzZSA6IGludCAtPiBfIEV4cDEudCBsaXN0IC0+IF8gRXhwMS50XG4gICAgdmFsIGFwcGx5IDogJ2EgRXhwMS50IC0+ICdhIEV4cDEudCBsaXN0IC0+IF8gRXhwMS50XG4gICAgdmFsIGRlZmluZSA6IFZpc2liaWxpdHkudmlzaWJsZSBFeHAxLnQgLT4gRGVmLnRcbiAgICB2YWwgcmVjb3JkIDogKHN0cmluZyAqIF8gRXhwMS50KSBsaXN0IC0+IF8gRXhwMS50XG4gICAgdmFsIHZhcmlhbnQgOiAoc3RyaW5nICogXyBFeHAxLnQgbGlzdCkgbGlzdCAtPiBfIEV4cDEudFxuICAgIHZhbCBjcmVhdGUgOiBfIEV4cDEudCAtPiB0XG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBDYW5vbmljYWxfZGlnZXN0IDogQ2Fub25pY2FsID0gc3RydWN0XG4gIHR5cGUgdCA9IENhbm9uaWNhbCBvZiBEaWdlc3QudFxuXG4gIGxldCB0b19kaWdlc3QgKENhbm9uaWNhbCB4KSA9IHhcblxuICBtb2R1bGUgQ0QgPSBDcmVhdGVfZGlnZXN0XG5cbiAgbW9kdWxlIEV4cDEgPSBzdHJ1Y3RcbiAgICB0eXBlIG9wYXF1ZSA9IERpZ2VzdC50XG5cbiAgICB0eXBlICdhIHQgPVxuICAgICAgfCBQb2x5X3ZhcmlhbnQgb2Ygb3BhcXVlIG9wdGlvbiBTb3J0ZWRfdGFibGUudFxuICAgICAgfCBOb25fcG9seV92YXJpYW50IG9mIChzdHJpbmcgKiBvcGFxdWUpXG4gICAgICB8IE9wYXF1ZSA6IG9wYXF1ZSAtPiBWaXNpYmlsaXR5Lm9wYXF1ZSB0XG5cbiAgICBsZXQgdG9fZGlnZXN0ICh0eXBlIGEpICh4IDogYSB0KSA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgT3BhcXVlIHggLT4geFxuICAgICAgfCBOb25fcG9seV92YXJpYW50IChfLCB4KSAtPiB4XG4gICAgICB8IFBvbHlfdmFyaWFudCB4IC0+IENELmRpZ2VzdF9sYXllciAoUG9seV92YXJpYW50IHgpXG4gICAgOztcblxuICAgIGxldCBlcXVhbCAodHlwZSBhKSAoeCA6IGEgdCkgKHkgOiBhIHQpID1cbiAgICAgIERpZ2VzdC5jb21wYXJlICh0b19kaWdlc3QgeCkgKHRvX2RpZ2VzdCB5KSA9IDBcbiAgICA7O1xuXG4gICAgbGV0IG9wYXF1ZSB4ID0gT3BhcXVlICh0b19kaWdlc3QgeClcblxuICAgIGxldCBjcmVhdGUgeCA9XG4gICAgICBsZXQgeCA9IENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IubWFwIH5mOnRvX2RpZ2VzdCB4IGluXG4gICAgICBsZXQgZGVzYyA9IENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IudG9fc3RyaW5nIHggaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLlBvbHlfdmFyaWFudCBsIC0+IFBvbHlfdmFyaWFudCBsXG4gICAgICB8IEJhc2UgXyAtPiBOb25fcG9seV92YXJpYW50IChkZXNjLCBDRC5kaWdlc3RfbGF5ZXIgeClcbiAgICAgIHwgQW5ub3RhdGUgXyAtPlxuICAgICAgICAoKiBJdCdzIHVuc2FmZSB0byB1c2UgZGVyaXZpbmcgYmluX2lvIHdoZW4gaW5oZXJpdGluZyBmcm9tIGEgcG9seW1vcnBoaWMgdmFyaWFudFxuICAgICAgICAgICB0aGF0IGhhcyBhIGN1c3RvbSBiaW5faW8uICBJZiB3ZSBmb3JiaWQgdGhhdCwgd2UgY2FuIGhhcHBpbHkgcmVqZWN0IGhlcmVcbiAgICAgICAgICAgYW55dGhpbmcgdGhhdCdzIGFubm90YXRlZC4gKilcbiAgICAgICAgTm9uX3BvbHlfdmFyaWFudCAoZGVzYywgQ0QuZGlnZXN0X2xheWVyIHgpXG4gICAgICB8IEFwcGxpY2F0aW9uIF8gLT5cbiAgICAgICAgKCogQXBwbGljYXRpb24gY2FuIHJlYWxseSBiZSBhIHBvbHktdmFyaWFudCB5b3UgY2FuIGluaGVyaXQgZnJvbSEgIEJ1dCBpdCdzIGFcbiAgICAgICAgICAgcmFyZSBzaXR1YXRpb24gdGhhdCBtb3N0bHkgKG9ubHk/KSBhcmlzZXMgd2l0aCBpbmhlcml0YW5jZSBmcm9tIHJlY3Vyc2l2ZVxuICAgICAgICAgICBwb2x5bW9ycGljIHZhcmlhbnRzLCB3aGljaCB3ZSd2ZSBub3Qgc2VlbiBhbnl3aGVyZSB5ZXQuICBTbyB3ZSByZWplY3QgaXQuICopXG4gICAgICAgIE5vbl9wb2x5X3ZhcmlhbnQgKGRlc2MsIENELmRpZ2VzdF9sYXllciB4KVxuICAgICAgfCBSZWNfYXBwIF8gLT5cbiAgICAgICAgKCogWW91IGNhbiBvbmx5IGdldCB0aGUgW1JlY19hcHBdIGNvbnN0cnVjdG9yIGZvciB0eXBlLXJlZmVyZW5jZXMgd2l0aGluIHRoZVxuICAgICAgICAgICBtdXR1YWwgZ3JvdXAgYmVpbmcgZGVmaW5lZC4gUmVmZXJlbmNlcyB3aGljaFxuICAgICAgICAgICBmb2xsb3cgYWZ0ZXIgdGhlIGN1cnJlbnQgZ3JvdXAgd2lsbCBhbHdheXMgYmUgW0FwcGxpY2F0aW9uXXMuXG5cbiAgICAgICAgICAgQW5kIHNpbmNlIG9jYW1sIHJlamVjdHMgcmVmZXJlbmNlcyBpbiBgaW5oZXJpdGFuY2UnIHBvc2l0aW9uIHRvIHR5cGVzIHdpdGhpblxuICAgICAgICAgICB0aGUgY3VycmVudCBncm91cCAoc2VlIGV4YW1wbGUpIHdpdGg6XG5cbiAgICAgICAgICAgRXJyb3I6IFRoZSB0eXBlIGNvbnN0cnVjdG9yIHRcbiAgICAgICAgICAgaXMgbm90IHlldCBjb21wbGV0ZWx5IGRlZmluZWRcblxuICAgICAgICAgICB0aGVuIGl0cyBvayB0byBzYXkgdGhhdCBhIHJlYy1hcHAgaXMgc29tZXRoaW5nIHRoYXQgY2FuJ3QgYmUgaW5oZXJpdGVkIGZyb20gYW5kXG4gICAgICAgICAgIHJldHVybiBbTm9uX3BvbHlfdmFyaWFudF0uXG5cbiAgICAgICAgICAgQW5kIHVubGlrZSB0aGUgW0FwcGxpY2F0aW9uXSBjYXNlLCBpdCBzaG91bGQgbmV2ZXIgYmUgcG9zc2libGUgdG8gc2VlXG4gICAgICAgICAgIGFuIGVycm9yIG1lc3NhZ2Ugd2l0aCB0aGUgW2Rlc2NdID0gW1JlY19hcHBdLlxuXG4gICAgICAgICAgIEV4YW1wbGU6IFt0eXBlIHQgPSBbYGEgb2YgWyB8IHRdIF1dXG4gICAgICAgICAgIEhlcmUsIFt8IHRdIHdvdWxkIGJlIGFuIGV4YW1wbGUgb2YgaW5oZXJpdGFuY2UgZnJvbSBhIFJlY19hcHAsIHdoaWNoXG4gICAgICAgICAgIGlzIHJlamVjdGVkIGJ5IHRoZSBjb21waWxlci5cbiAgICAgICAgKilcbiAgICAgICAgTm9uX3BvbHlfdmFyaWFudCAoZGVzYywgQ0QuZGlnZXN0X2xheWVyIHgpXG4gICAgICB8IFZhciBfIHwgVHVwbGUgXyB8IFJlY29yZCBfIHwgVmFyaWFudCBfIC0+XG4gICAgICAgIE5vbl9wb2x5X3ZhcmlhbnQgKGRlc2MsIENELmRpZ2VzdF9sYXllciB4KVxuICAgIDs7XG5cbiAgICBsZXQgdmFyIHggPSBjcmVhdGUgKFZhciB4KVxuICAgIGxldCBhcHBseSBkZWYgbCA9IGNyZWF0ZSAoQXBwbGljYXRpb24gKGRlZiwgbCkpXG4gICAgbGV0IHJlY3Vyc2UgdGlkIGwgPSBjcmVhdGUgKFJlY19hcHAgKHRpZCwgbCkpXG5cbiAgICBsZXQgZ2V0X3BvbHlfdmFyaWFudCAoeCA6IFZpc2liaWxpdHkudmlzaWJsZSB0KSA9XG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgTm9uX3BvbHlfdmFyaWFudCAoZGVzYywgXykgLT4gRXJyb3IgZGVzY1xuICAgICAgfCBQb2x5X3ZhcmlhbnQgbCAtPiBPayAoU29ydGVkX3RhYmxlLm1hcCB+ZjooT3B0aW9uLm1hcCB+ZjooZnVuIHggLT4gT3BhcXVlIHgpKSBsKVxuICAgIDs7XG4gIGVuZFxuXG4gIG1vZHVsZSBEZWYgPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPSBWaXNpYmlsaXR5LnZpc2libGUgRXhwMS50XG4gIGVuZFxuXG4gIG1vZHVsZSBDcmVhdGUgPSBzdHJ1Y3RcbiAgICBsZXQgYW5ub3RhdGUgdSB4ID0gRXhwMS5jcmVhdGUgKEFubm90YXRlICh1LCB4KSlcbiAgICBsZXQgYmFzZXR5cGUgdSBsID0gRXhwMS5jcmVhdGUgKEJhc2UgKHUsIGwpKVxuICAgIGxldCB0dXBsZSBsID0gRXhwMS5jcmVhdGUgKFR1cGxlIGwpXG5cbiAgICBsZXQgcG9seV92YXJpYW50IGxvYyBsID1cbiAgICAgIEV4cDEuY3JlYXRlIChQb2x5X3ZhcmlhbnQgKFNvcnRlZF90YWJsZS5jcmVhdGUgbG9jIH5lcTooZXF1YWxfb3B0aW9uIEV4cDEuZXF1YWwpIGwpKVxuICAgIDs7XG5cbiAgICBsZXQgdmFyIHggPSBFeHAxLmNyZWF0ZSAoVmFyIHgpXG4gICAgbGV0IGFwcGx5IHggbCA9IEV4cDEuY3JlYXRlIChBcHBsaWNhdGlvbiAoeCwgbCkpXG4gICAgbGV0IHJlY3Vyc2UgdCBsID0gRXhwMS5jcmVhdGUgKFJlY19hcHAgKHQsIGwpKVxuICAgIGxldCBkZWZpbmUgeCA9IHhcbiAgICBsZXQgcmVjb3JkIGwgPSBFeHAxLmNyZWF0ZSAoUmVjb3JkIGwpXG4gICAgbGV0IHZhcmlhbnQgbCA9IEV4cDEuY3JlYXRlIChWYXJpYW50IGwpXG4gICAgbGV0IGNyZWF0ZSBlID0gQ2Fub25pY2FsIChFeHAxLnRvX2RpZ2VzdCBlKVxuICBlbmRcbmVuZFxuXG5tb2R1bGUgQ2Fub25pY2FsX2Z1bGwgOiBzaWdcbiAgdHlwZSB0IFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBdXG5cbiAgaW5jbHVkZSBDYW5vbmljYWwgd2l0aCB0eXBlIHQgOj0gdFxuXG4gIHZhbCB0b19zdHJpbmdfaHVtIDogdCAtPiBzdHJpbmdcbmVuZCA9IHN0cnVjdFxuICBtb2R1bGUgQ0QgPSBDcmVhdGVfZGlnZXN0XG5cbiAgbW9kdWxlIEV4cDEgPSBzdHJ1Y3RcbiAgICB0eXBlIHQwID0gRXhwIG9mIHQwIENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IudCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuXG4gICAgbGV0IGVxdWFsX3QwIHggeSA9IGNvbXBhcmVfdDAgeCB5ID0gMFxuXG4gICAgdHlwZSAnYSB0ID0gdDAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICAgIGxldCB2YXIgeCA9IEV4cCAoQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci5WYXIgeClcbiAgICBsZXQgYXBwbHkgZCB4cyA9IEV4cCAoQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci5BcHBsaWNhdGlvbiAoZCwgeHMpKVxuICAgIGxldCByZWN1cnNlIHIgeHMgPSBFeHAgKENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IuUmVjX2FwcCAociwgeHMpKVxuXG4gICAgbGV0IHBvbHlfdmFyaWFudCBsb2MgeHMgPVxuICAgICAgRXhwXG4gICAgICAgIChDYW5vbmljYWxfZXhwX2NvbnN0cnVjdG9yLlBvbHlfdmFyaWFudFxuICAgICAgICAgICAoU29ydGVkX3RhYmxlLmNyZWF0ZSBsb2MgfmVxOihlcXVhbF9vcHRpb24gZXF1YWxfdDApIHhzKSlcbiAgICA7O1xuXG4gICAgbGV0IGdldF9wb2x5X3ZhcmlhbnQgPSBmdW5jdGlvblxuICAgICAgfCBFeHAgKFBvbHlfdmFyaWFudCB0YWIpIC0+IE9rIHRhYlxuICAgICAgfCBFeHAgY2MgLT4gRXJyb3IgKENhbm9uaWNhbF9leHBfY29uc3RydWN0b3IudG9fc3RyaW5nIGNjKVxuICAgIDs7XG5cbiAgICBsZXQgb3BhcXVlIHQgPSB0XG5cbiAgICBsZXQgcmVjIHRvX2RpZ2VzdCA9IGZ1bmN0aW9uXG4gICAgICB8IEV4cCBlIC0+IENELmRpZ2VzdF9sYXllciAoQ2Fub25pY2FsX2V4cF9jb25zdHJ1Y3Rvci5tYXAgfmY6dG9fZGlnZXN0IGUpXG4gICAgOztcbiAgZW5kXG5cbiAgbW9kdWxlIERlZiA9IHN0cnVjdFxuICAgICgqIEEgW0RlZi50XSBpcyBhbiBleHByZXNzaW9uIHdoaWNoIG1heSBiZSBhcHBsaWVkICopXG4gICAgdHlwZSB0ID0gRXhwMS50MCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwXVxuICBlbmRcblxuICAoKiBBIGNhbm9uaWNhbCBzaGFwZSBbdF0gaXMgYW4gW0V4cDEudF0uICopXG4gIHR5cGUgdCA9IEV4cDEudDAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF1cblxuICBsZXQgdG9fZGlnZXN0IGUgPSBFeHAxLnRvX2RpZ2VzdCBlXG5cbiAgbW9kdWxlIENyZWF0ZSA9IHN0cnVjdFxuICAgIGxldCBhbm5vdGF0ZSB1IHggPSBFeHAxLkV4cCAoQW5ub3RhdGUgKHUsIHgpKVxuICAgIGxldCBiYXNldHlwZSB1IHhzID0gRXhwMS5FeHAgKEJhc2UgKHUsIHhzKSlcbiAgICBsZXQgdHVwbGUgeHMgPSBFeHAxLkV4cCAoVHVwbGUgeHMpXG4gICAgbGV0IHBvbHlfdmFyaWFudCBsb2MgeHMgPSBFeHAxLnBvbHlfdmFyaWFudCBsb2MgeHNcbiAgICBsZXQgdmFyIG4gPSBFeHAxLkV4cCAoVmFyIG4pXG4gICAgbGV0IHJlY3Vyc2UgciB4cyA9IEV4cDEucmVjdXJzZSByIHhzXG4gICAgbGV0IGFwcGx5IGQgeHMgPSBFeHAxLmFwcGx5IGQgeHNcbiAgICBsZXQgZGVmaW5lIHggPSB4XG4gICAgbGV0IHJlY29yZCB4cyA9IEV4cDEuRXhwIChSZWNvcmQgeHMpXG4gICAgbGV0IHZhcmlhbnQgeHMgPSBFeHAxLkV4cCAoVmFyaWFudCB4cylcbiAgICBsZXQgY3JlYXRlIGV4cCA9IGV4cFxuICBlbmRcblxuICBsZXQgdG9fc3RyaW5nX2h1bSB0ID0gU2V4cC50b19zdHJpbmdfaHVtIChzZXhwX29mX3QgdClcbmVuZFxuXG5tb2R1bGUgVGlkIDogc2lnXG4gIGluY2x1ZGUgSWRlbnRpZmlhYmxlLlNcbmVuZCA9IHN0cnVjdFxuICBpbmNsdWRlIFN0cmluZ1xuZW5kXG5cbm1vZHVsZSBWaWQgOiBzaWdcbiAgaW5jbHVkZSBJZGVudGlmaWFibGUuU1xuZW5kID0gc3RydWN0XG4gIGluY2x1ZGUgU3RyaW5nXG5lbmRcblxubW9kdWxlIEdpZCA6IHNpZ1xuICAoKiB1bmlxdWUgZ3JvdXAtaWQsIHVzZWQgYXMga2V5IGZvciBUZW52IGJlbG93ICopXG4gIHR5cGUgdCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuXG4gIHZhbCBjcmVhdGUgOiB1bml0IC0+IHRcbmVuZCA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICBsZXQgciA9IHJlZiAwXG5cbiAgbGV0IGNyZWF0ZSAoKSA9XG4gICAgbGV0IHUgPSAhciBpblxuICAgIHIgOj0gMSArIHU7XG4gICAgdVxuICA7O1xuZW5kXG5cbm1vZHVsZSBFeHByZXNzaW9uID0gc3RydWN0XG4gIHR5cGUgJ3QgcG9seV9jb25zdHIgPVxuICAgIFsgYENvbnN0ciBvZiBzdHJpbmcgKiAndCBvcHRpb25cbiAgICB8IGBJbmhlcml0IG9mIExvY2F0aW9uLnQgKiAndFxuICAgIF1cbiAgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICBtb2R1bGUgR3JvdXAgOiBzaWdcbiAgICB0eXBlICdhIHQgW0BAZGVyaXZpbmcgY29tcGFyZSwgc2V4cF9vZl1cblxuICAgIHZhbCBjcmVhdGUgOiBMb2NhdGlvbi50IC0+IChUaWQudCAqIFZpZC50IGxpc3QgKiAnYSkgbGlzdCAtPiAnYSB0XG4gICAgdmFsIGlkIDogJ2EgdCAtPiBHaWQudFxuICAgIHZhbCBsb29rdXAgOiAnYSB0IC0+IFRpZC50IC0+IFZpZC50IGxpc3QgKiAnYVxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPVxuICAgICAgeyBnaWQgOiBHaWQudFxuICAgICAgOyBsb2MgOiBMb2NhdGlvbi50XG4gICAgICA7IG1lbWJlcnMgOiAoVGlkLnQgKiAoVmlkLnQgbGlzdCAqICdhKSkgbGlzdFxuICAgICAgfVxuICAgIFtAQGRlcml2aW5nIGNvbXBhcmUsIHNleHBfb2ZdXG5cbiAgICBsZXQgY3JlYXRlIGxvYyB0cmlwcyA9XG4gICAgICBsZXQgZ2lkID0gR2lkLmNyZWF0ZSAoKSBpblxuICAgICAgbGV0IG1lbWJlcnMgPSBMaXN0Lm1hcCB0cmlwcyB+ZjooZnVuICh4LCB2cywgdCkgLT4geCwgKHZzLCB0KSkgaW5cbiAgICAgIHsgZ2lkOyBsb2M7IG1lbWJlcnMgfVxuICAgIDs7XG5cbiAgICBsZXQgaWQgZyA9IGcuZ2lkXG5cbiAgICBsZXQgbG9va3VwIGcgdGlkID1cbiAgICAgIG1hdGNoIExpc3QuQXNzb2MuZmluZCBnLm1lbWJlcnMgfmVxdWFsOlRpZC4oID0gKSB0aWQgd2l0aFxuICAgICAgfCBTb21lIHNjaGVtZSAtPiBzY2hlbWVcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBldmFsX2ZhaWxcbiAgICAgICAgICBnLmxvY1xuICAgICAgICAgICFcImltcG9zc2libGU6IGxvb2t1cF9ncm91cCwgdW5ib3VuZCB0eXBlLWlkZW50aWZpZXI6ICV7VGlkfVwiXG4gICAgICAgICAgdGlkXG4gICAgICAgICAgKClcbiAgICA7O1xuICBlbmRcblxuICB0eXBlIHQgPVxuICAgIHwgQW5ub3RhdGUgb2YgVXVpZC50ICogdFxuICAgIHwgQmFzZSBvZiBVdWlkLnQgKiB0IGxpc3RcbiAgICB8IFJlY29yZCBvZiAoc3RyaW5nICogdCkgbGlzdFxuICAgIHwgVmFyaWFudCBvZiAoc3RyaW5nICogdCBsaXN0KSBsaXN0XG4gICAgfCBUdXBsZSBvZiB0IGxpc3RcbiAgICB8IFBvbHlfdmFyaWFudCBvZiAoTG9jYXRpb24udCAqIHQgcG9seV9jb25zdHIgbGlzdClcbiAgICB8IFZhciBvZiAoTG9jYXRpb24udCAqIFZpZC50KVxuICAgIHwgUmVjX2FwcCBvZiBUaWQudCAqIHQgbGlzdFxuICAgIHwgVG9wX2FwcCBvZiB0IEdyb3VwLnQgKiBUaWQudCAqIHQgbGlzdFxuICBbQEBkZXJpdmluZyB2YXJpYW50cywgc2V4cF9vZl1cblxuICB0eXBlIGdyb3VwID0gdCBHcm91cC50XG5cbiAgbGV0IGdyb3VwID0gR3JvdXAuY3JlYXRlXG5cbiAgdHlwZSBwb2x5X3ZhcmlhbnRfcm93ID0gdCBwb2x5X2NvbnN0clxuXG4gIGxldCBjb25zdHIgcyB0ID0gYENvbnN0ciAocywgdClcbiAgbGV0IGluaGVyaXRfIGxvYyB0ID0gYEluaGVyaXQgKGxvYywgdClcbiAgbGV0IHZhciBsb2MgdCA9IFZhciAobG9jLCB0KVxuICBsZXQgcG9seV92YXJpYW50IGxvYyB4cyA9IFBvbHlfdmFyaWFudCAobG9jLCB4cylcbiAgbGV0IGJhc2V0eXBlID0gYmFzZVxuXG4gICgqIFwiVlJcIiBzdGFuZHMgZm9yIFwidmFyaWFudCBvciByZWNvcmRcIiAqKVxuXG4gIGxldCBpc19jeWNsaWNfMCB+KHZpYV9WUiA6IGJvb2wpIDogZ3JvdXAgLT4gVGlkLnQgLT4gYm9vbCA9XG4gICAgZnVuIGdyb3VwIHRpZCAtPlxuICAgIGxldCBzZXQgPSByZWYgW10gaW5cbiAgICBsZXQgdmlzaXRlZCB0aWQgPSBMaXN0Lm1lbSAhc2V0IHRpZCB+ZXF1YWw6VGlkLmVxdWFsIGluXG4gICAgbGV0IGFkZCB0aWQgPSBzZXQgOj0gdGlkIDo6ICFzZXQgaW5cbiAgICBsZXQgcmVjIHRyYXYgPSBmdW5jdGlvblxuICAgICAgKCogV2UgbG9vayBmb3IgY3ljbGVzIGJ5IHRyYXZlcnNpbmcgdGhlIHN0cnVjdHVyZSBvZiB0eXBlLWV4cHJlc3Npb25zICopXG4gICAgICB8IEFubm90YXRlIChfLCB0KSAtPiB0cmF2IHRcbiAgICAgIHwgQmFzZSAoXywgdHMpIHwgVHVwbGUgdHMgfCBUb3BfYXBwIChfLCBfLCB0cykgLT4gTGlzdC5pdGVyIHRzIH5mOnRyYXZcbiAgICAgICgqIC4uaW5jbHVkaW5nIHBvbHktdmFyaWFudHMgKilcbiAgICAgIHwgUG9seV92YXJpYW50IChfLCBjcykgLT5cbiAgICAgICAgTGlzdC5pdGVyIGNzIH5mOihmdW5jdGlvblxuICAgICAgICAgIHwgYENvbnN0ciAoXywgTm9uZSkgLT4gKClcbiAgICAgICAgICB8IGBDb25zdHIgKF8sIFNvbWUgdCkgLT4gdHJhdiB0XG4gICAgICAgICAgfCBgSW5oZXJpdCAoX2xvYywgdCkgLT4gdHJhdiB0KVxuICAgICAgKCogLi4gYW5kIHJlY29yZHMgJiAobm9ybWFsKSB2YXJpYW50cyAqKVxuICAgICAgfCBSZWNvcmQgeHMgLT4gaWYgdmlhX1ZSIHRoZW4gTGlzdC5pdGVyIHhzIH5mOihmdW4gKF8sIHQpIC0+IHRyYXYgdCkgZWxzZSAoKVxuICAgICAgfCBWYXJpYW50IHhzIC0+XG4gICAgICAgIGlmIHZpYV9WUiB0aGVuIExpc3QuaXRlciB4cyB+ZjooZnVuIChfLCB0cykgLT4gTGlzdC5pdGVyIH5mOnRyYXYgdHMpIGVsc2UgKClcbiAgICAgICgqIFdlIGRvbnQgZm9sbG93IHR5cGUtdmFycyAqKVxuICAgICAgfCBWYXIgXyAtPiAoKVxuICAgICAgKCogdHJhdmVyc2UgKHJlY3Vyc2l2ZSkgdHlwZS1hcHBzIHdoZW4gZmlyc3QgZW5jb3VudGVyZWQgKilcbiAgICAgIHwgUmVjX2FwcCAodGlkLCB0cykgLT5cbiAgICAgICAgaWYgdmlzaXRlZCB0aWRcbiAgICAgICAgdGhlbiAoKVxuICAgICAgICBlbHNlIChcbiAgICAgICAgICBhZGQgdGlkO1xuICAgICAgICAgIHRyYXZfdGlkIHRpZCk7XG4gICAgICAgIExpc3QuaXRlciB0cyB+Zjp0cmF2XG4gICAgYW5kIHRyYXZfdGlkIHRpZCA9XG4gICAgICBsZXQgXywgYm9keSA9IEdyb3VwLmxvb2t1cCBncm91cCB0aWQgaW5cbiAgICAgIHRyYXYgYm9keVxuICAgIGluXG4gICAgdHJhdl90aWQgdGlkO1xuICAgIGxldCByZXMgPSB2aXNpdGVkIHRpZCBpblxuICAgICgqbGV0IF9zcyA9IFN0cmluZy5jb25jYXQgfnNlcDpcIixcIiAoTGlzdC5tYXAgKCFzZXQpIH5mOihzcHJpbnRmICFcIiV7VGlkfVwiKSkgaW4qKVxuICAgICgqUHJpbnRmLnByaW50ZiAhXCJpc19jeWxpYzogJXtUaWR9IC0tPiAoJXMpICViICAtLSAlcyUhXCIgdGlkIF9zcyByZXMgKEdyb3VwLmxvYyBncm91cCk7KilcbiAgICByZXNcbiAgOztcblxuICBsZXQgaXNfY3ljbGljID0gaXNfY3ljbGljXzAgfnZpYV9WUjp0cnVlXG4gIGxldCBpc19jeWNsaWNfd2l0aF9ub19pbnRlcnZlbmluZ19WUiA9IGlzX2N5Y2xpY18wIH52aWFfVlI6ZmFsc2VcbmVuZFxuXG5pbmNsdWRlIEV4cHJlc3Npb25cblxubW9kdWxlIEV2YWx1YXRpb24gKENhbm9uaWNhbCA6IENhbm9uaWNhbCkgPSBzdHJ1Y3RcbiAgKCogW1ZlbnYudF1cbiAgICAgRW52aXJvbm1lbnQgZm9yIHJlc29sdmluZyB0eXBlLXZhcnMgKilcbiAgbW9kdWxlIFZlbnYgOiBzaWdcbiAgICB0eXBlIHRcblxuICAgIHZhbCBsb29rdXAgOiB0IC0+IFZpZC50IC0+IFZpc2liaWxpdHkudmlzaWJsZSBDYW5vbmljYWwuRXhwMS50IG9wdGlvblxuICAgIHZhbCBjcmVhdGUgOiAoVmlkLnQgKiBWaXNpYmlsaXR5LnZpc2libGUgQ2Fub25pY2FsLkV4cDEudCkgbGlzdCAtPiB0XG4gIGVuZCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFZpc2liaWxpdHkudmlzaWJsZSBDYW5vbmljYWwuRXhwMS50IE1hcC5NKFZpZCkudFxuXG4gICAgbGV0IGNyZWF0ZSA9XG4gICAgICBMaXN0LmZvbGRcbiAgICAgICAgfmluaXQ6KE1hcC5lbXB0eSAobW9kdWxlIFZpZCkpXG4gICAgICAgIH5mOihmdW4gdCAoaywgdikgLT4gTWFwLnNldCB+a2V5OmsgfmRhdGE6diB0KVxuICAgIDs7XG5cbiAgICBsZXQgbG9va3VwIHQgayA9IE1hcC5maW5kIHQga1xuICBlbmRcblxuICBtb2R1bGUgQXBwbGljYW5kID0gc3RydWN0XG4gICAgdHlwZSB0ID1cbiAgICAgIHwgUmVjdXJzaW9uX2xldmVsIG9mIGludFxuICAgICAgfCBEZWZpbml0aW9uIG9mIENhbm9uaWNhbC5EZWYudFxuICBlbmRcblxuICAoKiBbVGVudi50XVxuICAgICBFbnZpcm9ubWVudCBmb3IgcmVzb2x2aW5nIHR5cGUtZGVmaW5pdGlvbnMgKilcbiAgbW9kdWxlIFRlbnYgOiBzaWdcbiAgICB0eXBlIGtleSA9IEdpZC50ICogVGlkLnRcbiAgICB0eXBlIHRcblxuICAgIHZhbCBmaW5kIDogdCAtPiBrZXkgLT4gWyBgUmVjdXJzaW9uX2xldmVsIG9mIGludCBdIG9wdGlvblxuICAgIHZhbCBlbXB0eSA6IHRcbiAgICB2YWwgZXh0ZW5kIDogdCAtPiBrZXkgLT4gWyBgUmVjdXJzaW9uX2xldmVsIG9mIGludCBdIC0+IHRcbiAgZW5kID0gc3RydWN0XG4gICAgbW9kdWxlIEtleSA9IHN0cnVjdFxuICAgICAgbW9kdWxlIFQgPSBzdHJ1Y3RcbiAgICAgICAgdHlwZSB0ID0gR2lkLnQgKiBUaWQudCBbQEBkZXJpdmluZyBjb21wYXJlLCBzZXhwX29mXVxuICAgICAgZW5kXG5cbiAgICAgIGluY2x1ZGUgVFxuICAgICAgaW5jbHVkZSBDb21wYXJhdG9yLk1ha2UgKFQpXG4gICAgZW5kXG5cbiAgICB0eXBlIGtleSA9IEtleS50XG4gICAgdHlwZSB0ID0gWyBgUmVjdXJzaW9uX2xldmVsIG9mIGludCBdIE1hcC5NKEtleSkudFxuXG4gICAgbGV0IGZpbmQgdCBrID0gTWFwLmZpbmQgdCBrXG4gICAgbGV0IGVtcHR5ID0gTWFwLmVtcHR5IChtb2R1bGUgS2V5KVxuICAgIGxldCBleHRlbmQgdCBrIHYgPSBNYXAuc2V0IH5rZXk6ayB+ZGF0YTp2IHRcbiAgZW5kXG5cbiAgKCogW0RlZmluaW5nLnRdXG4gICAgIE1vbmFkIGZvciBtYW5hZ2luZyB1bi1yb2xsaW5nIGRlcHRoLCBhbmQgbWFpbnRhaW5nIGEgW1RlbnYudF0gKilcbiAgbW9kdWxlIERlZmluaW5nIDogc2lnXG4gICAgdHlwZSAnYSB0XG5cbiAgICB2YWwgcmV0dXJuIDogJ2EgLT4gJ2EgdFxuICAgIHZhbCBiaW5kIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuICAgIHZhbCBsb29rX2VudiA6IFRlbnYua2V5IC0+IEFwcGxpY2FuZC50IG9wdGlvbiB0XG4gICAgdmFsIGV4dGVuZF9uZXdfdGlkIDogVGVudi5rZXkgLT4gQ2Fub25pY2FsLkRlZi50IHQgLT4gQXBwbGljYW5kLnQgdFxuICAgIHZhbCBleGVjIDogJ2EgdCAtPiAnYVxuICBlbmQgPSBzdHJ1Y3RcbiAgICB0eXBlICdhIHQgPSBkZXB0aDppbnQgLT4gVGVudi50IC0+ICdhXG5cbiAgICBsZXQgcmV0dXJuIHggfmRlcHRoOl8gX3RlbnYgPSB4XG5cbiAgICBsZXQgYmluZCB0IGYgfmRlcHRoIHRlbnYgPVxuICAgICAgbGV0IHggPSB0IH5kZXB0aCB0ZW52IGluXG4gICAgICAoZiB4KSB+ZGVwdGggdGVudlxuICAgIDs7XG5cbiAgICBsZXQgbG9va19lbnYga2V5IH5kZXB0aDpfIHRlbnYgPVxuICAgICAgbGV0IHJlc3VsdCA9IFRlbnYuZmluZCB0ZW52IGtleSBpblxuICAgICAgT3B0aW9uLm1hcCB+ZjooZnVuIChgUmVjdXJzaW9uX2xldmVsIHgpIC0+IEFwcGxpY2FuZC5SZWN1cnNpb25fbGV2ZWwgeCkgcmVzdWx0XG4gICAgOztcblxuICAgIGxldCBleHRlbmRfbmV3X3RpZCBrZXkgZGVmX3QgfmRlcHRoIHRlbnYgPVxuICAgICAgQXBwbGljYW5kLkRlZmluaXRpb25cbiAgICAgICAgKGxldCB2YWx1ZSA9IGBSZWN1cnNpb25fbGV2ZWwgZGVwdGggaW5cbiAgICAgICAgIGxldCB0ZW52ID0gVGVudi5leHRlbmQgdGVudiBrZXkgdmFsdWUgaW5cbiAgICAgICAgIGRlZl90IH5kZXB0aDooZGVwdGggKyAxKSB0ZW52KVxuICAgIDs7XG5cbiAgICBsZXQgZXhlYyB0ID0gdCB+ZGVwdGg6MCBUZW52LmVtcHR5XG4gIGVuZFxuXG4gIHR5cGUgJ2EgZGVmaW5pbmcgPSAnYSBEZWZpbmluZy50XG5cbiAgbGV0ICggPj49ICkgPSBEZWZpbmluZy5iaW5kXG4gIGxldCByZXR1cm4gPSBEZWZpbmluZy5yZXR1cm5cblxuICBsZXQgc2VxdWVuY2VfZGVmaW5pbmcgOiAnYSBsaXN0IC0+IGY6KCdhIC0+ICdiIGRlZmluaW5nKSAtPiAnYiBsaXN0IGRlZmluaW5nID1cbiAgICBmdW4geHMgfmYgLT5cbiAgICBsZXQgcmVjIGxvb3AgYWNjX3lzID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gcmV0dXJuIChMaXN0LnJldiBhY2NfeXMpXG4gICAgICB8IHggOjogeHMgLT4gZiB4ID4+PSBmdW4geSAtPiBsb29wICh5IDo6IGFjY195cykgeHNcbiAgICBpblxuICAgIGxvb3AgW10geHNcbiAgOztcblxuICAoKlxuICAgICBTaGFwZSBldmFsdWF0aW9uLlxuXG4gICAgIFNoYXBlcyBhcmUgZXZhbHVhdGVkIHRvIGNhbm9uaWNhbC1zaGFwZSAoZXhwcmVzc2lvbnMpLCB3aXRoIGFkZGl0aW9uYWwgZGVmcyBjb2xsZWN0ZWRcbiAgICAgaW4gdGhlIFtkZWZpbmluZ10gbW9uYWQsIHdoaWNoIGFsc28gbWFuYWdlcyBnZW5lcmF0aW9uL21hcHBpbmcgdG8gW0Nhbm9uaWNhbC5UaWQudF1cblxuICAgICBUaGVyZSBpcyBkb3dud2FyZHMgY29udGV4dCBvZiBbZ3JvdXBdIGFuZCBbVmVudi50XVxuICAgICBUaGUgKGN1cnJlbnQpIFtncm91cF0gY2hhbmdlcyB3aGVuIHRoZSBjYXNlIGZvciBbVG9wX2FwcF0gY2FsbHMgW2V2YWxfYXBwXS5cblxuICAgICBUaGUgY3VycmVudCBbVmVudi50XSBpcyBhYmFuZG9uZWQgd2hlbiBbZXZhbF9hcHBdIGlzIGNhbGxlZCwgYW5kIHRoZW4gcmUtY3JlYXRlZCBhZnRlclxuICAgICB0aGUgZGVjaXNpb24gaGFzIGJlZW4gbWFkZSB0byBlaXRoZXIgaW5saW5lIHRoZSB0eXBlLWFwcGxpY2F0aW9uLCBvciBtYWtlIGEgcmVmZXJlbmNlXG4gICAgIHRvIGEgdHlwZS1kZWZpbml0aW9uLCB3aGljaCBpcyBjcmVhdGVkIGF0IG1vc3Qgb25jZSBmb3IgZWFjaCAoR2lkLnQgKiBUaWQudCkuXG5cbiAgICAgV2UgbWFrZSBhIHR5cGUtZGVmaW5pdGlvbiBhbHdheXMgZm9yIFJlY29yZHMgYW5kIFZhcmlhbnRzLCBhbmQgaW4gYWRkaXRpb24gZm9yIGFueVxuICAgICBvdGhlciBjeWNsaWMgdHlwZS1kZWZpbml0aW9uLlxuICAqKVxuXG4gIGxldCByZWMgZXZhbCA6IGdyb3VwIC0+IFZlbnYudCAtPiB0IC0+IFZpc2liaWxpdHkudmlzaWJsZSBDYW5vbmljYWwuRXhwMS50IGRlZmluaW5nID1cbiAgICBmdW4gZ3JvdXAgdmVudiB0IC0+XG4gICAgICBtYXRjaCB0IHdpdGhcbiAgICAgIHwgUmVjb3JkIGJpbmRzIC0+XG4gICAgICAgIHNlcXVlbmNlX2RlZmluaW5nIGJpbmRzIH5mOihmdW4gKHMsIHgpIC0+XG4gICAgICAgICAgZXZhbCBncm91cCB2ZW52IHggPj49IGZ1biB5IC0+IHJldHVybiAocywgeSkpXG4gICAgICAgID4+PSBmdW4gYmluZHMgLT4gcmV0dXJuIChDYW5vbmljYWwuQ3JlYXRlLnJlY29yZCBiaW5kcylcbiAgICAgIHwgVmFyaWFudCBhbHRzIC0+XG4gICAgICAgIHNlcXVlbmNlX2RlZmluaW5nIGFsdHMgfmY6KGZ1biAocywgeHMpIC0+XG4gICAgICAgICAgZXZhbF9saXN0IGdyb3VwIHZlbnYgeHMgPj49IGZ1biB5cyAtPiByZXR1cm4gKHMsIHlzKSlcbiAgICAgICAgPj49IGZ1biBhbHRzIC0+IHJldHVybiAoQ2Fub25pY2FsLkNyZWF0ZS52YXJpYW50IGFsdHMpXG4gICAgICB8IFZhciAobG9jLCB2aWQpIC0+XG4gICAgICAgIChtYXRjaCBWZW52Lmxvb2t1cCB2ZW52IHZpZCB3aXRoXG4gICAgICAgICB8IFNvbWUgeCAtPiByZXR1cm4geFxuICAgICAgICAgfCBOb25lIC0+IGV2YWxfZmFpbCBsb2MgIVwiRnJlZSB0eXBlIHZhcmlhYmxlOiAnJXtWaWR9XCIgdmlkICgpKVxuICAgICAgfCBBbm5vdGF0ZSAocywgdCkgLT5cbiAgICAgICAgZXZhbCBncm91cCB2ZW52IHQgPj49IGZ1biB2IC0+IHJldHVybiAoQ2Fub25pY2FsLkNyZWF0ZS5hbm5vdGF0ZSBzIHYpXG4gICAgICB8IEJhc2UgKHMsIHRzKSAtPlxuICAgICAgICBldmFsX2xpc3QgZ3JvdXAgdmVudiB0cyA+Pj0gZnVuIHZzIC0+IHJldHVybiAoQ2Fub25pY2FsLkNyZWF0ZS5iYXNldHlwZSBzIHZzKVxuICAgICAgfCBUdXBsZSB0cyAtPiBldmFsX2xpc3QgZ3JvdXAgdmVudiB0cyA+Pj0gZnVuIHZzIC0+IHJldHVybiAoQ2Fub25pY2FsLkNyZWF0ZS50dXBsZSB2cylcbiAgICAgIHwgVG9wX2FwcCAoaW5fZ3JvdXAsIHRpZCwgYXJncykgLT5cbiAgICAgICAgZXZhbF9saXN0IGdyb3VwIHZlbnYgYXJnc1xuICAgICAgICA+Pj0gZnVuIGFyZ3MgLT5cbiAgICAgICAgKCogYXJncyBldmFsdWF0ZWQgaW4gY3VycmVudCBncm91cCAqKVxuICAgICAgICBldmFsX2FwcCBpbl9ncm91cCB0aWQgYXJnc1xuICAgICAgKCogZ3JvdXAgY2hhbmdlZCBoZXJlICopXG4gICAgICB8IFJlY19hcHAgKHRpZCwgYXJncykgLT5cbiAgICAgICAgZXZhbF9saXN0IGdyb3VwIHZlbnYgYXJncyA+Pj0gZnVuIGFyZ3MgLT4gZXZhbF9hcHAgZ3JvdXAgdGlkIGFyZ3NcbiAgICAgIHwgUG9seV92YXJpYW50IChsb2MsIGNzKSAtPlxuICAgICAgICBzZXF1ZW5jZV9kZWZpbmluZyB+ZjooZXZhbF9wb2x5X2NvbnN0ciBncm91cCB2ZW52KSBjc1xuICAgICAgICA+Pj0gZnVuIHhzcyAtPiByZXR1cm4gKENhbm9uaWNhbC5DcmVhdGUucG9seV92YXJpYW50IGxvYyAoTGlzdC5jb25jYXQgeHNzKSlcblxuICBhbmQgZXZhbF9saXN0IDogZ3JvdXAgLT4gVmVudi50IC0+IHQgbGlzdCAtPiBfIENhbm9uaWNhbC5FeHAxLnQgbGlzdCBkZWZpbmluZyA9XG4gICAgZnVuIGdyb3VwIHZlbnYgdHMgLT4gc2VxdWVuY2VfZGVmaW5pbmcgdHMgfmY6KGV2YWwgZ3JvdXAgdmVudilcblxuICBhbmQgZXZhbF9wb2x5X2NvbnN0clxuICAgIDogIGdyb3VwIC0+IFZlbnYudCAtPiB0IHBvbHlfY29uc3RyXG4gICAgICAtPiAoc3RyaW5nICogVmlzaWJpbGl0eS5vcGFxdWUgQ2Fub25pY2FsLkV4cDEudCBvcHRpb24pIGxpc3QgZGVmaW5pbmdcbiAgICA9XG4gICAgZnVuIGdyb3VwIHZlbnYgYyAtPlxuICAgICAgbWF0Y2ggYyB3aXRoXG4gICAgICB8IGBDb25zdHIgKHMsIE5vbmUpIC0+IHJldHVybiBbIHMsIE5vbmUgXVxuICAgICAgfCBgQ29uc3RyIChzLCBTb21lIHQpIC0+XG4gICAgICAgIGV2YWwgZ3JvdXAgdmVudiB0ID4+PSBmdW4gdiAtPiByZXR1cm4gWyBzLCBTb21lIChDYW5vbmljYWwuRXhwMS5vcGFxdWUgdikgXVxuICAgICAgfCBgSW5oZXJpdCAobG9jLCB0KSAtPlxuICAgICAgICBldmFsIGdyb3VwIHZlbnYgdFxuICAgICAgICA+Pj0gZnVuIHYgLT5cbiAgICAgICAgKG1hdGNoIENhbm9uaWNhbC5FeHAxLmdldF9wb2x5X3ZhcmlhbnQgdiB3aXRoXG4gICAgICAgICB8IE9rIHRhYiAtPiByZXR1cm4gKFNvcnRlZF90YWJsZS5leHBvc2UgdGFiKVxuICAgICAgICAgfCBFcnJvciBkZXNjIC0+XG4gICAgICAgICAgIGV2YWxfZmFpbFxuICAgICAgICAgICAgIGxvY1xuICAgICAgICAgICAgIFwiVGhlIHNoYXBlIGZvciBhbiBpbmhlcml0ZWQgdHlwZSBpcyBub3QgZGVzY3JpYmVkIGFzIGEgcG9seW1vcnBoaWMtdmFyaWFudDogJXNcIlxuICAgICAgICAgICAgIGRlc2NcbiAgICAgICAgICAgICAoKSlcblxuICBhbmQgZXZhbF9kZWZpbml0aW9uIDogZ3JvdXAgLT4gVmlkLnQgbGlzdCAtPiB0IC0+IENhbm9uaWNhbC5EZWYudCBkZWZpbmluZyA9XG4gICAgZnVuIGdyb3VwIGZvcm1hbHMgYm9keSAtPlxuICAgICAgbGV0IHZlbnYgPSBWZW52LmNyZWF0ZSAoTGlzdC5tYXBpIGZvcm1hbHMgfmY6KGZ1biBpIHggLT4geCwgQ2Fub25pY2FsLkV4cDEudmFyIGkpKSBpblxuICAgICAgZXZhbCBncm91cCB2ZW52IGJvZHkgPj49IGZ1biB2IC0+IHJldHVybiAoQ2Fub25pY2FsLkNyZWF0ZS5kZWZpbmUgdilcblxuICBhbmQgZXZhbF9hcHAgOiBncm91cCAtPiBUaWQudCAtPiBfIENhbm9uaWNhbC5FeHAxLnQgbGlzdCAtPiBfIENhbm9uaWNhbC5FeHAxLnQgZGVmaW5pbmcgPVxuICAgIGZ1biBncm91cCB0aWQgYXJncyAtPlxuICAgICAgbGV0IGdpZCA9IEdyb3VwLmlkIGdyb3VwIGluXG4gICAgICBsZXQgZm9ybWFscywgYm9keSA9IEdyb3VwLmxvb2t1cCBncm91cCB0aWQgaW5cbiAgICAgIGxldCByZWNvcmRfb3Jfbm9ybWFsX3ZhcmlhbnQgPVxuICAgICAgICBtYXRjaCBib2R5IHdpdGhcbiAgICAgICAgfCBSZWNvcmQgXyB8IFZhcmlhbnQgXyAtPiB0cnVlXG4gICAgICAgIHwgVHVwbGUgXyB8IEFubm90YXRlIF8gfCBCYXNlIF8gfCBQb2x5X3ZhcmlhbnQgXyB8IFZhciBfIHwgUmVjX2FwcCBfIHwgVG9wX2FwcCBfIC0+XG4gICAgICAgICAgZmFsc2VcbiAgICAgIGluXG4gICAgICBsZXQgY3ljbGljID0gaXNfY3ljbGljIGdyb3VwIHRpZCBpblxuICAgICAgbGV0IGN5Y2xpY19ub19WUiA9IGlzX2N5Y2xpY193aXRoX25vX2ludGVydmVuaW5nX1ZSIGdyb3VwIHRpZCBpblxuICAgICAgaWYgKHJlY29yZF9vcl9ub3JtYWxfdmFyaWFudCAmJiBjeWNsaWMpIHx8IGN5Y2xpY19ub19WUlxuICAgICAgdGhlblxuICAgICAgICBEZWZpbmluZy5sb29rX2VudiAoZ2lkLCB0aWQpXG4gICAgICAgID4+PSAoZnVuY3Rpb25cbiAgICAgICAgICB8IFNvbWUgcmVjdXJzZSAtPiByZXR1cm4gcmVjdXJzZVxuICAgICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgICAgRGVmaW5pbmcuZXh0ZW5kX25ld190aWQgKGdpZCwgdGlkKSAoZXZhbF9kZWZpbml0aW9uIGdyb3VwIGZvcm1hbHMgYm9keSkpXG4gICAgICAgID4+PSBmdW5jdGlvblxuICAgICAgICB8IFJlY3Vyc2lvbl9sZXZlbCByIC0+IHJldHVybiAoQ2Fub25pY2FsLkV4cDEucmVjdXJzZSByIGFyZ3MpXG4gICAgICAgIHwgRGVmaW5pdGlvbiBkZWYgLT4gcmV0dXJuIChDYW5vbmljYWwuRXhwMS5hcHBseSBkZWYgYXJncylcbiAgICAgIGVsc2UgKFxuICAgICAgICBsZXQgdmVudiA9XG4gICAgICAgICAgbWF0Y2ggTGlzdC56aXAgZm9ybWFscyBhcmdzIHdpdGhcbiAgICAgICAgICB8IE9rIHggLT4gVmVudi5jcmVhdGUgeFxuICAgICAgICAgIHwgVW5lcXVhbF9sZW5ndGhzIC0+IGZhaWx3aXRoIFwiYXBwbHksIGluY29ycmVjdCB0eXBlIGFwcGxpY2F0aW9uIGFyaXR5XCJcbiAgICAgICAgaW5cbiAgICAgICAgZXZhbCBncm91cCB2ZW52IGJvZHkpXG4gIDs7XG5cbiAgKCogdG9wIGxldmVsIGVudHJ5IHBvaW50IGZvciBldmFsdWF0aW9uICopXG4gIGxldCBldmFsIDogdCAtPiBDYW5vbmljYWwudCA9XG4gICAgZnVuIHQgLT5cbiAgICAgIGxldCBncm91cCA9IGdyb3VwIChMb2NhdGlvbi5vZl9zdHJpbmcgXCJ0b3AtbGV2ZWxcIikgW10gaW5cbiAgICAgIGxldCB2ZW52ID0gVmVudi5jcmVhdGUgW10gaW5cbiAgICAgIGxldCB2ID0gRGVmaW5pbmcuZXhlYyAoZXZhbCBncm91cCB2ZW52IHQpIGluXG4gICAgICBDYW5vbmljYWwuQ3JlYXRlLmNyZWF0ZSB2XG4gIDs7XG5lbmRcblxubW9kdWxlIENhbm9uaWNhbCA9IHN0cnVjdFxuICBpbmNsdWRlIENhbm9uaWNhbF9mdWxsXG5cbiAgbW9kdWxlIEV4cCA9IHN0cnVjdFxuICAgIHR5cGUgdCA9IFZpc2liaWxpdHkudmlzaWJsZSBFeHAxLnRcbiAgZW5kXG5lbmRcblxuaW5jbHVkZSBFdmFsdWF0aW9uIChDYW5vbmljYWxfZnVsbClcbm1vZHVsZSBDYW5vbmljYWxfc2VsZWN0ZWQgPSBDYW5vbmljYWxfZGlnZXN0XG5tb2R1bGUgRXZhbHVhdGlvbl90b19kaWdlc3QgPSBFdmFsdWF0aW9uIChDYW5vbmljYWxfc2VsZWN0ZWQpXG5cbmxldCBldmFsX3RvX2RpZ2VzdCBleHAgPSBDYW5vbmljYWxfc2VsZWN0ZWQudG9fZGlnZXN0IChFdmFsdWF0aW9uX3RvX2RpZ2VzdC5ldmFsIGV4cClcbmxldCBldmFsX3RvX2RpZ2VzdF9zdHJpbmcgZXhwID0gRGlnZXN0LnRvX2hleCAoZXZhbF90b19kaWdlc3QgZXhwKVxuXG5tb2R1bGUgRm9yX3R5cGVyZXAgPSBzdHJ1Y3RcbiAgZXhjZXB0aW9uIE5vdF9hX3R1cGxlIG9mIHQgW0BAZGVyaXZpbmcgc2V4cF9vZl1cblxuICBsZXQgZGVjb25zdHJ1Y3RfdHVwbGVfZXhuIHQgPVxuICAgIG1hdGNoIHQgd2l0aFxuICAgIHwgVHVwbGUgdHMgLT4gdHNcbiAgICB8IF8gLT4gcmFpc2UgKE5vdF9hX3R1cGxlIHQpXG4gIDs7XG5lbmRcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT0NhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgIFhhdmllciBMZXJveSwgcHJvamV0IENyaXN0YWwsIElOUklBIFJvY3F1ZW5jb3VydCAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQ29weXJpZ2h0IDE5OTYgSW5zdGl0dXQgTmF0aW9uYWwgZGUgUmVjaGVyY2hlIGVuIEluZm9ybWF0aXF1ZSBldCAgICAgKilcbigqICAgICBlbiBBdXRvbWF0aXF1ZS4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgICAgKilcbigqICAgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIuMSwgd2l0aCB0aGUgICAgICAgICAgKilcbigqICAgc3BlY2lhbCBleGNlcHRpb24gb24gbGlua2luZyBkZXNjcmliZWQgaW4gdGhlIGZpbGUgTElDRU5TRS4gICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTk9URTpcbiAgIElmIHRoaXMgZmlsZSBpcyBzdHJpbmdMYWJlbHMubWxpLCBydW4gdG9vbHMvc3luY19zdGRsaWJfZG9jcyBhZnRlciBlZGl0aW5nXG4gICBpdCB0byBnZW5lcmF0ZSBzdHJpbmcubWxpLlxuXG4gICBJZiB0aGlzIGZpbGUgaXMgc3RyaW5nLm1saSwgZG8gbm90IGVkaXQgaXQgZGlyZWN0bHkgLS0gZWRpdFxuICAgc3RyaW5nTGFiZWxzLm1saSBpbnN0ZWFkLlxuICopXG5cbigqKiBTdHJpbmdzLlxuXG4gICAgQSBzdHJpbmcgW3NdIG9mIGxlbmd0aCBbbl0gaXMgYW4gaW5kZXhhYmxlIGFuZCBpbW11dGFibGUgc2VxdWVuY2VcbiAgICBvZiBbbl0gYnl0ZXMuIEZvciBoaXN0b3JpY2FsIHJlYXNvbnMgdGhlc2UgYnl0ZXMgYXJlIHJlZmVycmVkIHRvXG4gICAgYXMgY2hhcmFjdGVycy5cblxuICAgIFRoZSBzZW1hbnRpY3Mgb2Ygc3RyaW5nIGZ1bmN0aW9ucyBpcyBkZWZpbmVkIGluIHRlcm1zIG9mXG4gICAgaW5kaWNlcyBhbmQgcG9zaXRpb25zLiBUaGVzZSBhcmUgZGVwaWN0ZWQgYW5kIGRlc2NyaWJlZFxuICAgIGFzIGZvbGxvd3MuXG5cbnt2XG5wb3NpdGlvbnMgIDAgICAxICAgMiAgIDMgICA0ICAgIG4tMSAgICBuXG4gICAgICAgICAgICstLS0rLS0tKy0tLSstLS0rICAgICArLS0tLS0rXG4gIGluZGljZXMgIHwgMCB8IDEgfCAyIHwgMyB8IC4uLiB8IG4tMSB8XG4gICAgICAgICAgICstLS0rLS0tKy0tLSstLS0rICAgICArLS0tLS0rXG52fVxuICAgIHt1bFxuICAgIHstIEFuIHtlIGluZGV4fSBbaV0gb2YgW3NdIGlzIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIFxcW1swXTtbbi0xXVxcXS5cbiAgICAgICBJdCByZXByZXNlbnRzIHRoZSBbaV10aCBieXRlIChjaGFyYWN0ZXIpIG9mIFtzXSB3aGljaCBjYW4gYmVcbiAgICAgICBhY2Nlc3NlZCB1c2luZyB0aGUgY29uc3RhbnQgdGltZSBzdHJpbmcgaW5kZXhpbmcgb3BlcmF0b3JcbiAgICAgICBbcy5baV1dLn1cbiAgICB7LSBBIHtlIHBvc2l0aW9ufSBbaV0gb2YgW3NdIGlzIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlXG4gICAgICAgXFxbWzBdO1tuXVxcXS4gSXQgcmVwcmVzZW50cyBlaXRoZXIgdGhlIHBvaW50IGF0IHRoZSBiZWdpbm5pbmcgb2ZcbiAgICAgICB0aGUgc3RyaW5nLCBvciB0aGUgcG9pbnQgYmV0d2VlbiB0d28gaW5kaWNlcywgb3IgdGhlIHBvaW50IGF0XG4gICAgICAgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLiBUaGUgW2lddGggYnl0ZSBpbmRleCBpcyBiZXR3ZWVuIHBvc2l0aW9uXG4gICAgICAgW2ldIGFuZCBbaSsxXS59fVxuXG4gICAgVHdvIGludGVnZXJzIFtzdGFydF0gYW5kIFtsZW5dIGFyZSBzYWlkIHRvIGRlZmluZSBhIHtlIHZhbGlkXG4gICAgc3Vic3RyaW5nfSBvZiBbc10gaWYgW2xlbiA+PSAwXSBhbmQgW3N0YXJ0XSwgW3N0YXJ0K2xlbl0gYXJlXG4gICAgcG9zaXRpb25zIG9mIFtzXS5cblxuICAgIHtiIFVuaWNvZGUgdGV4dC59IFN0cmluZ3MgYmVpbmcgYXJiaXRyYXJ5IHNlcXVlbmNlcyBvZiBieXRlcywgdGhleVxuICAgIGNhbiBob2xkIGFueSBraW5kIG9mIHRleHR1YWwgZW5jb2RpbmcuIEhvd2V2ZXIgdGhlIHJlY29tbWVuZGVkXG4gICAgZW5jb2RpbmcgZm9yIHN0b3JpbmcgVW5pY29kZSB0ZXh0IGluIE9DYW1sIHN0cmluZ3MgaXMgVVRGLTguIFRoaXNcbiAgICBpcyB0aGUgZW5jb2RpbmcgdXNlZCBieSBVbmljb2RlIGVzY2FwZXMgaW4gc3RyaW5nIGxpdGVyYWxzLiBGb3JcbiAgICBleGFtcGxlIHRoZSBzdHJpbmcgW1wiXFx1ezFGNDJCfVwiXSBpcyB0aGUgVVRGLTggZW5jb2Rpbmcgb2YgdGhlXG4gICAgVW5pY29kZSBjaGFyYWN0ZXIgVSsxRjQyQi5cblxuICAgIHtiIFBhc3QgbXV0YWJpbGl0eS59IE9DYW1sIHN0cmluZ3MgdXNlZCB0byBiZSBtb2RpZmlhYmxlIGluIHBsYWNlLFxuICAgIGZvciBpbnN0YW5jZSB2aWEgdGhlIHshU3RyaW5nLnNldH0gYW5kIHshU3RyaW5nLmJsaXR9XG4gICAgZnVuY3Rpb25zLiBUaGlzIHVzZSBpcyBub3dhZGF5cyBvbmx5IHBvc3NpYmxlIHdoZW4gdGhlIGNvbXBpbGVyIGlzXG4gICAgcHV0IGluIFwidW5zYWZlLXN0cmluZ1wiIG1vZGUgYnkgZ2l2aW5nIHRoZSBbLXVuc2FmZS1zdHJpbmddXG4gICAgY29tbWFuZC1saW5lIG9wdGlvbi4gVGhpcyBjb21wYXRpYmlsaXR5IG1vZGUgbWFrZXMgdGhlIHR5cGVzXG4gICAgW3N0cmluZ10gYW5kIFtieXRlc10gKHNlZSB7IUJ5dGVzLnR9KSBpbnRlcmNoYW5nZWFibGUgc28gdGhhdFxuICAgIGZ1bmN0aW9ucyBleHBlY3RpbmcgYnl0ZSBzZXF1ZW5jZXMgY2FuIGFsc28gYWNjZXB0IHN0cmluZ3MgYXNcbiAgICBhcmd1bWVudHMgYW5kIG1vZGlmeSB0aGVtLlxuXG4gICAgVGhlIGRpc3RpbmN0aW9uIGJldHdlZW4gW2J5dGVzXSBhbmQgW3N0cmluZ10gd2FzIGludHJvZHVjZWQgaW5cbiAgICBPQ2FtbCA0LjAyLCBhbmQgdGhlIFwidW5zYWZlLXN0cmluZ1wiIGNvbXBhdGliaWxpdHkgbW9kZSB3YXMgdGhlXG4gICAgZGVmYXVsdCB1bnRpbCBPQ2FtbCA0LjA1LiBTdGFydGluZyB3aXRoIDQuMDYsIHRoZSBjb21wYXRpYmlsaXR5XG4gICAgbW9kZSBpcyBvcHQtaW47IHdlIGludGVuZCB0byByZW1vdmUgdGhlIG9wdGlvbiBpbiB0aGUgZnV0dXJlLlxuXG4gICAgVGhlIGxhYmVsZWQgdmVyc2lvbiBvZiB0aGlzIG1vZHVsZSBjYW4gYmUgdXNlZCBhcyBkZXNjcmliZWQgaW4gdGhlXG4gICAgeyFTdGRMYWJlbHN9IG1vZHVsZS5cbiopXG5cbigqKiB7MTpzdHJpbmdzIFN0cmluZ3N9ICopXG5cbnR5cGUgdCA9IHN0cmluZ1xuKCoqIFRoZSB0eXBlIGZvciBzdHJpbmdzLiAqKVxuXG52YWwgbWFrZSA6IGludCAtPiBjaGFyIC0+IHN0cmluZ1xuKCoqIFttYWtlIG4gY10gaXMgYSBzdHJpbmcgb2YgbGVuZ3RoIFtuXSB3aXRoIGVhY2ggaW5kZXggaG9sZGluZyB0aGVcbiAgICBjaGFyYWN0ZXIgW2NdLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW24gPCAwXSBvciBbbiA+IF17IVN5cy5tYXhfc3RyaW5nX2xlbmd0aH0uICopXG5cbnZhbCBpbml0IDogaW50IC0+IChpbnQgLT4gY2hhcikgLT4gc3RyaW5nXG4oKiogW2luaXQgbiBmXSBpcyBhIHN0cmluZyBvZiBsZW5ndGggW25dIHdpdGggaW5kZXhcbiAgICBbaV0gaG9sZGluZyB0aGUgY2hhcmFjdGVyIFtmIGldIChjYWxsZWQgaW4gaW5jcmVhc2luZyBpbmRleCBvcmRlcikuXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbbiA8IDBdIG9yIFtuID4gXXshU3lzLm1heF9zdHJpbmdfbGVuZ3RofS5cbiAgICBAc2luY2UgNC4wMi4wICopXG5cbnZhbCBlbXB0eSA6IHN0cmluZ1xuKCoqIFRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgb2ZfYnl0ZXMgOiBieXRlcyAtPiBzdHJpbmdcbigqKiBSZXR1cm4gYSBuZXcgc3RyaW5nIHRoYXQgY29udGFpbnMgdGhlIHNhbWUgYnl0ZXMgYXMgdGhlIGdpdmVuIGJ5dGVcbiAgICBzZXF1ZW5jZS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCB0b19ieXRlcyA6IHN0cmluZyAtPiBieXRlc1xuKCoqIFJldHVybiBhIG5ldyBieXRlIHNlcXVlbmNlIHRoYXQgY29udGFpbnMgdGhlIHNhbWUgYnl0ZXMgYXMgdGhlIGdpdmVuXG4gICAgc3RyaW5nLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxuZXh0ZXJuYWwgbGVuZ3RoIDogc3RyaW5nIC0+IGludCA9IFwiJXN0cmluZ19sZW5ndGhcIlxuKCoqIFtsZW5ndGggc10gaXMgdGhlIGxlbmd0aCAobnVtYmVyIG9mIGJ5dGVzL2NoYXJhY3RlcnMpIG9mIFtzXS4gKilcblxuZXh0ZXJuYWwgZ2V0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyID0gXCIlc3RyaW5nX3NhZmVfZ2V0XCJcbigqKiBbZ2V0IHMgaV0gaXMgdGhlIGNoYXJhY3RlciBhdCBpbmRleCBbaV0gaW4gW3NdLiBUaGlzIGlzIHRoZSBzYW1lXG4gICAgYXMgd3JpdGluZyBbcy5baV1dLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW2ldIG5vdCBhbiBpbmRleCBvZiBbc10uICopXG5cbigqKiB7MTpjb25jYXQgQ29uY2F0ZW5hdGluZ31cblxuICAgIHtiIE5vdGUufSBUaGUgeyFTdGRsaWIuKCBeICl9IGJpbmFyeSBvcGVyYXRvciBjb25jYXRlbmF0ZXMgdHdvXG4gICAgc3RyaW5ncy4gKilcblxudmFsIGNvbmNhdCA6IHN0cmluZyAtPiBzdHJpbmcgbGlzdCAtPiBzdHJpbmdcbigqKiBbY29uY2F0IHNlcCBzc10gY29uY2F0ZW5hdGVzIHRoZSBsaXN0IG9mIHN0cmluZ3MgW3NzXSwgaW5zZXJ0aW5nXG4gICAgdGhlIHNlcGFyYXRvciBzdHJpbmcgW3NlcF0gYmV0d2VlbiBlYWNoLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgdGhlIHJlc3VsdCBpcyBsb25nZXIgdGhhblxuICAgIHshU3lzLm1heF9zdHJpbmdfbGVuZ3RofSBieXRlcy4gKilcblxudmFsIGNhdCA6IHN0cmluZyAtPiBzdHJpbmcgLT4gc3RyaW5nXG4oKiogW2NhdCBzMSBzMl0gY29uY2F0ZW5hdGVzIHMxIGFuZCBzMiAoW3MxIF4gczJdKS5cblxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIHRoZSByZXN1bHQgaXMgbG9uZ2VyIHRoZW5cbiAgICB0aGFuIHshU3lzLm1heF9zdHJpbmdfbGVuZ3RofSBieXRlcy5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbigqKiB7MTpwcmVkaWNhdGVzIFByZWRpY2F0ZXMgYW5kIGNvbXBhcmlzb25zfSAqKVxuXG52YWwgZXF1YWwgOiB0IC0+IHQgLT4gYm9vbFxuKCoqIFtlcXVhbCBzMCBzMV0gaXMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIFtzMF0gYW5kIFtzMV0gYXJlIGNoYXJhY3Rlci13aXNlXG4gICAgZXF1YWwuXG4gICAgQHNpbmNlIDQuMDMuMCAoNC4wNS4wIGluIFN0cmluZ0xhYmVscykgKilcblxudmFsIGNvbXBhcmUgOiB0IC0+IHQgLT4gaW50XG4oKiogW2NvbXBhcmUgczAgczFdIHNvcnRzIFtzMF0gYW5kIFtzMV0gaW4gbGV4aWNvZ3JhcGhpY2FsIG9yZGVyLiBbY29tcGFyZV1cbiAgICBiZWhhdmVzIGxpa2UgeyFTdGRsaWIuY29tcGFyZX0gb24gc3RyaW5ncyBidXQgbWF5IGJlIG1vcmUgZWZmaWNpZW50LiAqKVxuXG52YWwgc3RhcnRzX3dpdGggOlxuICBwcmVmaXggKCogY29tbWVudCB0aHdhcnRzIHRvb2xzL3N5bmNfc3RkbGliX2RvY3MgKikgOnN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuKCoqIFtzdGFydHNfd2l0aCBdW35dW3ByZWZpeCBzXSBpcyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgW3NdIHN0YXJ0cyB3aXRoXG4gICAgW3ByZWZpeF0uXG5cbiAgICBAc2luY2UgNC4xMy4wICopXG5cbnZhbCBlbmRzX3dpdGggOlxuICBzdWZmaXggKCogY29tbWVudCB0aHdhcnRzIHRvb2xzL3N5bmNfc3RkbGliX2RvY3MgKikgOnN0cmluZyAtPiBzdHJpbmcgLT4gYm9vbFxuKCoqIFtlbmRzX3dpdGggc3VmZml4IHNdIGlzIFt0cnVlXSBpZiBhbmQgb25seSBpZiBbc10gZW5kcyB3aXRoIFtzdWZmaXhdLlxuXG4gICAgQHNpbmNlIDQuMTMuMCAqKVxuXG52YWwgY29udGFpbnNfZnJvbSA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciAtPiBib29sXG4oKiogW2NvbnRhaW5zX2Zyb20gcyBzdGFydCBjXSBpcyBbdHJ1ZV0gaWYgYW5kIG9ubHkgaWYgW2NdIGFwcGVhcnMgaW4gW3NdXG4gICAgYWZ0ZXIgcG9zaXRpb24gW3N0YXJ0XS5cblxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtzdGFydF0gaXMgbm90IGEgdmFsaWQgcG9zaXRpb24gaW4gW3NdLiAqKVxuXG52YWwgcmNvbnRhaW5zX2Zyb20gOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgLT4gYm9vbFxuKCoqIFtyY29udGFpbnNfZnJvbSBzIHN0b3AgY10gaXMgW3RydWVdIGlmIGFuZCBvbmx5IGlmIFtjXSBhcHBlYXJzIGluIFtzXVxuICAgIGJlZm9yZSBwb3NpdGlvbiBbc3RvcCsxXS5cblxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtzdG9wIDwgMF0gb3IgW3N0b3ArMV0gaXMgbm90IGEgdmFsaWRcbiAgICBwb3NpdGlvbiBpbiBbc10uICopXG5cbnZhbCBjb250YWlucyA6IHN0cmluZyAtPiBjaGFyIC0+IGJvb2xcbigqKiBbY29udGFpbnMgcyBjXSBpcyB7IVN0cmluZy5jb250YWluc19mcm9tfVsgcyAwIGNdLiAqKVxuXG4oKiogezE6ZXh0cmFjdCBFeHRyYWN0aW5nIHN1YnN0cmluZ3N9ICopXG5cbnZhbCBzdWIgOiBzdHJpbmcgLT4gaW50IC0+IGludCAtPiBzdHJpbmdcbigqKiBbc3ViIHMgcG9zIGxlbl0gaXMgYSBzdHJpbmcgb2YgbGVuZ3RoIFtsZW5dLCBjb250YWluaW5nIHRoZVxuICAgIHN1YnN0cmluZyBvZiBbc10gdGhhdCBzdGFydHMgYXQgcG9zaXRpb24gW3Bvc10gYW5kIGhhcyBsZW5ndGhcbiAgICBbbGVuXS5cblxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtwb3NdIGFuZCBbbGVuXSBkbyBub3QgZGVzaWduYXRlIGEgdmFsaWRcbiAgICBzdWJzdHJpbmcgb2YgW3NdLiAqKVxuXG52YWwgc3BsaXRfb25fY2hhciA6IGNoYXIgLT4gc3RyaW5nIC0+IHN0cmluZyBsaXN0XG4oKiogW3NwbGl0X29uX2NoYXIgc2VwIHNdIGlzIHRoZSBsaXN0IG9mIGFsbCAocG9zc2libHkgZW1wdHkpXG4gICAgc3Vic3RyaW5ncyBvZiBbc10gdGhhdCBhcmUgZGVsaW1pdGVkIGJ5IHRoZSBjaGFyYWN0ZXIgW3NlcF0uXG5cbiAgICBUaGUgZnVuY3Rpb24ncyByZXN1bHQgaXMgc3BlY2lmaWVkIGJ5IHRoZSBmb2xsb3dpbmcgaW52YXJpYW50czpcbiAgICB7dWxcbiAgICB7LSBUaGUgbGlzdCBpcyBub3QgZW1wdHkufVxuICAgIHstIENvbmNhdGVuYXRpbmcgaXRzIGVsZW1lbnRzIHVzaW5nIFtzZXBdIGFzIGEgc2VwYXJhdG9yIHJldHVybnMgYVxuICAgICAgc3RyaW5nIGVxdWFsIHRvIHRoZSBpbnB1dCAoW2NvbmNhdCAobWFrZSAxIHNlcClcbiAgICAgIChzcGxpdF9vbl9jaGFyIHNlcCBzKSA9IHNdKS59XG4gICAgey0gTm8gc3RyaW5nIGluIHRoZSByZXN1bHQgY29udGFpbnMgdGhlIFtzZXBdIGNoYXJhY3Rlci59fVxuXG4gICAgQHNpbmNlIDQuMDQuMCAoNC4wNS4wIGluIFN0cmluZ0xhYmVscykgKilcblxuKCoqIHsxOnRyYW5zZm9ybWluZyBUcmFuc2Zvcm1pbmd9ICopXG5cbnZhbCBtYXAgOiAoY2hhciAtPiBjaGFyKSAtPiBzdHJpbmcgLT4gc3RyaW5nXG4oKiogW21hcCBmIHNdIGlzIHRoZSBzdHJpbmcgcmVzdWx0aW5nIGZyb20gYXBwbHlpbmcgW2ZdIHRvIGFsbCB0aGVcbiAgICBjaGFyYWN0ZXJzIG9mIFtzXSBpbiBpbmNyZWFzaW5nIG9yZGVyLlxuXG4gICAgQHNpbmNlIDQuMDAuMCAqKVxuXG52YWwgbWFwaSA6IChpbnQgLT4gY2hhciAtPiBjaGFyKSAtPiBzdHJpbmcgLT4gc3RyaW5nXG4oKiogW21hcGkgZiBzXSBpcyBsaWtlIHshbWFwfSBidXQgdGhlIGluZGV4IG9mIHRoZSBjaGFyYWN0ZXIgaXMgYWxzb1xuICAgIHBhc3NlZCB0byBbZl0uXG5cbiAgICBAc2luY2UgNC4wMi4wICopXG5cbnZhbCBmb2xkX2xlZnQgOiAoJ2EgLT4gY2hhciAtPiAnYSkgLT4gJ2EgLT4gc3RyaW5nIC0+ICdhXG4oKiogW2ZvbGRfbGVmdCBmIHggc10gY29tcHV0ZXMgW2YgKC4uLiAoZiAoZiB4IHMuWzBdKSBzLlsxXSkgLi4uKSBzLltuLTFdXSxcbiAgICB3aGVyZSBbbl0gaXMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIFtzXS5cbiAgICBAc2luY2UgNC4xMy4wICopXG5cbnZhbCBmb2xkX3JpZ2h0IDogKGNoYXIgLT4gJ2EgLT4gJ2EpIC0+IHN0cmluZyAtPiAnYSAtPiAnYVxuKCoqIFtmb2xkX3JpZ2h0IGYgcyB4XSBjb21wdXRlcyBbZiBzLlswXSAoZiBzLlsxXSAoIC4uLiAoZiBzLltuLTFdIHgpIC4uLikpXSxcbiAgICB3aGVyZSBbbl0gaXMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIFtzXS5cbiAgICBAc2luY2UgNC4xMy4wICopXG5cbnZhbCBmb3JfYWxsIDogKGNoYXIgLT4gYm9vbCkgLT4gc3RyaW5nIC0+IGJvb2xcbigqKiBbZm9yX2FsbCBwIHNdIGNoZWNrcyBpZiBhbGwgY2hhcmFjdGVycyBpbiBbc10gc2F0aXNmeSB0aGUgcHJlZGljYXRlIFtwXS5cbiAgICBAc2luY2UgNC4xMy4wICopXG5cbnZhbCBleGlzdHMgOiAoY2hhciAtPiBib29sKSAtPiBzdHJpbmcgLT4gYm9vbFxuKCoqIFtleGlzdHMgcCBzXSBjaGVja3MgaWYgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBvZiBbc10gc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGVcbiAgICBbcF0uXG4gICAgQHNpbmNlIDQuMTMuMCAqKVxuXG52YWwgdHJpbSA6IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbdHJpbSBzXSBpcyBbc10gd2l0aG91dCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiBXaGl0ZXNwYWNlXG4gICAgY2hhcmFjdGVycyBhcmU6IFsnICddLCBbJ1xceDBDJ10gKGZvcm0gZmVlZCksIFsnXFxuJ10sIFsnXFxyJ10sIGFuZCBbJ1xcdCddLlxuXG4gICAgQHNpbmNlIDQuMDAuMCAqKVxuXG52YWwgZXNjYXBlZCA6IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbZXNjYXBlZCBzXSBpcyBbc10gd2l0aCBzcGVjaWFsIGNoYXJhY3RlcnMgcmVwcmVzZW50ZWQgYnkgZXNjYXBlXG4gICAgc2VxdWVuY2VzLCBmb2xsb3dpbmcgdGhlIGxleGljYWwgY29udmVudGlvbnMgb2YgT0NhbWwuXG5cbiAgICBBbGwgY2hhcmFjdGVycyBvdXRzaWRlIHRoZSBVUy1BU0NJSSBwcmludGFibGUgcmFuZ2UgXFxbMHgyMDsweDdFXFxdIGFyZVxuICAgIGVzY2FwZWQsIGFzIHdlbGwgYXMgYmFja3NsYXNoICgweDJGKSBhbmQgZG91YmxlLXF1b3RlICgweDIyKS5cblxuICAgIFRoZSBmdW5jdGlvbiB7IVNjYW5mLnVuZXNjYXBlZH0gaXMgYSBsZWZ0IGludmVyc2Ugb2YgW2VzY2FwZWRdLFxuICAgIGkuZS4gW1NjYW5mLnVuZXNjYXBlZCAoZXNjYXBlZCBzKSA9IHNdIGZvciBhbnkgc3RyaW5nIFtzXSAodW5sZXNzXG4gICAgW2VzY2FwZWQgc10gZmFpbHMpLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgdGhlIHJlc3VsdCBpcyBsb25nZXIgdGhhblxuICAgIHshU3lzLm1heF9zdHJpbmdfbGVuZ3RofSBieXRlcy4gKilcblxudmFsIHVwcGVyY2FzZV9hc2NpaSA6IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbdXBwZXJjYXNlX2FzY2lpIHNdIGlzIFtzXSB3aXRoIGFsbCBsb3dlcmNhc2UgbGV0dGVyc1xuICAgIHRyYW5zbGF0ZWQgdG8gdXBwZXJjYXNlLCB1c2luZyB0aGUgVVMtQVNDSUkgY2hhcmFjdGVyIHNldC5cblxuICAgIEBzaW5jZSA0LjAzLjAgKDQuMDUuMCBpbiBTdHJpbmdMYWJlbHMpICopXG5cbnZhbCBsb3dlcmNhc2VfYXNjaWkgOiBzdHJpbmcgLT4gc3RyaW5nXG4oKiogW2xvd2VyY2FzZV9hc2NpaSBzXSBpcyBbc10gd2l0aCBhbGwgdXBwZXJjYXNlIGxldHRlcnMgdHJhbnNsYXRlZFxuICAgIHRvIGxvd2VyY2FzZSwgdXNpbmcgdGhlIFVTLUFTQ0lJIGNoYXJhY3RlciBzZXQuXG5cbiAgICBAc2luY2UgNC4wMy4wICg0LjA1LjAgaW4gU3RyaW5nTGFiZWxzKSAqKVxuXG52YWwgY2FwaXRhbGl6ZV9hc2NpaSA6IHN0cmluZyAtPiBzdHJpbmdcbigqKiBbY2FwaXRhbGl6ZV9hc2NpaSBzXSBpcyBbc10gd2l0aCB0aGUgZmlyc3QgY2hhcmFjdGVyIHNldCB0b1xuICAgIHVwcGVyY2FzZSwgdXNpbmcgdGhlIFVTLUFTQ0lJIGNoYXJhY3RlciBzZXQuXG5cbiAgICBAc2luY2UgNC4wMy4wICg0LjA1LjAgaW4gU3RyaW5nTGFiZWxzKSAqKVxuXG52YWwgdW5jYXBpdGFsaXplX2FzY2lpIDogc3RyaW5nIC0+IHN0cmluZ1xuKCoqIFt1bmNhcGl0YWxpemVfYXNjaWkgc10gaXMgW3NdIHdpdGggdGhlIGZpcnN0IGNoYXJhY3RlciBzZXQgdG8gbG93ZXJjYXNlLFxuICAgIHVzaW5nIHRoZSBVUy1BU0NJSSBjaGFyYWN0ZXIgc2V0LlxuXG4gICAgQHNpbmNlIDQuMDMuMCAoNC4wNS4wIGluIFN0cmluZ0xhYmVscykgKilcblxuKCoqIHsxOnRyYXZlcnNpbmcgVHJhdmVyc2luZ30gKilcblxudmFsIGl0ZXIgOiAoY2hhciAtPiB1bml0KSAtPiBzdHJpbmcgLT4gdW5pdFxuKCoqIFtpdGVyIGYgc10gYXBwbGllcyBmdW5jdGlvbiBbZl0gaW4gdHVybiB0byBhbGwgdGhlIGNoYXJhY3RlcnMgb2YgW3NdLlxuICAgIEl0IGlzIGVxdWl2YWxlbnQgdG8gW2Ygcy5bMF07IGYgcy5bMV07IC4uLjsgZiBzLltsZW5ndGggcyAtIDFdOyAoKV0uICopXG5cbnZhbCBpdGVyaSA6IChpbnQgLT4gY2hhciAtPiB1bml0KSAtPiBzdHJpbmcgLT4gdW5pdFxuKCoqIFtpdGVyaV0gaXMgbGlrZSB7IWl0ZXJ9LCBidXQgdGhlIGZ1bmN0aW9uIGlzIGFsc28gZ2l2ZW4gdGhlXG4gICAgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXIgaW5kZXguXG5cbiAgICBAc2luY2UgNC4wMC4wICopXG5cbigqKiB7MTpzZWFyY2hpbmcgU2VhcmNoaW5nfSAqKVxuXG52YWwgaW5kZXhfZnJvbSA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciAtPiBpbnRcbigqKiBbaW5kZXhfZnJvbSBzIGkgY10gaXMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIFtjXSBpblxuICAgIFtzXSBhZnRlciBwb3NpdGlvbiBbaV0uXG5cbiAgICBAcmFpc2UgTm90X2ZvdW5kIGlmIFtjXSBkb2VzIG5vdCBvY2N1ciBpbiBbc10gYWZ0ZXIgcG9zaXRpb24gW2ldLlxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtpXSBpcyBub3QgYSB2YWxpZCBwb3NpdGlvbiBpbiBbc10uICopXG5cblxudmFsIGluZGV4X2Zyb21fb3B0IDogc3RyaW5nIC0+IGludCAtPiBjaGFyIC0+IGludCBvcHRpb25cbigqKiBbaW5kZXhfZnJvbV9vcHQgcyBpIGNdIGlzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBbY11cbiAgICBpbiBbc10gYWZ0ZXIgcG9zaXRpb24gW2ldIChpZiBhbnkpLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW2ldIGlzIG5vdCBhIHZhbGlkIHBvc2l0aW9uIGluIFtzXS5cbiAgICBAc2luY2UgNC4wNSAqKVxuXG52YWwgcmluZGV4X2Zyb20gOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgLT4gaW50XG4oKiogW3JpbmRleF9mcm9tIHMgaSBjXSBpcyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBbY10gaW5cbiAgICBbc10gYmVmb3JlIHBvc2l0aW9uIFtpKzFdLlxuXG4gICAgQHJhaXNlIE5vdF9mb3VuZCBpZiBbY10gZG9lcyBub3Qgb2NjdXIgaW4gW3NdIGJlZm9yZSBwb3NpdGlvbiBbaSsxXS5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbaSsxXSBpcyBub3QgYSB2YWxpZCBwb3NpdGlvbiBpbiBbc10uICopXG5cbnZhbCByaW5kZXhfZnJvbV9vcHQgOiBzdHJpbmcgLT4gaW50IC0+IGNoYXIgLT4gaW50IG9wdGlvblxuKCoqIFtyaW5kZXhfZnJvbV9vcHQgcyBpIGNdIGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIFtjXVxuICAgIGluIFtzXSBiZWZvcmUgcG9zaXRpb24gW2krMV0gKGlmIGFueSkuXG5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbaSsxXSBpcyBub3QgYSB2YWxpZCBwb3NpdGlvbiBpbiBbc10uXG4gICAgQHNpbmNlIDQuMDUgKilcblxudmFsIGluZGV4IDogc3RyaW5nIC0+IGNoYXIgLT4gaW50XG4oKiogW2luZGV4IHMgY10gaXMgeyFTdHJpbmcuaW5kZXhfZnJvbX1bIHMgMCBjXS4gKilcblxudmFsIGluZGV4X29wdCA6IHN0cmluZyAtPiBjaGFyIC0+IGludCBvcHRpb25cbigqKiBbaW5kZXhfb3B0IHMgY10gaXMgeyFTdHJpbmcuaW5kZXhfZnJvbV9vcHR9WyBzIDAgY10uXG5cbiAgICBAc2luY2UgNC4wNSAqKVxuXG52YWwgcmluZGV4IDogc3RyaW5nIC0+IGNoYXIgLT4gaW50XG4oKiogW3JpbmRleCBzIGNdIGlzIHshU3RyaW5nLnJpbmRleF9mcm9tfVsgcyAobGVuZ3RoIHMgLSAxKSBjXS4gKilcblxudmFsIHJpbmRleF9vcHQgOiBzdHJpbmcgLT4gY2hhciAtPiBpbnQgb3B0aW9uXG4oKiogW3JpbmRleF9vcHQgcyBjXSBpcyB7IVN0cmluZy5yaW5kZXhfZnJvbV9vcHR9WyBzIChsZW5ndGggcyAtIDEpIGNdLlxuXG4gICAgQHNpbmNlIDQuMDUgKilcblxuKCoqIHsxIFN0cmluZ3MgYW5kIFNlcXVlbmNlc30gKilcblxudmFsIHRvX3NlcSA6IHQgLT4gY2hhciBTZXEudFxuKCoqIFt0b19zZXEgc10gaXMgYSBzZXF1ZW5jZSBtYWRlIG9mIHRoZSBzdHJpbmcncyBjaGFyYWN0ZXJzIGluXG4gICAgaW5jcmVhc2luZyBvcmRlci4gSW4gW1widW5zYWZlLXN0cmluZ1wiXSBtb2RlLCBtb2RpZmljYXRpb25zIG9mIHRoZSBzdHJpbmdcbiAgICBkdXJpbmcgaXRlcmF0aW9uIHdpbGwgYmUgcmVmbGVjdGVkIGluIHRoZSBzZXF1ZW5jZS5cblxuICAgIEBzaW5jZSA0LjA3ICopXG5cbnZhbCB0b19zZXFpIDogdCAtPiAoaW50ICogY2hhcikgU2VxLnRcbigqKiBbdG9fc2VxaSBzXSBpcyBsaWtlIHshdG9fc2VxfSBidXQgYWxzbyB0dXBsZXMgdGhlIGNvcnJlc3BvbmRpbmcgaW5kZXguXG5cbiAgICBAc2luY2UgNC4wNyAqKVxuXG52YWwgb2Zfc2VxIDogY2hhciBTZXEudCAtPiB0XG4oKiogW29mX3NlcSBzXSBpcyBhIHN0cmluZyBtYWRlIG9mIHRoZSBzZXF1ZW5jZSdzIGNoYXJhY3RlcnMuXG5cbiAgICBAc2luY2UgNC4wNyAqKVxuXG4oKiogezE6ZGVwcmVjYXRlZCBEZXByZWNhdGVkIGZ1bmN0aW9uc30gKilcblxuZXh0ZXJuYWwgY3JlYXRlIDogaW50IC0+IGJ5dGVzID0gXCJjYW1sX2NyZWF0ZV9zdHJpbmdcIlxuICBbQEBvY2FtbC5kZXByZWNhdGVkIFwiVXNlIEJ5dGVzLmNyZWF0ZS9CeXRlc0xhYmVscy5jcmVhdGUgaW5zdGVhZC5cIl1cbigqKiBbY3JlYXRlIG5dIHJldHVybnMgYSBmcmVzaCBieXRlIHNlcXVlbmNlIG9mIGxlbmd0aCBbbl0uXG4gICAgVGhlIHNlcXVlbmNlIGlzIHVuaW5pdGlhbGl6ZWQgYW5kIGNvbnRhaW5zIGFyYml0cmFyeSBieXRlcy5cbiAgICBAcmFpc2UgSW52YWxpZF9hcmd1bWVudCBpZiBbbiA8IDBdIG9yIFtuID4gXXshU3lzLm1heF9zdHJpbmdfbGVuZ3RofS5cblxuICAgIEBkZXByZWNhdGVkIFRoaXMgaXMgYSBkZXByZWNhdGVkIGFsaWFzIG9mXG4gICAgeyFCeXRlcy5jcmVhdGV9L3shQnl0ZXNMYWJlbHMuY3JlYXRlfS4gKilcblxuZXh0ZXJuYWwgc2V0IDogYnl0ZXMgLT4gaW50IC0+IGNoYXIgLT4gdW5pdCA9IFwiJXN0cmluZ19zYWZlX3NldFwiXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgQnl0ZXMuc2V0L0J5dGVzTGFiZWxzLnNldCBpbnN0ZWFkLlwiXVxuKCoqIFtzZXQgcyBuIGNdIG1vZGlmaWVzIGJ5dGUgc2VxdWVuY2UgW3NdIGluIHBsYWNlLFxuICAgIHJlcGxhY2luZyB0aGUgYnl0ZSBhdCBpbmRleCBbbl0gd2l0aCBbY10uXG4gICAgWW91IGNhbiBhbHNvIHdyaXRlIFtzLltuXSA8LSBjXSBpbnN0ZWFkIG9mIFtzZXQgcyBuIGNdLlxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtuXSBpcyBub3QgYSB2YWxpZCBpbmRleCBpbiBbc10uXG5cbiAgICBAZGVwcmVjYXRlZCBUaGlzIGlzIGEgZGVwcmVjYXRlZCBhbGlhcyBvZlxuICAgIHshQnl0ZXMuc2V0fS97IUJ5dGVzTGFiZWxzLnNldH0uICopXG5cbnZhbCBibGl0IDpcbiAgc3RyaW5nIC0+IGludCAtPiBieXRlcyAtPiBpbnQgLT4gaW50IC0+IHVuaXRcbigqKiBbYmxpdCBzcmMgc3JjX3BvcyBkc3QgZHN0X3BvcyBsZW5dIGNvcGllcyBbbGVuXSBieXRlc1xuICAgIGZyb20gdGhlIHN0cmluZyBbc3JjXSwgc3RhcnRpbmcgYXQgaW5kZXggW3NyY19wb3NdLFxuICAgIHRvIGJ5dGUgc2VxdWVuY2UgW2RzdF0sIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBudW1iZXIgW2RzdF9wb3NdLlxuXG4gICAgQHJhaXNlIEludmFsaWRfYXJndW1lbnQgaWYgW3NyY19wb3NdIGFuZCBbbGVuXSBkbyBub3RcbiAgICBkZXNpZ25hdGUgYSB2YWxpZCByYW5nZSBvZiBbc3JjXSwgb3IgaWYgW2RzdF9wb3NdIGFuZCBbbGVuXVxuICAgIGRvIG5vdCBkZXNpZ25hdGUgYSB2YWxpZCByYW5nZSBvZiBbZHN0XS4gKilcblxudmFsIGNvcHkgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJTdHJpbmdzIG5vdyBpbW11dGFibGU6IG5vIG5lZWQgdG8gY29weVwiXVxuKCoqIFJldHVybiBhIGNvcHkgb2YgdGhlIGdpdmVuIHN0cmluZy5cblxuICAgIEBkZXByZWNhdGVkIEJlY2F1c2Ugc3RyaW5ncyBhcmUgaW1tdXRhYmxlLCBpdCBkb2Vzbid0IG1ha2UgbXVjaFxuICAgIHNlbnNlIHRvIG1ha2UgaWRlbnRpY2FsIGNvcGllcyBvZiB0aGVtLiAqKVxuXG52YWwgZmlsbCA6IGJ5dGVzIC0+IGludCAtPiBpbnQgLT4gY2hhciAtPiB1bml0XG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWQgXCJVc2UgQnl0ZXMuZmlsbC9CeXRlc0xhYmVscy5maWxsIGluc3RlYWQuXCJdXG4oKiogW2ZpbGwgcyBwb3MgbGVuIGNdIG1vZGlmaWVzIGJ5dGUgc2VxdWVuY2UgW3NdIGluIHBsYWNlLFxuICAgIHJlcGxhY2luZyBbbGVuXSBieXRlcyBieSBbY10sIHN0YXJ0aW5nIGF0IFtwb3NdLlxuICAgIEByYWlzZSBJbnZhbGlkX2FyZ3VtZW50IGlmIFtwb3NdIGFuZCBbbGVuXSBkbyBub3RcbiAgICBkZXNpZ25hdGUgYSB2YWxpZCBzdWJzdHJpbmcgb2YgW3NdLlxuXG4gICAgQGRlcHJlY2F0ZWQgVGhpcyBpcyBhIGRlcHJlY2F0ZWQgYWxpYXMgb2ZcbiAgICB7IUJ5dGVzLmZpbGx9L3shQnl0ZXNMYWJlbHMuZmlsbH0uICopXG5cbnZhbCB1cHBlcmNhc2UgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWRcbiAgICBcIlVzZSBTdHJpbmcudXBwZXJjYXNlX2FzY2lpL1N0cmluZ0xhYmVscy51cHBlcmNhc2VfYXNjaWkgaW5zdGVhZC5cIl1cbigqKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBhcmd1bWVudCwgd2l0aCBhbGwgbG93ZXJjYXNlIGxldHRlcnNcbiAgICB0cmFuc2xhdGVkIHRvIHVwcGVyY2FzZSwgaW5jbHVkaW5nIGFjY2VudGVkIGxldHRlcnMgb2YgdGhlIElTT1xuICAgIExhdGluLTEgKDg4NTktMSkgY2hhcmFjdGVyIHNldC5cblxuICAgIEBkZXByZWNhdGVkIEZ1bmN0aW9ucyBvcGVyYXRpbmcgb24gTGF0aW4tMSBjaGFyYWN0ZXIgc2V0IGFyZSBkZXByZWNhdGVkLiAqKVxuXG52YWwgbG93ZXJjYXNlIDogc3RyaW5nIC0+IHN0cmluZ1xuICBbQEBvY2FtbC5kZXByZWNhdGVkXG4gICAgXCJVc2UgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaS9TdHJpbmdMYWJlbHMubG93ZXJjYXNlX2FzY2lpIGluc3RlYWQuXCJdXG4oKiogUmV0dXJuIGEgY29weSBvZiB0aGUgYXJndW1lbnQsIHdpdGggYWxsIHVwcGVyY2FzZSBsZXR0ZXJzXG4gICAgdHJhbnNsYXRlZCB0byBsb3dlcmNhc2UsIGluY2x1ZGluZyBhY2NlbnRlZCBsZXR0ZXJzIG9mIHRoZSBJU09cbiAgICBMYXRpbi0xICg4ODU5LTEpIGNoYXJhY3RlciBzZXQuXG5cbiAgICBAZGVwcmVjYXRlZCBGdW5jdGlvbnMgb3BlcmF0aW5nIG9uIExhdGluLTEgY2hhcmFjdGVyIHNldCBhcmUgZGVwcmVjYXRlZC4gKilcblxudmFsIGNhcGl0YWxpemUgOiBzdHJpbmcgLT4gc3RyaW5nXG4gIFtAQG9jYW1sLmRlcHJlY2F0ZWRcbiAgICBcIlVzZSBTdHJpbmcuY2FwaXRhbGl6ZV9hc2NpaS9TdHJpbmdMYWJlbHMuY2FwaXRhbGl6ZV9hc2NpaSBpbnN0ZWFkLlwiXVxuKCoqIFJldHVybiBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50LCB3aXRoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgc2V0IHRvIHVwcGVyY2FzZSxcbiAgICB1c2luZyB0aGUgSVNPIExhdGluLTEgKDg4NTktMSkgY2hhcmFjdGVyIHNldC4uXG5cbiAgICBAZGVwcmVjYXRlZCBGdW5jdGlvbnMgb3BlcmF0aW5nIG9uIExhdGluLTEgY2hhcmFjdGVyIHNldCBhcmUgZGVwcmVjYXRlZC4gKilcblxudmFsIHVuY2FwaXRhbGl6ZSA6IHN0cmluZyAtPiBzdHJpbmdcbiAgW0BAb2NhbWwuZGVwcmVjYXRlZFxuICAgIFwiVXNlIFN0cmluZy51bmNhcGl0YWxpemVfYXNjaWkvU3RyaW5nTGFiZWxzLnVuY2FwaXRhbGl6ZV9hc2NpaSBpbnN0ZWFkLlwiXVxuKCoqIFJldHVybiBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50LCB3aXRoIHRoZSBmaXJzdCBjaGFyYWN0ZXIgc2V0IHRvIGxvd2VyY2FzZSxcbiAgICB1c2luZyB0aGUgSVNPIExhdGluLTEgKDg4NTktMSkgY2hhcmFjdGVyIHNldC5cblxuICAgIEBkZXByZWNhdGVkIEZ1bmN0aW9ucyBvcGVyYXRpbmcgb24gTGF0aW4tMSBjaGFyYWN0ZXIgc2V0IGFyZSBkZXByZWNhdGVkLiAqKVxuXG4oKiogezEgQmluYXJ5IGRlY29kaW5nIG9mIGludGVnZXJzfSAqKVxuXG4oKiogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIHNlY3Rpb24gYmluYXJ5IGRlY29kZSBpbnRlZ2VycyBmcm9tIHN0cmluZ3MuXG5cbiAgICBBbGwgZm9sbG93aW5nIGZ1bmN0aW9ucyByYWlzZSBbSW52YWxpZF9hcmd1bWVudF0gaWYgdGhlIGNoYXJhY3RlcnNcbiAgICBuZWVkZWQgYXQgaW5kZXggW2ldIHRvIGRlY29kZSB0aGUgaW50ZWdlciBhcmUgbm90IGF2YWlsYWJsZS5cblxuICAgIExpdHRsZS1lbmRpYW4gKHJlc3AuIGJpZy1lbmRpYW4pIGVuY29kaW5nIG1lYW5zIHRoYXQgbGVhc3RcbiAgICAocmVzcC4gbW9zdCkgc2lnbmlmaWNhbnQgYnl0ZXMgYXJlIHN0b3JlZCBmaXJzdC4gIEJpZy1lbmRpYW4gaXNcbiAgICBhbHNvIGtub3duIGFzIG5ldHdvcmsgYnl0ZSBvcmRlci4gIE5hdGl2ZS1lbmRpYW4gZW5jb2RpbmcgaXNcbiAgICBlaXRoZXIgbGl0dGxlLWVuZGlhbiBvciBiaWctZW5kaWFuIGRlcGVuZGluZyBvbiB7IVN5cy5iaWdfZW5kaWFufS5cblxuICAgIDMyLWJpdCBhbmQgNjQtYml0IGludGVnZXJzIGFyZSByZXByZXNlbnRlZCBieSB0aGUgW2ludDMyXSBhbmRcbiAgICBbaW50NjRdIHR5cGVzLCB3aGljaCBjYW4gYmUgaW50ZXJwcmV0ZWQgZWl0aGVyIGFzIHNpZ25lZCBvclxuICAgIHVuc2lnbmVkIG51bWJlcnMuXG5cbiAgICA4LWJpdCBhbmQgMTYtYml0IGludGVnZXJzIGFyZSByZXByZXNlbnRlZCBieSB0aGUgW2ludF0gdHlwZSxcbiAgICB3aGljaCBoYXMgbW9yZSBiaXRzIHRoYW4gdGhlIGJpbmFyeSBlbmNvZGluZy4gIFRoZXNlIGV4dHJhIGJpdHNcbiAgICBhcmUgc2lnbi1leHRlbmRlZCAob3IgemVyby1leHRlbmRlZCkgZm9yIGZ1bmN0aW9ucyB3aGljaCBkZWNvZGUgOC1iaXRcbiAgICBvciAxNi1iaXQgaW50ZWdlcnMgYW5kIHJlcHJlc2VudGVkIHRoZW0gd2l0aCBbaW50XSB2YWx1ZXMuXG4qKVxuXG52YWwgZ2V0X3VpbnQ4IDogc3RyaW5nIC0+IGludCAtPiBpbnRcbigqKiBbZ2V0X3VpbnQ4IGIgaV0gaXMgW2JdJ3MgdW5zaWduZWQgOC1iaXQgaW50ZWdlciBzdGFydGluZyBhdCBjaGFyYWN0ZXJcbiAgICBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDggOiBzdHJpbmcgLT4gaW50IC0+IGludFxuKCoqIFtnZXRfaW50OCBiIGldIGlzIFtiXSdzIHNpZ25lZCA4LWJpdCBpbnRlZ2VyIHN0YXJ0aW5nIGF0IGNoYXJhY3RlclxuICAgIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfdWludDE2X25lIDogc3RyaW5nIC0+IGludCAtPiBpbnRcbigqKiBbZ2V0X3VpbnQxNl9uZSBiIGldIGlzIFtiXSdzIG5hdGl2ZS1lbmRpYW4gdW5zaWduZWQgMTYtYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF91aW50MTZfYmUgOiBzdHJpbmcgLT4gaW50IC0+IGludFxuKCoqIFtnZXRfdWludDE2X2JlIGIgaV0gaXMgW2JdJ3MgYmlnLWVuZGlhbiB1bnNpZ25lZCAxNi1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X3VpbnQxNl9sZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50XG4oKiogW2dldF91aW50MTZfbGUgYiBpXSBpcyBbYl0ncyBsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIDE2LWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfaW50MTZfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludFxuKCoqIFtnZXRfaW50MTZfbmUgYiBpXSBpcyBbYl0ncyBuYXRpdmUtZW5kaWFuIHNpZ25lZCAxNi1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDE2X2JlIDogc3RyaW5nIC0+IGludCAtPiBpbnRcbigqKiBbZ2V0X2ludDE2X2JlIGIgaV0gaXMgW2JdJ3MgYmlnLWVuZGlhbiBzaWduZWQgMTYtYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQxNl9sZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50XG4oKiogW2dldF9pbnQxNl9sZSBiIGldIGlzIFtiXSdzIGxpdHRsZS1lbmRpYW4gc2lnbmVkIDE2LWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfaW50MzJfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDMyXG4oKiogW2dldF9pbnQzMl9uZSBiIGldIGlzIFtiXSdzIG5hdGl2ZS1lbmRpYW4gMzItYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQzMl9iZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50MzJcbigqKiBbZ2V0X2ludDMyX2JlIGIgaV0gaXMgW2JdJ3MgYmlnLWVuZGlhbiAzMi1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDMyX2xlIDogc3RyaW5nIC0+IGludCAtPiBpbnQzMlxuKCoqIFtnZXRfaW50MzJfbGUgYiBpXSBpcyBbYl0ncyBsaXR0bGUtZW5kaWFuIDMyLWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbnZhbCBnZXRfaW50NjRfbmUgOiBzdHJpbmcgLT4gaW50IC0+IGludDY0XG4oKiogW2dldF9pbnQ2NF9uZSBiIGldIGlzIFtiXSdzIG5hdGl2ZS1lbmRpYW4gNjQtYml0IGludGVnZXJcbiAgICBzdGFydGluZyBhdCBjaGFyYWN0ZXIgaW5kZXggW2ldLlxuXG4gICAgQHNpbmNlIDQuMTMuMFxuKilcblxudmFsIGdldF9pbnQ2NF9iZSA6IHN0cmluZyAtPiBpbnQgLT4gaW50NjRcbigqKiBbZ2V0X2ludDY0X2JlIGIgaV0gaXMgW2JdJ3MgYmlnLWVuZGlhbiA2NC1iaXQgaW50ZWdlclxuICAgIHN0YXJ0aW5nIGF0IGNoYXJhY3RlciBpbmRleCBbaV0uXG5cbiAgICBAc2luY2UgNC4xMy4wXG4qKVxuXG52YWwgZ2V0X2ludDY0X2xlIDogc3RyaW5nIC0+IGludCAtPiBpbnQ2NFxuKCoqIFtnZXRfaW50NjRfbGUgYiBpXSBpcyBbYl0ncyBsaXR0bGUtZW5kaWFuIDY0LWJpdCBpbnRlZ2VyXG4gICAgc3RhcnRpbmcgYXQgY2hhcmFjdGVyIGluZGV4IFtpXS5cblxuICAgIEBzaW5jZSA0LjEzLjBcbiopXG5cbigqKi8qKilcblxuKCogVGhlIGZvbGxvd2luZyBpcyBmb3Igc3lzdGVtIHVzZSBvbmx5LiBEbyBub3QgY2FsbCBkaXJlY3RseS4gKilcblxuZXh0ZXJuYWwgdW5zYWZlX2dldCA6IHN0cmluZyAtPiBpbnQgLT4gY2hhciA9IFwiJXN0cmluZ191bnNhZmVfZ2V0XCJcbmV4dGVybmFsIHVuc2FmZV9zZXQgOiBieXRlcyAtPiBpbnQgLT4gY2hhciAtPiB1bml0ID0gXCIlc3RyaW5nX3Vuc2FmZV9zZXRcIlxuICBbQEBvY2FtbC5kZXByZWNhdGVkXVxuZXh0ZXJuYWwgdW5zYWZlX2JsaXQgOlxuICBzdHJpbmcgLT4gaW50IC0+IGJ5dGVzIC0+IGludCAtPiBpbnQgLT5cbiAgICB1bml0ID0gXCJjYW1sX2JsaXRfc3RyaW5nXCIgW0BAbm9hbGxvY11cbmV4dGVybmFsIHVuc2FmZV9maWxsIDpcbiAgYnl0ZXMgLT4gaW50IC0+IGludCAtPiBjaGFyIC0+IHVuaXQgPSBcImNhbWxfZmlsbF9zdHJpbmdcIiBbQEBub2FsbG9jXVxuICBbQEBvY2FtbC5kZXByZWNhdGVkXVxuIl19
