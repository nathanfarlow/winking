// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.1.1

//# unitInfo: Provides: Unix
//# unitInfo: Requires: Stdlib, Stdlib__Array, Stdlib__Bytes, Stdlib__Callback, Stdlib__Fun, Stdlib__Hashtbl, Stdlib__Int, Stdlib__List, Stdlib__Printexc, Stdlib__Printf, Stdlib__Sys
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$6 = "",
    cst$7 = ", ",
    cst_c$1 = "-c",
    cst_bin_sh = "/bin/sh",
    cst_0_0_0_0$0 = "0.0.0.0",
    cst_127_0_0_1$0 = "127.0.0.1",
    cst_Unix_Unix_error = "Unix.Unix_error",
    cst_tcp$2 = "tcp",
    cst_udp$2 = "udp",
    caml_channel_descriptor = runtime.caml_channel_descriptor,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_equal = runtime.caml_string_equal,
    caml_unix_inet_addr_of_string = runtime.caml_unix_inet_addr_of_string,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$5 = cst$6,
    cst$4 = cst$6,
    cst$1 = ': "',
    cst$2 = '"',
    cst$3 = ": ",
    shell = cst_bin_sh,
    cst = cst$6,
    cst$0 = cst$6,
    Stdlib = global_data.Stdlib,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Fun = global_data.Stdlib__Fun,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Callback = global_data.Stdlib__Callback,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Unix_error = [248, cst_Unix_Unix_error, runtime.caml_fresh_oo_id(0)];
   caml_call2
    (Stdlib_Callback[2], cst_Unix_Unix_error, [0, Unix_error, 0, cst$0, cst]);
   var
    _p_ = [0, 1],
    _q_ = [0, 1],
    _o_ = [0, 1],
    cst_close_process_full = "close_process_full",
    cst_close_process = "close_process",
    cst_close_process_out = "close_process_out",
    cst_close_process_in = "close_process_in",
    cst_process_full_pid = "process_full_pid",
    cst_process_pid = "process_pid",
    cst_process_out_pid = "process_out_pid",
    cst_process_in_pid = "process_in_pid",
    cst_c$0 = cst_c$1,
    _l_ = [0, 1],
    _m_ = [0, 1],
    _n_ = [0, 1],
    _j_ = [0, 1],
    _k_ = [0, 1],
    _i_ = [0, 1],
    _h_ = [0, 1],
    _g_ = [0, 1],
    cst_c = cst_c$1,
    cst_udp$1 = cst_udp$2,
    cst_tcp$1 = cst_tcp$2,
    cst_tcp = cst_tcp$2,
    cst_udp = cst_udp$2,
    cst_udp$0 = cst_udp$2,
    cst_tcp$0 = cst_tcp$2,
    cst_0_0_0_0 = cst_0_0_0_0$0,
    cst_127_0_0_1 = cst_127_0_0_1$0,
    cst_Unix_sendto = "Unix.sendto",
    cst_Unix_send = "Unix.send",
    cst_Unix_recvfrom = "Unix.recvfrom",
    cst_Unix_recv = "Unix.recv",
    _d_ = runtime.caml_int64_create_lo_mi_hi(0, 0, 0),
    cst_Unix_single_write = "Unix.single_write",
    cst_Unix_write = "Unix.write",
    cst_Unix_read = "Unix.read",
    cst_failed = '" failed',
    cst_on = ' on "',
    cst_E2BIG = "E2BIG",
    cst_EACCES = "EACCES",
    cst_EAGAIN = "EAGAIN",
    cst_EBADF = "EBADF",
    cst_EBUSY = "EBUSY",
    cst_ECHILD = "ECHILD",
    cst_EDEADLK = "EDEADLK",
    cst_EDOM = "EDOM",
    cst_EEXIST = "EEXIST",
    cst_EFAULT = "EFAULT",
    cst_EFBIG = "EFBIG",
    cst_EINTR = "EINTR",
    cst_EINVAL = "EINVAL",
    cst_EIO = "EIO",
    cst_EISDIR = "EISDIR",
    cst_EMFILE = "EMFILE",
    cst_EMLINK = "EMLINK",
    cst_ENAMETOOLONG = "ENAMETOOLONG",
    cst_ENFILE = "ENFILE",
    cst_ENODEV = "ENODEV",
    cst_ENOENT = "ENOENT",
    cst_ENOEXEC = "ENOEXEC",
    cst_ENOLCK = "ENOLCK",
    cst_ENOMEM = "ENOMEM",
    cst_ENOSPC = "ENOSPC",
    cst_ENOSYS = "ENOSYS",
    cst_ENOTDIR = "ENOTDIR",
    cst_ENOTEMPTY = "ENOTEMPTY",
    cst_ENOTTY = "ENOTTY",
    cst_ENXIO = "ENXIO",
    cst_EPERM = "EPERM",
    cst_EPIPE = "EPIPE",
    cst_ERANGE = "ERANGE",
    cst_EROFS = "EROFS",
    cst_ESPIPE = "ESPIPE",
    cst_ESRCH = "ESRCH",
    cst_EXDEV = "EXDEV",
    cst_EWOULDBLOCK = "EWOULDBLOCK",
    cst_EINPROGRESS = "EINPROGRESS",
    cst_EALREADY = "EALREADY",
    cst_ENOTSOCK = "ENOTSOCK",
    cst_EDESTADDRREQ = "EDESTADDRREQ",
    cst_EMSGSIZE = "EMSGSIZE",
    cst_EPROTOTYPE = "EPROTOTYPE",
    cst_ENOPROTOOPT = "ENOPROTOOPT",
    cst_EPROTONOSUPPORT = "EPROTONOSUPPORT",
    cst_ESOCKTNOSUPPORT = "ESOCKTNOSUPPORT",
    cst_EOPNOTSUPP = "EOPNOTSUPP",
    cst_EPFNOSUPPORT = "EPFNOSUPPORT",
    cst_EAFNOSUPPORT = "EAFNOSUPPORT",
    cst_EADDRINUSE = "EADDRINUSE",
    cst_EADDRNOTAVAIL = "EADDRNOTAVAIL",
    cst_ENETDOWN = "ENETDOWN",
    cst_ENETUNREACH = "ENETUNREACH",
    cst_ENETRESET = "ENETRESET",
    cst_ECONNABORTED = "ECONNABORTED",
    cst_ECONNRESET = "ECONNRESET",
    cst_ENOBUFS = "ENOBUFS",
    cst_EISCONN = "EISCONN",
    cst_ENOTCONN = "ENOTCONN",
    cst_ESHUTDOWN = "ESHUTDOWN",
    cst_ETOOMANYREFS = "ETOOMANYREFS",
    cst_ETIMEDOUT = "ETIMEDOUT",
    cst_ECONNREFUSED = "ECONNREFUSED",
    cst_EHOSTDOWN = "EHOSTDOWN",
    cst_EHOSTUNREACH = "EHOSTUNREACH",
    cst_ELOOP = "ELOOP",
    cst_EOVERFLOW = "EOVERFLOW",
    _c_ = [0, [11, "EUNKNOWNERR ", [4, 0, 0, 0, 0]], "EUNKNOWNERR %d"],
    _b_ =
      [0,
       [11,
        "Unix.Unix_error(Unix.",
        [2, 0, [11, cst$7, [3, 0, [11, cst$7, [3, 0, [12, 41, 0]]]]]]],
       "Unix.Unix_error(Unix.%s, %S, %S)"];
   function _a_(param){
    if(param[1] !== Unix_error) return 0;
    var s = param[4], s$0 = param[3], e = param[2];
    if(typeof e === "number"){
     var _e8_ = e;
     if(34 <= _e8_)
      switch(_e8_){
        case 34:
         var msg = cst_ESPIPE; break;
        case 35:
         var msg = cst_ESRCH; break;
        case 36:
         var msg = cst_EXDEV; break;
        case 37:
         var msg = cst_EWOULDBLOCK; break;
        case 38:
         var msg = cst_EINPROGRESS; break;
        case 39:
         var msg = cst_EALREADY; break;
        case 40:
         var msg = cst_ENOTSOCK; break;
        case 41:
         var msg = cst_EDESTADDRREQ; break;
        case 42:
         var msg = cst_EMSGSIZE; break;
        case 43:
         var msg = cst_EPROTOTYPE; break;
        case 44:
         var msg = cst_ENOPROTOOPT; break;
        case 45:
         var msg = cst_EPROTONOSUPPORT; break;
        case 46:
         var msg = cst_ESOCKTNOSUPPORT; break;
        case 47:
         var msg = cst_EOPNOTSUPP; break;
        case 48:
         var msg = cst_EPFNOSUPPORT; break;
        case 49:
         var msg = cst_EAFNOSUPPORT; break;
        case 50:
         var msg = cst_EADDRINUSE; break;
        case 51:
         var msg = cst_EADDRNOTAVAIL; break;
        case 52:
         var msg = cst_ENETDOWN; break;
        case 53:
         var msg = cst_ENETUNREACH; break;
        case 54:
         var msg = cst_ENETRESET; break;
        case 55:
         var msg = cst_ECONNABORTED; break;
        case 56:
         var msg = cst_ECONNRESET; break;
        case 57:
         var msg = cst_ENOBUFS; break;
        case 58:
         var msg = cst_EISCONN; break;
        case 59:
         var msg = cst_ENOTCONN; break;
        case 60:
         var msg = cst_ESHUTDOWN; break;
        case 61:
         var msg = cst_ETOOMANYREFS; break;
        case 62:
         var msg = cst_ETIMEDOUT; break;
        case 63:
         var msg = cst_ECONNREFUSED; break;
        case 64:
         var msg = cst_EHOSTDOWN; break;
        case 65:
         var msg = cst_EHOSTUNREACH; break;
        case 66:
         var msg = cst_ELOOP; break;
        default: var msg = cst_EOVERFLOW;
      }
     else
      switch(_e8_){
        case 0:
         var msg = cst_E2BIG; break;
        case 1:
         var msg = cst_EACCES; break;
        case 2:
         var msg = cst_EAGAIN; break;
        case 3:
         var msg = cst_EBADF; break;
        case 4:
         var msg = cst_EBUSY; break;
        case 5:
         var msg = cst_ECHILD; break;
        case 6:
         var msg = cst_EDEADLK; break;
        case 7:
         var msg = cst_EDOM; break;
        case 8:
         var msg = cst_EEXIST; break;
        case 9:
         var msg = cst_EFAULT; break;
        case 10:
         var msg = cst_EFBIG; break;
        case 11:
         var msg = cst_EINTR; break;
        case 12:
         var msg = cst_EINVAL; break;
        case 13:
         var msg = cst_EIO; break;
        case 14:
         var msg = cst_EISDIR; break;
        case 15:
         var msg = cst_EMFILE; break;
        case 16:
         var msg = cst_EMLINK; break;
        case 17:
         var msg = cst_ENAMETOOLONG; break;
        case 18:
         var msg = cst_ENFILE; break;
        case 19:
         var msg = cst_ENODEV; break;
        case 20:
         var msg = cst_ENOENT; break;
        case 21:
         var msg = cst_ENOEXEC; break;
        case 22:
         var msg = cst_ENOLCK; break;
        case 23:
         var msg = cst_ENOMEM; break;
        case 24:
         var msg = cst_ENOSPC; break;
        case 25:
         var msg = cst_ENOSYS; break;
        case 26:
         var msg = cst_ENOTDIR; break;
        case 27:
         var msg = cst_ENOTEMPTY; break;
        case 28:
         var msg = cst_ENOTTY; break;
        case 29:
         var msg = cst_ENXIO; break;
        case 30:
         var msg = cst_EPERM; break;
        case 31:
         var msg = cst_EPIPE; break;
        case 32:
         var msg = cst_ERANGE; break;
        default: var msg = cst_EROFS;
      }
    }
    else
     var x = e[1], msg = caml_call2(Stdlib_Printf[4], _c_, x);
    return [0, caml_call4(Stdlib_Printf[4], _b_, msg, s$0, s)];
   }
   caml_call1(Stdlib_Printexc[9], _a_);
   function handle_unix_error(f, arg){
    try{var _e7_ = caml_call1(f, arg); return _e7_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Unix_error) throw caml_maybe_attach_backtrace(exn, 0);
     var
      arg$0 = exn[4],
      fun_name = exn[3],
      err = exn[2],
      _e5_ = runtime.caml_check_bound(runtime.caml_sys_argv(0), 0)[1];
     caml_call1(Stdlib[49], _e5_);
     caml_call1(Stdlib[49], cst$1);
     caml_call1(Stdlib[49], fun_name);
     caml_call1(Stdlib[49], cst_failed);
     if(0 < caml_ml_string_length(arg$0)){
      caml_call1(Stdlib[49], cst_on);
      caml_call1(Stdlib[49], arg$0);
      caml_call1(Stdlib[49], cst$2);
     }
     caml_call1(Stdlib[49], cst$3);
     var _e6_ = runtime.unix_error_message(err);
     caml_call1(Stdlib[53], _e6_);
     return caml_call1(Stdlib[99], 2);
    }
   }
   var stdin = 0, stdout = 1, stderr = 2;
   function read(fd, buf, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_read(fd, buf, ofs, len);
    return caml_call1(Stdlib[1], cst_Unix_read);
   }
   function write(fd, buf, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_write(fd, buf, ofs, len);
    return caml_call1(Stdlib[1], cst_Unix_write);
   }
   function single_write(fd, buf, ofs, len){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_single_write(fd, buf, ofs, len);
    return caml_call1(Stdlib[1], cst_Unix_single_write);
   }
   function write_substring(fd, buf, ofs, len){
    return write(fd, caml_call1(Stdlib_Bytes[49], buf), ofs, len);
   }
   function single_write_substring(fd, buf, ofs, len){
    return single_write(fd, caml_call1(Stdlib_Bytes[49], buf), ofs, len);
   }
   function map_file(fd, opt, kind, layout, shared, dims){
    if(opt) var sth = opt[1], pos = sth; else var pos = _d_;
    return runtime.caml_unix_map_file_bytecode
            (fd, kind, layout, shared, dims, pos);
   }
   function pause(param){
    var sigs = runtime.unix_sigprocmask(1, 0);
    return runtime.unix_sigsuspend(sigs);
   }
   function sleep(duration){return runtime.unix_sleep(duration);}
   function is_inet6_addr(s){return 16 === caml_ml_string_length(s) ? 1 : 0;}
   var
    inet_addr_any = caml_unix_inet_addr_of_string(cst_0_0_0_0$0),
    inet_addr_loopback = caml_unix_inet_addr_of_string(cst_127_0_0_1$0);
   try{var _bw_ = caml_unix_inet_addr_of_string("::"), inet6_addr_any = _bw_;}
   catch(_e4_){
    var _e_ = caml_wrap_exception(_e4_);
    if(_e_[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(_e_, 0);
    var inet6_addr_any = inet_addr_any;
   }
   try{
    var
     _bv_ = caml_unix_inet_addr_of_string("::1"),
     inet6_addr_loopback = _bv_;
   }
   catch(_e3_){
    var _f_ = caml_wrap_exception(_e3_);
    if(_f_[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(_f_, 0);
    var inet6_addr_loopback = inet_addr_loopback;
   }
   function domain_of_sockaddr(param){
    if(0 === param[0]) return 0;
    var a = param[1];
    return is_inet6_addr(a) ? 2 : 1;
   }
   function recv(fd, buf, ofs, len, flags){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_recv(fd, buf, ofs, len, flags);
    return caml_call1(Stdlib[1], cst_Unix_recv);
   }
   function recvfrom(fd, buf, ofs, len, flags){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_recvfrom(fd, buf, ofs, len, flags);
    return caml_call1(Stdlib[1], cst_Unix_recvfrom);
   }
   function send(fd, buf, ofs, len, flags){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_send(fd, buf, ofs, len, flags);
    return caml_call1(Stdlib[1], cst_Unix_send);
   }
   function sendto(fd, buf, ofs, len, flags, addr){
    if(0 <= ofs && 0 <= len && (caml_ml_bytes_length(buf) - len | 0) >= ofs)
     return runtime.unix_sendto(fd, buf, ofs, len, flags, addr);
    return caml_call1(Stdlib[1], cst_Unix_sendto);
   }
   function send_substring(fd, buf, ofs, len, flags){
    return send(fd, caml_call1(Stdlib_Bytes[49], buf), ofs, len, flags);
   }
   function sendto_substring(fd, buf, ofs, len, flags, addr){
    return sendto
            (fd, caml_call1(Stdlib_Bytes[49], buf), ofs, len, flags, addr);
   }
   function getsockopt(fd, opt){return runtime.unix_getsockopt(0, fd, opt);}
   function setsockopt(fd, opt, v){
    return runtime.unix_setsockopt(0, fd, opt, v);
   }
   function getsockopt_int(fd, opt){
    return runtime.unix_getsockopt(1, fd, opt);
   }
   function setsockopt_int(fd, opt, v){
    return runtime.unix_setsockopt(1, fd, opt, v);
   }
   function getsockopt_optint(fd, opt){
    return runtime.unix_getsockopt(2, fd, opt);
   }
   function setsockopt_optint(fd, opt, v){
    return runtime.unix_setsockopt(2, fd, opt, v);
   }
   function getsockopt_float(fd, opt){
    return runtime.unix_getsockopt(3, fd, opt);
   }
   function setsockopt_float(fd, opt, v){
    return runtime.unix_setsockopt(3, fd, opt, v);
   }
   function getsockopt_error(fd){return runtime.unix_getsockopt(4, fd, 0);}
   function getaddrinfo(node, service, opts){
    try{
     var
      _eR_ = runtime.unix_getaddrinfo(node, service, opts),
      _eS_ = caml_call1(Stdlib_List[9], _eR_);
     return _eS_;
    }
    catch(_eT_){
     var _eQ_ = caml_wrap_exception(_eT_);
     if(_eQ_[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(_eQ_, 0);
     var
      opt_socktype = [0, 0],
      opt_protocol = [0, 0],
      opt_passive = [0, 0],
      _eC_ =
        function(param){
         if(typeof param === "number"){
          if(2 === param){opt_passive[1] = 1; return 0;}
         }
         else
          switch(param[0]){
            case 1:
             var s = param[1]; opt_socktype[1] = [0, s]; return 0;
            case 2:
             var p = param[1]; opt_protocol[1] = p; return 0;
          }
         return 0;
        };
     caml_call2(Stdlib_List[17], _eC_, opts);
     var
      get_port =
        function(ty, kind){
         if(caml_string_equal(service, cst$6)) return [0, [0, ty, 0], 0];
         try{
          var _e0_ = [0, [0, ty, runtime.caml_int_of_string(service)], 0];
          return _e0_;
         }
         catch(_e1_){
          var _eX_ = caml_wrap_exception(_e1_);
          if(_eX_[1] !== Stdlib[7])
           throw caml_maybe_attach_backtrace(_eX_, 0);
          try{
           var
            _eZ_ =
              [0, [0, ty, runtime.unix_getservbyname(service, kind)[3]], 0];
           return _eZ_;
          }
          catch(_e2_){
           var _eY_ = caml_wrap_exception(_e2_);
           if(_eY_ === Stdlib[8]) return 0;
           throw caml_maybe_attach_backtrace(_eY_, 0);
          }
         }
        },
      _eD_ = opt_socktype[1];
     if(_eD_)
      var
       ty = _eD_[1],
       _eE_ =
         1 === ty
          ? get_port(1, cst_udp)
          : ty
            ? caml_string_equal(service, cst$6) ? [0, [0, ty, 0], 0] : 0
            : get_port(0, cst_tcp),
       ports = _eE_;
     else
      var
       _eO_ = get_port(1, cst_udp$0),
       _eP_ = get_port(0, cst_tcp$0),
       ports = caml_call2(Stdlib[37], _eP_, _eO_);
     if(caml_string_equal(node, cst$6))
      var
       addresses =
         caml_call2(Stdlib_List[36], 2, opts)
          ? [0, [0, inet_addr_any, cst_0_0_0_0], 0]
          : [0, [0, inet_addr_loopback, cst_127_0_0_1], 0];
     else
      try{
       var
        _eN_ = [0, [0, caml_unix_inet_addr_of_string(node), node], 0],
        addresses = _eN_;
      }
      catch(_eV_){
       var _eH_ = caml_wrap_exception(_eV_);
       if(_eH_[1] !== Stdlib[7]) throw caml_maybe_attach_backtrace(_eH_, 0);
       try{
        var
         he = runtime.unix_gethostbyname(node),
         _eK_ = caml_call1(Stdlib_Array[11], he[4]),
         _eL_ = function(a){return [0, a, he[1]];},
         _eM_ = caml_call2(Stdlib_List[19], _eL_, _eK_),
         _eJ_ = _eM_;
       }
       catch(_eW_){
        var _eI_ = caml_wrap_exception(_eW_);
        if(_eI_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_eI_, 0);
        var _eJ_ = 0;
       }
       var addresses = _eJ_;
      }
     var
      _eF_ =
        function(param){
         var port = param[2], ty = param[1];
         function _eU_(param){
          var name = param[2], addr = param[1];
          return [0, 1, ty, opt_protocol[1], [1, addr, port], name];
         }
         return caml_call2(Stdlib_List[19], _eU_, addresses);
        },
      _eG_ = caml_call2(Stdlib_List[19], _eF_, ports);
     return caml_call1(Stdlib_List[14], _eG_);
    }
   }
   function getnameinfo(addr, opts){
    try{var _ey_ = runtime.unix_getnameinfo(addr, opts); return _ey_;}
    catch(_ez_){
     var _ex_ = caml_wrap_exception(_ez_);
     if(_ex_[1] !== Stdlib[6]) throw caml_maybe_attach_backtrace(_ex_, 0);
     if(0 === addr[0]){var f = addr[1]; return [0, cst$4, f];}
     var p = addr[2], a = addr[1];
     try{
      if(caml_call2(Stdlib_List[36], 1, opts))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var _ew_ = runtime.unix_gethostbyaddr(a)[1], hostname = _ew_;
     }
     catch(_eB_){
      var _et_ = caml_wrap_exception(_eB_);
      if(_et_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_et_, 0);
      if(caml_call2(Stdlib_List[36], 2, opts))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var hostname = runtime.unix_string_of_inet_addr(a);
     }
     try{
      if(caml_call2(Stdlib_List[36], 3, opts))
       throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var
       kind = caml_call2(Stdlib_List[36], 4, opts) ? cst_udp$1 : cst_tcp$1,
       _ev_ = runtime.unix_getservbyport(p, kind)[1],
       service = _ev_;
     }
     catch(_eA_){
      var _eu_ = caml_wrap_exception(_eA_);
      if(_eu_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_eu_, 0);
      var service = caml_call1(Stdlib_Int[12], p);
     }
     return [0, hostname, service];
    }
   }
   function waitpid_non_intr(pid){
    for(;;)
     try{var _er_ = runtime.unix_waitpid(0, pid); return _er_;}
     catch(_es_){
      var _ep_ = caml_wrap_exception(_es_);
      if(_ep_[1] === Unix_error){
       var _eq_ = _ep_[2];
       if(typeof _eq_ === "number" && 11 === _eq_) continue;
      }
      throw caml_maybe_attach_backtrace(_ep_, 0);
     }
   }
   function system(cmd){
    var
     pid =
       runtime.unix_spawn
        (cst_bin_sh, [0, shell, cst_c, cmd], 0, 0, [0, 0, 1, 2]);
    return waitpid_non_intr(pid)[2];
   }
   function create_process_gen
   (cmd, args, optenv, new_stdin, new_stdout, new_stderr){
    var toclose = [0, 0];
    function close_after(param){
     var _ek_ = toclose[1];
     function _el_(fd){
      try{var _en_ = runtime.unix_close(fd); return _en_;}
      catch(_eo_){
       var _em_ = caml_wrap_exception(_eo_);
       if(_em_[1] === Unix_error) return 0;
       throw caml_maybe_attach_backtrace(_em_, 0);
      }
     }
     return caml_call2(Stdlib_List[17], _el_, _ek_);
    }
    function file_descr_not_standard(fd){
     var fd$0 = fd;
     for(;;){
      if(3 <= fd$0) return fd$0;
      var fd$1 = runtime.unix_dup(_g_, fd$0);
      toclose[1] = [0, fd$1, toclose[1]];
      var fd$0 = fd$1;
     }
    }
    var
     _eg_ = 2 === new_stderr ? 2 : file_descr_not_standard(new_stderr),
     _eh_ = 1 === new_stdout ? 1 : file_descr_not_standard(new_stdout),
     _ei_ = 0 === new_stdin ? 0 : file_descr_not_standard(new_stdin),
     redirections = [0, _ei_, _eh_, _eg_];
    function _ej_(param){
     return runtime.unix_spawn(cmd, args, optenv, 1, redirections);
    }
    return caml_call2(Stdlib_Fun[4], close_after, _ej_);
   }
   function create_process(cmd, args, new_stdin, new_stdout, new_stderr){
    return create_process_gen(cmd, args, 0, new_stdin, new_stdout, new_stderr);
   }
   function create_process_env
   (cmd, args, env, new_stdin, new_stdout, new_stderr){
    return create_process_gen
            (cmd, args, [0, env], new_stdin, new_stdout, new_stderr);
   }
   var popen_processes = caml_call2(Stdlib_Hashtbl[1], 0, 7);
   function open_proc(prog, args, envopt, proc, input, output, error){
    var pid = create_process_gen(prog, args, envopt, input, output, error);
    return caml_call3(Stdlib_Hashtbl[5], popen_processes, proc, pid);
   }
   function open_process_args_in(prog, args){
    var
     match = runtime.unix_pipe(_h_, 0),
     in_write = match[2],
     in_read = match[1],
     inchan = runtime.unix_inchannel_of_filedescr(in_read);
    try{open_proc(prog, args, 0, [1, inchan], stdin, in_write, stderr);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[93], inchan);
     runtime.unix_close(in_write);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    runtime.unix_close(in_write);
    return inchan;
   }
   function open_process_args_out(prog, args){
    var
     match = runtime.unix_pipe(_i_, 0),
     out_write = match[2],
     out_read = match[1],
     outchan = runtime.unix_outchannel_of_filedescr(out_write);
    try{open_proc(prog, args, 0, [2, outchan], out_read, stdout, stderr);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     caml_call1(Stdlib[76], outchan);
     runtime.unix_close(out_read);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    runtime.unix_close(out_read);
    return outchan;
   }
   function open_process_args(prog, args){
    var
     match = runtime.unix_pipe(_j_, 0),
     in_write = match[2],
     in_read = match[1];
    try{var match$0 = runtime.unix_pipe(_k_, 0);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    var
     out_write = match$0[2],
     out_read = match$0[1],
     inchan = runtime.unix_inchannel_of_filedescr(in_read),
     outchan = runtime.unix_outchannel_of_filedescr(out_write);
    try{
     open_proc
      (prog, args, 0, [0, inchan, outchan], out_read, in_write, stderr);
    }
    catch(e){
     var e$0 = caml_wrap_exception(e);
     runtime.unix_close(out_read);
     runtime.unix_close(out_write);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     throw caml_maybe_attach_backtrace(e$0, 0);
    }
    runtime.unix_close(out_read);
    runtime.unix_close(in_write);
    return [0, inchan, outchan];
   }
   function open_process_args_full(prog, args, env){
    var
     match = runtime.unix_pipe(_l_, 0),
     in_write = match[2],
     in_read = match[1];
    try{var match$0 = runtime.unix_pipe(_m_, 0);}
    catch(e$0){
     var e = caml_wrap_exception(e$0);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     throw caml_maybe_attach_backtrace(e, 0);
    }
    var out_write = match$0[2], out_read = match$0[1];
    try{var match$1 = runtime.unix_pipe(_n_, 0);}
    catch(e){
     var e$0 = caml_wrap_exception(e);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     runtime.unix_close(out_read);
     runtime.unix_close(out_write);
     throw caml_maybe_attach_backtrace(e$0, 0);
    }
    var
     err_write = match$1[2],
     err_read = match$1[1],
     inchan = runtime.unix_inchannel_of_filedescr(in_read),
     outchan = runtime.unix_outchannel_of_filedescr(out_write),
     errchan = runtime.unix_inchannel_of_filedescr(err_read);
    try{
     open_proc
      (prog,
       args,
       [0, env],
       [3, inchan, outchan, errchan],
       out_read,
       in_write,
       err_write);
    }
    catch(e){
     var e$1 = caml_wrap_exception(e);
     runtime.unix_close(out_read);
     runtime.unix_close(out_write);
     runtime.unix_close(in_read);
     runtime.unix_close(in_write);
     runtime.unix_close(err_read);
     runtime.unix_close(err_write);
     throw caml_maybe_attach_backtrace(e$1, 0);
    }
    runtime.unix_close(out_read);
    runtime.unix_close(in_write);
    runtime.unix_close(err_write);
    return [0, inchan, outchan, errchan];
   }
   function open_process_shell(fn, cmd){
    return caml_call2(fn, shell, [0, shell, cst_c$0, cmd]);
   }
   function open_process_in(cmd){
    return open_process_shell(open_process_args_in, cmd);
   }
   function open_process_out(cmd){
    return open_process_shell(open_process_args_out, cmd);
   }
   function open_process(cmd){
    return open_process_shell(open_process_args, cmd);
   }
   function open_process_full(cmd){
    return open_process_shell(open_process_args_full, cmd);
   }
   function find_proc_id(fun_name, proc){
    try{
     var _ee_ = caml_call2(Stdlib_Hashtbl[6], popen_processes, proc);
     return _ee_;
    }
    catch(_ef_){
     var _ed_ = caml_wrap_exception(_ef_);
     if(_ed_ === Stdlib[8])
      throw caml_maybe_attach_backtrace
             ([0, Unix_error, 3, fun_name, cst$5], 1);
     throw caml_maybe_attach_backtrace(_ed_, 0);
    }
   }
   function remove_proc_id(proc){
    return caml_call2(Stdlib_Hashtbl[10], popen_processes, proc);
   }
   function process_in_pid(inchan){
    return find_proc_id(cst_process_in_pid, [1, inchan]);
   }
   function process_out_pid(outchan){
    return find_proc_id(cst_process_out_pid, [2, outchan]);
   }
   function process_pid(param){
    var outchan = param[2], inchan = param[1];
    return find_proc_id(cst_process_pid, [0, inchan, outchan]);
   }
   function process_full_pid(param){
    var errchan = param[3], outchan = param[2], inchan = param[1];
    return find_proc_id(cst_process_full_pid, [3, inchan, outchan, errchan]);
   }
   function close_process_in(inchan){
    var proc = [1, inchan], pid = find_proc_id(cst_close_process_in, proc);
    remove_proc_id(proc);
    caml_call1(Stdlib[93], inchan);
    return waitpid_non_intr(pid)[2];
   }
   function close_process_out(outchan){
    var proc = [2, outchan], pid = find_proc_id(cst_close_process_out, proc);
    remove_proc_id(proc);
    try{caml_call1(Stdlib[76], outchan);}
    catch(_ec_){
     var _eb_ = caml_wrap_exception(_ec_);
     if(_eb_[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(_eb_, 0);
    }
    return waitpid_non_intr(pid)[2];
   }
   function close_process(param){
    var
     outchan = param[2],
     inchan = param[1],
     proc = [0, inchan, outchan],
     pid = find_proc_id(cst_close_process, proc);
    remove_proc_id(proc);
    caml_call1(Stdlib[93], inchan);
    try{caml_call1(Stdlib[76], outchan);}
    catch(_ea_){
     var _d$_ = caml_wrap_exception(_ea_);
     if(_d$_[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(_d$_, 0);
    }
    return waitpid_non_intr(pid)[2];
   }
   function close_process_full(param){
    var
     errchan = param[3],
     outchan = param[2],
     inchan = param[1],
     proc = [3, inchan, outchan, errchan],
     pid = find_proc_id(cst_close_process_full, proc);
    remove_proc_id(proc);
    caml_call1(Stdlib[93], inchan);
    try{caml_call1(Stdlib[76], outchan);}
    catch(_d__){
     var _d9_ = caml_wrap_exception(_d__);
     if(_d9_[1] !== Stdlib[11]) throw caml_maybe_attach_backtrace(_d9_, 0);
    }
    caml_call1(Stdlib[93], errchan);
    return waitpid_non_intr(pid)[2];
   }
   function open_connection(sockaddr){
    var sock = runtime.unix_socket(_o_, domain_of_sockaddr(sockaddr), 0, 0);
    try{
     runtime.unix_connect(sock, sockaddr);
     var
      _d7_ = runtime.unix_outchannel_of_filedescr(sock),
      _d8_ = [0, runtime.unix_inchannel_of_filedescr(sock), _d7_];
     return _d8_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     runtime.unix_close(sock);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function shutdown_connection(inchan){
    return runtime.unix_shutdown(caml_channel_descriptor(inchan), 1);
   }
   function establish_server(server_fun, sockaddr){
    var sock = runtime.unix_socket(_q_, domain_of_sockaddr(sockaddr), 0, 0);
    runtime.unix_setsockopt(0, sock, 2, 1);
    runtime.unix_bind(sock, sockaddr);
    runtime.unix_listen(sock, 5);
    a:
    for(;;)
     for(;;){
      try{var match = runtime.unix_accept(_p_, sock);}
      catch(_d6_){
       var _d4_ = caml_wrap_exception(_d6_);
       if(_d4_[1] === Unix_error){
        var _d5_ = _d4_[2];
        if(typeof _d5_ === "number" && 11 === _d5_) continue;
       }
       throw caml_maybe_attach_backtrace(_d4_, 0);
      }
      var s = match[1], id = runtime.unix_fork(0);
      if(0 === id){
       if(0 !== runtime.unix_fork(0)) runtime.unix_exit(0);
       runtime.unix_close(sock);
       var
        inchan = runtime.unix_inchannel_of_filedescr(s),
        outchan = runtime.unix_outchannel_of_filedescr(s);
       caml_call2(server_fun, inchan, outchan);
       caml_call1(Stdlib[99], 0);
      }
      else{runtime.unix_close(s); waitpid_non_intr(id);}
      continue a;
     }
   }
   function _r_(_d3_){return runtime.unix_setsid(_d3_);}
   function _s_(_d2_, _d1_){return runtime.unix_tcflow(_d2_, _d1_);}
   function _t_(_d0_, _dZ_){return runtime.unix_tcflush(_d0_, _dZ_);}
   function _u_(_dY_){return runtime.unix_tcdrain(_dY_);}
   function _v_(_dX_, _dW_){return runtime.unix_tcsendbreak(_dX_, _dW_);}
   function _w_(_dV_, _dU_, _dT_){
    return runtime.unix_tcsetattr(_dV_, _dU_, _dT_);
   }
   function _x_(_dS_){return runtime.unix_tcgetattr(_dS_);}
   function _y_(_dR_, _dQ_){return runtime.unix_getservbyport(_dR_, _dQ_);}
   function _z_(_dP_, _dO_){return runtime.unix_getservbyname(_dP_, _dO_);}
   function _A_(_dN_){return runtime.unix_getprotobynumber(_dN_);}
   function _B_(_dM_){return runtime.unix_getprotobyname(_dM_);}
   function _C_(_dL_){return runtime.unix_gethostbyaddr(_dL_);}
   function _D_(_dK_){return runtime.unix_gethostbyname(_dK_);}
   function _E_(_dJ_){return runtime.unix_gethostname(_dJ_);}
   function _F_(_dI_){return runtime.unix_getpeername(_dI_);}
   function _G_(_dH_){return runtime.unix_getsockname(_dH_);}
   function _H_(_dG_, _dF_){return runtime.unix_shutdown(_dG_, _dF_);}
   function _I_(_dE_, _dD_){return runtime.unix_listen(_dE_, _dD_);}
   function _J_(_dC_, _dB_){return runtime.unix_connect(_dC_, _dB_);}
   function _K_(_dA_, _dz_){return runtime.unix_bind(_dA_, _dz_);}
   function _L_(_dy_, _dx_){return runtime.unix_accept(_dy_, _dx_);}
   function _M_(_dw_, _dv_, _du_, _dt_){
    return runtime.unix_socketpair(_dw_, _dv_, _du_, _dt_);
   }
   function _N_(_ds_, _dr_, _dq_, _dp_){
    return runtime.unix_socket(_ds_, _dr_, _dq_, _dp_);
   }
   function _O_(_do_){return runtime.unix_string_of_inet_addr(_do_);}
   function _P_(_dn_){return caml_unix_inet_addr_of_string(_dn_);}
   function _Q_(_dm_){return runtime.unix_getgrgid(_dm_);}
   var _R_ = runtime.caml_unix_getpwuid;
   function _S_(_dl_){return runtime.unix_getgrnam(_dl_);}
   function _T_(_dk_){return runtime.unix_getpwnam(_dk_);}
   function _U_(_dj_){return runtime.unix_getlogin(_dj_);}
   function _V_(_di_, _dh_){return runtime.unix_initgroups(_di_, _dh_);}
   function _W_(_dg_){return runtime.unix_setgroups(_dg_);}
   function _X_(_df_){return runtime.unix_getgroups(_df_);}
   function _Y_(_de_){return runtime.unix_setgid(_de_);}
   function _Z_(_dd_){return runtime.unix_getegid(_dd_);}
   function ___(_dc_){return runtime.unix_getgid(_dc_);}
   function _$_(_db_){return runtime.unix_setuid(_db_);}
   function _aa_(_da_){return runtime.unix_geteuid(_da_);}
   var _ab_ = runtime.caml_unix_getuid;
   function _ac_(_c$_, _c__){return runtime.unix_setitimer(_c$_, _c__);}
   function _ad_(_c9_){return runtime.unix_getitimer(_c9_);}
   function _ae_(_c8_, _c7_, _c6_){
    return runtime.unix_utimes(_c8_, _c7_, _c6_);
   }
   function _af_(_c5_){return runtime.unix_times(_c5_);}
   function _ag_(_c4_){return runtime.unix_sleep(_c4_);}
   function _ah_(_c3_){return runtime.unix_alarm(_c3_);}
   var
    _ai_ = runtime.caml_unix_mktime,
    _aj_ = runtime.caml_unix_localtime,
    _ak_ = runtime.caml_unix_gmtime;
   function _al_(_c2_){return runtime.caml_unix_gettimeofday(_c2_);}
   function _am_(_c1_){return runtime.caml_unix_time(_c1_);}
   function _an_(_c0_){return runtime.unix_sigsuspend(_c0_);}
   function _ao_(_cZ_){return runtime.unix_sigpending(_cZ_);}
   function _ap_(_cY_, _cX_){return runtime.unix_sigprocmask(_cY_, _cX_);}
   function _aq_(_cW_, _cV_){return runtime.unix_kill(_cW_, _cV_);}
   function _ar_(_cU_, _cT_, _cS_){
    return runtime.unix_lockf(_cU_, _cT_, _cS_);
   }
   function _as_(_cR_, _cQ_, _cP_, _cO_){
    return runtime.unix_select(_cR_, _cQ_, _cP_, _cO_);
   }
   var
    _at_ = runtime.caml_unix_readlink,
    _au_ = runtime.caml_unix_has_symlink,
    _av_ = runtime.caml_unix_symlink;
   function _aw_(_cN_, _cM_){return runtime.unix_mkfifo(_cN_, _cM_);}
   function _ax_(_cL_, _cK_){return runtime.unix_pipe(_cL_, _cK_);}
   var
    _ay_ = runtime.caml_unix_closedir,
    _az_ = runtime.caml_unix_rewinddir,
    _aA_ = runtime.caml_unix_readdir,
    _aB_ = runtime.caml_unix_opendir;
   function _aC_(_cJ_){return runtime.unix_chroot(_cJ_);}
   function _aD_(_cI_){return runtime.unix_getcwd(_cI_);}
   function _aE_(_cH_){return runtime.unix_chdir(_cH_);}
   var _aF_ = runtime.caml_unix_rmdir, _aG_ = runtime.caml_unix_mkdir;
   function _aH_(_cG_){return runtime.unix_clear_close_on_exec(_cG_);}
   function _aI_(_cF_){return runtime.unix_set_close_on_exec(_cF_);}
   function _aJ_(_cE_){return runtime.unix_clear_nonblock(_cE_);}
   function _aK_(_cD_){return runtime.unix_set_nonblock(_cD_);}
   function _aL_(_cC_, _cB_, _cA_){
    return runtime.unix_dup2(_cC_, _cB_, _cA_);
   }
   function _aM_(_cz_, _cy_){return runtime.unix_dup(_cz_, _cy_);}
   function _aN_(_cx_, _cw_){return runtime.unix_access(_cx_, _cw_);}
   function _aO_(_cv_){return runtime.unix_umask(_cv_);}
   function _aP_(_cu_, _ct_, _cs_){
    return runtime.unix_fchown(_cu_, _ct_, _cs_);
   }
   function _aQ_(_cr_, _cq_, _cp_){
    return runtime.unix_chown(_cr_, _cq_, _cp_);
   }
   function _aR_(_co_, _cn_){return runtime.unix_fchmod(_co_, _cn_);}
   function _aS_(_cm_, _cl_){return runtime.unix_chmod(_cm_, _cl_);}
   function _aT_(_ck_){return runtime.unix_realpath(_ck_);}
   function _aU_(_cj_, _ci_, _ch_){
    return runtime.unix_link(_cj_, _ci_, _ch_);
   }
   function _aV_(_cg_, _cf_){return runtime.unix_rename(_cg_, _cf_);}
   var _aW_ = runtime.caml_unix_unlink;
   function _aX_(_ce_){return runtime.unix_fstat_64(_ce_);}
   var _aY_ = runtime.caml_unix_lstat_64, _aZ_ = runtime.caml_unix_stat_64;
   function _a0_(_cd_, _cc_){return runtime.unix_ftruncate_64(_cd_, _cc_);}
   function _a1_(_cb_, _ca_){return runtime.unix_truncate_64(_cb_, _ca_);}
   var
    _a2_ =
      [0,
       function(_b$_, _b__, _b9_){
        return runtime.unix_lseek_64(_b$_, _b__, _b9_);
       },
       _a1_,
       _a0_,
       _aZ_,
       _aY_,
       _aX_],
    _a3_ = runtime.caml_unix_isatty;
   function _a4_(_b8_){return runtime.unix_fstat(_b8_);}
   var _a5_ = runtime.caml_unix_lstat, _a6_ = runtime.caml_unix_stat;
   function _a7_(_b7_, _b6_){return runtime.unix_ftruncate(_b7_, _b6_);}
   function _a8_(_b5_, _b4_){return runtime.unix_truncate(_b5_, _b4_);}
   function _a9_(_b3_, _b2_, _b1_){
    return runtime.unix_lseek(_b3_, _b2_, _b1_);
   }
   var _a__ = caml_channel_descriptor, _a$_ = caml_channel_descriptor;
   function _ba_(_b0_){return runtime.unix_outchannel_of_filedescr(_b0_);}
   function _bb_(_bZ_){return runtime.unix_inchannel_of_filedescr(_bZ_);}
   function _bc_(_bY_){return runtime.unix_fsync(_bY_);}
   function _bd_(_bX_){return runtime.unix_close(_bX_);}
   function _be_(_bW_, _bV_, _bU_){
    return runtime.unix_open(_bW_, _bV_, _bU_);
   }
   function _bf_(_bT_){return runtime.unix_nice(_bT_);}
   function _bg_(_bS_){return runtime.unix_getppid(_bS_);}
   function _bh_(_bR_){return runtime.unix_getpid(_bR_);}
   function _bi_(_bQ_){return runtime.unix_exit(_bQ_);}
   function _bj_(_bP_, _bO_){return runtime.unix_waitpid(_bP_, _bO_);}
   function _bk_(_bN_){return runtime.unix_wait(_bN_);}
   function _bl_(_bM_){return runtime.unix_fork(_bM_);}
   function _bm_(_bL_, _bK_, _bJ_){
    return runtime.unix_execvpe(_bL_, _bK_, _bJ_);
   }
   function _bn_(_bI_, _bH_){return runtime.unix_execvp(_bI_, _bH_);}
   function _bo_(_bG_, _bF_, _bE_){
    return runtime.unix_execve(_bG_, _bF_, _bE_);
   }
   function _bp_(_bD_, _bC_){return runtime.unix_execv(_bD_, _bC_);}
   function _bq_(_bB_, _bA_){return runtime.unix_putenv(_bB_, _bA_);}
   var _br_ = runtime.caml_sys_unsafe_getenv, _bs_ = runtime.caml_sys_getenv;
   function _bt_(_bz_){return runtime.unix_environment_unsafe(_bz_);}
   function _bu_(_by_){return runtime.unix_environment(_by_);}
   var
    Unix =
      [0,
       Unix_error,
       function(_bx_){return runtime.unix_error_message(_bx_);},
       handle_unix_error,
       _bu_,
       _bt_,
       _bs_,
       _br_,
       _bq_,
       _bp_,
       _bo_,
       _bn_,
       _bm_,
       _bl_,
       _bk_,
       _bj_,
       system,
       _bi_,
       _bh_,
       _bg_,
       _bf_,
       stdin,
       stdout,
       stderr,
       _be_,
       _bd_,
       _bc_,
       read,
       write,
       single_write,
       write_substring,
       single_write_substring,
       _bb_,
       _ba_,
       _a$_,
       _a__,
       _a9_,
       _a8_,
       _a7_,
       _a6_,
       _a5_,
       _a4_,
       _a3_,
       _a2_,
       map_file,
       _aW_,
       _aV_,
       _aU_,
       _aT_,
       _aS_,
       _aR_,
       _aQ_,
       _aP_,
       _aO_,
       _aN_,
       _aM_,
       _aL_,
       _aK_,
       _aJ_,
       _aI_,
       _aH_,
       _aG_,
       _aF_,
       _aE_,
       _aD_,
       _aC_,
       _aB_,
       _aA_,
       _az_,
       _ay_,
       _ax_,
       _aw_,
       create_process,
       create_process_env,
       open_process_in,
       open_process_out,
       open_process,
       open_process_full,
       open_process_args_in,
       open_process_args_out,
       open_process_args,
       open_process_args_full,
       process_in_pid,
       process_out_pid,
       process_pid,
       process_full_pid,
       close_process_in,
       close_process_out,
       close_process,
       close_process_full,
       _av_,
       _au_,
       _at_,
       _as_,
       _ar_,
       _aq_,
       _ap_,
       _ao_,
       _an_,
       pause,
       _am_,
       _al_,
       _ak_,
       _aj_,
       _ai_,
       _ah_,
       sleep,
       _ag_,
       _af_,
       _ae_,
       _ad_,
       _ac_,
       _ab_,
       _aa_,
       _$_,
       ___,
       _Z_,
       _Y_,
       _X_,
       _W_,
       _V_,
       _U_,
       _T_,
       _S_,
       _R_,
       _Q_,
       _P_,
       _O_,
       inet_addr_any,
       inet_addr_loopback,
       inet6_addr_any,
       inet6_addr_loopback,
       is_inet6_addr,
       _N_,
       domain_of_sockaddr,
       _M_,
       _L_,
       _K_,
       _J_,
       _I_,
       _H_,
       _G_,
       _F_,
       recv,
       recvfrom,
       send,
       send_substring,
       sendto,
       sendto_substring,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       open_connection,
       shutdown_connection,
       establish_server,
       _E_,
       _D_,
       _C_,
       _B_,
       _A_,
       _z_,
       _y_,
       getaddrinfo,
       getnameinfo,
       _x_,
       _w_,
       _v_,
       _u_,
       _t_,
       _s_,
       _r_];
   runtime.caml_register_global(136, Unix, "Unix");
   return;
  }
  (globalThis));

//# unitInfo: Provides: UnixLabels
//# unitInfo: Requires: Unix
//# unitInfo: Force_link: true
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Unix = global_data.Unix,
    Unix_error = Unix[1],
    error_message = Unix[2],
    handle_unix_error = Unix[3],
    environment = Unix[4],
    unsafe_environment = Unix[5],
    getenv = Unix[6],
    unsafe_getenv = Unix[7],
    putenv = Unix[8],
    execv = Unix[9],
    execve = Unix[10],
    execvp = Unix[11],
    execvpe = Unix[12],
    fork = Unix[13],
    wait = Unix[14],
    waitpid = Unix[15],
    system = Unix[16],
    exit = Unix[17],
    getpid = Unix[18],
    getppid = Unix[19],
    nice = Unix[20],
    stdin = Unix[21],
    stdout = Unix[22],
    stderr = Unix[23],
    openfile = Unix[24],
    close = Unix[25],
    fsync = Unix[26],
    read = Unix[27],
    write = Unix[28],
    single_write = Unix[29],
    write_substring = Unix[30],
    single_write_substring = Unix[31],
    in_channel_of_descr = Unix[32],
    out_channel_of_descr = Unix[33],
    descr_of_in_channel = Unix[34],
    descr_of_out_channel = Unix[35],
    lseek = Unix[36],
    truncate = Unix[37],
    ftruncate = Unix[38],
    stat = Unix[39],
    lstat = Unix[40],
    fstat = Unix[41],
    isatty = Unix[42],
    LargeFile = Unix[43],
    map_file = Unix[44],
    unlink = Unix[45],
    rename = Unix[46],
    link = Unix[47],
    realpath = Unix[48],
    chmod = Unix[49],
    fchmod = Unix[50],
    chown = Unix[51],
    fchown = Unix[52],
    umask = Unix[53],
    access = Unix[54],
    dup = Unix[55],
    dup2 = Unix[56],
    set_nonblock = Unix[57],
    clear_nonblock = Unix[58],
    set_close_on_exec = Unix[59],
    clear_close_on_exec = Unix[60],
    mkdir = Unix[61],
    rmdir = Unix[62],
    chdir = Unix[63],
    getcwd = Unix[64],
    chroot = Unix[65],
    opendir = Unix[66],
    readdir = Unix[67],
    rewinddir = Unix[68],
    closedir = Unix[69],
    pipe = Unix[70],
    mkfifo = Unix[71],
    create_process = Unix[72],
    create_process_env = Unix[73],
    open_process_in = Unix[74],
    open_process_out = Unix[75],
    open_process = Unix[76],
    open_process_full = Unix[77],
    open_process_args_in = Unix[78],
    open_process_args_out = Unix[79],
    open_process_args = Unix[80],
    open_process_args_full = Unix[81],
    process_in_pid = Unix[82],
    process_out_pid = Unix[83],
    process_pid = Unix[84],
    process_full_pid = Unix[85],
    close_process_in = Unix[86],
    close_process_out = Unix[87],
    close_process = Unix[88],
    close_process_full = Unix[89],
    symlink = Unix[90],
    has_symlink = Unix[91],
    readlink = Unix[92],
    select = Unix[93],
    lockf = Unix[94],
    kill = Unix[95],
    sigprocmask = Unix[96],
    sigpending = Unix[97],
    sigsuspend = Unix[98],
    pause = Unix[99],
    time = Unix[100],
    gettimeofday = Unix[101],
    gmtime = Unix[102],
    localtime = Unix[103],
    mktime = Unix[104],
    alarm = Unix[105],
    sleep = Unix[106],
    sleepf = Unix[107],
    times = Unix[108],
    utimes = Unix[109],
    getitimer = Unix[110],
    setitimer = Unix[111],
    getuid = Unix[112],
    geteuid = Unix[113],
    setuid = Unix[114],
    getgid = Unix[115],
    getegid = Unix[116],
    setgid = Unix[117],
    getgroups = Unix[118],
    setgroups = Unix[119],
    initgroups = Unix[120],
    getlogin = Unix[121],
    getpwnam = Unix[122],
    getgrnam = Unix[123],
    getpwuid = Unix[124],
    getgrgid = Unix[125],
    inet_addr_of_string = Unix[126],
    string_of_inet_addr = Unix[127],
    inet_addr_any = Unix[128],
    inet_addr_loopback = Unix[129],
    inet6_addr_any = Unix[130],
    inet6_addr_loopback = Unix[131],
    is_inet6_addr = Unix[132],
    socket = Unix[133],
    domain_of_sockaddr = Unix[134],
    socketpair = Unix[135],
    accept = Unix[136],
    bind = Unix[137],
    connect = Unix[138],
    listen = Unix[139],
    shutdown = Unix[140],
    getsockname = Unix[141],
    getpeername = Unix[142],
    recv = Unix[143],
    recvfrom = Unix[144],
    send = Unix[145],
    send_substring = Unix[146],
    sendto = Unix[147],
    sendto_substring = Unix[148],
    getsockopt = Unix[149],
    setsockopt = Unix[150],
    getsockopt_int = Unix[151],
    setsockopt_int = Unix[152],
    getsockopt_optint = Unix[153],
    setsockopt_optint = Unix[154],
    getsockopt_float = Unix[155],
    setsockopt_float = Unix[156],
    getsockopt_error = Unix[157],
    open_connection = Unix[158],
    shutdown_connection = Unix[159],
    establish_server = Unix[160],
    gethostname = Unix[161],
    gethostbyname = Unix[162],
    gethostbyaddr = Unix[163],
    getprotobyname = Unix[164],
    getprotobynumber = Unix[165],
    getservbyname = Unix[166],
    getservbyport = Unix[167],
    getaddrinfo = Unix[168],
    getnameinfo = Unix[169],
    tcgetattr = Unix[170],
    tcsetattr = Unix[171],
    tcsendbreak = Unix[172],
    tcdrain = Unix[173],
    tcflush = Unix[174],
    tcflow = Unix[175],
    setsid = Unix[176],
    UnixLabels =
      [0,
       Unix_error,
       error_message,
       handle_unix_error,
       environment,
       unsafe_environment,
       getenv,
       unsafe_getenv,
       putenv,
       execv,
       execve,
       execvp,
       execvpe,
       fork,
       wait,
       waitpid,
       system,
       exit,
       getpid,
       getppid,
       nice,
       stdin,
       stdout,
       stderr,
       openfile,
       close,
       fsync,
       read,
       write,
       single_write,
       write_substring,
       single_write_substring,
       in_channel_of_descr,
       out_channel_of_descr,
       descr_of_in_channel,
       descr_of_out_channel,
       lseek,
       truncate,
       ftruncate,
       stat,
       lstat,
       fstat,
       isatty,
       LargeFile,
       map_file,
       unlink,
       rename,
       link,
       realpath,
       chmod,
       fchmod,
       chown,
       fchown,
       umask,
       access,
       dup,
       dup2,
       set_nonblock,
       clear_nonblock,
       set_close_on_exec,
       clear_close_on_exec,
       mkdir,
       rmdir,
       chdir,
       getcwd,
       chroot,
       opendir,
       readdir,
       rewinddir,
       closedir,
       pipe,
       mkfifo,
       create_process,
       create_process_env,
       open_process_in,
       open_process_out,
       open_process,
       open_process_full,
       open_process_args_in,
       open_process_args_out,
       open_process_args,
       open_process_args_full,
       process_in_pid,
       process_out_pid,
       process_pid,
       process_full_pid,
       close_process_in,
       close_process_out,
       close_process,
       close_process_full,
       symlink,
       has_symlink,
       readlink,
       select,
       lockf,
       kill,
       sigprocmask,
       sigpending,
       sigsuspend,
       pause,
       time,
       gettimeofday,
       gmtime,
       localtime,
       mktime,
       alarm,
       sleep,
       sleepf,
       times,
       utimes,
       getitimer,
       setitimer,
       getuid,
       geteuid,
       setuid,
       getgid,
       getegid,
       setgid,
       getgroups,
       setgroups,
       initgroups,
       getlogin,
       getpwnam,
       getgrnam,
       getpwuid,
       getgrgid,
       inet_addr_of_string,
       string_of_inet_addr,
       inet_addr_any,
       inet_addr_loopback,
       inet6_addr_any,
       inet6_addr_loopback,
       is_inet6_addr,
       socket,
       domain_of_sockaddr,
       socketpair,
       accept,
       bind,
       connect,
       listen,
       shutdown,
       getsockname,
       getpeername,
       recv,
       recvfrom,
       send,
       send_substring,
       sendto,
       sendto_substring,
       getsockopt,
       setsockopt,
       getsockopt_int,
       setsockopt_int,
       getsockopt_optint,
       setsockopt_optint,
       getsockopt_float,
       setsockopt_float,
       getsockopt_error,
       open_connection,
       shutdown_connection,
       establish_server,
       gethostname,
       gethostbyname,
       gethostbyaddr,
       getprotobyname,
       getprotobynumber,
       getservbyname,
       getservbyport,
       getaddrinfo,
       getnameinfo,
       tcgetattr,
       tcsetattr,
       tcsendbreak,
       tcdrain,
       tcflush,
       tcflow,
       setsid];
   runtime.caml_register_global(1, UnixLabels, "UnixLabels");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ1bml4LmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6W10sInNvdXJjZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0ciLCJzb3VyY2VzQ29udGVudCI6W119
